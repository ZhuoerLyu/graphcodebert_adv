{"id1": "17522011", "id2": "8754809", "code1": "    public static String read(ClassLoader classLoader, String name, boolean all) throws IOException {\n        if (all) {\n            StringMaker sm = new StringMaker();\n            Enumeration enu = classLoader.getResources(name);\n            while (enu.hasMoreElements()) {\n                URL url = (URL) enu.nextElement();\n                InputStream is = url.openStream();\n                String s = read(is);\n                if (s != null) {\n                    sm.append(s);\n                    sm.append(StringPool.NEW_LINE);\n                }\n                is.close();\n            }\n            return sm.toString().trim();\n        } else {\n            InputStream is = classLoader.getResourceAsStream(name);\n            String s = read(is);\n            is.close();\n            return s;\n        }\n    }\n", "code2": "    @SuppressWarnings(\"unchecked\")\n    public void launch(final ILaunchConfiguration configuration, final String mode, final ILaunch launch, final IProgressMonitor monitor) throws CoreException {\n        {\n            Assert.notNull(configuration);\n            Assert.notNull(monitor);\n        }\n        final String projectName = configuration.getAttribute(INexOpenLaunchConfigurationConstants.NEXOPEN_PROJECT_NAME, \"\");\n        final IProject prj = JavaCore.create(ResourcesPlugin.getWorkspace().getRoot()).getJavaProject(projectName).getProject();\n        if (NexOpenProjectUtils.isNexOpenProject(prj)) {\n            final IFile pom = prj.getFile(\"pom.xml\");\n            if (!pom.exists()) {\n                throw new IllegalStateException(\"Not a NexOpen project. Not Maven2 root pom.xml available\");\n            }\n            ContentHandlerTemplate.handle(pom, new ContentHandlerCallback() {\n\n                public void processHandle(final Document doc) {\n                    handleRootProfile(doc);\n                }\n            });\n            final IFile bpom = prj.getFile(\"business/pom.xml\");\n            if (!bpom.exists()) {\n                throw new IllegalStateException(\"Not a NexOpen project. Not Maven2 business pom.xml available\");\n            }\n            ContentHandlerTemplate.handle(bpom, new ContentHandlerCallback() {\n\n                public void processHandle(final Document doc) {\n                    try {\n                        handleBusinessProfile(doc, configuration, prj);\n                    } catch (final CoreException e) {\n                        if (Logger.getLog().isInfoEnabled()) {\n                            Logger.getLog().info(\"CoreException\", e);\n                        }\n                        throw new RuntimeException(e);\n                    }\n                }\n            });\n            final ByteArrayOutputStream output = new ByteArrayOutputStream();\n            try {\n                final Properties props = new Properties();\n                final String dialectName = configuration.getAttribute(INexOpenLaunchConfigurationConstants.HIBERNATE_DIALECT, \"MySQL5InnoDB\");\n                props.setProperty(\"hibernate.dialect\", support.getDialectClass(dialectName));\n                props.setProperty(\"hibernate.connection.driver_class\", configuration.getAttribute(INexOpenLaunchConfigurationConstants.JDBC_DRIVER, \"com.mysql.jdbc.Driver\"));\n                props.setProperty(\"hibernate.connection.url\", configuration.getAttribute(INexOpenLaunchConfigurationConstants.JDBC_URL, \"jdbc:mysql://<host><:port>/<database>\"));\n                props.setProperty(\"hibernate.connection.username\", configuration.getAttribute(INexOpenLaunchConfigurationConstants.JDBC_USERNAME, \"sa\"));\n                props.setProperty(\"hibernate.connection.password\", configuration.getAttribute(INexOpenLaunchConfigurationConstants.JDBC_PASSWORD, \"\"));\n                props.store(output, \"hibernate properties for code generation using NexOpen Tools 1.0.0\");\n                final IFile props_file = prj.getFile(\"business/src/test/resources/hibernate.properties\");\n                if (!props_file.exists()) {\n                    props_file.create(new ByteArrayInputStream(output.toByteArray()), true, monitor);\n                } else {\n                    props_file.setContents(new ByteArrayInputStream(output.toByteArray()), true, false, monitor);\n                }\n            } catch (final IOException e) {\n                Logger.getLog().error(\"I/O exception \", e);\n                throw new RuntimeException(e);\n            } finally {\n                try {\n                    output.flush();\n                    output.close();\n                } catch (IOException e) {\n                }\n            }\n            if (NexOpenProjectUtils.is04xProject(prj)) {\n                final IFile appContext = prj.getFile(\"web/src/main/webapp/WEB-INF/applicationContext.xml\");\n                if (!appContext.exists()) {\n                    throw new IllegalStateException(\"It no exists applicationContext.xml under web/src/main/webapp/WEB-INF, not a NexOpen project\");\n                }\n                ContentHandlerTemplate.handle(appContext, new ContentHandlerCallback() {\n\n                    public void processHandle(final Document doc) {\n                        final Element root = doc.getDocumentElement();\n                        final List<Element> beans = XMLUtils.getChildElementsByTagName(root, \"bean\");\n                        for (final Element bean : beans) {\n                            final String id = bean.getAttribute(\"id\");\n                            if (\"valueListAdapterResolver\".equals(id)) {\n                                try {\n                                    final String pkgName = configuration.getAttribute(INexOpenLaunchConfigurationConstants.NEXOPEN_PACKAGE, \"\");\n                                    final String className = new StringBuilder(pkgName).append(\".vlh.support.AnnotationValueListAdapterResolver\").toString();\n                                    bean.setAttribute(\"class\", className);\n                                    break;\n                                } catch (final CoreException e) {\n                                    if (Logger.getLog().isInfoEnabled()) {\n                                        Logger.getLog().info(\"CoreException\", e);\n                                    }\n                                    throw new RuntimeException(e);\n                                }\n                            }\n                        }\n                    }\n                });\n            }\n            {\n                final String dialectName = configuration.getAttribute(INexOpenLaunchConfigurationConstants.HIBERNATE_DIALECT, \"MySQL5InnoDB\");\n                if (support.isReverseEngineeringFileNeeded(dialectName)) {\n                    try {\n                        final IFile revengFile = prj.getFile(\"business/src/test/resources/\" + support.getReversEngineeringFile(dialectName));\n                        if (!revengFile.exists()) {\n                            final Bundle bundle = HibernateActivator.getDefault().getBundle();\n                            final Path src = new Path(\"resources/\" + support.getReversEngineeringFile(dialectName));\n                            final InputStream in = FileLocator.openStream(bundle, src, false);\n                            final ByteArrayOutputStream baos = new ByteArrayOutputStream();\n                            IOUtils.copy(in, baos);\n                            String str = baos.toString();\n                            str = str.replace(\"${schema}\", configuration.getAttribute(INexOpenLaunchConfigurationConstants.JDBC_USERNAME, \"sa\"));\n                            revengFile.create(new ByteArrayInputStream(str.getBytes()), true, null);\n                        }\n                    } catch (final IOException e) {\n                        if (Logger.getLog().isInfoEnabled()) {\n                            Logger.getLog().info(\"CoreException\", e);\n                        }\n                        throw new RuntimeException(e);\n                    }\n                }\n            }\n            final IResource resource = (IResource) prj.getAdapter(IResource.class);\n            final QualifiedName qn = new QualifiedName(\"org.nexopenframework.ide.eclipse.ui\", \"default.profile\");\n            final String profile = resource.getPersistentProperty(qn);\n            resource.setPersistentProperty(qn, \"reverse-engineering\");\n            try {\n                final InstallProjectAction action = new InstallProjectAction();\n                action.scheduleJob(prj, monitor);\n                prj.refreshLocal(2, monitor);\n            } finally {\n                prj.setPersistentProperty(qn, profile);\n            }\n        } else {\n            Logger.getLog().info(\"Not a NexOpen project :: \" + prj);\n        }\n    }\n", "label": 0, "substitutes": {"read": ["report", "php", "handle", "transform", "process", "text", "find", "select", "sync", "test", "hello", "word", "resource", "reader", "view", "create", "raw", "stream", "run", "link", "build", "write", "open", "readable", "load", "reads", "close", "rd", "format", "required", "req", "content", "get", "input", "READ", "iter", "it", "parse", "show", "reflect", "walk", "Read", "info", "download", "config", "file", "reading", "check", "print"], "classLoader": ["classReader", "moduleloader", "ClassLoading", "thisLoader", "classloader", "thisPath", "moduleReader", "ClassPath", "fileLoader", " classLoading", "thisReader", "ClassManager", " classManager", "moduleLoader", "fileReader", "moduleLoading", "ClassReader", "classPath", "ClassLoader", "classManager", " classloader", "thisloader", "classLoading", " classReader", "Classloader", " classPath", "fileLoading", "fileManager"], "name": ["type", "nm", "ref", "named", "alias", "part", "word", "resource", "description", "m", "names", "base", "label", "old", "message", "current", "missing", "family", "filename", "l", "NAME", "common", "order", "parent", "search", "path", "null", "ame", "local", "n", "key", "string", "file", "password", "size", "root", "source", "id", "Name", "prefix", "title"], "all": ["first", "empty", "active", "each", "and", "default", "ALL", "also", "m", "force", "oll", "optional", "attribute", "All", "only", "multi", "list", "always", "required", "none", "enabled", "global", "many", "total", "valid", "allowed", "null", "any", "collection", "full", "local", "n", "multiple", "latest", "loop", "both"], "sm": ["nm", "ms", "arms", "sp", "hm", "mt", "SM", "m", "sbm", "mem", "imm", "ism", "md", "mg", "ym", "Sm", "esm", "mph", "tm", "arm", "sym", "sim", "rm", "dm", "bm", "sk", "cm", "sf", "igm", "gm", "wm", "mb", "asm", "tem", "sy", "km", "mn", "rpm", "mm", "model", "pm", "shell", "sem", "sam", "hem"], "enu": ["attenfu", "attenu", " enfu", "denfu", "enpu", " enuu", "erU", " enui", " enU", "eru", "ancu", "deniu", "atteniu", "attenuu", "Enpu", "Enui", "denuu", "encu", "Encu", " ennu", "enfu", "enuu", "denu", "EnU", " encu", "enus", "anu", " eniu", "enU", "erui", "Enu", "enui", "annu", "eniu", " enpu", "ennu", "anus", " enus", "erpu", "Ennu", "Enus"], "url": ["f", "browser", "gl", "sb", "ref", "dl", "bl", "sp", "ob", "resource", "bel", "ls", "web", "ll", "base", "char", "link", "pl", "net", "sl", "log", "b", "cert", "build", "open", "pkg", "db", "rel", "ur", "v", "mount", "uri", "URL", "rl", "l", "nl", "path", "ol", "add", "r", "key", "http", "arl", "job", "il", "Url", "user"], "is": ["mis", "mi", "ois", "ms", "iris", "mos", "ins", "oss", "Is", "im", "js", "ri", "nis", "fs", "sys", "bs", "ls", "isa", "ais", "init", "in", "dis", "tis", "ism", "rest", "bits", "vis", "ps", "sim", "ires", "i", "its", "mus", "act", "gc", "ris", "os", "IS", "are", "has", "was", "iter", "it", "out", "sis", "isc", "ims", "ir", "isl", "lis", "obs", "bis", "ip", "isf", "vs", "isi", "isin", "iso", "ios", "iss", "es", "abs"], "s": ["f", "csv", "ss", "sb", "prints", "p", "ms", "y", "parts", "h", "arts", "js", "m", "ws", "fs", "qs", "set", "ains", "ls", "conv", "t", "hs", "ns", "ings", "ves", "uts", "c", "stats", "b", "ps", "S", "ts", "join", "ags", "v", "its", "less", "sv", "ats", "str", "os", "rs", "l", "ols", "ds", "sol", "sql", "gs", "css", "g", "n", "sts", "string", "gets", "ists", "tes", "es", "ries", "results", "ies", "cs", "abs"]}}
{"id1": "13644375", "id2": "6371589", "code1": "    public String get(String url) {\n        try {\n            HttpGet get = new HttpGet(url);\n            HttpResponse response = this.getHttpClient().execute(get);\n            HttpEntity entity = response.getEntity();\n            if (entity == null) {\n                throw new RuntimeException(\"response body was empty\");\n            }\n            return EntityUtils.toString(entity);\n        } catch (RuntimeException ex) {\n            throw ex;\n        } catch (Exception ex) {\n            throw new RuntimeException(ex);\n        }\n    }\n", "code2": "    public void insertUser(final List<NewUser> newUsers) {\n        try {\n            connection.setAutoCommit(false);\n            final Map<String, PasswordAndSalt> pass = new HashMap<String, PasswordAndSalt>();\n            final Map<String, List<RealmWithEncryptedPass>> realmPass = new HashMap<String, List<RealmWithEncryptedPass>>();\n            final List<String> userDirs = new ArrayList<String>();\n            Iterator<NewUser> iter = newUsers.iterator();\n            NewUser user;\n            Realm realm;\n            String username;\n            PasswordHasher ph;\n            while (iter.hasNext()) {\n                user = iter.next();\n                username = user.username.toLowerCase(locale);\n                ph = PasswordFactory.getInstance().getPasswordHasher();\n                pass.put(user.username, new PasswordAndSalt(ph.hashPassword(user.password), ph.getSalt()));\n                realmPass.put(user.username, new ArrayList<RealmWithEncryptedPass>());\n                realmPass.get(user.username).add(new RealmWithEncryptedPass(cm.getRealm(\"null\"), PasswordFactory.getInstance().getPasswordHasher().hashRealmPassword(username, \"\", user.password)));\n                if (user.realms != null) {\n                    for (String realmName : user.realms) {\n                        realm = cm.getRealm(realmName);\n                        realmPass.get(user.username).add(new RealmWithEncryptedPass(realm, PasswordFactory.getInstance().getPasswordHasher().hashRealmPassword(username, realm.getFullRealmName(), user.password)));\n                    }\n                    user.realms = null;\n                }\n            }\n            new ProcessEnvelope().executeNull(new ExecuteProcessAbstractImpl(connection, false, false, true, true) {\n\n                @Override\n                public void executeProcessReturnNull() throws SQLException {\n                    psImpl = connImpl.prepareStatement(sqlCommands.getProperty(\"user.add\"), Statement.RETURN_GENERATED_KEYS);\n                    Iterator<NewUser> iter = newUsers.iterator();\n                    NewUser user;\n                    DomainDb domain = null;\n                    while (iter.hasNext()) {\n                        user = iter.next();\n                        psImpl.setString(1, user.username);\n                        psImpl.setString(2, user.username.toLowerCase(locale));\n                        if (domain == null || (domain.getDomainId() != user.domainId)) {\n                            domain = (DomainDb) cmDB.getDomain(user.domainId);\n                        }\n                        userDirs.add(user.username + '@' + domain.getDomainName());\n                        psImpl.setInt(3, user.domainId);\n                        psImpl.setString(4, pass.get(user.username).password);\n                        psImpl.setString(5, pass.get(user.username).salt);\n                        psImpl.executeUpdate();\n                        rsImpl = psImpl.getGeneratedKeys();\n                        if (rsImpl.next()) {\n                            user.userId = rsImpl.getInt(1);\n                            rsImpl.close();\n                        } else {\n                            throw new SQLException(\"Need to have a user id generated.\");\n                        }\n                    }\n                }\n            });\n            new ProcessEnvelope().executeNull(new ExecuteProcessAbstractImpl(connection, false, false, true, true) {\n\n                @Override\n                public void executeProcessReturnNull() throws SQLException {\n                    psImpl = connImpl.prepareStatement(sqlCommands.getProperty(\"realm.addUser\"));\n                    Iterator<NewUser> iter = newUsers.iterator();\n                    NewUser user;\n                    List<RealmWithEncryptedPass> list;\n                    RealmWithEncryptedPass rwep;\n                    RealmDb realm;\n                    while (iter.hasNext()) {\n                        user = iter.next();\n                        list = realmPass.get(user.username);\n                        if (list != null) {\n                            Iterator<RealmWithEncryptedPass> iter1 = list.iterator();\n                            while (iter1.hasNext()) {\n                                rwep = iter1.next();\n                                realm = (RealmDb) rwep.realm;\n                                psImpl.setInt(1, realm.getRealmId());\n                                psImpl.setInt(2, user.userId);\n                                psImpl.setInt(3, user.domainId);\n                                psImpl.setString(4, rwep.password);\n                                psImpl.executeUpdate();\n                            }\n                        }\n                    }\n                }\n            });\n            connection.commit();\n            Iterator<String> iterator = userDirs.iterator();\n            while (iterator.hasNext()) {\n                cm.requestDirCreation(new File(cm.getUsersDirectory(), iterator.next()).getPath());\n            }\n            cm.createDirectories();\n        } catch (GeneralSecurityException e) {\n            log.error(e);\n            if (connection != null) {\n                try {\n                    connection.rollback();\n                } catch (SQLException ex) {\n                }\n            }\n            throw new RuntimeException(\"Error updating Realms. Unable to continue Operation.\");\n        } catch (SQLException sqle) {\n            log.error(sqle);\n            if (connection != null) {\n                try {\n                    connection.rollback();\n                } catch (SQLException ex) {\n                }\n            }\n        } finally {\n            if (connection != null) {\n                try {\n                    connection.setAutoCommit(true);\n                } catch (SQLException ex) {\n                }\n            }\n        }\n    }\n", "label": 0, "substitutes": {"get": ["play", "json", "find", "select", "put", "draw", "service", "request", "execute", "resource", "create", "set", "update", "run", "debug", "command", "we", "build", "open", "load", "current", "call", "post", "read", "see", "head", "method", "give", "pull", "query", "parse", "search", "show", "GET", "pre", "ge", "Get", "http", "download", "gets", "got", "exec", "send", "body", "check", "print", "delete", "like"], "url": ["ref", "address", "dl", "page", "ls", "web", "ll", "base", "link", "build", "pl", "sl", "ur", "mount", "uri", "URL", "name", "str", "rl", "l", "api", "nl", "parse", "path", "href", "domain", "ret", "full", "http", "location", "html", "string", "pattern", "server", "loc", "Url", "id", "host"], "response": ["all", "reply", "respons", "json", "block", "image", "output", "res", "entry", "next", "service", "request", "resource", "application", "client", "yes", "Response", "page", "status", "trace", "connection", "open", "resp", "soc", "document", "message", "result", "onse", "re", "post", "content", "successful", "pos", "respond", "tree", "object", "answer", "http", "still", "body", "data", "given"], "entity": ["type", "event", "unique", "json", "image", "and", "entry", "put", "email", "ee", "comment", "resource", "obj", "client", "base", "ce", "me", "one", "em", "load", "document", "result", "content", "e", "eme", "le", "person", "total", "ent", "note", "object", "component", "form", "encrypted", "security", "group", "complex", "record", "instance", "line", "model", "any", "el", "activity", "member", "info", "session", "remote", "channel", "Entity", "iso", "ity", "body", "unit", "user", "data", "pe", "peer"]}}
{"id1": "20306677", "id2": "471804", "code1": "    public int update(BusinessObject o) throws DAOException {\n        int update = 0;\n        Bill bill = (Bill) o;\n        try {\n            PreparedStatement pst = connection.prepareStatement(XMLGetQuery.getQuery(\"UPDATE_BILL\"));\n            pst.setInt(1, bill.getId());\n            update = pst.executeUpdate();\n            if (update <= 0) {\n                connection.rollback();\n                throw new DAOException(\"Number of rows <= 0\");\n            } else if (update > 1) {\n                connection.rollback();\n                throw new DAOException(\"Number of rows > 1\");\n            }\n            connection.commit();\n        } catch (SQLException e) {\n            Log.write(e.getMessage());\n            throw new DAOException(\"A SQLException has occured\");\n        } catch (NullPointerException npe) {\n            Log.write(npe.getMessage());\n            throw new DAOException(\"Connection null\");\n        }\n        return update;\n    }\n", "code2": "    public static void doVersionCheck(View view) {\n        view.showWaitCursor();\n        try {\n            URL url = new URL(jEdit.getProperty(\"version-check.url\"));\n            InputStream in = url.openStream();\n            BufferedReader bin = new BufferedReader(new InputStreamReader(in));\n            String line;\n            String version = null;\n            String build = null;\n            while ((line = bin.readLine()) != null) {\n                if (line.startsWith(\".version\")) version = line.substring(8).trim(); else if (line.startsWith(\".build\")) build = line.substring(6).trim();\n            }\n            bin.close();\n            if (version != null && build != null) {\n                if (jEdit.getBuild().compareTo(build) < 0) newVersionAvailable(view, version, url); else {\n                    GUIUtilities.message(view, \"version-check\" + \".up-to-date\", new String[0]);\n                }\n            }\n        } catch (IOException e) {\n            String[] args = { jEdit.getProperty(\"version-check.url\"), e.toString() };\n            GUIUtilities.error(view, \"read-error\", args);\n        }\n        view.hideWaitCursor();\n    }\n", "label": 0, "substitutes": {"update": ["edit", "all", "report", "json", "value", "flush", "insert", "find", "u", "match", "put", "test", "draw", "updated", "fill", "execute", "op", " Update", "size", "UPDATE", "create", "set", "status", "run", "init", "date", "build", "print", "write", "oo", "load", "replace", "current", "call", " UPDATE", "touch", "up", "state", "now", "get", "ask", "out", "upload", "login", "commit", "query", "offset", "change", "batch", "add", "database", "use", "num", "local", "id", "save", "send", "where", "patch", "Update", "check", "latest", "version", "index", "delete", "user", "push"], "o": ["oice", "u", "y", "om", "ao", "ob", "ooo", "bo", " mo", "obj", "m", "onet", "mo", "oin", "oa", "t", "po", "k", "oo", "b", "to", " os", "v", "i", "e", "vo", "oid", "os", "out", "fo", "object", "O", "n", "iso", "p", "a"], "bill": ["report", "handle", "stuff", "money", "unk", "BILL", "bank", " billed", "nn", "service", "Bill", "trade", "bo", "ll", "ann", "work", "build", "net", "company", "ship", "b", "biz", "bb", "fax", "pay", "iban", "sk", "nb", "vo", "kick", "lex", "project", " billing", "conn", " Bill", "fund", "batch", "gross", "bean", "inv", "bar", "book", "quote", "phy"], "pst": ["apst", " pST", "apct", "cstra", "picstra", "pse", "pct", "tpse", " pct", "tpst", "cst", "opstra", " psp", "cth", "opst", "tpct", " pse", "pkgst", "opct", "opse", "pstra", "pST", "pth", "tpstra", "picstro", "pkgstra", "pkgstro", "cstro", "tpST", "psp", "pkgth", " pstra", "pstro", "picst", "tpsp", "apST", "picth", "apsp"]}}
{"id1": "13783898", "id2": "149935", "code1": "    public static boolean encodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.ENCODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "code2": "    public void convert(File src, File dest) throws IOException {\n        InputStream in = new BufferedInputStream(new FileInputStream(src));\n        DcmParser p = pfact.newDcmParser(in);\n        Dataset ds = fact.newDataset();\n        p.setDcmHandler(ds.getDcmHandler());\n        try {\n            FileFormat format = p.detectFileFormat();\n            if (format != FileFormat.ACRNEMA_STREAM) {\n                System.out.println(\"\\n\" + src + \": not an ACRNEMA stream!\");\n                return;\n            }\n            p.parseDcmFile(format, Tags.PixelData);\n            if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) {\n                System.out.println(\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n                return;\n            }\n            boolean hasPixelData = p.getReadTag() == Tags.PixelData;\n            boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12;\n            int pxlen = p.getReadLength();\n            if (hasPixelData) {\n                if (inflate) {\n                    ds.putUS(Tags.BitsAllocated, 16);\n                    pxlen = pxlen * 4 / 3;\n                }\n                if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) {\n                    System.out.println(\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                    return;\n                }\n            }\n            ds.putUI(Tags.StudyInstanceUID, uid(studyUID));\n            ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID));\n            ds.putUI(Tags.SOPInstanceUID, uid(instUID));\n            ds.putUI(Tags.SOPClassUID, classUID);\n            if (!ds.contains(Tags.NumberOfSamples)) {\n                ds.putUS(Tags.NumberOfSamples, 1);\n            }\n            if (!ds.contains(Tags.PhotometricInterpretation)) {\n                ds.putCS(Tags.PhotometricInterpretation, \"MONOCHROME2\");\n            }\n            if (fmi) {\n                ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian));\n            }\n            OutputStream out = new BufferedOutputStream(new FileOutputStream(dest));\n            try {\n            } finally {\n                ds.writeFile(out, encodeParam());\n                if (hasPixelData) {\n                    if (!skipGroupLen) {\n                        out.write(PXDATA_GROUPLEN);\n                        int grlen = pxlen + 8;\n                        out.write((byte) grlen);\n                        out.write((byte) (grlen >> 8));\n                        out.write((byte) (grlen >> 16));\n                        out.write((byte) (grlen >> 24));\n                    }\n                    out.write(PXDATA_TAG);\n                    out.write((byte) pxlen);\n                    out.write((byte) (pxlen >> 8));\n                    out.write((byte) (pxlen >> 16));\n                    out.write((byte) (pxlen >> 24));\n                }\n                if (inflate) {\n                    int b2, b3;\n                    for (; pxlen > 0; pxlen -= 3) {\n                        out.write(in.read());\n                        b2 = in.read();\n                        b3 = in.read();\n                        out.write(b2 & 0x0f);\n                        out.write(b2 >> 4 | ((b3 & 0x0f) << 4));\n                        out.write(b3 >> 4);\n                    }\n                } else {\n                    for (; pxlen > 0; --pxlen) {\n                        out.write(in.read());\n                    }\n                }\n                out.close();\n            }\n            System.out.print('.');\n        } finally {\n            in.close();\n        }\n    }\n", "label": 1, "substitutes": {"encodeFileToFile": ["encodeStringAsFile", "encodeFileToFiles", "encodeFileToDisk", "encodeFileAsFile", "encodeStringToFile", "encodeFileToStream", "encodeFileFromFiles", "encodeStringAsDisk", "encodeStringAsStream", "encodeFiletoFile", "encodeFileAsStream", "encodeStringToDisk", "encodeFileAsDisk", "encodeFiletoDisk", "encodeFiletoFiles", "encodeStringToFiles", "encodeFileFromStream", "encodeFileAsFiles", "encodeFileFromDisk", "encodeStringAsFiles", "encodeFiletoStream", "encodeFileFromFile", "encodeStringToStream"], "infile": ["inputfilename", "inputFile", "outbase", "outFile", " inFile", "inpath", " inbase", " infilename", "outfilename", "inbase", "InFile", "infilename", "inFile", "inputfile", "Inbase", "inputpath", " inpath", "Inpath", "outpath", "Infile"], "outfile": ["outfp", "newFile", "outname", "newfile", "indir", " outname", "outFile", "outdir", "fromfile", "outfilename", "inname", "newname", " outfilename", "tofp", "infilename", "todir", "inFile", "infp", "toFile", "newfilename", "fromfp", " outFile", "fromdir", "tofile", "fromFile"], "in": ["rin", "en", "image", "inn", "ini", "by", "gin", "con", "IN", "ins", "pin", "im", "ar", "on", "oin", "ro", "al", "In", "t", "inner", "inside", "init", "re", "up", "i", "bin", "get", "inc", "input", "amin", "or", "iter", "it", "per", " din", "form", "conn", "ain", "ind", "nin", "info", "din", "inf", "is", "isin", "source", "cin", "id", "from"], "out": ["ion", "co", "en", "nt", "flush", "con", "output", "res", "oss", "cn", "on", "sys", "t", "inner", "net", "write", "print", "b", "to", "end", "opt", "up", "writer", "os", "outer", "it", "OU", "gt", "null", "ou", "at", "outs", "g", "o", "aos", "ex", "n", "io", "Out", "file", "fn", "OUT", "can", "ne", "ot"], "buffer": ["phrase", "buf", "window", "bone", "block", "buff", "sample", "column", "frame", "comment", "view", "sequence", "append", "table", "pad", "library", "mem", "base", "template", "command", "attribute", "document", "message", "available", "stack", "number", "cache", "Buffer", "variable", "black", "total", "initial", "note", "history", "paste", "queue", "length", "binary", "batch", "bar", "padding", "info", "row", "display", "temp", "button", "password", "memory", "print", "header", "character"], "read": ["first", "each", "text", "find", "select", "reader", "wait", "allow", "raw", "stream", "set", "run", "before", "range", "write", "open", "push", "readable", "load", "print", "reads", "hold", "seek", "close", "i", "req", "skip", "get", " Read", "give", "input", "need", "iter", "through", "query", "len", "length", "Read", "ind", "add", "connect", "count", "n", "ready", "start", "size", "reading", "send", "check", "index", "READ", "end", "ok"], "success": ["first", "same", "good", "response", "value", " succ", "ceed", "cess", "positive", "fail", "city", "release", " successful", "summary", "please", "status", " Success", "ith", "accept", "Success", "danger", "done", "ratulations", "ccess", "growth", "warning", "primary", "result", "safe", " okay", "second", "unity", "crit", "condition", "successful", " failure", "sufficient", "error", "valid", "complete", "commit", "snap", "democracy", "continue", "photo", "surv", "successfully", "town", "submit", "support", " successes", "setup", "ok"]}}
{"id1": "62362", "id2": "3024992", "code1": "    public void convert(File src, File dest) throws IOException {\n        InputStream in = new BufferedInputStream(new FileInputStream(src));\n        DcmParser p = pfact.newDcmParser(in);\n        Dataset ds = fact.newDataset();\n        p.setDcmHandler(ds.getDcmHandler());\n        try {\n            FileFormat format = p.detectFileFormat();\n            if (format != FileFormat.ACRNEMA_STREAM) {\n                System.out.println(\"\\n\" + src + \": not an ACRNEMA stream!\");\n                return;\n            }\n            p.parseDcmFile(format, Tags.PixelData);\n            if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) {\n                System.out.println(\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n                return;\n            }\n            boolean hasPixelData = p.getReadTag() == Tags.PixelData;\n            boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12;\n            int pxlen = p.getReadLength();\n            if (hasPixelData) {\n                if (inflate) {\n                    ds.putUS(Tags.BitsAllocated, 16);\n                    pxlen = pxlen * 4 / 3;\n                }\n                if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) {\n                    System.out.println(\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                    return;\n                }\n            }\n            ds.putUI(Tags.StudyInstanceUID, uid(studyUID));\n            ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID));\n            ds.putUI(Tags.SOPInstanceUID, uid(instUID));\n            ds.putUI(Tags.SOPClassUID, classUID);\n            if (!ds.contains(Tags.NumberOfSamples)) {\n                ds.putUS(Tags.NumberOfSamples, 1);\n            }\n            if (!ds.contains(Tags.PhotometricInterpretation)) {\n                ds.putCS(Tags.PhotometricInterpretation, \"MONOCHROME2\");\n            }\n            if (fmi) {\n                ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian));\n            }\n            OutputStream out = new BufferedOutputStream(new FileOutputStream(dest));\n            try {\n            } finally {\n                ds.writeFile(out, encodeParam());\n                if (hasPixelData) {\n                    if (!skipGroupLen) {\n                        out.write(PXDATA_GROUPLEN);\n                        int grlen = pxlen + 8;\n                        out.write((byte) grlen);\n                        out.write((byte) (grlen >> 8));\n                        out.write((byte) (grlen >> 16));\n                        out.write((byte) (grlen >> 24));\n                    }\n                    out.write(PXDATA_TAG);\n                    out.write((byte) pxlen);\n                    out.write((byte) (pxlen >> 8));\n                    out.write((byte) (pxlen >> 16));\n                    out.write((byte) (pxlen >> 24));\n                }\n                if (inflate) {\n                    int b2, b3;\n                    for (; pxlen > 0; pxlen -= 3) {\n                        out.write(in.read());\n                        b2 = in.read();\n                        b3 = in.read();\n                        out.write(b2 & 0x0f);\n                        out.write(b2 >> 4 | ((b3 & 0x0f) << 4));\n                        out.write(b3 >> 4);\n                    }\n                } else {\n                    for (; pxlen > 0; --pxlen) {\n                        out.write(in.read());\n                    }\n                }\n                out.close();\n            }\n            System.out.print('.');\n        } finally {\n            in.close();\n        }\n    }\n", "code2": "    @Test\n    public void testCopy_readerToWriter_nullIn() throws Exception {\n        ByteArrayOutputStream baout = new ByteArrayOutputStream();\n        OutputStream out = new YellOnFlushAndCloseOutputStreamTest(baout, true, true);\n        Writer writer = new OutputStreamWriter(baout, \"US-ASCII\");\n        try {\n            IOUtils.copy((Reader) null, writer);\n            fail();\n        } catch (NullPointerException ex) {\n        }\n    }\n", "label": 1, "substitutes": {"convert": ["Converting", "compvert", "converts", "unverted", "consvert", "Conprocess", "CONversion", "converted", "Conversion", "unprocess", "confer", "unfer", "Confer", "unvert", "unverts", "compverts", "ConVERT", "Converted", "CONvert", "conversion", "conprocess", "CONfer", "Convert", "CONverted", "unversion", "compversion", "compprocess", "consversion", "converting", "CONverting", "consVERT", "consverting", "conVERT", "CONVERT", "Converts"], "src": ["ser", "buster", "rc", "txt", "hl", "scan", "usr", "attr", "img", "orig", "func", "ins", "sit", "cont", "sys", "stream", "SourceFile", "sq", "addr", "rest", "pkg", "cur", "sr", "rel", "filename", "ur", "Source", "its", "req", "url", "uri", "RC", "rs", "str", "SOURCE", "inst", "input", "upload", "sin", "rx", "sc", "st", "path", "ource", "s", "iv", "scene", "href", "http", "config", "dist", "start", "file", "source", "loc", "ipl", "ebin", "from", "host", "cc"], "dest": ["txt", "img", " destinations", "gin", "orig", "test", "disk", "est", "table", "port", "rest", "write", " Dest", "result", " dst", "mat", "target", "foreign", " orig", " destination", "dir", "dat", "Dest", "dist", "temp", " Destination", "source", "tif"], "in": ["en", "rin", "inn", "res", "IN", "ins", "d", "ar", "reader", "m", "stream", "In", "inner", "b", "up", "i", "bin", "serv", "l", "input", "sql", "st", "ind", "r", "el", "ad", "io", "din", "inf", "is", "isin", "source", "as", "file", "cin", "from"], "p": ["f", "php", "pa", "pb", "dp", "j", "pd", "tp", "rep", "vp", "sp", "d", "py", "parser", "part", "h", "op", "pp", "m", "fp", "t", "pl", "c", "pkg", "b", "pg", "ps", "ping", "post", "pro", "i", "cp", "ph", "pc", "pt", "pi", "l", "it", "per", "parse", "P", "pers", "at", "lp", "pre", "g", "r", "jp", "pm", "er", "wp", "prot", "pe", "ap"], "ds": ["dates", "dp", "di", " ads", "scripts", "loads", "yes", "qs", "tests", "ns", "ps", "drivers", "db", "dds", "sd", "ats", "dt", " DS", "ports", "ras", "terms", "ss", "DS", "ws", "bs", "docs", "hs", "workers", "iffs", "lists", "os", "edes", "gs", " dd", "hd", "vs", " d", "uds", "ils", "eds", "xs", "tags", "Ds", "dl", "els", "sets", "gd", "ls", "ts", "ags", "rs", " des", "obs", "s", "outs", "ods", "sts", "posts", "ands", "tes", "cs", "amps", "dos", "ads", "pd", "tp", "mys", "d", "cks", "js", " os", "its", "aws", "ys", "des", "eps", "dd", "ks", "points", "df", "nas", "dh"], "format": ["type", "f", "style", "layout", "settings", "output", "policy", "MAT", "feature", "mt", "fm", "set", "status", "table", "tag", "t", "feat", " Format", "module", "template", "sche", "spec", "fc", "shape", "mode", "Format", "ct", "act", "mat", "name", "ats", "pi", "top", "l", "it", "parse", "form", "path", "at", "filter", "lat", "pattern", "id", "cf", "file", "source", "size", "unit", "version", "pretty", "title"], "hasPixelData": ["HaspixelDATA", "hasixelData", "hasPixelDATA", "Haspixeldata", "hasPixeldata", "HasPixelDATA", "HaspixelData", "hasFrameData", "hasFrameDATA", "haspixelDATA", "hasFramedata", "HasPixeldata", "haspixeldata", " hasPixelDATA", " hasPixeldata", "hasixeldata", "hasixelDATA", "HasPixelData", "haspixelData"], "inflate": ["inFLated", "Inflate", "invalidATE", "inFLat", "inFLocate", "incelate", " invalidicate", "infolat", "Inflat", "invalidate", "inFlicate", "inflATE", "inflated", "incelicate", " inflocate", "incelocate", "Informocate", "Informated", "incelATE", "inFlATE", " inflicate", "inFlate", " invalidate", "informat", "infolated", "Inflocate", "inflicate", "inFlocate", "infolocate", "informocate", "informate", "Informat", "invalidicate", "Inflated", " inflATE", "inflocate", "informated", "Informate", "inFLate", "invalidocate", " invalidATE", "inflat", " invalidocate", "infolate"], "pxlen": ["pxln", "mmlin", "packlen", "pxlength", "cpln", "xplength", "cplength", "phpln", "pixellength", "pxlin", "cpden", "mxlength", "cplen", "packlength", "pexlength", "xylen", "mmlen", "pxdec", "tmpln", "packdec", "phplength", "pexln", "mxdec", "packfun", "pexls", "mxlen", "pxls", "pxfun", "xylin", "xyln", "tmplin", "xpden", "mxln", "tmplen", "pexlen", "pxden", "phplen", "pexfun", "mmlength", "pixelfun", "packls", "xpln", "phpdec", "pixells", "pexden", "tmplength", "xplen", "packln", "mmln", "pixellen", "xylength"], "out": ["output", "res", "obj", "ln", "client", "sys", "sum", "inter", "init", "net", "log", "print", "err", "list", "up", "crit", "name", "writer", "outer", "cmd", "conn", "gov", "ou", "group", "aos", "outs", "dir", "cfg", "inv", "screen", "gr", "io", "msg", "temp", "Out", "OUT", "user", "store", "pretty", "prefix", "ex"]}}
{"id1": "3266833", "id2": "693636", "code1": "    public MotixFileItem(final InputStream is, final String name, final String contentType, final int index) throws IOException {\n        this.name = name;\n        this.contentType = contentType;\n        this.index = index;\n        this.extension = FilenameUtils.getExtension(this.name);\n        this.isImage = ImageUtils.isImage(name);\n        ArrayInputStream isAux = null;\n        final ByteArrayOutputStream out = new ByteArrayOutputStream();\n        try {\n            IOUtils.copy(is, out);\n            isAux = new ArrayInputStream(out.toByteArray());\n            if (this.isImage) {\n                this.bufferedImage = imaging.read(isAux);\n            }\n        } finally {\n            IOUtils.closeQuietly(out);\n            IOUtils.closeQuietly(isAux);\n        }\n        this.inputStream = new ArrayInputStream(out.toByteArray());\n    }\n", "code2": "    public static int createEmptyCart() {\n        int SHOPPING_ID = 0;\n        Connection con = null;\n        try {\n            con = getConnection();\n        } catch (java.lang.Exception ex) {\n            ex.printStackTrace();\n        }\n        try {\n            PreparedStatement insert_cart = null;\n            SHOPPING_ID = Integer.parseInt(Sequence.getSequenceNumber(\"shopping_cart\"));\n            insert_cart = con.prepareStatement(\"INSERT INTO shopping_cart (sc_id, sc_time) VALUES ( ? , NOW() )\");\n            insert_cart.setInt(1, SHOPPING_ID);\n            insert_cart.executeUpdate();\n            con.commit();\n            insert_cart.close();\n            returnConnection(con);\n        } catch (java.lang.Exception ex) {\n            try {\n                con.rollback();\n                ex.printStackTrace();\n            } catch (Exception se) {\n                System.err.println(\"Transaction rollback failed.\");\n            }\n        }\n        return SHOPPING_ID;\n    }\n", "label": 0, "substitutes": {"is": ["ois", "iris", "us", "parts", "Is", "fs", "sys", "bs", "isa", "ais", "init", "in", "bits", "i", "its", "serv", "get", "ris", "os", "IS", "has", "was", "isc", "isl", "lis", "s", "bis", "isf", "any", "info", "ists", "isi", "ios", "as", "isin", "iso", "iss", "sis"], "name": ["type", "admin", "handle", "image", "value", "default", "named", "alias", "part", "word", "description", "sequence", "create", "names", "in", "base", "template", "code", "current", "family", "filename", "number", "format", "i", "url", "position", "get", "NAME", "order", "this", "parent", "search", "path", "length", "term", "normal", "null", "ame", "local", "self", "n", "key", "location", "string", "info", "file", "size", "source", "body", "class", "id", "version", "Name", "data", "prefix", "title"], "contentType": ["messageLength", " contentLength", "messageType", "mediaQuery", "contentQuery", "Contenttype", "messagetype", "messageControl", " contenttype", "mediaControl", "contentUnit", "mediaTypes", "contentLength", "messageQuery", "ContentTypes", "ContentType", "ContentLength", " contentTypes", " contentControl", "fileType", "fileQuery", "messageTypes", "contentControl", "fileTypes", "mediaUnit", "mediaType", "fileLength", "contenttype", " contentUnit", "messageUnit", "mediatype", "contentTypes", "mediaLength"], "index": ["type", "access", "address", "image", "lock", "find", "value", "test", "fee", "depth", "sequence", "exclusive", "create", "axis", "x", "level", "code", "action", "open", "slice", "max", "list", "i", "Index", "number", "content", "position", "error", "success", "sort", "pos", "offset", "path", "length", "height", "si", "dx", "ind", "batch", "instance", "num", "count", "n", "row", "key", "info", "start", "size", "timeout", "id", "update", "prefix"], "extension": ["protend", "protension", "contention", "xtitude", "extention", "contitude", "xtention", "protention", "xtend", "extitude", "extend", "xtension", "protitude", "contension", "contend"], "isImage": ["isFile", "hasMedia", "wasFile", " isFile", "isaPhoto", "ISImage", "wasMedia", "wasImage", "needsimage", "needsMedia", "needsPhoto", "ISPhoto", "isoImage", " isItemImage", "hasFile", "hasImage", "areImage", "isItemImage", "areItemImage", "isPicture", "hasimage", "needsImage", "ISPicture", "needsFile", "isaPicture", " isMedia", "areMedia", "isoItemImage", "isoFile", "isoMedia", "isimage", "needsPicture", "isaImage", "isMedia", "isPhoto", "areFile", "ISimage", "isaimage", "wasimage"], "isAux": ["wasAult", "isAAxx", "isPaUX", "isAcux", "isiOAiox", "isOAaux", " isAaux", " isAx", "isinPaUX", "isiAux", "isAaux", " isAUX", "isOAult", "isAiox", "isiAuxe", "isCAuxe", "isauxe", "isinAaux", "isAult", "isAAUX", "isPaux", "isCAiox", "isAndUX", "isAx", "isCAux", "isCAx", "isAndux", "isNAux", "isAcx", "isOAUX", "isSAUX", "isAndaux", "isiAaux", "wasAxx", "wasAAult", "isiOAaux", "isNAmp", "isOAiox", "wasAAxx", "isiOAux", "isaaux", "isCAUX", "isSAmp", "isaiox", "isaux", "isinPaaux", "wasAUX", "isinPaux", "isOAux", "isAAux", "isAxx", "isAmp", "isAcUX", "isOAxx", " isCAx", "isiAiox", "wasAAux", "isiOAuxe", " isCAux", "isCAaux", "isinPamp", "isSAux", "isAcaux", "isNAaux", "isPamp", "isinAmp", "isSAaux", "wasAAUX", "isAUX", "isinAux", "isAuxe", "isPaaux", "isAAult", " isCAUX", "isAndx", "isinAUX", "isOAuxe", "wasAux", "isNAUX", " isCAaux"], "out": ["all", "ion", "co", "nt", "lock", "by", "vol", "output", "con", "cos", "res", "oss", "cn", "sys", "sum", "tmp", "conv", "t", "in", "port", "chain", "net", "we", "log", "b", "to", "go", "result", "list", "up", "v", "gc", " Out", "cache", "os", " OUT", "outer", "pos", "ent", "OU", "order", "it", "this", "conn", "null", "at", "batch", "o", "outs", "aos", "boot", "auto", "n", "io", "Out", "pool", "timeout", "OUT", "user", "p", "ex", " output", "w"], "bufferedImage": ["bufferredImages", "renderedImages", "renderedVideo", "bufferingImage", "bufferingimage", "buffererImages", "bufferedimage", "renderingImage", "renderedImage", "bufferredimage", "renderingImages", "renderedimage", "bufferredImage", "bufferingImages", "buffererImage", "bufferedVideo", "buffererimage", "bufferedImages", "bufferredVideo", "bufferingVideo", "renderingVideo", "buffererVideo", "renderingimage"], "inputStream": ["outputView", "outputStream", "InputStream", "InputView", "InputSteam", "currentStream", "Inputstream", "outputSteam", "outputstream", "currentSteam", "inputstream", "currentstream", "currentView", "inputSteam", "inputView"]}}
{"id1": "2518655", "id2": "12380475", "code1": "    public static void main(String[] args) throws FileNotFoundException {\n        if (args.length < 2) throw new IllegalArgumentException();\n        String fnOut = args[args.length - 1];\n        PrintWriter writer = new PrintWriter(fnOut);\n        for (int i = 0; i < args.length - 1; i++) {\n            File fInput = new File(args[i]);\n            Scanner in = new Scanner(fInput);\n            while (in.hasNext()) {\n                writer.println(in.nextLine());\n            }\n        }\n        writer.close();\n    }\n", "code2": "    public void transport(File file) throws TransportException {\n        if (file.exists()) {\n            if (file.isDirectory()) {\n                File[] files = file.listFiles();\n                for (int i = 0; i < files.length; i++) {\n                    transport(file);\n                }\n            } else if (file.isFile()) {\n                try {\n                    FileChannel inChannel = new FileInputStream(file).getChannel();\n                    FileChannel outChannel = new FileOutputStream(destinationDir).getChannel();\n                    inChannel.transferTo(0, inChannel.size(), outChannel);\n                } catch (IOException e) {\n                    log.error(\"File transfer failed\", e);\n                }\n            }\n        }\n    }\n", "label": 1, "substitutes": {"fnOut": [" fnIn", "synOutput", "fnOr", " fnNet", "pdfIn", "synIn", "fnOs", " fnOutput", "dnOr", "fnNet", "pdfNet", "dnOut", "fnIn", "bfNet", " fnOs", "synOr", "synOut", "bfOut", "dnIn", "fnOutput", "pdfOs", "pdfOut", "dnOutput", "bfIn", " fnOr", "bfOs"], "writer": ["runner", "report", "window", "worker", "creator", "flush", "her", "rator", "Writer", "caster", "and", "writers", "console", "parser", "driver", "service", "comment", "reader", "builder", "client", "wright", "writing", "table", "inner", "maker", "white", "aster", "editor", "write", "buffer", "writ", "master", "journal", "println", "close", "widget", "format", "variable", "external", "operator", "outer", "written", "commit", "walker", "handler", "auto", "width", "fn", "file", "riter", "zero", "send", "loader", "wrapper", "print", "w"], "i": ["mi", "u", "ini", "j", "us", "y", "ski", "I", "ie", "ogi", "qi", "di", "im", "ri", "ei", "m", "ki", "client", "init", "x", "hi", "me", "iu", "q", "ti", "bi", "c", "chain", "ic", "multi", "ci", "ai", "sim", "gi", "ui", "v", "uri", "pi", "ij", "ix", "it", "li", "xi", "ims", "\u0438", "si", "my", "g", "ind", "batch", "ip", "ma", "key", "gu", "is", "ii", "id", "phi"], "fInput": [" fIn", " fNew", "cfNew", "sfIn", "lNew", "fIn", "linput", "cfOutput", " finput", "fileInput", "cfInput", " fOutput", "sfinput", "fileIn", "fileOutput", "finput", "fileinput", "sfInput", "cfinput", "sfOutput", "fNew", "lInput", "lOutput", "fOutput"], "in": ["all", "rin", "en", "inn", "ini", "gin", "con", "IN", "vin", "ins", "pin", "ln", "client", "al", "In", "conv", "t", "inside", "inner", "thin", "re", "kin", "conf", "bin", "serv", "inc", "out", "input", "sin", "or", "it", " din", "again", "ind", "r", "ma", "info", "n", "din", "inf", "is", "isin", "cin", "check"]}}
{"id1": "23118425", "id2": "932225", "code1": "    public synchronized String encrypt(String plaintext) throws Exception {\n        MessageDigest md = null;\n        try {\n            md = MessageDigest.getInstance(\"MD5\");\n        } catch (Exception e) {\n        }\n        try {\n            md.update(plaintext.getBytes(\"UTF-8\"));\n        } catch (Exception e) {\n        }\n        byte raw[] = md.digest();\n        String hash = (new BASE64Encoder()).encode(raw);\n        return hash;\n    }\n", "code2": "    public void createVendorSignature() {\n        byte b;\n        try {\n            _vendorMessageDigest = MessageDigest.getInstance(\"MD5\");\n            _vendorSig = Signature.getInstance(\"MD5/RSA/PKCS#1\");\n            _vendorSig.initSign((PrivateKey) _vendorPrivateKey);\n            _vendorMessageDigest.update(getBankString().getBytes());\n            _vendorMessageDigestBytes = _vendorMessageDigest.digest();\n            _vendorSig.update(_vendorMessageDigestBytes);\n            _vendorSignatureBytes = _vendorSig.sign();\n        } catch (Exception e) {\n        }\n        ;\n    }\n", "label": 1, "substitutes": {"encrypt": ["decipher", "Encryption", "enrypted", "decryption", "encipher", "decrypted", "enipher", "encryption", "enryption", "Encrypted", "encrypted", "decrypt", "Encipher", "Encrypt", "enrypt"], "plaintext": [" plainth", "plainpassword", "realstring", " Plainth", " PlainText", " plainpassword", " plaintxt", "publicText", "broadstring", "plainth", "plainText", " plainText", "plaintxt", "realtext", "publicpassword", "publicth", " Plaintext", "realtxt", "realText", "broadtext", "publictext", " plainstring", "plainstring", " Plainpassword", "broadText", "broadtxt"], "md": [" Md", "good", " mc", "nt", "sm", "ms", "pd", "od", "d", "der", "mt", "m", "managed", "mo", "doc", "deb", "mod", "mg", "del", "red", "mp", "esm", "dr", "rm", "det", "dm", "sd", "nd", "ds", "dd", "cmd", "metadata", " dd", "material", "cd", "mb", "hd", "MD", "ind", "dig", "ad", "grad", "mn", "mc", "mm", "gr", "mk", "msg", "ld", "med", "bd", "df", "dh"], "raw": ["extra", "all", "buf", "json", "orig", "random", "known", "ng", "original", "draw", "unknown", "cooked", "custom", "clean", "clear", "mem", "message", "available", "sh", "unsigned", "bytes", "input", "out", "valid", "hex", " Raw", "pack", "aw", "hook", "RAW", " RAW", "rendered", "full", "row", "n", "html", "core", "Raw", "rew", "data", "bare", "w"], "hash": ["ashes", "ashed", "handle", "tr", "json", "mask", "ash", "Hash", "cloth", "h", "bh", "sum", "tag", "sha", "shadow", "ASH", "message", "alert", "sh", "name", "hed", "total", "has", "hex", "dump", "search", "component", "height", "proof", "href", "key", "html", "rh", "password", "ssh", "mac", "check", "id", "print"]}}
{"id1": "20568568", "id2": "1586662", "code1": "    private String createHTML(PAGE_TYPE requestPage) {\n        String result = \"<html><head>\";\n        URL url = getClass().getClassLoader().getResource(\"org/compiere/images/PAPanel.css\");\n        InputStreamReader ins;\n        try {\n            ins = new InputStreamReader(url.openStream());\n            BufferedReader bufferedReader = new BufferedReader(ins);\n            String cssLine;\n            while ((cssLine = bufferedReader.readLine()) != null) result += cssLine + \"\\n\";\n        } catch (IOException e1) {\n            log.log(Level.SEVERE, e1.getLocalizedMessage(), e1);\n        }\n        switch(requestPage) {\n            case PAGE_LOGO:\n                result += \"</head><body class=\\\"header\\\">\" + \"<table width=\\\"100%\\\"><tr><td>\" + \"<img src=\\\"res:org/compiere/images/logo_ad.png\\\">\" + \"</td><td></td><td width=\\\"290\\\">\" + \"</td></tr></table>\" + \"</body></html>\";\n                break;\n            case PAGE_HOME:\n                result += \"</head><body><div class=\\\"content\\\">\\n\";\n                queryZoom = null;\n                queryZoom = new ArrayList<MQuery>();\n                String appendToHome = null;\n                String sql = \" SELECT x.AD_CLIENT_ID, x.NAME, x.DESCRIPTION, x.AD_WINDOW_ID, x.PA_GOAL_ID, x.LINE, x.HTML, m.AD_MENU_ID\" + \" FROM PA_DASHBOARDCONTENT x\" + \" LEFT OUTER JOIN AD_MENU m ON x.ad_window_id=m.ad_window_id\" + \" WHERE (x.AD_Client_ID=0 OR x.AD_Client_ID=?) AND x.IsActive='Y'\" + \" ORDER BY LINE\";\n                PreparedStatement pstmt = null;\n                ResultSet rs = null;\n                try {\n                    pstmt = DB.prepareStatement(sql, null);\n                    pstmt.setInt(1, Env.getAD_Client_ID(Env.getCtx()));\n                    rs = pstmt.executeQuery();\n                    while (rs.next()) {\n                        appendToHome = rs.getString(\"HTML\");\n                        if (appendToHome != null) {\n                            if (rs.getString(\"DESCRIPTION\") != null) result += \"<H2>\" + rs.getString(\"DESCRIPTION\") + \"</H2>\\n\";\n                            result += stripHtml(appendToHome, false) + \"<br>\\n\";\n                        }\n                        if (rs.getInt(\"AD_MENU_ID\") > 0) {\n                            result += \"<a class=\\\"hrefNode\\\" href=\\\"http:///window/node#\" + String.valueOf(rs.getInt(\"AD_WINDOW_ID\") + \"\\\">\" + rs.getString(\"DESCRIPTION\") + \"</a><br>\\n\");\n                        }\n                        result += \"<br>\\n\";\n                        if (rs.getInt(\"PA_GOAL_ID\") > 0) result += goalsDetail(rs.getInt(\"PA_GOAL_ID\"));\n                    }\n                } catch (SQLException e) {\n                    log.log(Level.SEVERE, sql, e);\n                } finally {\n                    DB.close(rs, pstmt);\n                    rs = null;\n                    pstmt = null;\n                }\n                result += \"<br><br><br>\\n\" + \"</div>\\n</body>\\n</html>\\n\";\n                break;\n            default:\n                log.warning(\"Unknown option - \" + requestPage);\n        }\n        return result;\n    }\n", "code2": "    int doOne(int bid, int tid, int aid, int delta) {\n        int aBalance = 0;\n        if (Conn == null) {\n            bench.incrementFailedTransactionCount();\n            return 0;\n        }\n        try {\n            if (Benchmark.prepared_stmt) {\n                pstmt1.setInt(1, delta);\n                pstmt1.setInt(2, aid);\n                pstmt1.executeUpdate();\n                pstmt1.clearWarnings();\n                pstmt2.setInt(1, aid);\n                ResultSet RS = pstmt2.executeQuery();\n                pstmt2.clearWarnings();\n                while (RS.next()) {\n                    aBalance = RS.getInt(1);\n                }\n                pstmt3.setInt(1, delta);\n                pstmt3.setInt(2, tid);\n                pstmt3.executeUpdate();\n                pstmt3.clearWarnings();\n                pstmt4.setInt(1, delta);\n                pstmt4.setInt(2, bid);\n                pstmt4.executeUpdate();\n                pstmt4.clearWarnings();\n                pstmt5.setInt(1, tid);\n                pstmt5.setInt(2, bid);\n                pstmt5.setInt(3, aid);\n                pstmt5.setInt(4, delta);\n                pstmt5.executeUpdate();\n                pstmt5.clearWarnings();\n            } else {\n                Statement Stmt = Conn.createStatement();\n                String Query = \"UPDATE accounts\";\n                Query += \" SET Abalance = Abalance + \" + delta;\n                Query += \" WHERE Aid = \" + aid;\n                int res = Stmt.executeUpdate(Query);\n                Stmt.clearWarnings();\n                Query = \"SELECT Abalance\";\n                Query += \" FROM accounts\";\n                Query += \" WHERE Aid = \" + aid;\n                ResultSet RS = Stmt.executeQuery(Query);\n                Stmt.clearWarnings();\n                while (RS.next()) {\n                    aBalance = RS.getInt(1);\n                }\n                Query = \"UPDATE tellers\";\n                Query += \" SET Tbalance = Tbalance + \" + delta;\n                Query += \" WHERE Tid = \" + tid;\n                Stmt.executeUpdate(Query);\n                Stmt.clearWarnings();\n                Query = \"UPDATE branches\";\n                Query += \" SET Bbalance = Bbalance + \" + delta;\n                Query += \" WHERE Bid = \" + bid;\n                Stmt.executeUpdate(Query);\n                Stmt.clearWarnings();\n                Query = \"INSERT INTO history(Tid, Bid, Aid, delta)\";\n                Query += \" VALUES (\";\n                Query += tid + \",\";\n                Query += bid + \",\";\n                Query += aid + \",\";\n                Query += delta + \")\";\n                Stmt.executeUpdate(Query);\n                Stmt.clearWarnings();\n                Stmt.close();\n            }\n            if (Benchmark.transactions) {\n                Conn.commit();\n            }\n            return aBalance;\n        } catch (java.lang.Exception e) {\n            if (Benchmark.verbose) {\n                System.out.println(\"Transaction failed: \" + e.getMessage());\n                e.printStackTrace();\n            }\n            bench.incrementFailedTransactionCount();\n            if (Benchmark.transactions) {\n                try {\n                    Conn.rollback();\n                } catch (SQLException e1) {\n                }\n            }\n        }\n        return 0;\n    }\n", "label": 0, "substitutes": {"createHTML": [" createHT", "seeSQL", "createURL", "CreateHTML", "CreateSQL", "CreateURL", "seeHTML", " createURL", "seeURL", "seeHT", " createSQL", "createSQL", "CreateHT", "createHT"], "requestPage": ["RequestPage", "referencepage", "responsePage", "responseLine", "requestLine", "referenceApp", "referenceType", "RequestFrame", "RequestType", "questionApp", "RequestLine", "questionType", "questionPage", "questionpage", "referencePage", "requestpage", " requestType", "responseType", "requestType", "Requestpage", "RequestApp", " requestFrame", "responseFrame", " requestLine", "requestFrame", "requestApp"], "result": ["all", "report", "response", "json", "value", "product", "output", "res", "match", "params", "word", "comment", "feature", "description", "request", "summary", "sequence", "page", "reason", "prefix", "work", "trace", "date", "command", "buffer", "function", "document", "message", "join", "detail", "format", "cache", "error", "complete", "success", "section", "out", "cup", "this", "true", "search", "answer", "term", "line", "r", "relation", "html", "figure", "source", "root", "memory", "results", "Result", "render"], "url": ["browser", "f", "gl", "sb", "ref", "dl", "res", "resource", "ws", "fs", "ls", "web", "ll", "in", "base", "char", "link", "sl", "open", "lr", "re", "xml", "ur", "rel", "uri", "URL", "get", "rl", "str", "l", "nl", "ol", "r", "ssl", "http", "html", "il", "Url", "loader", "abs"], "ins": [" in", "ics", "rys", "con", "res", "ints", "mr", "gin", "reader", "ln", "ws", "fs", "Ins", "qs", "ains", "bs", "ls", "in", "inner", "pins", "ts", "includes", "kins", "asin", "its", "ips", "ats", "ris", "input", "ds", " din", "gs", "pers", "lins", "ars", "als", "vs", "sts", "rates", "din", "uds", "is", "INS", "isin", "rus", "ils", "cin", "ks", "eds", "cs"], "bufferedReader": ["buffedContainer", "bufferedWriter", "bufferingreader", "buffiledReader", " buffererBuilder", " bufferedWriter", " buffedReader", "buffedWriter", "buffiledreader", "buffaredLoader", "buffedreader", " buffedreader", "bufferedBuilder", " bufferedContainer", "buffaredBuilder", "buffedBuilder", "buffererLoader", "bufferedLoader", " buffererLoader", "buffedLoader", " bufferedLoader", " buffedWriter", "bufferedreader", "buffererWriter", "buffedReader", "buffaredReader", " buffererReader", "buffaredWriter", "bufferedContainer", "buffiledContainer", "bufferingContainer", " buffererWriter", "buffererReader", " bufferedBuilder", "bufferingWriter", "bufferingReader", " bufferedreader", " buffedContainer", "buffiledWriter", "buffererBuilder"], "cssLine": ["rssBody", "ssBody", "cssBody", "CSSBlock", "csRow", "ssLin", "CSSRow", "rssBlock", "cosBlock", "rssLine", "styleRow", "ssline", "cssData", "styleline", "javascriptRow", "ssRow", "ssBlock", "cosBody", "styleLine", "cssBlock", "javascriptLine", "javascriptBlock", "cssLin", "cosLine", "styleData", "rssRow", "cssline", "csData", "ssData", "cosRow", "cssRow", "CSSLine", "CSSLin", "csLine", "ssLine", "javascriptLin", "csline"], "e1": ["o2", " e5", " e0", "e3", "e2", " e01", "E0", "ee5", " e2", "e01", "E3", " e3", "ee0", "o0", "o01", "o5", "ee01", "o1", "ee3", "e0", "E1", "ee1", "E2", "ee2", "e5"], "queryZoom": ["viewzoo", "queryZXom", "queryZXoom", "viewZome", "queryzolution", "viewZom", " queryzom", "queryZom", "queryZome", "viewzom", "queryDome", "queryDoo", "queryXoo", "viewzome", "queryXoom", "queryZoneooming", " queryZooming", "queryZolution", "queryZooming", "queryzom", "queryXome", "queryDoom", "queryZXooming", "queryZoneom", "queryZoo", " queryZolution", "viewzoom", "queryZoneoom", "viewZoom", "queryXom", "queryZXolution", "queryzome", "queryZoneolution", "queryDom", "viewZoo", "queryzoom", " queryzolution", " queryZom", " queryzooming", "queryzoo", "queryzooming", " queryzoom"], "appendToHome": ["addToUrl", "appendetoHome", "addtoHome", "addtoUrl", "appendTOHome", "addtoMenu", "appendtoUrl", "appendToUrl", "addToHome", "appendTOUrl", "appendetoUrl", "appendTOQuery", "addToMenu", "appendToQuery", "appendToMenu", "appendtoMenu", "addToQuery", "appendtoHome", "appendTOMenu", "appendetoMenu", "addtoQuery", "appendetoQuery", "appendtoQuery"], "sql": ["csv", "series", "json", "ms", "dl", "select", "imp", "params", "sp", "mt", "sys", "ls", "table", "sq", "spec", "q", "db", "rel", "xml", "sd", "sv", "condition", "statement", "sel", "ql", "query", "SQL", "nl", "sol", "expr", "cmd", "sn", "inv", "ma", "qu", "string", "quote", "spr", "fn", "where", "scl", "QL", "setup", "expression"], "pstmt": ["psemr", "pstpr", " pstm", "prsthStatement", "pStst", " pstrmr", "psthmt", "postmt", "pSTms", "pStmt", " pstms", "pstmr", "postsql", "pstbl", "pmtst", "pfrpr", "pstrm", "pmtpr", "pstartmt", "pstm", "pfrsql", "pstMT", "pstStatement", "pstatm", " pstmr", "pstatbl", " pfrsql", "pSTst", "pSTStatement", "pstartms", "pstartst", " pstrbl", "prstst", " pStst", "pSTMT", "prsthmt", "pstrsql", "postm", "prsthpr", " pstbl", " pStMT", "prstStatement", "pstms", " pstst", "psebl", " pstsql", "pstrbl", " pstrmt", "psem", " pstrm", "pSTpr", "prstpr", " pStmt", "pstartMT", "pStMT", "pstsql", "postpr", "prstmt", "pstatmt", "pstrmt", "pmtStatement", "psthStatement", "psthst", "pfrm", "pSTmt", " pfrpr", "pstst", "pstatmr", " pstpr", "psthpr", "pmtmt", "prsthst", "pStms", " pstMT", " pfrm", "pstrmr", "psemt", " pfrmt", "pstrpr", " pStms", "pfrmt"], "rs": ["xs", "rc", "ows", "ss", "rys", "ms", "res", "rt", "mr", "rows", "Rs", "ws", "fs", "bs", "ls", "ps", "ts", "rd", "its", "ats", "ris", "os", "ys", "ds", "ims", "gs", "ars", "sts", "rates", "ras", "ks", "RS", "ues", "cs"]}}
{"id1": "7757297", "id2": "3945236", "code1": "    public boolean submit(String uri) throws java.io.IOException, Exception {\n        if (getUserInfo()) {\n            String encodedrdf = URLEncoder.encode(rdfpayload, \"UTF-8\");\n            URL url = new URL(uri);\n            URLConnection connection = url.openConnection();\n            connection.setDoOutput(true);\n            setDescription(mDescription.getText());\n            addCreator(mUser.getText());\n            lastUser = mUser.getText();\n            PrintWriter out = new PrintWriter(connection.getOutputStream());\n            out.println(\"rdfblob=\" + encodedrdf);\n            writeCreators(out);\n            writeCategories(out);\n            writeName(out);\n            writeDescription(out);\n            writeDate(out);\n            out.println(\"&inputtype=1\");\n            out.println(\"&op=Submit\");\n            out.close();\n            return doSubmit(connection, rdfpayload);\n        } else {\n            JOptionPane.showMessageDialog(null, \"Submit cannot be completed without user information, please try again.\", \"User Info Error\", JOptionPane.ERROR_MESSAGE);\n            return false;\n        }\n    }\n", "code2": "    public static void hash(String... plainTexts) {\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"MD5\");\n            for (String plainText : plainTexts) md.update(plainText.getBytes());\n            byte b[] = md.digest();\n            int i;\n            StringBuffer buf = new StringBuffer(\"\");\n            for (int offset = 0; offset < b.length; offset++) {\n                i = b[offset];\n                if (i < 0) i += 256;\n                if (i < 16) buf.append(\"0\");\n                buf.append(Integer.toHexString(i));\n            }\n            String str = buf.toString();\n            System.out.println(\"result: \" + buf.toString());\n            System.out.println(\"result: \" + buf.toString().substring(8, 24));\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        }\n    }\n", "label": 0, "substitutes": {"submit": ["Submit", "edit", "report", "process", " submission", "request", "execute", "create", "update", "launch", "run", "accept", "open", "close", "post", "format", "input", "upload", "login", "form", "download", "sub", "save", "send", "apply", "print", "display"], "uri": ["origin", "report", "wiki", "address", "subject", "ri", "URI", "description", "resource", "directory", "range", "link", "message", "filename", "i", "ui", "ur", "URL", "name", " URI", "pi", "doi", "iri", "path", "term", "href", "info", "course", "http", "location", "campus", "msg", "file", "source", "password", "id", "du", "prefix", "title"], "encodedrdf": ["encodedrtfx", "encodedridl", "encodedrdl", "encodedrp", "encodedwsl", "encuredrdp", "encodingrdfs", "encodedridfc", "encodedwsfx", "encodedwsf", "encuredrp", "encuredrfc", "encodedrtl", "encodedrsfs", "encodedrdfs", "encodedwsfs", "encodedrsf", "encodedridp", "encuredrl", "encodeddrf", "encodingrdf", "encodingrdfx", "encodeddrp", "encodeddrfc", "encodingrdl", "encodingrsl", "encuredrdf", "encodingrsf", "encodedrsl", "encodedrfc", "encuredrdl", "encodedrdfc", "encodedrf", "encodedrtf", "encodedrl", "encodedridf", "encodeddrl", "encuredrdfc", "encuredrf", "encodedrsfx", "encodedrdp", "encodingrsfx", "encodingrsfs", "encodedrdfx", "encodedrtfs"], "url": ["browser", "address", "sb", "con", "service", "resource", "m", "client", "https", "ls", "web", "ll", "base", "link", "build", "log", "sl", "open", "b", "cert", "ur", "mount", "URL", "name", "str", "l", "nl", "li", "ul", "conn", "r", "ssl", "http", "location", "socket", "file", "loc", "Url", "p"], "connection": ["ion", "generation", "response", "creator", "con", "connected", "entry", "output", "ticket", "resource", "application", "description", "client", "https", "using", "web", "context", "in", "link", "command", "c", "open", "function", "document", "message", "result", "number", "condition", "position", "writer", "statement", "Connection", "l", "handler", "conn", "network", "connect", "database", "relation", "channel", "n", "socket", "io", "still", "communication", "index", "server", "session", "established"], "lastUser": ["latestDate", "latestUser", "LastDate", "lastAuthor", " lastDate", " lastAuthor", "lastDate", "LastAuthor", "LastUser", "latestCategory", "lastCategory", " lastCategory", "LastCategory", "latestAuthor"], "out": ["all", "report", "window", "co", "txt", "nt", "json", "con", "output", "res", "cont", "obj", "client", "sys", "raw", "set", "table", "help", "conv", "init", "in", "inner", "chain", "net", "log", "print", "write", "to", "err", "rem", "list", "up", "v", "conf", "format", "cache", "serv", "writer", "ent", "it", "ch", "query", "cmd", "conn", "null", "ou", "at", "outs", "aos", "o", "line", "inv", "screen", "n", "gr", "io", "Out", "pool", "timeout", "OUT", "check", "p", "pretty", "server", "ex"]}}
{"id1": "23402240", "id2": "16590954", "code1": "    public boolean actualizarNdivisiones(int idTorneo, int nDivisiones) {\n        int intResult = 0;\n        String sql = \"UPDATE torneo\" + \" SET  numeroDivisiones=\" + nDivisiones + \" WHERE idTorneo=\" + idTorneo;\n        try {\n            connection = conexionBD.getConnection();\n            connection.setAutoCommit(false);\n            ps = connection.prepareStatement(sql);\n            intResult = ps.executeUpdate();\n            connection.commit();\n        } catch (SQLException ex) {\n            ex.printStackTrace();\n            try {\n                connection.rollback();\n            } catch (SQLException exe) {\n                exe.printStackTrace();\n            }\n        } finally {\n            conexionBD.close(ps);\n            conexionBD.close(connection);\n        }\n        return (intResult > 0);\n    }\n", "code2": "    public void createJAR(String fileString, String ext) {\n        try {\n            File file = new File(fileString);\n            int i = fileString.lastIndexOf(java.io.File.separator);\n            String dir = fileString.substring(0, i + 1);\n            if (ext.matches(\"jar\")) {\n                jarFile = new File(getClass().getClassLoader().getResource(\"jsdviewer.jar\").toURI());\n                java.io.FileOutputStream fstrm = new java.io.FileOutputStream(file);\n                FileChannel in = (new java.io.FileInputStream(jarFile)).getChannel();\n                FileChannel out = fstrm.getChannel();\n                in.transferTo(0, jarFile.length(), out);\n                in.close();\n                out.close();\n            } else {\n                file.mkdir();\n            }\n            File.umount(file);\n            File temp = new File(dir + \"document.jsd\");\n            FileOutputStream fstrm2 = new FileOutputStream(temp.getCanonicalPath());\n            ostrm = new ObjectOutputStream(fstrm2);\n            ostrm.writeObject(doc);\n            ostrm.flush();\n            ostrm.close();\n            File.umount();\n            File docFile = new File(file.getCanonicalPath() + java.io.File.separator + \"document.jsd\");\n            File.cp_p(temp, docFile);\n            File.umount();\n            temp.delete();\n            File.umount(file);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n", "label": 0, "substitutes": {"actualizarNdivisiones": [" actualizarNisioners", " actualizarNdome", " actualizarMisionas", " actualizarNumente", " actualizarNumenters", " actualizarNumentes", " actualizarMdivisionas", " actualizarNisionas", " actualizarNdomas", " actualizarMisione", " actualizarNdivisione", " actualizarNisiones", " actualizarMdivisioners", " actualizarNdivisioners", " actualizarMisiones", " actualizarNisione", " actualizarNumentas", " actualizarMdivisiones", " actualizarMisioners", " actualizarNdomes", " actualizarNdomers", " actualizarMdivisione", " actualizarNdivisionas"], "idTorneo": ["idMorneos", "idTronos", "idTronpo", "idTornei", "idLTorneo", "idTalepo", "idMorno", "idTeroi", "idTaleo", "idLTaneO", "idTeroO", "idToralo", "idTaneon", "idTeroon", "idMornos", "idTeroo", "idMorneo", "idTanei", "idTorne", "idLTorneon", "idTornpo", "idMornepo", "idLTanei", "idTaneo", "idLTaneo", "idTornos", "idMornee", "idLTornei", "idTornee", "idTalee", "idTaneO", "idLTaneon", "idTorno", "idTorneos", "idToralon", "idToralO", "idTrono", "idTorali", "idTorneon", "idMorne", "idTrone", "idLTorneO", "idTaleos", "idTornepo", "idMornpo", "idTorneO"], "nDivisiones": ["nDivisionss", "nDivisions", "nDivitionales", "nDecionales", "nDivisionses", "nDecisione", "ndivisions", "nDivionals", "ndivisiones", "nDividee", "ndivionales", "nDivides", "nDiviones", "nDecionals", "nDecione", "nDivisionsales", "ndivions", "nDivitiones", "nDeciones", "nDivisionse", "ndivione", "nDecisiones", "nDivisione", "nDivideals", "nDivitione", "nDecisionals", "nDivions", "nDivitionals", "nDivisionals", "nDivione", "ndivisione", "nDivideales", "nDividees", "ndiviones", "ndivisionales", "nDivionales", "nDivisionales", "nDecisionales"], "intResult": ["uintValue", "floatResults", "floatReturn", "floatResult", "intValue", " intresult", "strValue", "interResult", "IntReturn", "strResult", " intValue", "intRes", "floatresult", "intResults", "interReturn", "intReturn", "INTresult", "uintResult", "strReturn", "strResults", "IntResults", "IntResult", "IntRes", " intRes", "interResults", " intReturn", "uintResults", "INTResults", "INTReturn", " intResults", "INTResult", "intresult", "interRes", "uintReturn"], "sql": ["csv", "sb", "json", "dl", "select", "params", "sp", "description", "pp", "ln", "qs", "status", "table", "ls", "sq", "template", "q", "spec", "log", "db", "xml", "sv", "url", "sel", "ql", "login", "query", "SQL", "cmd", "sol", "nl", "mail", "seed", "s", "sn", "inv", "pel", "string", "spr", "fn", "scl", "expression"], "connection": ["ion", "computer", "response", "creator", "subject", "reference", "con", "connected", "pointer", "platform", "engine", "bo", "resource", "application", "description", "client", "page", "table", "context", "port", "directory", "po", "link", "command", "c", "open", "function", "to", "document", "current", "system", "close", "db", "number", "condition", "position", "writer", "statement", "Connection", "handler", "conn", "created", "network", "collection", "connect", "database", "relation", "channel", "nc", "location", "socket", "no", "communication", "pool", "user", "server", "session", " Connection"], "ps": ["pb", "pd", "PS", "gres", "prep", "tp", "res", "sp", "pse", "mt", "Ps", "pp", "processor", "fp", "po", "stats", "mp", "pg", "ts", "ping", "aps", "cp", "ptr", "ips", "fps", "pt", "pn", "pps", "statement", "rs", "pos", "eps", "proc", "ds", "gs", "pers", "s", "ports", "jp", "posts", "pr", "p", "pe", "cs"]}}
{"id1": "12428013", "id2": "414258", "code1": "    public static void polishOff(IProgressMonitor monitor, String from, String to, String renameTo) {\n        if (monitor != null && monitor.isCanceled()) {\n            return;\n        }\n        try {\n            ftpClient = new FTPClient();\n            ftpClient.setRemoteAddr(InetAddress.getByName(PrefPageOne.getValue(CONSTANTS.PREF_HOST)));\n            ftpClient.setControlPort(PrefPageOne.getIntValue(CONSTANTS.PREF_FTPPORT));\n            ftpClient.connect();\n            try {\n                Thread.sleep(1000);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n            ftpClient.login((PrefPageOne.getValue(CONSTANTS.PREF_USERNAME)), FTPUtils.decrypt(PrefPageOne.getValue(CONSTANTS.PREF_PASSWORD)));\n            try {\n                Thread.sleep(1000);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n            if (from != null) {\n                FTPHolder ftpHolder = new FTPHolder(from, to, renameTo, false);\n                synchedSet.add(ftpHolder);\n            }\n            JobHandler.aquireFTPLock();\n            for (Iterator iter = synchedSet.iterator(); iter.hasNext(); ) {\n                if (monitor != null && monitor.isCanceled()) {\n                    JobHandler.releaseFTPLock();\n                    ftpClient.quit();\n                    return;\n                }\n                Thread.yield();\n                FTPHolder element = (FTPHolder) iter.next();\n                ftpClient.setType(FTPTransferType.ASCII);\n                ftpClient.put(element.from, element.to);\n                if (element.renameTo != null) {\n                    try {\n                        ftpClient.delete(element.renameTo);\n                    } catch (Exception e) {\n                    }\n                    ftpClient.rename(element.to, element.renameTo);\n                    log.info(\"RENAME: \" + element.to + \"To: \" + element.renameTo);\n                }\n            }\n            JobHandler.releaseFTPLock();\n            ftpClient.quit();\n        } catch (UnknownHostException e) {\n            e.printStackTrace();\n        } catch (FTPException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        synchedSet.clear();\n    }\n", "code2": "    public Configuration(URL url) {\n        InputStream in = null;\n        try {\n            load(in = url.openStream());\n        } catch (Exception e) {\n            throw new RuntimeException(\"Could not load configuration from \" + url, e);\n        } finally {\n            if (in != null) {\n                try {\n                    in.close();\n                } catch (IOException ignore) {\n                }\n            }\n        }\n    }\n", "label": 0, "substitutes": {"polishOff": ["finISHoff", " swishExec", " swISHOff", " swishersExec", " swishoff", "finishOff", " swishingExec", "finishExec", " swISHoff", "finISHOff", " swishingOff", " swishersoff", "finISHExec", " swishingoff", " swishersOff", " swISHExec", " swishOff", "finishoff"], "monitor": ["meter", "runner", "report", "video", "that", "pai", "mr", "problem", "test", "minimum", "Monitor", "driver", "mate", "execute", "description", "m", "summary", "processor", " monitoring", " Monitor", "status", "thread", "monkey", "mx", "trace", "profile", "directory", "menu", "log", "spin", "man", "mon", "hover", "message", "timer", "ai", "sim", "master", "detail", "dm", "number", "bm", "when", "progress", "state", "cm", "writer", "stat", "note", "handler", "batch", "network", "healthy", "tim", "manager", "info", "member", "watch", "pool", "timeout", "check", "username", "umi"], "from": ["origin", "back", "address", "text", "by", "about", "reset", "From", "original", "part", "a", "bound", "fr", "create", "set", "what", "before", "base", "code", "range", "link", "old", "un", "org", "off", "url", "name", "host", "str", "os", "input", "or", "pos", "query", "st", "rom", "normal", "form", "path", "term", "add", "local", "remote", "string", "html", "with", "no", "as", "source", "low", "file", "user", "id", "data"], "to": ["type", "tr", "address", "value", "by", "To", "about", "output", "test", "two", "toc", "on", "client", "TO", "tmp", "table", "tt", "t", "port", "po", "done", "template", "range", "tu", "pro", "org", "number", "format", " too", "name", "eto", "token", "os", "top", "total", "target", "too", "tab", " TO", "data", "into", "path", "term", "o", "oto", "auto", "html", "no", "size", "source", "file", "body", "zero", "id", "user", "ta", "delete"], "renameTo": ["renowOr", "renadeTo", "renenameBody", "reameOr", "renAMETo", "denamT", "denamTO", "renewFrom", "renAMEto", "renAMETO", "renokeTO", "renameFor", "denamTarget", "denameTo", "penAMEFrom", "penAMETo", "renowTO", "renameto", "renamiT", "reennameFrom", "renamiTo", "denameTO", "rennameFrom", "rennameTO", "rennameto", "renateto", "reameTarget", "renenameTO", "reameTO", "renAMEFrom", "renowTarget", "reameTo", "denameT", "renamiTarget", "renowTo", "rennamTo", "reennameTO", "denamTo", "penameFrom", "renamT", "penAMEFor", "renamesTO", "renateTarget", "renadeFor", "renenameTo", "renAMEFor", "renadeFrom", "renokeTo", "renateFrom", "renamTO", "renateTO", "renewTO", "reenameTO", "reameto", "renameT", "reameFrom", "renenameTarget", "renokeOr", "rennamFor", "reenameFrom", "renateTo", "renamesBody", "renameFrom", "reenameOr", "renamTo", "renewBody", "rennameTo", "renenameT", "renamesFrom", "rennamto", "denameTarget", "penAMEto", "renamTarget", "reameBody", "rennameTarget", "penameTo", "renamiTO", "reennameTarget", "renokeTarget", "renamesTo", "renameTO", "renameTarget", "renenameOr", "renewTo", "renadeto", "reenameBody", "renenameFrom", "renAMETarget", "reennameTo", "penameto", "rennamFrom", "renameOr", "reenameTarget", "renameBody", "penameFor", "reenameTo"], "ftpClient": ["ftpcConnection", "aftpRemote", "ftPClient", "afttpConnect", "ftPclient", "ftwpAPI", "fttpConn", "aftpEntry", "aftcpclient", "ftwpClient", "ftapStore", "aftpControl", "aftpPlayer", "ftcControl", "fttpEntry", "ftpStore", "ftpcClient", "aftcpEntry", "fttpConnect", "aftcpStore", "ftpConnection", "aftcpClient", "fttRemote", "ftpiControl", "ftapAPI", "ftcpConnection", "fttpStore", "ftapClient", "ftpControl", "ftPConnection", "afttpConnection", "ftcclient", "aftPClient", "fttpConnection", "ftpConnect", "ftcpStore", "ftcpClient", "aftpClient", "ftpiClient", "aftpConnection", "ftpEntry", "ftwpControl", "aftpConnect", "ftpAPI", "fttpclient", "fttclient", "afttpPlayer", "ftcpclient", "afttpControl", "ftphpclient", "ftcpConn", "afttpAPI", "ftapControl", "fttClient", "fttpRemote", "ftpcclient", "aftcpControl", "ftlpclient", "ftcpConnect", "afttpRemote", "afttpclient", "ftcpControl", "ftpPlayer", "ftpConn", "aftpAPI", "ftcClient", "ftcpPlayer", "afttpClient", "ftpclient", "aftPControl", "ftpcPlayer", "ftlpClient", "fttpPlayer", "aftcpConn", "aftpclient", "ftapclient", "ftPControl", "aftpStore", "ftphpEntry", "aftPclient", "fttpClient", "fttpControl", "ftcpEntry", "fttConn", "ftphpClient", "ftpRemote", "ftlpConnect", "fttpAPI", "ftcpRemote", "ftpiclient", "ftwpclient", "aftpConn"], "ftpHolder": ["ftpHoster", "ftphander", "ftpHeolder", "ftpHholder", "ftPHholder", "ftPHoster", "ftpHeander", "ftpHaver", "ftpHeoster", "ftphaver", "ftpHeholder", "ftPHander", "ftpNolder", "ftcpHolder", "ftcpHaver", "ftcpHoster", "ftpHander", "ftpNholder", "ftpNoster", "ftphoster", "ftcpHholder", "ftpNaver", "ftPHolder", "ftphholder", "ftpholder"], "iter": ["exp", "ser", "oper", "tr", "actor", "altern", "test", "ite", "reader", "other", "Iter", "inter", "thread", "mem", "inner", "orient", "loop", "impl", "Iterator", "list", "ptr", "counter", "ator", "itter", "writer", "coll", "ait", "outer", "valid", "it", "former", "walker", "per", "upper", "order", "ir", "enter", "iner", "iterator", "inv", "ner", "er", "cer", "ver", "store", "ne", "ter", "ipper"], "element": ["event", "empty", "style", "worker", "pair", "actor", "address", "item", "match", "entry", "test", "option", "sequence", "article", "air", "append", "finder", "module", "environment", "atom", "ment", "attribute", "action", "editor", "document", "message", "result", "cell", "letter", "e", "number", "detail", "variable", "le", "section", "container", "former", "lem", "ele", "object", "component", "Element", "lement", "search", "record", "instance", "xxx", "model", "iterator", "relation", "activity", "manager", "info", "member", "er", "field", "button", "lements", "folder", "elt", "data", "peer"]}}
{"id1": "20011285", "id2": "19687456", "code1": "    public static void copy(File sourceFile, File destinationFile) {\n        try {\n            if (((sourceFile == null) && (destinationFile == null)) || ((sourceFile == null) || (destinationFile == null))) {\n                System.out.println(\"sourceFile & destinationFile is null\");\n                System.exit(-1);\n            }\n            if (sourceFile.isDirectory()) {\n                File[] tmp = sourceFile.listFiles();\n                File f;\n                for (int i = 0; i < tmp.length; i++) {\n                    f = new File(destinationFile.getAbsolutePath() + File.separator + tmp[i].getName());\n                    f.getParentFile().mkdirs();\n                    copy(tmp[i], f);\n                }\n            } else {\n                System.out.println(\"\\nCopy from: \" + sourceFile + \"\\n\\n     to: \" + destinationFile);\n                FileChannel source = new FileInputStream(sourceFile).getChannel();\n                FileChannel destination = new FileOutputStream(destinationFile).getChannel();\n                destination.transferFrom(source, 0, source.size());\n                source.close();\n                destination.close();\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n", "code2": "    public void testReadPerMemberSixSmall() throws IOException {\n        GZIPMembersInputStream gzin = new GZIPMembersInputStream(new ByteArrayInputStream(sixsmall_gz));\n        gzin.setEofEachMember(true);\n        for (int i = 0; i < 3; i++) {\n            int count2 = IOUtils.copy(gzin, new NullOutputStream());\n            assertEquals(\"wrong 1-byte member count\", 1, count2);\n            gzin.nextMember();\n            int count3 = IOUtils.copy(gzin, new NullOutputStream());\n            assertEquals(\"wrong 5-byte member count\", 5, count3);\n            gzin.nextMember();\n        }\n        int countEnd = IOUtils.copy(gzin, new NullOutputStream());\n        assertEquals(\"wrong eof count\", 0, countEnd);\n    }\n", "label": 1, "substitutes": {"copy": ["proxy", "export", "php", "co", "cop", "cat", "sync", "py", "share", "create", "link", "c", "transfer", "Copy", "write", "slice", "to", "close", "cp", "gc", "paste", "split", "opy", "cut", "zip", "Cop", "download", "remote", "pixel", "save", "crop", "file", "clip", "clone", "p", "delete", "move"], "sourceFile": ["ourcePath", "initFILE", "sourcefile", " sourcefile", "packageFile", "ourceUser", "SourceDir", " sourceHeader", "SourceFile", "sourceDir", "srcFILE", "originLine", "packageFILE", "aceFiles", "identFile", "Sourcefile", "acePlace", "sourceUnit", " sourceLocal", "sourceUser", "sampleFile", "initfile", "identFiles", "originFile", "SourceUnit", " sourceLog", " sourceUnit", " sourceWeb", "SourceLine", "aceFile", "sampleLocal", "sourceDirectory", "sourceHeader", "packageUser", "srcfile", "originDir", "identDate", "sampleFILE", "sourceDate", "SourceFiles", "srcUser", " sourceDate", "ourceDirectory", "identPlace", "originWeb", "ourceFile", "srcFiles", " sourcePlace", "sourcePlace", "srcHeader", "sourceLocal", "srcUnit", "sourceFiles", "sourceWeb", " sourceDir", "SourceLog", "ourceFILE", "srcFile", "packageDirectory", "samplefile", "SourceWeb", "ourceLog", "sourcePath", "sourceLine", "SourcePath", " sourceFiles", "ourcefile", " sourcePath", " sourceLine", "initHeader", "initFile", "aceDate", "srcDirectory", " sourceFILE", "sourceFILE", "srcLocal", "sourceLog"], "destinationFile": ["destinatedLine", "estinatorFile", "identinatedMail", "destmentationFile", "destinateLocation", "destationDir", "transinationFILE", "transinateFile", "destensionDir", "destructionFile", "identinatedLine", "transinateDir", "resultinationDisk", "parentinationFILE", "destinatedDisk", "resultinateFile", "destructionFILE", "resultinateLocation", "destinoKey", "identinationFile", "destructionLine", "parentinationEmail", "transinateDisk", "estinationPath", "destinateFile", "resultinationFile", "destificationfile", "resultinatefile", "destructionMail", "destinatorLocation", "destentionLine", "identinationLine", "destinateFILE", "parentinationFile", "identinationMail", "transinateFILE", "destinatefile", "destationfile", "catinatefile", "estinationfile", "destinationfile", "destinatorEmail", "destmentationDisk", "destationFile", "identinatedFile", "catinateKey", "destensionFILE", "destinateKey", "destinationDisk", "destentionMail", "destinationDir", "destinatorDir", "parentinateFile", "destinatedFILE", "resultinationfile", "destinationEmail", "catinationFile", "destinatorFILE", "destinationPath", "destinateDir", "destentionFILE", "identinatedFILE", "destensionDisk", "transinationDisk", "destinationMail", "destinatedMail", "catinationKey", "destinatorDisk", "destentionFile", "destinoFile", "destinatorFile", "destinatedLocation", "destinatorfile", "destificationDir", "destinationLocation", "estinationDir", "parentinateFILE", "destinatedfile", "destationPath", "destinationFILE", "destationKey", "estinatorfile", "identinationFILE", "destensionFile", "parentinateEmail", "estinatorPath", "destumentFILE", "estinationFile", "destinateEmail", "destinatedFile", "destinationKey", "catinateFile", "transinationDir", "transinationFile", "destmentationFILE", "destinationLine", "destificationFile", "resultinationLocation", "destumentFile", "destinateDisk", "destmentationDir", "resultinateDisk", "estinatorDir", "destinofile", "destificationPath", "destumentEmail", "destinatorPath", "catinationfile"], "tmp": ["buf", "apps", "stuff", "txt", "nt", "xs", "bt", "buff", "img", "cmp", "ms", "sp", "cb", "parts", "obj", "tar", "m", "managed", "tt", "t", "pkg", "mp", "perm", "multi", "cur", "src", "aaa", "yy", "nb", "tf", "tab", "qq", "my", "np", "pres", "obs", "dir", "split", "mb", "etc", "xxx", "emp", "aux", "mm", "files", "mk", "msg", "temp", "shots", "p", "data", "abs"], "f": ["fi", "fe", "xf", "u", "bf", "z", "func", "d", "af", "h", "obj", "m", "fs", "fr", "fp", "fm", "fac", "t", "lf", "k", "q", "c", "fc", "fd", "b", "v", "e", "tf", "sf", "fw", "l", "uf", "fo", "flo", "g", "o", "fab", "full", "fa", "F", "cf", "field", "file", "ff", "fb", "p", "a", "df", "fl", "w"], "i": ["mi", "major", "u", "j", "ms", "us", "y", "ini", "I", "ie", "qi", "di", "im", "ri", "ei", "m", "iq", "ki", "ami", "init", "in", "x", "hi", "me", "iu", "q", "k", "bi", "ti", "ic", "multi", "ci", "ai", "sim", "gi", "ui", "e", "v", "pi", "ij", "ix", "iter", "it", "ji", "li", "my", "ims", "xi", "si", "point", "ori", "batch", "ind", "o", "ip", "zi", "ma", "key", "ii", "is", "eu", "index", "id", "p", "phi"], "source": ["origin", "series", "style", "scan", "image", "subject", "sample", "ie", "console", "service", "score", "resource", "storage", "se", "comment", "sequence", "stream", "site", "init", "in", "base", "ce", "template", "before", "store", "spec", "inner", "scope", "system", "src", "result", "missing", "Source", "none", "owner", "archive", "SOURCE", "input", "iter", "query", "tree", "parent", "search", "show", "seed", "ource", "use", "iterator", "zip", "local", "info", "start", "file", "size", "body", "zero", "shell", "index", "from", "session"], "destination": ["declinated", "Destation", "Destaration", "destaration", "Destinate", " destation", "combinate", " destension", "combination", "destension", "coordinated", "combation", "destinate", "coordation", " destinate", "coordinate", "destation", "declaration", "declation", " destinator", "Destinator", "combension", " destaration", "coordination", " destinated", "declination", "declinator", "destinated", "Destination", "Destension", "destinator", "declinate"]}}
{"id1": "23246123", "id2": "9687813", "code1": "    protected Control createDialogArea(Composite parent) {\n        Composite composite = (Composite) super.createDialogArea(parent);\n        setTitle(DialogsMessages.getString(\"LicenseDialog.Caption\"));\n        setMessage(DialogsMessages.getString(\"LicenseDialog.Explanation\"));\n        Composite content = new Composite(composite, SWT.NONE);\n        content.setLayoutData(new GridData(GridData.FILL_BOTH));\n        final int ncol = 1;\n        GridLayout layout = new GridLayout(1, false);\n        layout.numColumns = ncol;\n        content.setLayout(layout);\n        Browser browser = null;\n        Text text = null;\n        try {\n            browser = new Browser(content, SWT.NONE);\n            browser.setLayoutData(new GridData(GridData.FILL_BOTH));\n        } catch (Throwable t) {\n            text = new Text(content, SWT.MULTI | SWT.WRAP | SWT.VERTICAL);\n            text.setLayoutData(new GridData(GridData.FILL_BOTH));\n        }\n        URL url = PalobrowserPlugin.getDefault().getBundle().getResource(browser != null ? \"license.html\" : \"license.txt\");\n        InputStream in = null;\n        BufferedReader r = null;\n        StringBuffer sb = new StringBuffer();\n        try {\n            in = url.openStream();\n            r = new BufferedReader(new InputStreamReader(in, \"ISO-8859-1\"));\n            String line;\n            while ((line = r.readLine()) != null) sb.append(line).append(\"\\r\\n\");\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            if (r != null) {\n                try {\n                    r.close();\n                } catch (IOException e) {\n                }\n            }\n            if (in != null) {\n                try {\n                    in.close();\n                } catch (IOException e) {\n                }\n            }\n        }\n        if (browser != null) browser.setText(sb.toString()); else text.setText(sb.toString());\n        return composite;\n    }\n", "code2": "    public static InputStream getFileInputStream(String path) throws IOException {\n        InputStream is = null;\n        File file = new File(path);\n        if (file.exists()) is = new BufferedInputStream(new FileInputStream(file));\n        if (is == null) {\n            URL url = FileUtils.class.getClassLoader().getResource(path);\n            is = (url == null) ? null : url.openStream();\n        }\n        return is;\n    }\n", "label": 0, "substitutes": {"createDialogArea": ["createEditorArea", " createWindowArea", "createEditorarea", "createImagearea", "createDialogBox", " createDialogBox", " createWindowAction", "createWindowArea", " createWindowarea", "createEditorBar", " createDialogAction", "createImageBox", " createWindowBox", "CreateDialogarea", "CreateDialogueBar", "CreateDialogBar", "createImageAction", "createFrameBar", "CreateDialogueArea", "createDialoguearea", "createWindowarea", "createDialogarea", "createDialogAction", "createFramearea", "CreateDialogArea", "createDialogBar", "createWindowAction", "createImageArea", "CreateDialoguearea", "createDialogueArea", "createWindowBox", "createEditorBox", "createDialogueBar", "createEditorAction", " createDialogarea", "createFrameArea"], "parent": ["parents", "block", "default", "par", "params", "sp", "part", "page", "context", "port", "base", "template", "ca", "document", "ps", "cp", "child", "pc", "pt", "container", "comp", " parents", "this", "tree", "form", "component", "null", "g", "instance", "self", "pool", "Parent", "root", "p", "server"], "composite": ["Composites", "compositionitable", "compposite", "comosites", "composesitable", "comosert", "compositionert", "composert", "composites", "Comosert", "compositable", "completite", "conposesite", "comosit", "conposesited", "compositionit", "compoite", "conposites", "comppositable", "compositionites", "composesites", "comosite", "composited", "completited", "conposite", "completites", "conpositor", "compoit", "compposites", "compposit", "compositor", "comosited", "comositor", "Comosites", "conposited", "composesite", "Comosite", "Comositable", "comositable", "composesited", "composit", "composesitor", "compoites", "Composite", "composesert", "Composert", "completitor", "Compositable", "compoitable", "conposesites", "conposesitor", "compositionite"], "content": ["license", "image", "value", "settings", "ctx", "con", "console", "city", "cont", "comment", "application", "view", "article", "create", "page", "context", "ce", "template", "code", "c", "action", "load", "document", "current", "message", "xml", "widget", "format", "ct", "cache", "media", "child", "copy", "cp", "cm", "get", "Content", "container", "section", "this", "object", "component", "form", "java", "null", "path", "instance", "core", "html", "cf", "control", "pool", "wp", "body", "version", "wrapper", "header", "title"], "ncol": [" ncolumn", "ncolumn", "numCol", "numcol", "ncCol", " nCol", "Ncolumn", "nrow", "NCol", "ncl", " nrow", "Nrow", " ncl", "nCol", "numrow", "numcolumn", "numcl", "nccolumn", "nccol", "nccl", "Ncol"], "layout": ["lay", "window", "style", "block", "settings", "layer", "draw", "view", "grid", "set", "Layout", "library", "shadow", "template", "management", "shape", "flow", "join", "system", "list", "hold", "widget", "format", "def", "background", "scroll", "cache", "position", "tab", "l", "rang", "height", "group", "language", "batch", "sheet", "slot", "padding", "pool", "shell", "unit", "loop", "loader", "setup", "display"], "numColumns": ["numberColumnS", "numberColumnes", "numcolumns", "numberColumns", "numCols", "numColS", "numberCold", "numberColS", "numViews", "numcolumnes", "numViewS", "numcolumnS", "numColes", "numcolumnd", "numViewd", "numCold", "numColumnes", "numberCols", "numViewes", "numColumnd", "numberColumnd", "numberColes", "numColumnS"], "browser": ["runner", "back", "window", "rar", "hr", "br", "google", "by", "theme", "caster", "bridge", "abl", "console", "platform", "test", "callback", "webkit", "driver", "storage", "erer", "client", "orer", "river", "page", "web", "flash", "aster", "be", "gg", "editor", "buffer", "b", "vis", "mobile", "rame", "bb", "sim", "roller", "widget", "ler", "uri", "writer", "or", "chrome", "wrapper", "og", "Browser", "book", "bar", "bor", "manager", "ger", "core", "html", "vr", "io", "er", "http", "there", "remote", "root", "user", "ver", "fb", "loader", "server"], "text": ["txt", "nt", "image", "output", "cont", "comment", "word", "utils", "description", "view", "article", "ont", "page", "context", "tt", "t", "x", "template", "code", "label", "print", "editor", "net", "message", "font", "xml", "ext", "ct", "format", "widget", "read", "writer", "str", "out", "TEXT", "note", "object", "term", "binary", "language", "Text", "string", "config", "html", "source", "pdf", "translation", "data", "license", "title"], "url": ["window", "gl", "address", "dll", "dl", "res", "resource", "https", "bel", "web", "ll", "char", "link", "sl", "open", "b", "lr", "result", "rel", "re", "ur", "uri", "URL", "name", "str", "rl", "get", "l", "nl", "ssl", "domain", "http", "location", "html", "file", "il", "Url"], "in": ["f", "all", "mi", "rin", "en", "inn", "ini", "gin", "con", "ie", "IN", "mr", "ins", "ar", "reader", "ln", "on", "fr", "m", "stream", "In", "t", "inner", "inside", "init", "net", "err", "b", "dr", "i", "bin", "inc", "l", "input", "out", "or", "iter", "it", "ir", "ain", "s", "ind", "o", "nin", "el", "mc", "mm", "n", "ner", "io", "din", "inf", "er", "is", "file", "source", "cin", "from"], "r": ["hr", "rar", "rc", "tr", "br", "j", "rt", "res", "mr", "rg", "d", "rer", "cr", "R", "ri", "reader", "kr", "fr", "ro", "c", "err", "b", "sr", "dr", "lr", "re", "rel", "ur", "rd", "i", "rm", "rem", "right", "rf", "reg", "rb", "rl", "rr", "rs", "l", "or", "ry", "rx", "rate", "rect", "nr", "ren", "n", "rn", "vr", "er", "ra", "rus", "p"], "sb": ["buf", "txt", "bt", "pb", "sm", "bg", "sp", "cb", "ibl", "zb", "lb", "bps", "ws", "bh", "bs", "bsp", "wb", "sa", "sq", "sg", "b", "bb", "SB", "bp", "gc", "sv", "nb", "kb", "rb", "sf", " SB", "ub", "eb", "sw", "si", "obs", "lp", "mb", "bis", "stab", "ssl", "erb", "xb", "rob", "gob", "gb", "ib", "sth"], "line": ["phrase", "LINE", "rule", "lin", "block", "eline", "entry", "ine", "sample", "part", "comment", "frame", "word", "ln", "sequence", "page", "stroke", "char", "code", "range", "link", "chain", "log", "cell", "re", "ice", "ile", "number", "name", "le", "str", "liner", "entity", "l", "iter", "term", "Line", "row", "string", "no", "field", "inline", "file", "source", "body", "user", "print", "header"], "e": ["ze", "E", "event", "exp", "eeee", "f", "en", "fe", "ie", "oe", "ke", "entry", "ee", "et", "se", "a", "m", "t", "ce", "die", "ve", "be", "ae", "ue", "ome", "me", "c", "je", "re", "v", "i", "le", "error", "l", "ec", "ent", "eb", "g", "o", "ge", "el", "ed", "ger", "eg", "te", "ev", "er", "de", "xe", "p", "es", "ne", "pe"]}}
{"id1": "9872346", "id2": "18374478", "code1": "    public static synchronized Document readRemoteDocument(URL url, boolean validate) throws IOException, SAXParseException {\n        if (DEBUG) System.out.println(\"DocumentUtilities.readDocument( \" + url + \")\");\n        Document document = null;\n        try {\n            DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n            factory.setNamespaceAware(true);\n            factory.setCoalescing(true);\n            HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n            connection.setDefaultUseCaches(false);\n            connection.setUseCaches(false);\n            connection.setRequestProperty(\"User-Agent\", \"eXchaNGeR/\" + System.getProperty(\"xngr.version\") + \" (http://xngr.org/)\");\n            connection.connect();\n            InputStream stream = connection.getInputStream();\n            document = factory.newDocumentBuilder().parse(stream);\n            stream.close();\n            connection.disconnect();\n        } catch (SAXException e) {\n            if (e instanceof SAXParseException) {\n                throw (SAXParseException) e;\n            }\n        } catch (ParserConfigurationException e) {\n            e.printStackTrace();\n        }\n        if (DEBUG) System.out.println(\"DocumentUtilities.readDocument( \" + url + \") [\" + document + \"]\");\n        return document;\n    }\n", "code2": "    public void updateUser(final User user) throws IOException {\n        try {\n            Connection conn = null;\n            boolean autoCommit = false;\n            try {\n                conn = pool.getConnection();\n                autoCommit = conn.getAutoCommit();\n                conn.setAutoCommit(false);\n                final PreparedStatement updateUser = conn.prepareStatement(\"update users set mainRoleId=? where userId=?\");\n                updateUser.setInt(1, user.getMainRole().getId());\n                updateUser.setString(2, user.getUserId());\n                updateUser.executeUpdate();\n                final PreparedStatement deleteRoles = conn.prepareStatement(\"delete from userRoles where userId=?\");\n                deleteRoles.setString(1, user.getUserId());\n                deleteRoles.executeUpdate();\n                final PreparedStatement insertRoles = conn.prepareStatement(\"insert into userRoles (userId, roleId) values (?,?)\");\n                for (final Role role : user.getRoles()) {\n                    insertRoles.setString(1, user.getUserId());\n                    insertRoles.setInt(2, role.getId());\n                    insertRoles.executeUpdate();\n                }\n                conn.commit();\n            } catch (Throwable t) {\n                if (conn != null) conn.rollback();\n                throw new SQLException(t.toString());\n            } finally {\n                if (conn != null) {\n                    conn.setAutoCommit(autoCommit);\n                    conn.close();\n                }\n            }\n        } catch (final SQLException sqle) {\n            log.log(Level.SEVERE, sqle.toString(), sqle);\n            throw new IOException(sqle.toString());\n        }\n    }\n", "label": 0, "substitutes": {"readRemoteDocument": ["selectRawDocument", "readRemoteFile", "selectRemoteDocument", "selectRemoteFile", "readRawFile", "readremotedocument", "selectRawFile", "readremoteDocument", "readremoteObject", "selectRawdocument", "readRawDocument", "readRawObject", "readremoteFile", "selectRemoteObject", "readLocalFile", "selectRawObject", "readLocalDocument", "readLocaldocument", "readRawdocument", "readRemotedocument", "readLocalObject", "readRemoteObject", "selectRemotedocument"], "url": ["browser", "address", "ref", "u", "dl", "util", "request", "resource", "client", "web", "ls", "ll", "base", "abs", "link", "addr", "q", "sl", "b", "load", "impl", "lr", "ur", "mount", "org", "uri", "URL", "str", "rl", "l", "nl", "ul", "mail", "path", "github", "hub", "r", "ssl", "el", "domain", "channel", "key", "http", "location", "html", "href", "file", "loc", "Url", "p", "loader", "host", "cl"], "validate": [" validateidate", " invalidates", " invalidate", " validateate", " invalidation", " validateates", "Validate", "valididate", "validation", "Validation", " validateation", "Valididate", "Validates", " invalididate", "validates"], "document": ["event", "window", "response", "json", "value", "text", "duration", "um", "output", "entry", "dict", "word", "application", "doc", "article", "reason", "context", "command", "buffer", "message", "Document", "result", "xml", "content", "number", "program", "node", "information", "person", "entity", "initial", "tree", "metadata", "object", "component", "null", "ocument", "record", "instance", "language", "collection", "database", "model", "relation", "location", "file", "data", "expression"], "factory": ["Facter", "Fixture", "FFactory", "tixture", "Factory", "forificate", "bacter", "bactory", "kactory", "forFactory", "fificate", "fiber", "vacter", "fility", "hixture", "foractory", "invactory", "affificate", "facter", "hility", "Face", "kixture", "fancy", "bancy", "kiber", "afface", "affFactory", "hFactory", "facility", "face", "facixture", "affactory", "Fility", "facFactory", "inviber", "vancy", "facactory", "tactory", "bFactory", "fFactory", "Fificate", "hactory", "fixture", "invixture", "tiber", "forace", "kacter", "vFactory", "invacter", "vactory", "tacter", "Fancy"], "connection": ["ion", "response", "reference", "con", "connected", "entry", "operation", "pointer", "city", "engine", "service", "driver", "resource", "application", "builder", "description", "client", "create", "context", "directory", "link", "command", "open", "function", "current", "to", "close", "uri", "condition", "position", "writer", "statement", "Connection", "creation", "query", "cone", "object", "handler", "conn", "created", "network", "connect", "channel", "relation", "database", "location", "socket", "communication", "version", "wrapper", "server", "session", "character", " Connection"], "stream": ["REAM", "window", "response", "sample", "console", "cont", "resource", "reader", "client", "sequence", "Stream", "context", "feed", "in", "buffer", "message", "shape", "stack", "ream", "content", "read", "progress", "input", "upload", "out", "sw", "present", "length", "instance", "iterator", "channel", "zip", "screen", "row", "is", "file", "source", "pool", "body", "still", "sam", "data"]}}
{"id1": "7757297", "id2": "692738", "code1": "    public boolean submit(String uri) throws java.io.IOException, Exception {\n        if (getUserInfo()) {\n            String encodedrdf = URLEncoder.encode(rdfpayload, \"UTF-8\");\n            URL url = new URL(uri);\n            URLConnection connection = url.openConnection();\n            connection.setDoOutput(true);\n            setDescription(mDescription.getText());\n            addCreator(mUser.getText());\n            lastUser = mUser.getText();\n            PrintWriter out = new PrintWriter(connection.getOutputStream());\n            out.println(\"rdfblob=\" + encodedrdf);\n            writeCreators(out);\n            writeCategories(out);\n            writeName(out);\n            writeDescription(out);\n            writeDate(out);\n            out.println(\"&inputtype=1\");\n            out.println(\"&op=Submit\");\n            out.close();\n            return doSubmit(connection, rdfpayload);\n        } else {\n            JOptionPane.showMessageDialog(null, \"Submit cannot be completed without user information, please try again.\", \"User Info Error\", JOptionPane.ERROR_MESSAGE);\n            return false;\n        }\n    }\n", "code2": "    public Configuration(URL url) {\n        InputStream in = null;\n        try {\n            load(in = url.openStream());\n        } catch (Exception e) {\n            throw new RuntimeException(\"Could not load configuration from \" + url, e);\n        } finally {\n            if (in != null) {\n                try {\n                    in.close();\n                } catch (IOException ignore) {\n                }\n            }\n        }\n    }\n", "label": 0, "substitutes": {"submit": ["Submit", "edit", "report", "process", " submission", "request", "execute", "create", "update", "launch", "run", "accept", "open", "close", "post", "format", "input", "upload", "login", "form", "download", "sub", "save", "send", "apply", "print", "display"], "uri": ["origin", "report", "wiki", "address", "subject", "ri", "URI", "description", "resource", "directory", "range", "link", "message", "filename", "i", "ui", "ur", "URL", "name", " URI", "pi", "doi", "iri", "path", "term", "href", "info", "course", "http", "location", "campus", "msg", "file", "source", "password", "id", "du", "prefix", "title"], "encodedrdf": ["encodedrtfx", "encodedridl", "encodedrdl", "encodedrp", "encodedwsl", "encuredrdp", "encodingrdfs", "encodedridfc", "encodedwsfx", "encodedwsf", "encuredrp", "encuredrfc", "encodedrtl", "encodedrsfs", "encodedrdfs", "encodedwsfs", "encodedrsf", "encodedridp", "encuredrl", "encodeddrf", "encodingrdf", "encodingrdfx", "encodeddrp", "encodeddrfc", "encodingrdl", "encodingrsl", "encuredrdf", "encodingrsf", "encodedrsl", "encodedrfc", "encuredrdl", "encodedrdfc", "encodedrf", "encodedrtf", "encodedrl", "encodedridf", "encodeddrl", "encuredrdfc", "encuredrf", "encodedrsfx", "encodedrdp", "encodingrsfx", "encodingrsfs", "encodedrdfx", "encodedrtfs"], "url": ["browser", "address", "sb", "con", "service", "resource", "m", "client", "https", "ls", "web", "ll", "base", "link", "build", "log", "sl", "open", "b", "cert", "ur", "mount", "URL", "name", "str", "l", "nl", "li", "ul", "conn", "r", "ssl", "http", "location", "socket", "file", "loc", "Url", "p"], "connection": ["ion", "generation", "response", "creator", "con", "connected", "entry", "output", "ticket", "resource", "application", "description", "client", "https", "using", "web", "context", "in", "link", "command", "c", "open", "function", "document", "message", "result", "number", "condition", "position", "writer", "statement", "Connection", "l", "handler", "conn", "network", "connect", "database", "relation", "channel", "n", "socket", "io", "still", "communication", "index", "server", "session", "established"], "lastUser": ["latestDate", "latestUser", "LastDate", "lastAuthor", " lastDate", " lastAuthor", "lastDate", "LastAuthor", "LastUser", "latestCategory", "lastCategory", " lastCategory", "LastCategory", "latestAuthor"], "out": ["all", "report", "window", "co", "txt", "nt", "json", "con", "output", "res", "cont", "obj", "client", "sys", "raw", "set", "table", "help", "conv", "init", "in", "inner", "chain", "net", "log", "print", "write", "to", "err", "rem", "list", "up", "v", "conf", "format", "cache", "serv", "writer", "ent", "it", "ch", "query", "cmd", "conn", "null", "ou", "at", "outs", "aos", "o", "line", "inv", "screen", "n", "gr", "io", "Out", "pool", "timeout", "OUT", "check", "p", "pretty", "server", "ex"]}}
{"id1": "17161805", "id2": "4852691", "code1": "    private String encode(String plaintext) {\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"SHA\");\n            md.update(plaintext.getBytes(\"UTF-8\"));\n            byte raw[] = md.digest();\n            return (new BASE64Encoder()).encode(raw);\n        } catch (NoSuchAlgorithmException e) {\n            throw new IllegalStateException(\"Error encoding: \" + e);\n        } catch (UnsupportedEncodingException e) {\n            throw new IllegalStateException(\"Error encoding: \" + e);\n        }\n    }\n", "code2": "    public static final synchronized String hash(String data) {\n        if (digest == null) {\n            try {\n                digest = MessageDigest.getInstance(\"MD5\");\n            } catch (NoSuchAlgorithmException nsae) {\n                System.err.println(\"Failed to load the MD5 MessageDigest. \" + \"Jive will be unable to function normally.\");\n                nsae.printStackTrace();\n            }\n        }\n        digest.update(data.getBytes());\n        return toHex(digest.digest());\n    }\n", "label": 1, "substitutes": {"encode": ["encforce", "enscode", "unforce", "unprocess", "enforce", "unode", "Enode", "enprocess", "uncode", "enccode", "ensforce", "enode", "Encode", "ensprocess", "encprocess", "ensode", "Enforce"], "plaintext": [" plainth", "formText", " plaindata", "plainmessage", "aindata", "plainlat", "ainmessage", "formmessage", "pronText", "mainlat", "pronth", "pronlat", " plainmessage", "plainText", "plainth", " plainText", "ainText", " plainlat", "maintext", "mainth", "prontext", "formtext", "aintext", "formdata", "mainText", "plaindata"], "md": [" Md", " MD", "nt", "sm", "pd", "ms", "od", "ng", "d", "der", "mt", "amd", "m", "managed", "mo", "sha", "mod", "mg", "red", "del", "mp", "dr", "det", "dm", "sd", "dd", "cmd", "mand", "mb", "cd", "hd", "MD", "ind", "add", "grad", "mn", "mc", "mm", "pm", "mk", "msg", "ld", "pdf", "med", "bd", "df", "dh"], "raw": ["buf", "json", "value", "orig", "serial", "derived", "unknown", "cooked", "custom", "wrap", "clean", "bound", "mem", "inner", "stable", "message", "strip", "read", "def", "unsigned", "sh", "input", "valid", "des", "hex", " Raw", "pack", "cmd", "aw", "RAW", " RAW", "rendered", "full", "row", "n", "Raw", "map", "modified", "bytes", "bare"]}}
{"id1": "9210168", "id2": "614099", "code1": "            @Override\n            public void run() {\n                try {\n                    URL url = Thread.currentThread().getContextClassLoader().getResource(path);\n                    InputStream fis = url.openStream();\n                    InputStreamReader r = new InputStreamReader(fis, \"UTF-8\");\n                    BufferedReader br = new BufferedReader(r);\n                    String line;\n                    StringBuilder sb = new StringBuilder();\n                    while (null != (line = br.readLine())) {\n                        sb.append(line);\n                        sb.append(\"\\r\\n\");\n                    }\n                    br.close();\n                    r.close();\n                    fis.close();\n                    final String text = sb.toString();\n                    SwingUtilities.invokeLater(new Runnable() {\n\n                        @Override\n                        public void run() {\n                            MainPanel.this.source.setText(text);\n                            MainPanel.this.source.setCaretPosition(0);\n                        }\n                    });\n                } catch (Exception ex) {\n                }\n            }\n", "code2": "    public static void doVersionCheck(View view) {\n        view.showWaitCursor();\n        try {\n            URL url = new URL(jEdit.getProperty(\"version-check.url\"));\n            InputStream in = url.openStream();\n            BufferedReader bin = new BufferedReader(new InputStreamReader(in));\n            String line;\n            String develBuild = null;\n            String stableBuild = null;\n            while ((line = bin.readLine()) != null) {\n                if (line.startsWith(\".build\")) develBuild = line.substring(6).trim(); else if (line.startsWith(\".stablebuild\")) stableBuild = line.substring(12).trim();\n            }\n            bin.close();\n            if (develBuild != null && stableBuild != null) {\n                doVersionCheck(view, stableBuild, develBuild);\n            }\n        } catch (IOException e) {\n            String[] args = { jEdit.getProperty(\"version-check.url\"), e.toString() };\n            GUIUtilities.error(view, \"read-error\", args);\n        }\n        view.hideWaitCursor();\n    }\n", "label": 1, "substitutes": {"run": ["all", "play", "block", "process", "default", "func", "test", "execute", "thread", "launch", "runs", "work", "function", "call", "result", "close", "invoke", "def", "name", "get", "pass", "exit", "true", "show", "normal", "running", "Run", "begin", "start", "exec", "class", "apply", "display", "render"], "url": ["f", "browser", "gif", "hl", "gl", "ref", "res", "resource", "https", "bel", "ls", "web", "char", "pl", "sl", "b", "impl", "lr", "rel", "ur", "mount", "uri", "URL", "str", "rl", "l", "nl", "path", "rect", "ssl", "ret", "http", "io", "file", "Url", "fl", "abs"], "fis": ["fi", "fiis", "sfIS", "dfis", "fibus", "fbiss", "fIS", "lfIs", "fien", "fim", "fiim", "ifIs", " fIs", " fi", "lfim", "dfiss", "sfis", " fim", "fiien", "ifis", "fiss", " fibus", "fbi", "fbis", "sfIs", "lfis", "fbibus", "fiIs", "dfi", "sfien", "fiIS", "fIs", "ifien", "dfibus", " fiss", "ifIS"], "r": ["f", "rec", "hr", "rar", "rc", "tr", "rt", "res", "mr", "ar", "cr", "R", "ri", "reader", "kr", "fr", "ro", "b", "sr", "dr", "re", "rel", "ur", "rd", "ran", "rf", "rb", "rr", "rs", "rl", "l", "rx", "rect", "nr", "gr", "rn", "vr", "er", "ra", "pr", "p"], "br": ["browser", "buf", "hr", "bt", "tr", "bl", "bro", "mr", "bridge", "cb", "cr", "bh", "fr", "kr", "bs", "BR", "be", "ber", "err", "b", "bb", "sr", "lr", "dr", "rel", "bp", "bm", "nb", "rb", "str", "Br", "rx", "nr", "adr", "n", "vr", "pr", "p", "bd", "ab"], "line": ["LINE", "zone", "lin", "block", " row", " chunk", "ine", "eline", "entry", " block", "email", "sample", "bo", "lane", "frame", "word", "comment", "ln", "sequence", " frame", "lines", " entry", "page", "stroke", "base", "char", "code", " inline", "link", "log", " status", "cell", "e", "number", "name", "le", "liner", "str", "entity", "l", " error", "valid", "nl", "li", "point", "record", "Line", "model", "n", "row", "string", "no", "inline", "file", "user", "check", "print"], "sb": ["bt", "pb", "bf", "sync", "bg", "sp", "cb", "zb", "lb", "bh", "bs", "sbm", "bsp", "sa", "sq", "sg", "orb", "gb", "b", "soc", "bb", "db", "bj", "SB", "nb", "sv", "kb", "rb", "sf", "ub", "eb", "nl", "gs", "si", "lp", "mb", "sn", "bis", "stab", "ssl", "erb", "rob", "xb", "bn", "shell", "sam", "ib", "bd", "sth"], "text": ["translation", "txt", "layout", "value", "displayText", "output", "cont", "word", "comment", "lt", "t", "x", "code", "buffer", "b", "end", "message", "content", "ext", "format", "read", "name", "str", "out", "TEXT", "note", "st", "path", "term", "Text", "n", "html", "config", "msg", "source", "body", "pdf", "print", "data", "title"]}}
{"id1": "16572931", "id2": "13657103", "code1": "    private String unJar(String jarPath, String jarEntry) {\n        String path;\n        if (jarPath.lastIndexOf(\"lib/\") >= 0) path = jarPath.substring(0, jarPath.lastIndexOf(\"lib/\")); else path = jarPath.substring(0, jarPath.lastIndexOf(\"/\"));\n        String relPath = jarEntry.substring(0, jarEntry.lastIndexOf(\"/\"));\n        try {\n            new File(path + \"/\" + relPath).mkdirs();\n            JarFile jar = new JarFile(jarPath);\n            ZipEntry ze = jar.getEntry(jarEntry);\n            File bin = new File(path + \"/\" + jarEntry);\n            IOUtils.copy(jar.getInputStream(ze), new FileOutputStream(bin));\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return path + \"/\" + jarEntry;\n    }\n", "code2": "    private void forBundle(BundleManipulator manip) {\n        ByteArrayOutputStream bout = null;\n        try {\n            bout = new ByteArrayOutputStream();\n            ZipOutputStream zout = new ZipOutputStream(bout);\n            Bundle bundle = getBundle();\n            Enumeration<URL> files = bundle.findEntries(\"/\", \"*.vm\", false);\n            if (files != null) {\n                while (files.hasMoreElements()) {\n                    URL url = files.nextElement();\n                    String name = url.getFile();\n                    if (name.startsWith(\"/\")) {\n                        name = name.substring(1);\n                    }\n                    if (manip.includeEntry(name)) {\n                        zout.putNextEntry(new ZipEntry(name));\n                        IOUtils.copy(url.openStream(), zout);\n                    }\n                }\n            }\n            manip.finish(bundle, zout);\n            Manifest mf = new Manifest(bundle.getEntry(\"META-INF/MANIFEST.MF\").openStream());\n            zout.putNextEntry(new ZipEntry(\"META-INF/MANIFEST.MF\"));\n            mf.write(zout);\n            zout.close();\n            File tmpFile = File.createTempFile(TEMPLATES_SYMBOLIC_NAME, \".jar\");\n            FileUtils.writeByteArrayToFile(tmpFile, bout.toByteArray());\n            if (pluginAccessor.getPlugin(TEMPLATES_SYMBOLIC_NAME) != null) {\n                pluginController.uninstall(pluginAccessor.getPlugin(TEMPLATES_SYMBOLIC_NAME));\n            } else if (pluginAccessor.getPlugin(TEMPLATES_PLUGIN_KEY) != null) {\n                pluginController.uninstall(pluginAccessor.getPlugin(TEMPLATES_PLUGIN_KEY));\n            }\n            pluginController.installPlugin(new JarPluginArtifact(tmpFile));\n            ServiceReference ref = bundleContext.getServiceReference(PackageAdmin.class.getName());\n            ((PackageAdmin) bundleContext.getService(ref)).refreshPackages(null);\n            tmpFile.delete();\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            IOUtils.closeQuietly(bout);\n        }\n    }\n", "label": 1, "substitutes": {"unJar": [" unExt", " unZip", "removeJar", "UnJar", "unExt", "unZip", "removeExt", "unPath", "UnPath", "UnExt", " unPath", "UnZip", "removeZip", "removePath"], "jarPath": ["browserPath", "reportpath", " jarFile", "reportPath", "javaFile", "jFull", "jobpath", "relpath", "jarFile", "barePath", "jobLocation", " jarUrl", "jarpath", "carPath", "jPath", "reportName", " jarHome", "relHome", "bareName", " jarLocation", "jobFile", "browserName", "jarBase", "javaPath", "jarLocation", "javaUrl", "javaLocation", "javaBase", "relInfo", "pkgPath", "browserInfo", "jarHost", "pkgInfo", "jobPath", "bareHost", " jarpath", "carName", "javaInfo", "javaName", "browserUrl", "browserpath", "javapath", "carBase", "pkgpath", "jName", " jarName", "javaFull", "pkgName", "jarHome", " jarBase", "javaHost", "jarName", "jarUrl", "browserHome", "reportUrl", "jarInfo", "jHost", " jarInfo", "carpath", "bareFull", "jarFull"], "jarEntry": ["browserEnt", "sessionEntry", "jarEnt", "jarPost", "jarItem", "jItem", "JarEntry", "JarPost", "springEnt", "reportentry", "jEnt", "browserEnter", "browserName", "browserentry", "browserPost", "certentry", "sessionEnt", "browserInfo", "certEnt", "browserEntry", "javaItem", "certEntry", "springentry", "jarEnter", "javaentry", "jitEnt", "jitInfo", " jarEnter", "sessionName", "jobEntry", "jitEnter", "javaPost", "reportEnt", "jobEnt", " jarName", "springItem", "springEntry", "Jarentry", "jobPost", "jarName", "javaEntry", "jarentry", "reportPost", "jentry", "javaEnt", " jarentry", "JarEnt", " jarEnt", "reportEntry", "jarInfo", " jarInfo", "certName", "sessionentry", "jEntry", "jitEntry"], "path": ["home", "value", "min", "output", "test", "port", "base", "PATH", "to", "mount", "pi", "partial", "it", "hex", "walk", "core", "index", "address", "select", "here", "x", "template", "log", "name", "position", "method", "cmd", "history", "tree", "at", "key", "relative", "temp", "where", "file", "check", "id", "ref", "text", "ath", "module", "trace", "join", "url", "right", "input", "api", "order", "parent", "point", "dir", "Path", "with", "root", "host", "prefix", "data", "phi", "empty", "transform", "left", "distance", "client", "set", "context", "pkg", "message", "room", "near", "format", "route", "this", "pattern", "full", "self", "zip", "string", "location", "loc", "folder", "p", "print", "title"], "relPath": [" relText", "RELPort", "elpath", "Relpath", "RELName", "relpath", "RelPort", " relEntry", "relPort", " relpath", " relName", "RelEntry", "RelName", "elEntry", "elPath", " relPort", "RelText", "RELPath", "relText", "RELText", "relName", "elName", "relEntry", "RelPath"], "jar": ["rar", "good", "j", "war", "vol", "ie", "sp", "ar", "se", "jit", "tar", "jet", "deb", "be", "jj", "Jar", "pkg", "bag", "cert", "ctr", "zo", "ja", "cp", "jo", "jc", "lib", "le", "archive", "tab", "car", "comp", "pack", "java", "og", "batch", "bar", "zip", "star", "jp", "job", "sea", "bare"], "ze": ["z", "ie", "oe", "ee", "zed", "aze", "se", "ene", "zy", "ae", "ea", "ve", "be", "ce", "sl", "zo", "je", "e", "jo", "zes", "sk", "le", "zie", "ez", "za", "enz", "sle", "cz", "ge", "she", "Ze", "zip", "te", "zing", "ZE", "zer", "so", "zi", "ke", "ne", "pe"], "bin": ["bat", " Bin", "dll", "win", "buff", "gin", "con", "bl", "bg", "di", "pin", "pan", "obin", "ln", "bed", "box", "in", "bi", "spin", "b", "ic", "thin", "db", "kin", "bm", "lib", "abin", "bian", "sin", "png", "bu", "pic", "binary", "din", "sam", "fin", "skin", "jin", "cin", "ebin"]}}
{"id1": "19849797", "id2": "13333160", "code1": "    public static void copyFile(File sourceFile, File destFile) throws IOException {\n        if (!destFile.exists()) {\n            destFile.createNewFile();\n        }\n        FileChannel source = null;\n        FileChannel destination = null;\n        try {\n            source = new FileInputStream(sourceFile).getChannel();\n            destination = new FileOutputStream(destFile).getChannel();\n            destination.transferFrom(source, 0, source.size());\n        } finally {\n            if (source != null) {\n                source.close();\n            }\n            if (destination != null) {\n                destination.close();\n            }\n        }\n    }\n", "code2": "    private void run(Reader xmlIn, OutputStream out) throws IOException, SAXException {\n        Document dom = null;\n        try {\n            DocumentBuilderFactory f = DocumentBuilderFactory.newInstance();\n            f.setNamespaceAware(false);\n            f.setCoalescing(true);\n            f.setIgnoringComments(true);\n            f.setValidating(false);\n            DocumentBuilder b = f.newDocumentBuilder();\n            dom = b.parse(new InputSource(xmlIn));\n        } catch (ParserConfigurationException err) {\n            throw new IOException(err);\n        }\n        Element root = dom.getDocumentElement();\n        if (root == null) throw new SAXException(\"Not root in document\");\n        Attr att = root.getAttributeNode(\"label\");\n        if (att == null) root.setAttribute(\"label\", \"Wikipedia\");\n        Menu menu = parseMenu(root);\n        menu.id = \"menuWikipedia\";\n        ZipOutputStream zout = new ZipOutputStream(out);\n        String content = ResourceUtils.getContent(XUL4Wikipedia.class, \"chrome.manifest\");\n        addEntry(zout, \"chrome.manifest\", content);\n        content = ResourceUtils.getContent(XUL4Wikipedia.class, \"install.rdf\");\n        addEntry(zout, \"install.rdf\", content);\n        content = ResourceUtils.getContent(XUL4Wikipedia.class, \"library.js\");\n        addDir(zout, \"chrome/\");\n        addDir(zout, \"chrome/content/\");\n        addDir(zout, \"chrome/skin/\");\n        String signal = \"/*INSERT_CMD_HERE*/\";\n        int n = content.indexOf(signal);\n        if (n == -1) throw new RuntimeException(\"where is \" + signal + \" ??\");\n        ZipEntry entry = new ZipEntry(\"chrome/content/library.js\");\n        zout.putNextEntry(entry);\n        PrintWriter pout = new PrintWriter(zout);\n        pout.write(content.substring(0, n));\n        menu.toJS(pout);\n        pout.write(content.substring(n + signal.length()));\n        pout.flush();\n        zout.closeEntry();\n        entry = new ZipEntry(\"chrome/content/menu.xul\");\n        zout.putNextEntry(entry);\n        pout = new PrintWriter(zout);\n        pout.println(\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\");\n        pout.println(\"<overlay id=\\\"xul4wikipedia\\\" xmlns=\\\"\" + XUL.NS + \"\\\">\");\n        pout.println(\"<script src=\\\"library.js\\\"/>\");\n        pout.println(\"<popup id=\\\"contentAreaContextMenu\\\">\");\n        pout.println(\"<menuseparator/>\");\n        menu.toXUL(pout);\n        pout.println(\"</popup>\");\n        pout.println(\"</overlay>\");\n        pout.flush();\n        zout.closeEntry();\n        InputStream png = XUL4Wikipedia.class.getResourceAsStream(\"32px-Wikipedia-logo.png\");\n        if (png == null) throw new IOException(\"Cannot get icon\");\n        entry = new ZipEntry(\"chrome/skin/wikipedia.png\");\n        zout.putNextEntry(entry);\n        IOUtils.copyTo(png, zout);\n        zout.closeEntry();\n        zout.finish();\n        zout.flush();\n    }\n", "label": 1, "substitutes": {"copyFile": [" cpfile", "copyFiles", " copyfile", " copyStream", "transferFile", "transferStream", " cpFile", "copyStream", "copyfile", " copyFiles", " cpFiles", "transferfile", " cpStream", "transferFiles"], "sourceFile": ["ourcePath", "ourceTable", "sourcePath", "ourceLine", "sourcefile", " sourcefile", "ourceFile", "srcPath", "srcField", "sourceLine", "sourceField", "srcLine", "srcPage", "ourcefile", " sourceTable", "srcTable", " sourceLine", " sourcePath", "srcfile", " sourcePage", " sourceField", "sourceTable", "ourcePage", "ourceField", "sourcePage", "srcFile"], "destFile": ["DestPath", "optPath", "destPath", "DestFiles", " destPlace", "optEntity", "optFilename", "srcFolder", "restPlace", "DestFilename", "destFolder", "destPlace", "srcFiles", "optDir", "srcPath", " destDir", "optFile", "datPlace", "srcDir", " destFiles", "declFolder", "srcEntity", " destFilename", "DestDir", "destDir", "datFilename", "destEntity", "optFolder", "srcFile", "datFile", "datFiles", "restFile", "DestFile", " destPath", "declEntity", "restFiles", "restFilename", "declFile", "declDir", "destFilename", "destFiles"], "source": ["origin", "proxy", "back", "series", "style", "image", "subject", "match", "sample", "ie", "console", "service", "slave", "resource", "reader", "se", "comment", "score", "sequence", "force", "create", "stream", "table", "standard", "update", "init", "in", "inner", "ce", "char", "before", "store", "attribute", "spec", "scope", "load", "pose", "result", "src", "missing", "Source", "none", "owner", "copy", "target", "SOURCE", "input", "iter", "query", "note", "parent", "parse", "search", "component", "ource", "show", "iterator", "OURCE", "channel", "use", "local", "scale", "start", "send", "body", "shell", "index", "check", "cause", "from"], "destination": ["terminined", "Destation", "separinated", "Destinate", "destment", " destation", "verinated", "termininate", "separination", "restinator", "termininated", "Destment", "descinator", "separment", "noninated", "destinate", "separation", " destment", "descinate", "destinator", " destinate", "nonination", "decined", "decination", "verination", "restination", "descation", "destation", "restinate", "terminination", "Destinated", " destinator", "Destinator", "descination", "noninator", "noninate", " destinated", "veration", "verificate", " destined", "decinate", "destinated", "Destificate", "Destination", "destined", " destificate", "decinated", "destificate", "restinated"]}}
{"id1": "9261777", "id2": "23273706", "code1": "    public static void main(String[] args) {\n        String source, destination;\n        if (args[0].toLowerCase().endsWith(\".gz\")) {\n            source = args[0];\n            destination = source.substring(0, source.length() - 3);\n        } else {\n            source = args[0] + \".gz\";\n            destination = args[0];\n        }\n        InputStream is = null;\n        OutputStream os = null;\n        try {\n            is = new GZIPInputStream(new FileInputStream(source));\n            os = new FileOutputStream(destination);\n            byte[] buffer = new byte[8192];\n            for (int length; (length = is.read(buffer)) != -1; ) os.write(buffer, 0, length);\n        } catch (IOException e) {\n            System.err.println(\"Fehler: Kann nicht entpacken \" + args[0]);\n        } finally {\n            if (os != null) try {\n                os.close();\n            } catch (IOException e) {\n            }\n            if (is != null) try {\n                is.close();\n            } catch (IOException e) {\n            }\n        }\n    }\n", "code2": "    public String[][] getProjectTreeData() {\n        String[][] treeData = null;\n        String filename = dms_home + FS + \"temp\" + FS + username + \"adminprojects.xml\";\n        String urlString = dms_url + \"/servlet/com.ufnasoft.dms.server.ServerGetAdminProjects\";\n        try {\n            String urldata = urlString + \"?username=\" + URLEncoder.encode(username, \"UTF-8\") + \"&key=\" + URLEncoder.encode(key, \"UTF-8\") + \"&filename=\" + URLEncoder.encode(username, \"UTF-8\") + \"adminprojects.xml\";\n            DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n            factory.setValidating(false);\n            DocumentBuilder parser = factory.newDocumentBuilder();\n            URL u = new URL(urldata);\n            DataInputStream is = new DataInputStream(u.openStream());\n            FileOutputStream os = new FileOutputStream(filename);\n            int iBufSize = is.available();\n            byte inBuf[] = new byte[20000 * 1024];\n            int iNumRead;\n            while ((iNumRead = is.read(inBuf, 0, iBufSize)) > 0) os.write(inBuf, 0, iNumRead);\n            os.close();\n            is.close();\n            File f = new File(filename);\n            InputStream inputstream = new FileInputStream(f);\n            Document document = parser.parse(inputstream);\n            NodeList nodelist = document.getElementsByTagName(\"proj\");\n            int num = nodelist.getLength();\n            treeData = new String[num][3];\n            for (int i = 0; i < num; i++) {\n                treeData[i][0] = new String(DOMUtil.getSimpleElementText((Element) nodelist.item(i), \"pid\"));\n                treeData[i][1] = new String(DOMUtil.getSimpleElementText((Element) nodelist.item(i), \"ppid\"));\n                treeData[i][2] = new String(DOMUtil.getSimpleElementText((Element) nodelist.item(i), \"p\"));\n            }\n        } catch (MalformedURLException ex) {\n            System.out.println(ex);\n        } catch (ParserConfigurationException ex) {\n            System.out.println(ex);\n        } catch (NullPointerException e) {\n        } catch (Exception ex) {\n            System.out.println(ex);\n        }\n        return treeData;\n    }\n", "label": 1, "substitutes": {"source": ["origin", "back", "style", "address", "text", "subject", "sample", "service", "resource", "se", "details", "view", "sequence", "status", "site", "reason", "table", "context", "init", "script", "base", "ce", "template", "spec", "store", "char", "scope", "src", "filename", "content", "Source", "ui", "uri", "copy", "lower", "target", "SOURCE", "str", "input", "query", "tree", "parent", "sql", "search", "path", "ource", "component", "form", "language", "use", "info", "volume", "string", "config", "start", "file", "where", "body", "clip", "index", "size", "from", "check", "prefix", "expression", "title"], "destination": ["destacement", " destine", "portinator", " destino", "declinant", "certinate", "originator", "tempinate", "goodination", "origend", "tempino", "combination", "certination", "destinate", "destino", "declinations", "destinator", " destinate", "portine", "distinations", "goodinate", "combinant", "distinator", "combinator", "portination", "certacement", "testinator", "goodacement", "destinant", "testinate", " destinator", "origination", "distination", "destine", "goodinator", "distinant", "declination", "portend", "tempination", "certinator", "destinations", " destend", "declinator", "combinations", "origine", "testino", "testination", "declinate", "destend", "tempinator", "declacement"], "is": ["mis", "ics", "ois", "ist", "ms", "iris", "us", "ie", "webkit", "oss", "ins", "im", "Is", "js", "nis", "ri", "sys", "bs", "ains", "isa", "ais", "init", "icks", "in", "dis", "ns", "tis", "bits", "vis", "ps", "ts", "ic", "ires", "i", "its", "mus", "zes", "ris", "IS", "has", "are", "was", "iter", "sis", "isc", "ims", "ir", "si", "lis", "isl", "s", "obs", "bis", "isf", "ip", "info", "vs", "isi", "ios", "iso", "isin", "iss", "ib", "es", "abs"], "os": ["oes", "dos", "ss", "Os", "ost", "ms", "cos", "asis", "oss", "mos", "ob", "osi", "oses", "on", "fs", "sys", "bs", "oa", "ns", "dis", "\u00f3", "uts", "los", "mes", "ose", "ts", "mot", "ox", "ols", "pos", "or", "bos", "ops", "ys", "ones", "obs", "css", "s", "aos", "outs", "bis", "o", "oS", "OS", "io", "ios", "oos", "zero", "ks", "es", "ot"], "buffer": ["event", "phrase", "buf", "window", "block", "buff", "sample", "frame", "word", "comment", "view", "sequence", "append", "table", "pad", "library", "mem", "template", "command", "document", "message", "shape", "available", "stack", "background", "cache", "variable", "Buffer", "total", "history", "queue", "paste", "binary", "batch", "database", "bar", "padding", "row", "temp", "button", "memory", "display"], "length": ["type", "span", "text", "ENGTH", "hello", "time", "Length", "capacity", "stop", "distance", "sequence", "ence", "pad", "before", "ith", "bow", "bus", "frequency", "ment", "th", "integer", "shape", "load", "family", "of", "number", "position", "tail", "partial", "total", "l", "last", "ty", " Length", "offset", "len", "history", "point", "component", "height", "path", "split", "ength", "ind", "collection", "database", "full", "padding", "count", "volume", "string", "display", "width", "start", "size", "reading", "loop", "needed", "angle", "end", "duration", "character", "enth"]}}
{"id1": "2217889", "id2": "23666867", "code1": "    public static InputStream getResourceAsStreamIfAny(String resPath) {\n        URL url = findResource(resPath);\n        try {\n            return url == null ? null : url.openStream();\n        } catch (IOException e) {\n            ZMLog.warn(e, \" URL open Connection got an exception!\");\n            return null;\n        }\n    }\n", "code2": "    public static void copyFile(File in, File out) {\n        try {\n            FileChannel inChannel = null, outChannel = null;\n            try {\n                out.getParentFile().mkdirs();\n                inChannel = new FileInputStream(in).getChannel();\n                outChannel = new FileOutputStream(out).getChannel();\n                outChannel.transferFrom(inChannel, 0, inChannel.size());\n            } finally {\n                if (inChannel != null) {\n                    inChannel.close();\n                }\n                if (outChannel != null) {\n                    outChannel.close();\n                }\n            }\n        } catch (Exception e) {\n            ObjectUtils.throwAsError(e);\n        }\n    }\n", "label": 0, "substitutes": {"getResourceAsStreamIfAny": ["getResourceAsSteamIfANY", "getResourceAsSteamIFANY", "getResourceAsStreamIfPresent", "getResourceAsSteamIFAny", "getResourceAsSteamIFRequired", "getResourceAsSteamIfPresent", "getResourceAsStreamWhereRequired", "getResourceAsStreamifRequired", "getResourceAsStreamIFAny", "getResourceAsStreamifPresent", "getResourceAsSteamIfRequired", "getResourceAsSteamIFPresent", "getResourceAsStreamifANY", "getResourceAsStreamIfANY", "getResourceAsStreamIfRequired", "getResourceAsSteamIfAny", "getResourceAsStreamIFANY", "getResourceAsStreamIFPresent", "getResourceAsStreamifAny", "getResourceAsStreamWherePresent", "getResourceAsStreamWhereAny", "getResourceAsStreamIFRequired", "getResourceAsStreamWhereANY"], "resPath": ["relpath", " resCh", "ResUrl", " resName", " respath", "resId", "resName", "ResDir", "resourceDir", "resUrl", "ResPath", "relId", "resourceCh", " resId", "ResId", "respath", " resDir", "relPath", " resUrl", "Respath", "relUrl", "resCh", "resourceName", "ResName", "resDir", "resourcePath", "ResCh"], "url": ["f", "gl", "address", "ref", "sb", "dl", "util", "service", "resource", "raw", "web", "ls", "ll", "char", "link", "build", "sl", "cert", "bb", "impl", "db", "rel", "ur", "mount", "uri", "URL", "name", "get", "str", "l", "cmd", "nl", "mail", "path", "norm", "ssl", "domain", "http", "location", "job", "server", "file", "loc", "user", "Url", "print", "host"]}}
{"id1": "22135199", "id2": "823074", "code1": "    public void testCodingEmptyFile() throws Exception {\n        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n        WritableByteChannel channel = newChannel(baos);\n        HttpParams params = new BasicHttpParams();\n        SessionOutputBuffer outbuf = new SessionOutputBufferImpl(1024, 128, params);\n        HttpTransportMetricsImpl metrics = new HttpTransportMetricsImpl();\n        LengthDelimitedEncoder encoder = new LengthDelimitedEncoder(channel, outbuf, metrics, 16);\n        encoder.write(wrap(\"stuff;\"));\n        File tmpFile = File.createTempFile(\"testFile\", \"txt\");\n        FileOutputStream fout = new FileOutputStream(tmpFile);\n        OutputStreamWriter wrtout = new OutputStreamWriter(fout);\n        wrtout.flush();\n        wrtout.close();\n        FileChannel fchannel = new FileInputStream(tmpFile).getChannel();\n        encoder.transfer(fchannel, 0, 20);\n        encoder.write(wrap(\"more stuff\"));\n        String s = baos.toString(\"US-ASCII\");\n        assertTrue(encoder.isCompleted());\n        assertEquals(\"stuff;more stuff\", s);\n        tmpFile.delete();\n    }\n", "code2": "    public void convert(File src, File dest) throws IOException {\n        InputStream in = new BufferedInputStream(new FileInputStream(src));\n        DcmParser p = pfact.newDcmParser(in);\n        Dataset ds = fact.newDataset();\n        p.setDcmHandler(ds.getDcmHandler());\n        try {\n            FileFormat format = p.detectFileFormat();\n            if (format != FileFormat.ACRNEMA_STREAM) {\n                System.out.println(\"\\n\" + src + \": not an ACRNEMA stream!\");\n                return;\n            }\n            p.parseDcmFile(format, Tags.PixelData);\n            if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) {\n                System.out.println(\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n                return;\n            }\n            boolean hasPixelData = p.getReadTag() == Tags.PixelData;\n            boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12;\n            int pxlen = p.getReadLength();\n            if (hasPixelData) {\n                if (inflate) {\n                    ds.putUS(Tags.BitsAllocated, 16);\n                    pxlen = pxlen * 4 / 3;\n                }\n                if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) {\n                    System.out.println(\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                    return;\n                }\n            }\n            ds.putUI(Tags.StudyInstanceUID, uid(studyUID));\n            ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID));\n            ds.putUI(Tags.SOPInstanceUID, uid(instUID));\n            ds.putUI(Tags.SOPClassUID, classUID);\n            if (!ds.contains(Tags.NumberOfSamples)) {\n                ds.putUS(Tags.NumberOfSamples, 1);\n            }\n            if (!ds.contains(Tags.PhotometricInterpretation)) {\n                ds.putCS(Tags.PhotometricInterpretation, \"MONOCHROME2\");\n            }\n            if (fmi) {\n                ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian));\n            }\n            OutputStream out = new BufferedOutputStream(new FileOutputStream(dest));\n            try {\n            } finally {\n                ds.writeFile(out, encodeParam());\n                if (hasPixelData) {\n                    if (!skipGroupLen) {\n                        out.write(PXDATA_GROUPLEN);\n                        int grlen = pxlen + 8;\n                        out.write((byte) grlen);\n                        out.write((byte) (grlen >> 8));\n                        out.write((byte) (grlen >> 16));\n                        out.write((byte) (grlen >> 24));\n                    }\n                    out.write(PXDATA_TAG);\n                    out.write((byte) pxlen);\n                    out.write((byte) (pxlen >> 8));\n                    out.write((byte) (pxlen >> 16));\n                    out.write((byte) (pxlen >> 24));\n                }\n                if (inflate) {\n                    int b2, b3;\n                    for (; pxlen > 0; pxlen -= 3) {\n                        out.write(in.read());\n                        b2 = in.read();\n                        b3 = in.read();\n                        out.write(b2 & 0x0f);\n                        out.write(b2 >> 4 | ((b3 & 0x0f) << 4));\n                        out.write(b3 >> 4);\n                    }\n                } else {\n                    for (; pxlen > 0; --pxlen) {\n                        out.write(in.read());\n                    }\n                }\n                out.close();\n            }\n            System.out.print('.');\n        } finally {\n            in.close();\n        }\n    }\n", "label": 1, "substitutes": {"testCodingEmptyFile": [" testCodingEmptyFiles", " testCachingEmptyStream", " testCachingEmptyFile", " testCodingSizefile", " testCodingFullFiles", " testCachingEmptyfile", " testCodingEmptyStream", " testCodingEmptyfile", " testCachingemptyStream", " testCodingSizeFiles", " testCodingemptyFiles", " testCachingemptyfile", " testCodingSizeStream", " testCodingSizeFile", " testCachingemptyFiles", " testCachingEmptyFiles", " testCodingemptyStream", " testCodingFullFile", " testCodingemptyfile", " testCodingFullfile", " testCachingemptyFile", " testCodingemptyFile", " testCodingFullStream"], "baos": ["boOs", "taos", "aoos", "boos", "aoOS", "boo", "tao", "boOS", "baOs", "taOs", "baoss", " bao", " baoss", "aoo", "caoS", "booss", "taoS", " baOS", "caos", "baOS", "Baos", "caOs", "Baoss", "cao", " baOs", "BaOs", "baoS", "Bao", "bao", " baoS", "aoOs"], "channel": ["chan", "window", "block", "Channel", "con", "caster", "console", "service", "resource", "application", "client", "stream", "context", "connection", "chain", "command", "buffer", "c", "room", "message", "system", "cache", "cm", "container", "out", "input", "ch", "controller", "handler", "component", "queue", "batch", "network", "socket", "io", "file", "password", "can", "server", "session"], "params": ["services", "tags", "json", "settings", "cmp", "par", "options", "Par", "ctx", "parts", "details", "limits", "cms", "types", "sys", "names", "spec", "phys", "pins", "ps", "conf", "ams", "param", "properties", "name", "fps", "pi", "pps", "rs", "caps", "pretty", "ops", "proc", " parameters", "Parameters", "AMS", "headers", "mm", "config", "pool", "password", "p", "units", "data", "radius"], "outbuf": ["inbuff", " outbuffer", " outrb", "outputbuf", "outputbuff", "inbuf", "Outbuffer", "outputrb", " outBuffer", "outputbuffer", "inrb", "outrb", "Outbuf", "outBuffer", "OutBuffer", "Outbuff", "outbuff", " outbuff", "inbuffer", "inBuffer", "outbuffer"], "metrics": ["Metrics", "matrix", "mutcs", " metrices", "metrors", "mutrics", "metcs", "Metric", "mtcs", "matrics", "monrors", " metcs", " metths", "mtrices", "monrics", "mtrics", "monric", "Metrors", "metths", "matric", "monrix", "mtths", "metrices", "metrix", "metric", "matrors", "mutths", "mutrices", "Metrix"], "encoder": ["ecoding", "encuter", "ecoded", "enoding", "encoded", "enrier", "execoding", "encrier", "ecoder", "Encrier", " encuter", "Encuter", " encramer", "encramer", "ecramer", "Encoder", "Encramer", "Enciever", "ecrier", "enoder", "ecressor", "execoder", " encrier", "execrier", "enoded", " encressor", "eniever", "enramer", "Encoding", " encoding", "encressor", "enciever", "encoding", " encoded", "eciever", "enressor", "executer"], "tmpFile": ["tmpName", " tmpFilename", "tmpKey", "mpfile", " tmpfile", "fakeFilename", "mpFilename", "tmpFILE", "testFilename", "imgFILE", "tmpfile", "tempFilename", "tempPath", "mpFile", " tmpKey", "tmpFiles", "tempKey", "imgKey", "fakeFile", "txtfile", " tmpFILE", " tmpName", "tempfile", "mpName", "tempFILE", " tmpPath", " tmpFiles", "imgFile", "testName", "imgfile", "testfile", "tempFiles", "tempFile", "fakeFiles", "testFile", "tmpPath", "txtPath", "tmpFilename", "fakefile", "txtFile"], "fout": ["sfOut", "vout", "fulloutput", "vouts", "fao", "fullOUT", "wout", "dfoutput", "fOut", "dfbal", "sfout", "lout", "wao", "fouts", "wOut", "fbal", "lOUT", "fullout", "sfouts", "fullbal", "dfout", "sfao", "vao", "lbal", "wouts", "loutput", "vOut", "fOUT", "dfOUT", "foutput"], "wrtout": ["wrtin", "wrtn", "Wrtio", "ewltwriter", "wdrgen", "ewrtwriter", "hwrcwriter", "wRTout", "Wrdwriter", "wgtex", "wttio", "wwtout", "wwtw", "hwrtwriter", "wrdout", "wltout", "wrtex", "hwrtout", "wgtwriter", "wltin", "wrcwriter", "wgtw", "hwrcw", "Wrdio", "ewrtin", "ewrtgen", "wrdwriter", "wttwriter", "wrcex", "wrcout", "wRTio", "wRTn", "wrdgen", "Wrdout", "wttout", "hwrtw", "hwrtex", "Wrdn", "wrdin", "hwrcout", "Wrtwriter", "Wrtn", "wttn", "wdrout", "wrcw", "ewltin", "wRTwriter", "wrtio", "Wrtout", "hwrcex", "wrdn", "ewltout", "wdrin", "wwtwriter", "wrtgen", "wrtwriter", "wdrwriter", "wltgen", "wgtout", "wrtw", "ewltgen", "ewrtout", "wltwriter", "wrdio", "wwtex"], "fchannel": ["Fchannel", "flChannel", "fchan", " fChannel", " fconnection", "fChannel", "fconsole", "wchan", " fcontroller", " fchan", "fnet", " fnet", " fconsole", "fconnection", "fcontroller", "flconsole", "wchannel", "fccontroller", "flnet", "Fconsole", "wcontroller", "flchannel", "fcconnection", "fcchan", "FChannel", "Fnet", "fcchannel", "wconnection"], "s": ["f", "csv", "ss", "p", "j", "h", "js", "m", "ws", "qs", "ls", "t", "ns", "sq", "sg", "c", "b", "ts", "S", "v", "i", "e", "sv", "str", "rs", "ds", "gs", "g", "r", "n", "string", "gets", "is", "a", "w"]}}
{"id1": "16511008", "id2": "20886320", "code1": "    public ProgramProfilingMessageSymbol createNewProfilingMessageSymbol(int configID, int programMessageSymbolID) throws AdaptationException {\n        ProgramProfilingMessageSymbol profilingMessageSymbol = null;\n        Connection connection = null;\n        Statement statement = null;\n        ResultSet resultSet = null;\n        try {\n            String query = \"INSERT INTO ProgramProfilingMessageSymbols\" + \"(projectDeploymentConfigurationID, programMessageSymbolID)\" + \" VALUES (\" + configID + \", \" + programMessageSymbolID + \")\";\n            connection = DriverManager.getConnection(CONN_STR);\n            statement = connection.createStatement();\n            statement.executeUpdate(query);\n            query = \"SELECT * FROM ProgramProfilingMessageSymbols WHERE \" + \"projectDeploymentConfigurationID = \" + configID + \" AND \" + \"programMessageSymbolID           = \" + programMessageSymbolID;\n            resultSet = statement.executeQuery(query);\n            if (!resultSet.next()) {\n                connection.rollback();\n                String msg = \"Attempt to create program profiling message \" + \"symbol failed.\";\n                log.error(msg);\n                throw new AdaptationException(msg);\n            }\n            profilingMessageSymbol = getProfilingMessageSymbol(resultSet);\n            connection.commit();\n        } catch (SQLException ex) {\n            try {\n                connection.rollback();\n            } catch (Exception e) {\n            }\n            String msg = \"SQLException in createNewProfilingMessageSymbol\";\n            log.error(msg, ex);\n            throw new AdaptationException(msg, ex);\n        } finally {\n            try {\n                resultSet.close();\n            } catch (Exception ex) {\n            }\n            try {\n                statement.close();\n            } catch (Exception ex) {\n            }\n            try {\n                connection.close();\n            } catch (Exception ex) {\n            }\n        }\n        return profilingMessageSymbol;\n    }\n", "code2": "    @Override\n    public List<SearchResult> search(String query, SortOrder order, int maxResults) throws Exception {\n        if (query == null) {\n            return null;\n        }\n        String encodedQuery = \"\";\n        try {\n            encodedQuery = URLEncoder.encode(query, \"UTF-8\");\n        } catch (UnsupportedEncodingException e) {\n            throw e;\n        }\n        final int startAt = 0;\n        final int pageNr = (startAt - 1) / 30;\n        final String url = String.format(QUERYURL, encodedQuery, String.valueOf(pageNr), (order == SortOrder.BySeeders ? SORT_SEEDS : SORT_COMPOSITE));\n        HttpParams httpparams = new BasicHttpParams();\n        HttpConnectionParams.setConnectionTimeout(httpparams, CONNECTION_TIMEOUT);\n        HttpConnectionParams.setSoTimeout(httpparams, CONNECTION_TIMEOUT);\n        DefaultHttpClient httpclient = new DefaultHttpClient(httpparams);\n        httpclient.getParams().setParameter(\"http.useragent\", \"Mozilla/5.0 (Windows; U; Windows NT 6.1; en-US; rv:1.9.2.2) Gecko/20100316 Firefox/3.6.2\");\n        HttpGet httpget = new HttpGet(url);\n        HttpResponse response = httpclient.execute(httpget);\n        InputStream instream = response.getEntity().getContent();\n        String html = HttpHelper.ConvertStreamToString(instream);\n        instream.close();\n        return parseHtml(html);\n    }\n", "label": 0, "substitutes": {"createNewProfilingMessageSymbol": ["createNewProfilingMsgSchembol", "createNewProfilingMessageSchentax", "createNewProfilingMessageCymbol", "createNewProfilingMsgSymbol", "createNewProfilingMessageSyntax", "createNewProfilingMessagesymbol", "createNewProfilingMessagesyntax", "createNewProfilingMessageCyntax", "createNewProfilingMessageSchembol", "createNewProfilingMsgSyntax", "createNewProfilingMsgSchentax"], "configID": ["configURI", "componentId", "confId", "ConfigML", " configPK", "configIDs", "caseID", "confIDs", "configOR", " configURI", "componentOR", "caseML", "ConfigURL", " configOR", "caseURL", " configURL", "confID", " configid", "configURL", "confPK", " configIDs", "componentPK", "componentID", "Configid", "cfgID", " configML", "ConfigID", "configid", "configPK", "cfgId", "cfgURI", "configId", " configId", "cfgIDs", "caseid", "configML", "confOR", "confURI"], "programMessageSymbolID": ["programMessageSymbolValue", "programMessageSyptionid", "programMessageSyElementID", "programMessageSyTypeName", "programMessageSyTypeId", "programMessageSyElementName", "programMessageSyptionName", "programMessageSyptionId", "programMessageSymbolN", "programMessageSyrorID", "programMessageSymbId", "programMessageSymmbolN", "programMessageSyElementValue", "programMessageSySyID", "programMessageSymmbolId", "programMessageSymbolId", "programMessageSymbolIDs", "programMessageSyTypeID", "programMessageSyptionID", "programMessageSyrorIDs", "programMessageSymbolName", "programMessageSyrorN", "programMessageSymbN", "programMessageSyrorId", "programMessageSySyId", "programMessageSymbolid", "programMessageSymmbolName", "programMessageSymmbolValue", "programMessageSyTypeValue", "programMessageSySyid", "programMessageSymmbolIDs", "programMessageSyElementId", "programMessageSySyName", "programMessageSymbID", "programMessageSymmbolid", "programMessageSymmbolID", "programMessageSymbIDs"], "profilingMessageSymbol": ["profilingMessageSyntax", "profilingMessageSysols", "profilingMessageSymols", "profilingMessageCyavior", "profilingMessageSymmb", "profilingMsgSymbol", "profilingMessageSysmb", "profilingMessageSYmb", "profilingMessageSyse", "profilingMessageSymavior", "profilingMessageSymmbol", "profilingMessageSymb", "profilingMessageSyavior", "profilingMsgSyavior", "profilingMsgSymmbol", "profilingMessagePyntax", "profilingMessageSyols", "profilingMessageCymbol", "profilingMessagesyols", "profilingMessageSymntax", "profilingMessageSymse", "profilingMsgSyntax", "profilingMsgSymntax", "profilingMessagePyavior", "profilingMessagesyse", "profilingMessagesymb", "profilingMessageSYmbol", "profilingMessageCyntax", "profilingMsgSymavior", "profilingMessageSysmbol", "profilingMessagesymbol", "profilingMessageSYse", "profilingMessagePymbol"], "connection": ["ion", "generation", "response", "reference", "subject", "settings", "con", "connected", "entry", "operation", "character", "city", "engine", "bo", "resource", "application", "client", "sequence", "table", "context", "library", "module", "directory", "ce", "link", "command", "we", "associated", "open", "function", "device", "document", "current", "system", "db", "close", "information", "condition", "position", "writer", "Connection", "initial", "cone", "note", "handler", "conn", "created", "network", "line", "collection", "connect", "database", "relation", "channel", "volume", "usage", "config", "socket", "communication", "server", "session", "established"], "statement": ["phrase", "rule", "report", "resource", "linger", "response", "reference", "subject", " Statement", "policy", "sp", "comment", "mt", "execute", "storage", "stan", "se", "application", "sequence", "processor", "description", "set", "t", "library", "template", "directory", "ment", "command", "chain", "function", "management", "document", "message", "journal", "EMENT", "list", "state", "condition", "position", "bind", "stat", "sql", "note", "parse", "language", "network", "instance", "Statement", "database", "relation", "session", "activity", "volume", "usage", "shell", "memory", "print", "expression"], "resultSet": ["traceset", "ResultScan", " resultList", "resultScan", "resultset", "recordset", " resultset", "resultS", "recordSet", "eventList", "resultPath", "resultRow", "ResultS", " resultRow", "ResultPath", "traceList", "ResultHandle", "ResultSource", "ResultList", " resultSource", "eventSet", "rowList", " resultS", "recordList", "resultList", "rowSet", "rowRow", "traceSource", "resultHandle", "rowset", "ResultSet", " resultScan", "rowHandle", "recordHandle", "traceSet", " resultPath", "eventPath", "resultSource", "rowScan", "rowS", "ResultRow", "eventset", "Resultset"], "query": ["ion", "transform", "scan", "lock", "find", "select", "test", "QU", "comment", "request", "execute", "sequence", "create", "sum", "quest", "table", "how", "gate", "init", "script", "sq", "menu", "q", "command", "print", "spec", "scope", "code", "message", "call", "join", "eries", "content", "read", "Query", "condition", "get", "ql", "commit", "sql", "note", "search", "parse", "show", "question", "qu", "volume", "string", "quote", "key", "where", "password", "send", "check", "update", "ERY", "expression", "title"], "msg": ["txt", "nm", "sm", "text", "notice", "cmp", "bg", "comm", "mt", "m", "doc", "sum", "reason", "mess", "mun", "mem", "char", "sg", "mg", "md", "log", "pkg", "err", "man", "em", "message", "rup", "ged", "kg", "ung", "Msg", "req", "e", "ext", "mag", "name", "str", "error", "meg", "gm", "cmd", "sql", "note", "mail", "gs", "mu", "term", "nom", "mb", "g", "og", "cfg", "warn", "mn", "gr", "html", "gem", "med", "gen", "title", "ex"]}}
{"id1": "88047", "id2": "19096138", "code1": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "code2": "    public static void main(String[] args) {\n        String logFileName = args[0];\n        int extractLineEvery = new Integer(args[1]).intValue();\n        String filterToken = \"P0\";\n        if (args.length > 2) {\n            filterToken = args[2];\n        }\n        try {\n            BufferedReader br = new BufferedReader(new FileReader(logFileName));\n            BufferedWriter bw = new BufferedWriter(new FileWriter(new File(logFileName + \".trim\")));\n            String readLine;\n            int x = 0;\n            while ((readLine = br.readLine()) != null) {\n                if ((x++ % extractLineEvery == 0) && readLine.startsWith(filterToken)) {\n                    bw.write(readLine + \"\\n\");\n                }\n            }\n            bw.flush();\n            bw.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n", "label": 1, "substitutes": {"readAndRewrite": ["readAndResrite", "readAndResend", "readAndrewWrite", "readAndRepend", "readAndrewrites", "readAndRepWrite", "readAndResWrite", "readAndReprite", "readAndRewrites", "readAndrewrite", "readAndResrites", "readAndReprites", "readAndrewend", "readAndRewWrite", "readAndRewend"], "inFile": ["iFILE", " inFilename", "inputFilename", "inFilename", "INPlace", "inputFile", " infile", "INTime", "INFilename", "INFILE", "inPlace", "outfile", "initFilename", "INFace", "InFile", "outFilename", "inTime", "iFile", "iTime", "InFilename", "inputPlace", "inFILE", "inputFace", "docFile", "INFile", "initFile", "docTime", "docFILE", "initPlace", "docFilename", "initFace", "Infile", "infile", "iFilename", "inFace"], "outFile": ["reportFilename", "toFILE", "outFILE", "inFilename", "nameFILE", "reportfile", " outfile", "reportFile", "checkfile", "outfile", "checkFilename", "outFilename", "checkFile", "nameFilename", "toFilename", " outFILE", "reportFILE", "inFILE", " outFilename", "toFile", "namefile", "checkFILE", "tofile", "infile", "nameFile"], "iis": ["diiss", "iIs", "diIs", "Ii", "IIs", "iris", "aiIs", "liIs", "iiss", " iIs", "iisc", "iIS", "iiis", " ii", "liis", "eis", " iris", "iiisc", "dii", "Iiss", "diis", "aiIS", "aiis", "iiris", "liris", "Iis", "ii", " iiss", "eIs", " iIS", "liisc", " iisc", "iiIs", "eIS"], "dcmParser": ["dcrparser", " dcmReader", "dcommReader", " dpmListener", "DpmBuilder", "dfmLoader", "dromAssistant", "deromparser", "drumParser", "dpmAdapter", "Dpmparser", "dpmparser", "dpmAssistant", "drumReader", " dcmarser", " dpmarser", "dpmStatement", "DcmPar", "drumBuilder", "dcrParser", "decmReader", "dmmmReader", " dcmparser", "dfmReader", "dcomBuilder", "dpmParser", "dmoduleAssistant", "dpcPrivate", " dpmParser", "decmParser", "dcmPar", "deromParser", "dcmStatement", " dpmAssistant", "DpmReader", "dcmLoader", "dromListener", "dmoduleReader", "DpmPar", "dmmmAdapter", "dgrReader", "dpmPrivate", " dpmPar", "dcommParser", "dcomLoader", "dmmmParser", " dpmparser", "DcmBuilder", "dgrParser", "dcfReader", "dmReader", "dcmarser", "dromarser", " dcmAssistant", " dpmStatement", "dcrReader", "DcmReader", "dmmparser", " dcmLoader", "dcommListener", "dcmBuilder", "dromparser", "DpmAdapter", "dmmAdapter", "dcmListener", "dcomParser", " dpmReader", "dmmReader", "dpmListener", "dpmBuilder", " dpmBuilder", "dcmPrivate", " dcmStatement", "dcmReader", "dcfParser", "dfmParser", "dcmparser", " dcmPrivate", "dpmLoader", "dpmarser", "dmmarser", "dromReader", "dcmAssistant", "dcfStatement", "Dcmparser", "deromReader", "dmmParser", "dpcAssistant", "dpcReader", " dcmBuilder", "dgrStatement", "drumPar", "dmmmparser", "dpmReader", "decmarser", "deromarser", "dcrBuilder", "dgrPar", "dcfPar", "dmodulePrivate", " dpmLoader", "dcommAssistant", "dpcParser", "DcmAdapter", "dromParser", "dpmPar", "dmparser", "DcmParser", " dcmPar", " dcmListener", "dmarser", "DpmParser", "decmparser", "dmParser", "dcmAdapter", "dmoduleParser", "dfmBuilder", " dpmPrivate", "dcomReader"], "ds": ["services", "xs", "ss", "dos", "ads", "pd", "Ds", "dl", "DS", "ins", "d", "der", "js", "details", "ws", "fs", "sys", "bs", "gd", "sets", "ls", "qs", "hs", "ns", "in", "ps", "drivers", "db", "dds", "its", "sd", "sv", "rs", "os", "ys", "des", "eps", "dd", "dt", "data", "gs", "ims", " des", "pers", "s", "obs", " DS", "dx", "hd", "ods", "outs", "dat", "aos", "vs", "uds", "dq", "as", "da", "ils", "ks", "tes", "es", "bd", "df", "eds", "cs", "dh"], "pdReader": ["pdHelper", "hdReader", "hdParser", "vdReader", "dpCar", "pedCar", "dpRunner", "ddCar", "hdRead", "pdParser", "pedLoader", "hdWriter", "pdRunner", "pdLoader", "xdHelper", "ddRunner", "xdWriter", "pedRunner", "tdParser", "tdWriter", "ddRead", "vdHelper", "ddReader", "ddWriter", "ddParser", "pdCar", "vdWriter", "xdLoader", "pedReader", "tdReader", "xdReader", "pdRead", "dpLoader", "ddLoader", "ddHelper", "vdLoader", "dpReader", "tdRead"], "out": ["txt", "flush", "output", "ins", "cb", "tmp", "t", "inner", "err", "c", "to", "opt", "up", "v", "ent", "it", "gt", "ou", "nr", "n", "io", "msg", "Out", "all", "en", "nt", "res", "obj", "on", "sum", "conv", "one", "net", "log", "list", "over", "cache", "name", "os", "ch", "cmd", "conn", "at", "auto", "desc", "gr", " err", "id", "w", "con", "cn", "sys", "raw", "in", "we", "serv", "writer", "str", "s", "outs", "aos", "o", "pool", "OUT", "data", "gen", "co", "oss", "js", "client", "status", "inter", "go", "outer", "pos", "sw", "null", "cfg", "inv", "screen", "full", "p", "end", "ex"], "dcmEncParam": ["dmmEnParam", "dmmencMsg", "dcmEncCmd", "dcmEnNum", "dcmEnVal", "dcmencPar", "dcmEncMsg", "dcmEncVal", "dmmEncVal", "dmmencParam", "dcmEnPar", "dcmEscVal", "dmmencNum", "dcmencNum", "dmmEncPar", "dcmencParam", "dcmEscNum", "dcmEscPar", "dmmEnNum", "dmmEnPar", "dcmEncNum", "dcmDecCmd", "dmmEncNum", "dcmEnParam", "dcmEscParam", "dcmDecParam", "dmmencCmd", "dcmDecNum", "dmmEncCmd", "dmmEncMsg", "dcmDecMsg", "dcmEncPar", "dcmencCmd", "dcmencMsg", "dmmEncParam"], "pdWriter": ["pcWriting", "tdwriter", "pcwriter", "PDReader", "PDWrite", "pdEditor", "pdWrite", "PDWriter", "pidWrite", "pidWriter", "pcWriter", "dpEditor", "tdWriter", "dpWriter", "pdWriting", "tdEditor", "pidwriter", "pdwriter", "tdWrite", "tdWriting", "tdReader", "dpWrite", "pcWrite", "pidWriting", "PDEditor", "dpReader"]}}
{"id1": "8000624", "id2": "4599372", "code1": "    private void CopyTo(File dest) throws IOException {\n        FileReader in = null;\n        FileWriter out = null;\n        int c;\n        try {\n            in = new FileReader(image);\n            out = new FileWriter(dest);\n            while ((c = in.read()) != -1) out.write(c);\n        } finally {\n            if (in != null) try {\n                in.close();\n            } catch (Exception e) {\n            }\n            if (out != null) try {\n                out.close();\n            } catch (Exception e) {\n            }\n        }\n    }\n", "code2": "    @Override\n    public String readFixString(final int len) {\n        if (len < 1) {\n            return StringUtils.EMPTY;\n        }\n        final StringWriter sw = new StringWriter();\n        try {\n            IOUtils.copy(createLimitedInputStream(len), sw, null);\n        } catch (IOException e) {\n            throw createRuntimeException(e);\n        }\n        return sw.toString();\n    }\n", "label": 1, "substitutes": {"CopyTo": [" copiesInt", "CopyInt", " copyInt", " copyFrom", " CopyFrom", " copiesFrom", " CopyInt", " copiesTo", " copyTo", "CopyFrom"], "dest": ["origin", "txt", "usr", "image", "img", "cat", "output", "orig", "them", "sp", "d", "cont", "tmp", "est", "pipe", "mem", "rest", "th", "result", "src", "opt", "v", "filename", "name", "copy", "target", "it", "st", "path", "null", "dir", "nom", "Dest", "temp", "fn", "source", "loc", "p", "w"], "in": ["mi", "rin", "en", "image", "win", "inn", "ini", "by", "gin", "min", "con", "IN", "internal", "ins", "ar", "reader", "m", "on", "client", "al", "In", "t", "inner", "inside", "init", "one", "net", "from", "thin", "ai", "re", "up", "i", "read", "bin", "ac", "inc", "l", "input", "sin", "login", "iter", "it", "per", " din", "ir", " input", "ain", "ind", "o", "nin", "r", "local", "din", "inf", "is", "isin", "source", "file", "cin", "ire"], "out": ["all", "co", "en", "nt", "na", "flush", "by", "con", "output", "cos", "oe", "res", "oss", "cn", "op", "other", "obj", "ln", "client", "w", "not", "t", "inner", "dis", "ns", "one", "conv", "net", "write", "b", "to", "end", "loss", "list", "up", "v", "e", "writer", "os", "outer", "it", "gt", "note", "null", "at", "ou", "outs", "aos", "o", "batch", "boot", "ex", "full", "n", "io", "Out", "fn", "OUT", "user", "can", "ne", "ot"], "c": ["f", "rc", "u", "cat", "z", "con", "character", "cb", "d", "cont", "cr", "C", "bc", "t", "ce", "char", "code", "k", "cc", "ca", "current", "v", "i", "e", "ct", "conf", "ac", "cp", "gc", "cm", "l", "ec", "cod", "ch", "sc", "lc", "cd", "g", "unc", "cut", "nc", "count", "n", "arc", "uc", "cap", "cf", "cs", "cl"]}}
{"id1": "5620792", "id2": "17729554", "code1": "    public static String SHA1(String text, int HASH_VALUE_SIZE) throws NoSuchAlgorithmException, UnsupportedEncodingException {\n        MessageDigest md;\n        md = MessageDigest.getInstance(\"SHA-1\");\n        byte[] sha1hash = new byte[HASH_VALUE_SIZE];\n        md.update(text.getBytes(\"iso-8859-1\"), 0, text.length());\n        sha1hash = md.digest();\n        return convertToHex(sha1hash);\n    }\n", "code2": "    public boolean clonarFichero(FileInputStream rutaFicheroOrigen, String rutaFicheroDestino) {\n        System.out.println(\"\");\n        boolean estado = false;\n        try {\n            FileOutputStream salida = new FileOutputStream(rutaFicheroDestino);\n            FileChannel canalOrigen = rutaFicheroOrigen.getChannel();\n            FileChannel canalDestino = salida.getChannel();\n            canalOrigen.transferTo(0, canalOrigen.size(), canalDestino);\n            rutaFicheroOrigen.close();\n            salida.close();\n            estado = true;\n        } catch (IOException e) {\n            System.out.println(\"No se encontro el archivo\");\n            e.printStackTrace();\n            estado = false;\n        }\n        return estado;\n    }\n", "label": 0, "substitutes": {"SHA1": ["shaOne", "HS256", "sha1", "SHAOne", "sha256", " SHA2", "sha2", "HS2", "HSOne", "SHA256", " SHAOne", " SHA256", "SHA2", "HS1"], "text": ["event", "translation", "txt", "nt", "value", "subject", "select", "output", "tx", "test", "cont", "word", "comment", "t", "template", "code", "q", "document", "message", "current", "content", "ext", "read", "act", "url", "ct", "name", "pt", "str", "input", "TEXT", "out", "form", "path", "term", "Text", "pattern", "key", "string", "config", "msg", "password", "source", "print", "data", "prefix"], "HASH_VALUE_SIZE": ["HASH_VALUE_DIR", "HASH_VALUE_NAME", "HASH_VAL_NAME", "HASH_VALUE_TYPE", "HASH_VALUE_NO", "HASH_VALUE_SOURCE", "HASH_value_SIZE", "HASH_VAL_NO", "HASH_VALUE_Size", "HASH_value_DIR", "HASH_VAL_SIZE", "HASH_value_TYPE", "HASH_value_SOURCE", "HASH_VAL_Size"], "md": [" Md", " mc", "sm", "ms", "pd", "and", "od", " ms", "d", "hm", "h", " mo", "der", "mt", "js", " cmd", "m", " mm", "mod", "mg", "mp", "ctr", "mond", " sd", "rm", "det", "mode", "dm", "sd", "td", " rm", " cd", "nd", " del", " ma", "ds", "cond", "ind", "dd", "cmd", "mand", "metadata", " dd", "dir", "cd", "mb", "hd", "MD", "dig", "add", "ad", "grad", " man", "mc", "mm", "mn", "mk", "ld", "bd", "df", "dh"], "sha1hash": ["sha2result", "sha5sum", "SHA2str", "ha2result", "sha5value", " SHA31have", "ha1sum", "ha2sum", "sha2hex", "sha2have", "shaoneHash", "SHA1Hash", "sha31sum", "sha2str", "sha1have", " SHA1value", "shaonehash", "sha1result", "SHA2hash", "sha31have", " SHA31hash", "sha2sum", "ha2hash", "sha7Hash", "SHA1hash", "sha2Hash", "sha3str", " SHA31sum", "sha2hash", "sha1hex", "sha1value", " SHA31value", "sha1Hash", "ha2Hash", "sha5hash", "sha1str", "sha31hash", "SHA1str", "shaonesum", " SHA1have", "sha3hex", "sha7hex", "sha7hash", "sha1sum", "sha3Hash", "sha3hash", "sha31value", "ha1Hash", "shaoneresult", " SHA1sum", " SHA1hash", "sha2value", "ha1hash", "SHA2Hash", "sha5have", "ha1result", "SHA1hex", "SHA2hex", "sha7str"]}}
{"id1": "12349563", "id2": "12678045", "code1": "    public boolean resourceExists(String location) {\n        if ((location == null) || (location.length() == 0)) {\n            return false;\n        }\n        try {\n            URL url = buildURL(location);\n            URLConnection cxn = url.openConnection();\n            InputStream is = null;\n            try {\n                byte[] byteBuffer = new byte[2048];\n                is = cxn.getInputStream();\n                while (is.read(byteBuffer, 0, 2048) >= 0) ;\n                return true;\n            } finally {\n                if (is != null) {\n                    is.close();\n                }\n            }\n        } catch (IOException ex) {\n            return false;\n        }\n    }\n", "code2": "    private void addQDInformation() {\n        try {\n            long qdDate = System.currentTimeMillis();\n            if (_local == true) {\n                File qdFile = new File(\"qdinfo.dat\");\n                if (!qdFile.exists()) {\n                    return;\n                }\n                qdDate = qdFile.lastModified();\n            }\n            if (qdDate > this._qdFileDate) {\n                this._qdFileDate = qdDate;\n                for (int ii = 0; ii < this._projectInfo.size(); ii++) {\n                    Information info = getInfo(ii);\n                    if (info != null) {\n                        info._qdValue = null;\n                    }\n                }\n                Reader reader = null;\n                if (_local == true) {\n                    reader = new FileReader(\"qdinfo.dat\");\n                } else {\n                    StringBuffer urlName = new StringBuffer();\n                    urlName.append(\"http://boston.quik.com/rph/\");\n                    urlName.append(\"qdinfo.dat\");\n                    try {\n                        URL url = new URL(urlName.toString());\n                        InputStream stream = url.openStream();\n                        reader = new InputStreamReader(stream);\n                    } catch (MalformedURLException mue) {\n                        mue.printStackTrace();\n                    }\n                }\n                BufferedReader file = new BufferedReader(reader);\n                try {\n                    String line = null;\n                    while ((line = file.readLine()) != null) {\n                        if (line.startsWith(\"pg \")) {\n                            this._qdDate = Long.parseLong(line.substring(3), 16);\n                            this._qdDate = (this._qdDate + 946684800) * 1000;\n                        } else if (line.startsWith(\"pt \")) {\n                            line = line.substring(3).trim();\n                            int pos = -1;\n                            while ((line.length() > 0) && ((pos = line.indexOf(' ')) > 0)) {\n                                int projectNum = 0;\n                                Double value = null;\n                                if (pos > 0) {\n                                    projectNum = Integer.parseInt(line.substring(0, pos));\n                                    line = line.substring(pos).trim();\n                                }\n                                pos = line.indexOf(' ');\n                                if (pos > 0) {\n                                    value = new Double((double) Integer.parseInt(line.substring(0, pos)) / 100);\n                                    line = line.substring(pos).trim();\n                                }\n                                Information info = getInfo(projectNum);\n                                if (info == null) {\n                                    info = createInfo(projectNum);\n                                }\n                                if (info._qdValue == null) {\n                                    info._qdValue = value;\n                                }\n                            }\n                        }\n                    }\n                } finally {\n                    file.close();\n                }\n            }\n        } catch (FileNotFoundException e) {\n        } catch (IOException e) {\n        }\n    }\n", "label": 0, "substitutes": {"resourceExists": [" pathexists", " resourceexisted", " resourceIsists", " resourceExits", " pathExistent", " resourceexits", " pathexits", " resourceIsits", " resourceExistent", " resourceIsisted", " resourceExisted", " pathexistent", " pathexisted", " resourceIsistent", " resourceexistent", " resourceexists", " pathExists", " pathExits", " pathExisted"], "location": ["ocation", "ion", "window", "layout", "address", "reference", "zone", "value", "hello", "comment", "resource", "description", "area", "direction", "library", "module", "directory", "template", "connection", "command", "human", "document", "message", "zo", "system", "family", "Location", "filename", "color", "country", "program", "available", "uri", "name", "position", "LOC", "resolution", "localhost", "uration", "history", "search", "path", "point", "slot", "href", "local", "padding", "remote", "usage", "string", "file", "loc", "where", "translation", "server", "availability", "behavior"], "url": ["f", "hl", "gl", "address", "u", "google", "dl", "con", "res", "h", "www", "client", "https", "bel", "ls", "ll", "t", "base", "char", "build", "pl", "sl", "open", "b", "cert", "pkg", "call", "ur", "mount", "URL", "str", "l", "out", "cmd", "nl", "ul", "mail", "r", "ssl", "ret", "n", "http", "loc", "Url", "user"], "cxn": ["ctxN", " cxns", "CxN", " cxnor", "Ctxn", "connn", "ctxnor", "cwxn", "Cxnn", " cexns", "cexn", "cexns", "cwxns", "cxns", "cxxnor", "ctxnn", "Ctxns", "cxxn", "cxnor", "conns", "CtxN", "conN", "cexnor", "cwxN", "cxnn", "cxxns", " cexnor", "Cxn", " cexn", "Ctxnn", "cxN", "conn", "cwxnn", "cexN", "cxxN", " cxN", " cexN", "Cxns", "ctxns", "ctxn"], "is": ["ois", "does", "ms", "iris", "oss", "Is", "im", "fs", "sys", "bs", "isa", "ais", "init", "in", "dis", "abs", "tis", "bits", "ps", "ts", "ires", "i", "its", "serv", "rs", "ris", "IS", "os", "has", "ys", "was", "isc", "ir", "ims", "si", "lis", "isl", "s", "bis", "ip", "isf", "info", "ists", "isi", "iso", "ios", "isin", "still", "iss", "as", "es", "sis"], "byteBuffer": ["basicMatrix", "byteMatrix", "basicQueue", " byteQueue", "bufferContext", " byteSet", "bufferSet", "noteQueue", "binaryBuffer", "byteQueue", "byteFlow", "noteBuffer", "basicFlow", "binaryContext", " byteMatrix", "byteSet", "binaryWindow", "noteMatrix", "byteWindow", "bufferWindow", " byteContext", "binarySet", "basicBuffer", "byteContext", " byteWindow", "bufferBuffer", " byteFlow", "noteFlow"]}}
{"id1": "6963063", "id2": "22879400", "code1": "    public static void main(String args[]) {\n        int[] mas = { 3, 5, 6, 9, 1, -3, -4, -88 };\n        int sort = 0;\n        for (int j = 0; j < (mas.length); j++) {\n            for (int i = 0; i < mas.length - 1; i++) {\n                if (mas[i] > mas[i + 1]) {\n                    sort = mas[i];\n                    mas[i] = mas[i + 1];\n                    mas[i + 1] = sort;\n                }\n            }\n        }\n        for (int i = 0; i < mas.length; i++) {\n            System.out.print(\" \" + mas[i]);\n        }\n    }\n", "code2": "    public static Properties loadAllProperties(String resourceName, ClassLoader classLoader) throws IOException {\n        Assert.notNull(resourceName, \"Resource name must not be null\");\n        ClassLoader clToUse = classLoader;\n        if (clToUse == null) {\n            clToUse = ClassUtils.getDefaultClassLoader();\n        }\n        Properties properties = new Properties();\n        Enumeration urls = clToUse.getResources(resourceName);\n        while (urls.hasMoreElements()) {\n            URL url = (URL) urls.nextElement();\n            InputStream is = null;\n            try {\n                URLConnection con = url.openConnection();\n                con.setUseCaches(false);\n                is = con.getInputStream();\n                properties.load(is);\n            } finally {\n                if (is != null) {\n                    is.close();\n                }\n            }\n        }\n        return properties;\n    }\n", "label": 0, "substitutes": {"mas": ["ists", "mis", "masters", "ms", "ints", "asis", "pas", "stal", "mos", "aus", "pse", "wal", "jas", "Mas", "mers", "bs", "marks", "ares", "sa", "bas", "ias", "finals", "tis", "mes", "cas", "mon", "mad", "rums", "mont", "boxes", "ums", "ames", "mus", "ams", "lists", "ris", "amas", "dal", "phas", "las", "sels", "MAS", "ims", "ales", "pres", "lands", "aos", "stro", "mails", "ma", "als", "vs", "mast", "sts", "eas", "mons", "ras", "makes", "vers", "as", "mares", "men", "asks", "oos", "nets", "phis", "rices", "alis"], "sort": ["rol", "first", "tr", "su", "lock", "alpha", "cmp", "default", "ord", "ist", "min", "test", "score", "share", "orts", "trans", "orted", "status", "sum", "tmp", "port", "rank", "label", "ORT", "rm", "orting", "alt", "lib", "sup", "lower", "l", "pos", "orter", "order", "Sort", "it", "val", "search", "dir", "s", "ind", "use", "late", "weight", "desc", "ort", "scale", "save", "start", "send", "index", "store"], "j": ["json", "lock", "dj", "z", "br", "ie", "uj", "im", "js", "obj", "jas", "m", "jit", "fr", "ia", "other", "jl", "x", "k", "jj", "q", "adj", "bj", "aj", "v", "jc", "ja", "jo", "ij", "kj", "ji", "it", "jump", "at", "g", "ind", "ge", "nr", "oj", "J", "jp", "n", "job", "is", "pr"], "i": ["origin", "php", "fi", "I", "di", "ri", "ei", "yi", "ia", "ti", "port", "me", "ic", "sim", "gi", "pi", "iter", "it", "ni", "\u0438", "ir", "ip", "ret", "info", "io", "oi", "iy", "ini", "iq", "hi", "cli", "ci", "uri", "iri", "xi", "si", "g", "ind", "is", "id", "ix", "gu", "im", "iu", "in", "fire", "chain", "bi", "multi", "ui", "asi", "wi", "iso", "iti", "phi", "mi", "ish", "ie", "qi", "m", "ki", "status", "ami", "init", "ai", "ij", "ji", "li", "ori", "ii", "iii", "zi"]}}
{"id1": "6501291", "id2": "13783549", "code1": "    public static void extractFile(String input, String output) throws ZipException, IOException {\n        FileReader reader = new FileReader(input);\n        InputStream in = reader.getInputStream();\n        OutputStream out = new FileOutputStream(new File(output));\n        byte[] buf = new byte[512];\n        int len;\n        while ((len = in.read(buf)) > 0) out.write(buf, 0, len);\n        reader.close();\n        out.close();\n    }\n", "code2": "    private static void copy(String sourceName, String destName) throws IOException {\n        File source = new File(sourceName);\n        File dest = new File(destName);\n        FileChannel in = null, out = null;\n        try {\n            in = new FileInputStream(source).getChannel();\n            out = new FileOutputStream(dest).getChannel();\n            long size = in.size();\n            MappedByteBuffer buf = in.map(FileChannel.MapMode.READ_ONLY, 0, size);\n            out.write(buf);\n        } finally {\n            if (in != null) in.close();\n            if (out != null) out.close();\n        }\n    }\n", "label": 1, "substitutes": {"extractFile": ["extractStream", "ExtractFiles", "extressFiles", "extlateStream", "ExtactFiles", "extractFiles", "ExtractStream", "extactFiles", "ExtactStream", "Extactfile", "extactFile", "Extractfile", "extressFile", "ExtractFile", "extressfile", "extlateFiles", "extactStream", "extractfile", "extactfile", "extlatefile", "extlateFile", "ExtactFile", "extressStream"], "input": ["text", "select", "sample", "hello", "cont", "request", "raw", "run", "init", "accept", "feed", "base", "q", "open", "Input", "current", "list", "read", "url", "get", "error", "initial", "upload", "query", "audio", "form", "ip", "add", "pattern", "local", "config", "io", "start", "file", "source", "check", "index", "from", "prefix"], "output": ["export", "response", "put", "console", "web", "prefix", "port", "Output", "directory", "four", "log", "write", "pot", "net", "absolute", "to", "current", "result", "phone", "hidden", "target", "success", "exit", "parent", "ou", "monitor", "o", "full", "io", "icon", "temp", "file", "source", "display", "w"], "reader": ["author", "rar", "rc", "rator", "rt", "entry", "mr", "rer", "driver", "parser", "se", "ri", "fr", "ro", "inner", "Reader", "red", "cur", "dr", "reads", "rd", "read", "writer", "rr", "rl", "rs", "iter", "ry", "rot", "per", "parse", "rx", "r", "Larry", "zip", "info", "row", "ner", "io", "er", "ra", "reading", "loader"], "in": ["en", "inn", "and", "gin", "con", "IN", "ins", "on", "ro", "In", "inner", "inside", "ic", "i", "read", "bin", "get", "inc", "sin", "iter", "it", "per", "ind", "o", "mc", "mm", "info", "io", "din", "inf", "is", "source", "cin"], "out": ["all", "co", "en", "nt", "and", "con", "res", "cn", "obj", "on", "client", "sys", "conv", "t", "inner", "po", "one", "net", "write", "log", "b", "to", "ot", "up", "bin", "writer", "os", "outer", "it", "gt", "conn", "null", "at", "ou", "outs", "o", "aos", "auto", "n", "io", "Out", "check", "OUT", "ex"], "buf": ["seq", "good", "cv", "tr", "block", "br", "buff", "var", "img", "cat", "bl", "cam", "cb", "bh", "bed", "bc", "conv", "box", "bus", "buffer", "pkg", "bag", "b", "log", "fam", "cur", "db", "aka", "bin", "Buffer", "uf", "rb", "tab", "cmd", "mu", "queue", "batch", "bar", "Buff", "cap", "msg", "cf", "arr", "vec", "bytes", "gen"], "len": ["seq", "exp", "en", "nt", "wid", "dec", "z", "dl", "cmp", "et", "h", "la", "ln", "lic", "ls", "ll", "t", "lf", "pl", "del", "lan", "lit", "rel", "lif", "v", "ler", "lib", "le", "str", "coll", "l", "pos", "fun", "val", "nl", "length", "lon", "el", "n", "cap", "no", "mil", "Len", "fin", "ld", "il", "compl", "loc", "elt", "fl"]}}
{"id1": "21488868", "id2": "8182932", "code1": "    public static boolean encodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.ENCODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "code2": "    public static void unzip(File file, ZipFile zipFile, File targetDirectory) throws BusinessException {\n        LOG.info(\"Unzipping zip file '\" + file.getAbsolutePath() + \"' to directory '\" + targetDirectory.getAbsolutePath() + \"'.\");\n        assert (file.exists() && file.isFile());\n        if (targetDirectory.exists() == false) {\n            LOG.debug(\"Creating target directory.\");\n            if (targetDirectory.mkdirs() == false) {\n                throw new BusinessException(\"Could not create target directory at '\" + targetDirectory.getAbsolutePath() + \"'!\");\n            }\n        }\n        ZipInputStream zipin = null;\n        try {\n            zipin = new ZipInputStream(new FileInputStream(file));\n            ZipEntry entry = null;\n            while ((entry = zipin.getNextEntry()) != null) {\n                LOG.debug(\"Unzipping entry '\" + entry.getName() + \"'.\");\n                if (entry.isDirectory()) {\n                    LOG.debug(\"Skipping directory.\");\n                    continue;\n                }\n                final File targetFile = new File(targetDirectory, entry.getName());\n                final File parentTargetFile = targetFile.getParentFile();\n                if (parentTargetFile.exists() == false) {\n                    LOG.debug(\"Creating directory '\" + parentTargetFile.getAbsolutePath() + \"'.\");\n                    if (parentTargetFile.mkdirs() == false) {\n                        throw new BusinessException(\"Could not create target directory at '\" + parentTargetFile.getAbsolutePath() + \"'!\");\n                    }\n                }\n                InputStream input = null;\n                FileOutputStream output = null;\n                try {\n                    input = zipFile.getInputStream(entry);\n                    if (targetFile.createNewFile() == false) {\n                        throw new BusinessException(\"Could not create target file '\" + targetFile.getAbsolutePath() + \"'!\");\n                    }\n                    output = new FileOutputStream(targetFile);\n                    int readBytes = 0;\n                    byte[] buffer = new byte[BUFFER_SIZE];\n                    while ((readBytes = input.read(buffer, 0, buffer.length)) > 0) {\n                        output.write(buffer, 0, readBytes);\n                    }\n                } finally {\n                    FileUtil.closeCloseable(input);\n                    FileUtil.closeCloseable(output);\n                }\n            }\n        } catch (IOException e) {\n            throw new BusinessException(\"Could not unzip file '\" + file.getAbsolutePath() + \"'!\", e);\n        } finally {\n            FileUtil.closeCloseable(zipin);\n        }\n    }\n", "label": 1, "substitutes": {"encodeFileToFile": ["encodeStringAsFile", "encodeFileToFiles", "encodeFileToDisk", "encodeFileAsFile", "encodeStringToFile", "encodeFileToStream", "encodeFileFromFiles", "encodeStringAsDisk", "encodeStringAsStream", "encodeFiletoFile", "encodeFileAsStream", "encodeStringToDisk", "encodeFileAsDisk", "encodeFiletoDisk", "encodeFiletoFiles", "encodeStringToFiles", "encodeFileFromStream", "encodeFileAsFiles", "encodeFileFromDisk", "encodeStringAsFiles", "encodeFiletoStream", "encodeFileFromFile", "encodeStringToStream"], "infile": ["inputfilename", "inputFile", "outbase", "outFile", " inFile", "inpath", " inbase", " infilename", "outfilename", "inbase", "InFile", "infilename", "inFile", "inputfile", "Inbase", "inputpath", " inpath", "Inpath", "outpath", "Infile"], "outfile": ["outfp", "newFile", "outname", "newfile", "indir", " outname", "outFile", "outdir", "fromfile", "outfilename", "inname", "newname", " outfilename", "tofp", "infilename", "todir", "inFile", "infp", "toFile", "newfilename", "fromfp", " outFile", "fromdir", "tofile", "fromFile"], "in": ["rin", "en", "image", "inn", "ini", "by", "gin", "con", "IN", "ins", "pin", "im", "ar", "on", "oin", "ro", "al", "In", "t", "inner", "inside", "init", "re", "up", "i", "bin", "get", "inc", "input", "amin", "or", "iter", "it", "per", " din", "form", "conn", "ain", "ind", "nin", "info", "din", "inf", "is", "isin", "source", "cin", "id", "from"], "out": ["ion", "co", "en", "nt", "flush", "con", "output", "res", "oss", "cn", "on", "sys", "t", "inner", "net", "write", "print", "b", "to", "end", "opt", "up", "writer", "os", "outer", "it", "OU", "gt", "null", "ou", "at", "outs", "g", "o", "aos", "ex", "n", "io", "Out", "file", "fn", "OUT", "can", "ne", "ot"], "buffer": ["phrase", "buf", "window", "bone", "block", "buff", "sample", "column", "frame", "comment", "view", "sequence", "append", "table", "pad", "library", "mem", "base", "template", "command", "attribute", "document", "message", "available", "stack", "number", "cache", "Buffer", "variable", "black", "total", "initial", "note", "history", "paste", "queue", "length", "binary", "batch", "bar", "padding", "info", "row", "display", "temp", "button", "password", "memory", "print", "header", "character"], "read": ["first", "each", "text", "find", "select", "reader", "wait", "allow", "raw", "stream", "set", "run", "before", "range", "write", "open", "push", "readable", "load", "print", "reads", "hold", "seek", "close", "i", "req", "skip", "get", " Read", "give", "input", "need", "iter", "through", "query", "len", "length", "Read", "ind", "add", "connect", "count", "n", "ready", "start", "size", "reading", "send", "check", "index", "READ", "end", "ok"], "success": ["first", "same", "good", "response", "value", " succ", "ceed", "cess", "positive", "fail", "city", "release", " successful", "summary", "please", "status", " Success", "ith", "accept", "Success", "danger", "done", "ratulations", "ccess", "growth", "warning", "primary", "result", "safe", " okay", "second", "unity", "crit", "condition", "successful", " failure", "sufficient", "error", "valid", "complete", "commit", "snap", "democracy", "continue", "photo", "surv", "successfully", "town", "submit", "support", " successes", "setup", "ok"]}}
{"id1": "7872659", "id2": "1473212", "code1": "    private static boolean genCustRatingFileAndMovieIndexFile(String completePath, String masterFile, String CustRatingFileName, String MovieIndexFileName) {\n        try {\n            File inFile = new File(completePath + fSep + \"SmartGRAPE\" + fSep + masterFile);\n            FileChannel inC = new FileInputStream(inFile).getChannel();\n            File outFile1 = new File(completePath + fSep + \"SmartGRAPE\" + fSep + MovieIndexFileName);\n            FileChannel outC1 = new FileOutputStream(outFile1, true).getChannel();\n            File outFile2 = new File(completePath + fSep + \"SmartGRAPE\" + fSep + CustRatingFileName);\n            FileChannel outC2 = new FileOutputStream(outFile2, true).getChannel();\n            int fileSize = (int) inC.size();\n            int totalNoDataRows = fileSize / 7;\n            ByteBuffer mappedBuffer = inC.map(FileChannel.MapMode.READ_ONLY, 0, fileSize);\n            int startIndex = 1, count = 0;\n            short currentMovie = 1;\n            while (mappedBuffer.hasRemaining()) {\n                count++;\n                short movieName = mappedBuffer.getShort();\n                int customer = mappedBuffer.getInt();\n                byte rating = mappedBuffer.get();\n                if (movieName != currentMovie) {\n                    ByteBuffer outBuf1 = ByteBuffer.allocate(10);\n                    outBuf1.putShort(currentMovie);\n                    outBuf1.putInt(startIndex);\n                    outBuf1.putInt(count - 1);\n                    outBuf1.flip();\n                    outC1.write(outBuf1);\n                    currentMovie = movieName;\n                    startIndex = count;\n                }\n                ByteBuffer outBuf2 = ByteBuffer.allocate(5);\n                outBuf2.putInt(customer);\n                outBuf2.put(rating);\n                outBuf2.flip();\n                outC2.write(outBuf2);\n            }\n            ByteBuffer endOfIndexFile = ByteBuffer.allocate(10);\n            endOfIndexFile.putShort(currentMovie);\n            endOfIndexFile.putInt(startIndex);\n            endOfIndexFile.putInt(100480506);\n            endOfIndexFile.flip();\n            outC1.write(endOfIndexFile);\n            outC1.close();\n            outC2.close();\n            return true;\n        } catch (IOException e) {\n            System.err.println(e);\n            return false;\n        }\n    }\n", "code2": "    @Test\n    public void test_validate_geo_getEvents() {\n        try {\n            SchemaFactory factory = SchemaFactory.newInstance(\"http://www.w3.org/2001/XMLSchema\");\n            File schemaLocation = new File(\"tes.xsd\");\n            Schema schema = factory.newSchema(schemaLocation);\n            Validator validator = schema.newValidator();\n            URL url = new URL(\"http://ws.audioscrobbler.com/2.0/?method=geo.getevents&location=madrid&api_key=b25b959554ed76058ac220b7b2e0a026\");\n            InputStream inputStream = url.openStream();\n            Source source = new StreamSource(inputStream);\n            validator.validate(source);\n        } catch (IOException ex) {\n            Logger.getLogger(GetEvents_Test.class.getName()).log(Level.SEVERE, null, ex);\n            assertFalse(\"File not found\", true);\n        } catch (SAXException ex) {\n            Logger.getLogger(GetEvents_Test.class.getName()).log(Level.SEVERE, null, ex);\n            assertFalse(\"Schema did not validate\", true);\n        }\n        assertTrue(true);\n    }\n", "label": 0, "substitutes": {"genCustRatingFileAndMovieIndexFile": [" genCustRatingFileAndMovieVersionfile", " genCustRatingFileAndMovieindexTable", " genCustRatingFileAndVideoindexFiles", " genCustRatingFileAndMovieIndexFiles", " genCustRatingFileAndVideoIndexfile", " genCustRatingFileAndMovieVersionFile", " genCustRatingFileAndVideoindexfile", " genCustRatingFileAndMovieIndexfile", " genCustRatingFileAndVideoIndexTable", " genCustRatingFileAndVideoindexFile", " genCustRatingFileAndVideoIndexFile", " genCustRatingFileAndMovieVersionTable", " genCustRatingFileAndMovieindexfile", " genCustRatingFileAndMovieindexFiles", " genCustRatingFileAndMovieindexFile", " genCustRatingFileAndMovieIndexTable", " genCustRatingFileAndMovieVersionFiles", " genCustRatingFileAndVideoIndexFiles", " genCustRatingFileAndVideoindexTable"], "completePath": [" completeDirectory", "completeScript", "fullLocation", "COMPLELog", "completeDir", " completesLocation", "completePod", "pleteLocation", "pleteDir", "completeDirectory", "pletionProject", "CompleteDirectory", "pletionPath", "totalRoot", "totalLocation", "CompleteLog", " completeLocation", "CompleteDir", "COMPLEScript", "fullPath", "completeRoot", "pletePath", " completesDirectory", "CompleteScript", "CompletePath", "CompleteLocation", "pleteRoot", "fullPod", " completesPath", "completeNow", "completeProject", "totalPod", "pletionNow", "pleteScript", "totalPath", "COMPLEPath", "pleteProject", "completeLocation", "fullRoot", "pletePod", "pleteNow", "COMPLEDir", " completesDir", "pletionDir", "CompleteProject", "completeLog", "CompleteNow", " completeDir", "pleteLog"], "masterFile": ["currentName", "masterfile", "masterFilename", "managerPath", "MasterFile", " masterFilename", " masterPath", "completeName", "managerfile", "MasterName", "completefile", "managerFile", "currentfile", "managerFilename", "currentPath", "MasterPath", "Masterfile", " masterfile", "masterName", "MasterFilename", "completeFile", "masterPath", "currentFile"], "CustRatingFileName": ["CustRatingFilesName", "CustRankFilename", "CustRatingTableNames", "CustRatedFileSet", "CustRatingFilesInfo", "CustRatingFilesType", "CustRatedfileNames", "CustRatingFilenameNames", "CustRatedFileNames", "CustRatedfileType", "CustRankFileName", "CustRatedfileName", "CustRatingfileName", "CustRatingFileInfo", "CustRatingTablename", "CustRatingTableName", "CustRatingFilenameName", "CustRatingFileSet", "CustRankFileInfo", "CustRatingTableType", "CustRatingFilenameType", "CustRatingfileSet", "CustRatingFieldType", "CustRatingFieldInfo", "CustRatingFileNames", "CustRatingFileType", "CustRankFilesType", "CustRankFilesInfo", "CustRatedFileType", "CustRatedfileSet", "CustRankFilesName", "CustRatingFilesname", "CustRatingTableSet", "CustRatingFieldName", "CustRatedFileName", "CustRankFileType", "CustRatingfileType", "CustRatingfileNames", "CustRatingFieldname", "CustRatingTableInfo", "CustRatingFilename", "CustRatingFilenameSet", "CustRankFilesname"], "MovieIndexFileName": ["MovieIndexFileNumber", "MovieIndexFILEName", "MovieIndexfileType", "MovieindexFileNumber", "MovieindexFileNames", "MovieindexfileName", "MovieIndexFieldNames", "MovieindexFileKey", "MovieIndexFILEType", "MovieIndexFileKey", "MovieindexfileNumber", "MovieIndexfileName", "MovieIndexFileType", "MovieIndexTableKey", "MovieindexfileNames", "MovieindexfileKey", "MovieIndexFieldName", "MovieIndexFILENames", "MovieindexFileType", "MovieindexFileName", "MovieIndexFILENumber", "MovieIndexFileNames", "MovieIndexFieldType", "MovieIndexTableType", "MovieIndexFieldKey", "MovieIndexTableNames", "MovieIndexTableName", "MovieIndexfileKey", "MovieindexfileType", "MovieIndexfileNames", "MovieIndexfileNumber"], "inFile": ["inF", " infile", "INF", "outFile", "INFILE", "localFILE", "outfile", "localFile", "INfile", "localC", "localfile", "inFILE", "outC", "INFile", "outF", "INC", " inFILE", " inF", "infile"], "inC": [" outL", " inCI", "inF", "intC", " outC", "inputFile", " inG", " outF", "intCI", "outFile", "inCL", " inCS", "outG", "iCI", "outL", "iCS", "iR", " outCL", "inG", "inputF", "outC", "inputC", "inR", "outCL", "iC", "outF", "intR", "intCS", "inL", "inCS", " inL", " inF", "inCI", " inR", " inCL", "inputG"], "outFile1": ["outFile0", "outFile9", "outPage2", "outfile2", "outputFileOne", "outFileOnce", "outPage1", "outFILE1", "outputFile9", "outFileOne", "outputFile1", "outChannel9", "outFILE6", " outFile6", "outChannel1", "outPage9", "outfile0", "outfile1", "outFILE2", "outPage6", " outfile1", "outPageOne", "outputPage9", "outputPageOnce", " outfile6", "outFILE0", "outputPageOne", " outfile0", "outfile6", "outFile6", "outChannelOnce", "outPageOnce", " outFile0", "outputFileOnce", "outChannelOne", "outPage0", "outputPage1", " outfile2"], "outC1": ["inFile3", "inFileOne", "outROne", "outc3", "outC3", "outCB3", "outR3", "outc2", "outFileOne", "outPOne", "outc1", "outP1", "outCB1", "outP3", "outR1", "outR2", "inC0", "inC1", "outCB2", "outCOne", "inC2", "outFile3", "inCOne", "outCB0", "outP2", "inFile2", "outC0", "inC3", "inFile1", "outc0"], "outFile2": ["outFile0", "outF2", "outfile2", "outF1", " outFile02", " outFileTwo", "outF3", "outTable2", "exFile3", "exChannel2", "outChannel1", "exChannel3", "outfile0", "outfile1", "outTable3", "outFile02", "exFile1", "outChannel3", "outChannel0", "outChannel2", "exFile2", "outfile02", "outfileTwo", "outFileTwo", "exChannel1", "outFile3", " outFile3", "outF0", "exFile0", "outTable02", "exChannel0", "outTableTwo", "outfile3"], "outC2": ["allCTwo", "OutR1", "outE3", "outM22", "OutR2", "outE2", "outB22", "allB3", "outC3", "allC3", "outE4", "outC22", "outR3", "allC2", "OutR4", "outS2", "outS22", "OutC4", "allBTwo", "outR1", "outR2", "OutC1", "outM2", "outE1", "outBTwo", "outR4", "OutC2", "outMTwo", "allB22", "outB2", "allB2", "outS3", "outC4", "allC22", "outCTwo", "OutC3", "outSTwo", "outB3", "OutR3", "outM3"], "fileSize": ["byteLength", "baseSize", "fileSIZE", "FileName", "issueSize", " fileCount", "FileSIZE", "baseName", "baseSIZE", " fileSIZE", "issueName", "fileCount", "FileCount", " fileName", "issueSIZE", "FileSize", "byteName", "FileLength", "issueLength", "fileName", "fileLength", " fileLength", "byteSize", "byteSIZE", "baseCount"], "totalNoDataRows": ["totalNoDataRecoles", "totalNoDataRocks", "totalNoDataRecues", "totalNoDataSlues", "totalNodataRecocks", "totalNoDataRues", "totalNodataRecues", "totalNoDataRecocks", "totalNodataRues", "totalNodataRoles", "totalNodataRecows", "totalNoDataSloles", "totalNoDataSlows", "totalNoDataBocks", "totalNoDataSlocks", "totalNoDataBows", "totalNoDataBues", "totalNoDataRecows", "totalNoDataRoles", "totalNodataRocks", "totalNodataRecoles", "totalNodataRows", "totalNoDataBoles"], "mappedBuffer": ["mappingBuff", "mapperBuff", " mapedBuffer", "mmappedBuff", "MapedBB", " mapperCounter", "mapedCallback", " mapedBuff", "mapedQueue", "mattedData", "mappingData", "mmappingBuffer", "mappedQueue", "mressedBuff", "mappedBuff", "mappingBuffer", "mressedFB", "mmappedQueue", "maphBuff", "mapedBuffer", "mapedbuffer", " mappedFB", "maphCallback", "mapBuff", "mapperQueue", "matchedCounter", "maphBuffer", "matchedBuffer", "mappingCounter", " mapedFB", "mappedbuffer", " mapedCallback", "mattedBuff", "mappedData", "mattedBuffer", "mappingBB", "mappedCallback", "MapedData", "MapedBuff", "MappedData", "MappedBuffer", "mappingbuffer", " mapperBuff", "mressedBuffer", "mmappedBuffer", "mmappingbuffer", "mappedFB", "mapperBB", "mapedFB", "mmappingQueue", " mappedCallback", " mappedBuff", "mappingQueue", "mapedData", "mapBuffer", "matchedQueue", "mappedBB", "MapperBB", "MappedBB", "mapperbuffer", "MapperBuff", "MapedBuffer", "mressedCallback", "MappedBuff", "maphFB", "mmappingBuff", " mappedQueue", "mapedBB", "mapBB", "MapperBuffer", "matchedBuff", "mattedBB", "mapperCounter", "mapperBuffer", "mappedCounter", " mapperBuffer", " mappedCounter", "mmappedbuffer", " mapperQueue", "mapedBuff"], "startIndex": ["initindex", "StartIndex", "startIter", "StartInd", "StartPoint", "StartPosition", "firstIndex", "startPage", "startPos", "endPage", " startPage", "StartIter", " startPoint", "firstindex", " startPosition", "startPosition", " startPos", "initIndex", "firstPosition", "startInd", "Startindex", "endIter", "currentPoint", " startindex", "currentIndex", "currentPosition", "StartPos", "endIndex", " startInd", "initPosition", "startPoint", "currentPos", "StartPage", "startindex", "firstInd", " startIter", "endPosition"], "count": ["type", "first", "cloud", "process", "find", "con", "cast", "next", "depth", "force", "sum", "category", "status", "page", "limit", "code", "c", "ctr", "current", "call", "result", "max", "list", "conf", "mount", "number", "i", "counter", "act", "state", "name", "ount", "coll", "now", "total", "last", "order", "length", "continue", "amount", "batch", "Count", "ind", "found", "num", "add", "created", "n", "core", "info", "id", "start", "size", "more", "index", "check", "user"], "currentMovie": ["activeMovie", "reportedMusic", "activeSpider", "firstMouse", "currentDate", "currentMusic", "currentlyMovie", "firstMovie", "currentPlayer", "currentlySpider", "reportedMouse", "firstMonster", " currentMedia", "presentMusic", " currentPlayer", "currentlyHero", "reportedHero", " currentMonster", "presentHero", "currentlyDate", " currentVideo", "primaryMovie", "currentlyMonster", "currentMouse", "currentVideo", "primaryHero", "firstDate", "currentImage", "currentSpider", "reportedMovie", "currentlyPlayer", "reportedMedia", "presentImage", " currentSpider", " currentHero", " currentMouse", "currentMonster", "firstMedia", "primaryVideo", "activeVideo", "currentHero", "reportedImage", " currentImage", " currentMusic", "presentMovie", "currentlyVideo", "currentMedia", "activePlayer", "primaryDate", "firstVideo", "firstHero"], "movieName": ["ovieGroup", "filmName", "ovieNAME", " moviename", "movieNAME", "mpegNAME", "oviename", "filmNAME", "filmname", "mpegGroup", "moviename", "movieGroup", "httpname", "MovieType", " movieNAME", "monsterNAME", " movieTitle", "Moviename", "httpNAME", "MovieName", "MovieTitle", "movieTitle", " movieType", "ovieName", "filmType", "httpName", "mpegname", "filmGroup", "monsterName", "monstername", "movieType", "filmTitle", "mpegName"], "customer": ["CustomER", "customER", "sticker", " customator", "customity", "stickity", "developity", " customER", "Customity", "customator", "ustomator", "developorder", "customorder", "developizer", "stickizer", "stickER", "ustomer", "Customizer", "developer", "developER", "ustomorder", " customorder", "developator", "ustomER", "Customer", "customizer"], "rating": ["type", "playing", "boarding", "setting", "score", "option", " Rating", "credit", "tag", "ating", "rank", "average", "rat", "strength", "attribute", "ping", "rated", "testing", "review", "format", "rage", "having", "saving", "error", "Rating", "rate", "ranking", "scoring", "term", "weight", "core", "scale", "heading", "reading", "user", "reporting", "card", "translation"], "outBuf1": ["outBool3", "outBbufOne", "outBfx0", "outBuc5", "outBuff0", "outBdf1", "outBBuff0", "outBBuff11", "outBurg0", "outBuf64", "outBuff1", "outBuf5", "outBuffy1", "outBurg3", "outBdf64", "outRbuf0", "outBurg1", "outBulp64", "outBlf3", "outBulp3", "outRbuf18", "outBbuf18", "outBuf11", "outBuffy0", "outBbuf11", "outBufOnce", "outBooll", "outDuf11", "outBuffyl", "outBbufone", "outBulp1", "outDbuf0", "outBulpOnce", "outRufOne", "outBuff3", "outDuf0", "outBuffy3", "outRbufOne", "outBbufOnce", "outDuf1", "outBBuff1", "outBbuf0", "outBuf3", "outBbuf5", "outBufone", "outBbuf64", "outDbuf3", "outBbuf3", "outBuff2", "outBurg18", "outRuf3", "outBfx11", "outRuf18", "outBuffy18", "outDbuf1", "outBuffyone", "outBucOne", "outRuf5", "outBlf2", "outBbufl", "outBfx1", "outBool1", "outRuf1", "outBdfOnce", "outRbuf3", "outDuf3", "outBuf0", "outBlf1", "outBBuff3", "outBfx3", "outBlf0", "outRbuf1", "outRuf0", "outBufOne", "outBoolone", "outDbuf11", "outBuc1", "outBuc0", "outBdf3", "outBufl", "outBbuf1", "outBuf18", "outRbuf5"], "outBuf2": ["outBufTwo", "outBbuff15", "outBuf02", "outBuffj", "outMuf2", "outBuffy02", "outMuf3", "outBuffTwo", "outBbuf02", "outBfx15", "outBuffy4", "outBfgTwo", "outMbuf15", "outFbuf2", "outBfx1", "outBuf3", "outBbuf15", "outFufTwo", "outBuff4", "outBfg02", "outFbuf4", "outBuf15", "outBfg2", "outBbuff3", "outBfx3", "outBbufTwo", "outBbuf3", "outMuf15", "outMbuf2", "outBfx2", "outMbuf1", "outBuff2", "outFbufTwo", "outBuf42", "outBuff42", "outFuf4", "outFbuf02", "outBbuff2", "outFuf02", "outBuff3", "outMbuf3", "outBuff1", "outBuf4", "outBbuf2", "outBbufj", "outBbuff1", "outBbuff4", "outBbuf42", "outBuffy2", "outBuffyTwo", "outBbuff42", "outBbuf4", "outBufj", "outBbuffj", "outBuffy3", "outBbuf1", "outMuf1", "outFuf2", "outBfg4"], "endOfIndexFile": ["endOfIndLine", "endOfErrorF", "endofindexFile", "endOfIndexfile", "endFile", "endOfErrorFile", "endOfIndfile", "endofIndexfile", "endOfPositionFiles", "endOFIndexFile", "endOFIndexLine", "EndFile", "endOfindexTable", "endOfErrorFiles", "endOFindexFile", "endOfindexLine", "endOFindexfile", "endofIndexTable", "endofIndexF", "endOFindexLine", "endOfErrorfile", " endFile", "endofindexTable", "endofindexfile", "endofindexF", "endOfindexF", "endOfIndexFiles", "endOfindexfile", "endofIndexFile", "endOfIndFile", "endOfIndexLine", "endofindexFiles", "endofIndexFiles", "endOFIndexfile", "endOfPositionFile", "endOfindexFiles", "endOfIndexF", "endOfPositionfile", "endOfPositionTable", "endOfIndexTable", "endOfindexFile", "endedFile"]}}
{"id1": "9449064", "id2": "20019847", "code1": "    public static void main(String[] args) {\n        try {\n            boolean readExp = Utils.getFlag('l', args);\n            final boolean writeExp = Utils.getFlag('s', args);\n            final String expFile = Utils.getOption('f', args);\n            if ((readExp || writeExp) && (expFile.length() == 0)) {\n                throw new Exception(\"A filename must be given with the -f option\");\n            }\n            Experiment exp = null;\n            if (readExp) {\n                FileInputStream fi = new FileInputStream(expFile);\n                ObjectInputStream oi = new ObjectInputStream(new BufferedInputStream(fi));\n                exp = (Experiment) oi.readObject();\n                oi.close();\n            } else {\n                exp = new Experiment();\n            }\n            System.err.println(\"Initial Experiment:\\n\" + exp.toString());\n            final JFrame jf = new JFrame(\"Weka Experiment Setup\");\n            jf.getContentPane().setLayout(new BorderLayout());\n            final SetupPanel sp = new SetupPanel();\n            jf.getContentPane().add(sp, BorderLayout.CENTER);\n            jf.addWindowListener(new WindowAdapter() {\n\n                public void windowClosing(WindowEvent e) {\n                    System.err.println(\"\\nFinal Experiment:\\n\" + sp.m_Exp.toString());\n                    if (writeExp) {\n                        try {\n                            FileOutputStream fo = new FileOutputStream(expFile);\n                            ObjectOutputStream oo = new ObjectOutputStream(new BufferedOutputStream(fo));\n                            oo.writeObject(sp.m_Exp);\n                            oo.close();\n                        } catch (Exception ex) {\n                            ex.printStackTrace();\n                            System.err.println(\"Couldn't write experiment to: \" + expFile + '\\n' + ex.getMessage());\n                        }\n                    }\n                    jf.dispose();\n                    System.exit(0);\n                }\n            });\n            jf.pack();\n            jf.setVisible(true);\n            System.err.println(\"Short nap\");\n            Thread.currentThread().sleep(3000);\n            System.err.println(\"Done\");\n            sp.setExperiment(exp);\n        } catch (Exception ex) {\n            ex.printStackTrace();\n            System.err.println(ex.getMessage());\n        }\n    }\n", "code2": "    public static void copyFile(File source, File target) throws IOException {\n        FileChannel in = (new FileInputStream(source)).getChannel();\n        FileChannel out = (new FileOutputStream(target)).getChannel();\n        in.transferTo(0, source.length(), out);\n        in.close();\n        out.close();\n    }\n", "label": 1, "substitutes": {"readExp": ["readEx", " readEXP", "readExpress", "passExpl", " readProp", "readerExp", "ReadEx", "readexp", "ReadEXP", "readerLoc", "passexp", "readEXP", "readProp", "readerexp", "readExpl", "passExpress", " readEx", "checkExpl", " readExpress", "passExp", "Readexp", "ReadExp", "readLoc", "checkExp", "ReadProp", "checkExpress", "readerEXP", "readerProp", " readexp", "ReadLoc", "checkexp", "readerEx", " readExpl", " readLoc"], "writeExp": [" writeexp", "writEx", "riteReg", "riteEv", " writeEXP", "writeEXP", "writeEv", "riteexp", "writeConf", "riteExp", " writeExt", "writexp", "applyExp", "writeReg", " writeEx", " writeReg", "updateReg", " writeConf", "writEXP", "writeEx", "writXP", "writeexp", "riteExt", " writeEv", "writeExt", "applyEx", "applyXP", " writeXP", "updateExt", "writConf", "updateExp", "riteEXP", "applyEXP", "riteConf", "updateEv", "writeXP", "writExp"], "expFile": ["xpFile", "docPlace", "xpFILE", "ExpDir", "expfile", "xpPath", "mxFilename", "expFilename", "exfile", "exprFile", "mxName", "expFILE", "xpFiles", "repField", "exprName", " expFiles", "mxFile", "Expfile", " expDir", "docPath", "repPath", "exprfile", "xpfile", "exFiles", "xpFilename", "docField", "expName", "exprDir", " expfile", "exPlace", " expFILE", "ExpFile", "exFilename", "docFile", "expPath", "exprFILE", "exprFilename", "repFILE", "repFile", "mxFILE", "docFILE", "expDir", "expPlace", "expFiles", " expFilename", "docFilename", "xpField", "xpName", "expField", "exFILE", "exFile", " expPlace"], "exp": ["f", "dem", " resp", "plus", " vec", "nz", "rep", "imp", " exponent", "comm", " inst", "obj", "pp", " op", " doc", "raw", "bed", "eq", " disp", " lim", "wx", "pl", "ef", "Exp", " ne", "resp", " imp", "push", "ps", "opt", "isp", "ext", "EXP", " expanded", "def", "ox", " expansion", " rap", " extr", " est", "esp", "ez", "ent", "expl", " xp", "comp", " ep", "inst", "sc", "expr", " dj", "eps", " expr", " np", " exc", "ev", "jp", " sc", "lim", " ev", "inf", " expand", "xp", "prov", "zero", "pr", "acc", "expression"], "fi": ["mi", "fe", "ini", "qi", "osi", "ri", "ei", "abi", "ki", "ati", "ico", "ti", "lf", "cci", "aci", "ffe", "ci", "zo", "gi", "i", "uci", "obi", "ista", "uti", "pi", "iri", "fif", "eric", "Fi", "ni", "li", "si", "flo", "FI", "wi", "fa", "fty", "ii", "isi", "zi", "xf", "phi"], "oi": ["avi", "mi", "ini", "osi", "ri", "ink", "ei", "ki", "oin", "ico", "uo", "ami", "oa", "ti", "uta", "bi", "ovi", "multi", "ci", "i", "uci", "obi", "asi", "uti", "odi", "iri", "eric", "eni", "ni", "ori", "flo", "bis", "rio", "oni", "vi", "ivo", "io", "igi", "ii", "isi", "iso", "ati", "ta", "ita", "obo"], "jf": ["Jxf", "jjfc", " jfp", "Jsf", "jackf", "jcsf", "JF", " jif", "jcb", "Jf", "jjfp", "jfd", " jb", "jcf", " jfm", "jif", " jfx", "jb", " jbf", "jfm", "Jfx", "gf", " jfc", " jxf", "jcxf", "jfp", "jcfm", " jsf", "jjc", "Jb", "Jif", "bjfp", "jsxf", "djf", "gfc", "gc", "jsf", "Jfm", "jssf", "jc", "jjf", "Jbf", "jjif", "djbf", "bjf", " jv", "jbf", "jjfm", "jF", "bjv", "djfd", "jfc", "bjfm", "jsbf", "Jfd", "djxf", " jc", "jfx", "jackbf", "jcfx", "jackfd", "gfm", " jF", "jackxf", "jxf", "jjv", "jv", "jjF"], "sp": ["span", "sb", "pb", "sm", "tp", "par", "rep", "vp", "osp", "se", "op", "pp", "asp", "bsp", "sg", "pl", "ps", "bp", "isp", "cp", "sk", "sv", "sh", "pt", "spl", "sf", "esp", " esp", "sc", "sw", "st", "spe", "si", "space", "ep", "lp", "jp", "sam", "spr", "so", "Sp", "p", "SP", "ap"], "e": ["E", "f", "event", "fe", "ie", "ee", "d", "m", "t", "x", "re", "v", "i", "name", "it", "s", "ev", "el", "ed", "n", "er", " ev", "p", "a", "pe", "w"], "fo": ["lo", "hea", "co", "tto", "oe", "opa", "ooo", "bo", "folio", "ki", "mo", "ro", "uo", "ico", "ti", "FO", "po", "eno", "zo", "aco", "tf", "uf", "olf", "fif", "wt", "flo", "wi", "o", "wo", "ato", "io", "fa", "cf", "so", "oos", "tif", "xf", "obo"], "oo": ["lo", "co", "oes", "cro", "ko", "ilo", "ero", "oe", "opa", "ao", "ooo", "bo", "folio", "foo", "mo", "goo", "ro", "uo", "ico", "OO", "oa", "oooooooo", "po", "ollo", "zo", "oco", "ox", "ano", "aco", "oid", "aha", "ola", "olo", "flo", "oooo", "o", "oto", "elo", "yo", "wo", "ato", "ora", "so", "oos", "ta", "obo"], "ex": ["event", "pex", "su", "ctx", "tx", "ax", "nex", "status", "x", "sex", "wx", "err", "ception", "log", "exe", "ic", "re", "tex", "ext", "act", "com", "ox", "example", "none", "ac", "Exc", "external", "def", "EX", "or", "des", "lex", "hex", "ry", "Ex", "cre", "spe", "pers", "exc", " exc", "rex", "el", "aux", "te", "de", "except", "iox", "six", "px", "xe", "es", "ix"]}}
{"id1": "19849797", "id2": "2807585", "code1": "    public static void copyFile(File sourceFile, File destFile) throws IOException {\n        if (!destFile.exists()) {\n            destFile.createNewFile();\n        }\n        FileChannel source = null;\n        FileChannel destination = null;\n        try {\n            source = new FileInputStream(sourceFile).getChannel();\n            destination = new FileOutputStream(destFile).getChannel();\n            destination.transferFrom(source, 0, source.size());\n        } finally {\n            if (source != null) {\n                source.close();\n            }\n            if (destination != null) {\n                destination.close();\n            }\n        }\n    }\n", "code2": "    private static String encodeMd5(String key) {\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"MD5\");\n            md.reset();\n            md.update(key.getBytes());\n            byte[] bytes = md.digest();\n            String result = toHexString(bytes);\n            return result;\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return null;\n    }\n", "label": 0, "substitutes": {"copyFile": [" cpfile", "copyFiles", " copyfile", " copyStream", "transferFile", "transferStream", " cpFile", "copyStream", "copyfile", " copyFiles", " cpFiles", "transferfile", " cpStream", "transferFiles"], "sourceFile": ["ourcePath", "ourceTable", "sourcePath", "ourceLine", "sourcefile", " sourcefile", "ourceFile", "srcPath", "srcField", "sourceLine", "sourceField", "srcLine", "srcPage", "ourcefile", " sourceTable", "srcTable", " sourceLine", " sourcePath", "srcfile", " sourcePage", " sourceField", "sourceTable", "ourcePage", "ourceField", "sourcePage", "srcFile"], "destFile": ["DestPath", "optPath", "destPath", "DestFiles", " destPlace", "optEntity", "optFilename", "srcFolder", "restPlace", "DestFilename", "destFolder", "destPlace", "srcFiles", "optDir", "srcPath", " destDir", "optFile", "datPlace", "srcDir", " destFiles", "declFolder", "srcEntity", " destFilename", "DestDir", "destDir", "datFilename", "destEntity", "optFolder", "srcFile", "datFile", "datFiles", "restFile", "DestFile", " destPath", "declEntity", "restFiles", "restFilename", "declFile", "declDir", "destFilename", "destFiles"], "source": ["origin", "proxy", "back", "series", "style", "image", "subject", "match", "sample", "ie", "console", "service", "slave", "resource", "reader", "se", "comment", "score", "sequence", "force", "create", "stream", "table", "standard", "update", "init", "in", "inner", "ce", "char", "before", "store", "attribute", "spec", "scope", "load", "pose", "result", "src", "missing", "Source", "none", "owner", "copy", "target", "SOURCE", "input", "iter", "query", "note", "parent", "parse", "search", "component", "ource", "show", "iterator", "OURCE", "channel", "use", "local", "scale", "start", "send", "body", "shell", "index", "check", "cause", "from"], "destination": ["terminined", "Destation", "separinated", "Destinate", "destment", " destation", "verinated", "termininate", "separination", "restinator", "termininated", "Destment", "descinator", "separment", "noninated", "destinate", "separation", " destment", "descinate", "destinator", " destinate", "nonination", "decined", "decination", "verination", "restination", "descation", "destation", "restinate", "terminination", "Destinated", " destinator", "Destinator", "descination", "noninator", "noninate", " destinated", "veration", "verificate", " destined", "decinate", "destinated", "Destificate", "Destination", "destined", " destificate", "decinated", "destificate", "restinated"]}}
{"id1": "7143591", "id2": "9267602", "code1": "    public void getWebByUrl(String strUrl, String charset, String fileIndex) {\n        try {\n            System.out.println(\"Getting web by url: \" + strUrl);\n            addReport(\"Getting web by url: \" + strUrl + \"\\n\");\n            URL url = new URL(strUrl);\n            URLConnection conn = url.openConnection();\n            conn.setDoOutput(true);\n            InputStream is = null;\n            is = url.openStream();\n            String filePath = fPath + \"/web\" + fileIndex + \".htm\";\n            PrintWriter pw = null;\n            FileOutputStream fos = new FileOutputStream(filePath);\n            OutputStreamWriter writer = new OutputStreamWriter(fos);\n            pw = new PrintWriter(writer);\n            BufferedReader bReader = new BufferedReader(new InputStreamReader(is));\n            StringBuffer sb = new StringBuffer();\n            String rLine = null;\n            String tmp_rLine = null;\n            while ((rLine = bReader.readLine()) != null) {\n                tmp_rLine = rLine;\n                int str_len = tmp_rLine.length();\n                if (str_len > 0) {\n                    sb.append(\"\\n\" + tmp_rLine);\n                    pw.println(tmp_rLine);\n                    pw.flush();\n                    if (deepUrls.get(strUrl) < webDepth) getUrlByString(tmp_rLine, strUrl);\n                }\n                tmp_rLine = null;\n            }\n            is.close();\n            pw.close();\n            System.out.println(\"Get web successfully! \" + strUrl);\n            addReport(\"Get web successfully! \" + strUrl + \"\\n\");\n            addWebSuccessed();\n        } catch (Exception e) {\n            System.out.println(\"Get web failed!       \" + strUrl);\n            addReport(\"Get web failed!       \" + strUrl + \"\\n\");\n            addWebFailed();\n        }\n    }\n", "code2": "    public static void main(String[] args) throws IOException {\n        String urltext = \"http://www.vogella.de\";\n        URL url = new URL(urltext);\n        BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream()));\n        String inputLine;\n        while ((inputLine = in.readLine()) != null) {\n            System.out.println(inputLine);\n        }\n        in.close();\n    }\n", "label": 1, "substitutes": {"getWebByUrl": ["getWebByURL", "getUrlbyurl", "getWebByString", "getWebbyurl", "getUrlbyURL", "getUrlbyString", "getWebFromUrl", "getWebbyUrl", "getUrlByString", "getUrlByURL", "getWebByurl", "getWebFromString", "getWebbyURL", "getUrlByurl", "getWebFromurl", "getWebFromURL", "getUrlByUrl", "getWebbyString", "getUrlbyUrl"], "strUrl": ["sturl", "strStr", "STRUr", "arrurl", "StrStr", "strGl", "drUrl", "volStr", "nameUrl", "txtURL", "stDb", "txtGl", "instURL", "strURL", "nameURL", "stringUr", "volUr", "stringURL", "nameEmail", "strUr", " strURL", "drURL", "nameurl", "arrUr", "strEmail", "insturl", "STRStr", "nameDb", "STRUrl", "arrEmail", "stringUrl", "STREmail", " strurl", " strGl", "nameUr", "stURL", "txtUrl", "arrUrl", "drUr", "arrURL", "volURL", "arrStr", "StrGl", "strurl", " strDb", "stUr", "volUrl", "instUrl", "STRURL", "drDb", "nameStr", "stUrl", "txtStr", "Strurl", "StrURL", " strStr", "instUr", "stringDb", " strUr", "drurl", "StrUrl", "StrUr", "strDb"], "charset": ["ChARSec", "Charset", "chorsec", "Charsec", "ChARSets", "chARSec", "chARSET", "charsET", "CharsET", "ChARSet", "chorsets", "charsec", "chorset", "Charsets", "charsets", "chorsET", "chARSets", "ChARSET", "chARSet"], "fileIndex": [" fileNum", "ileindex", "byteindex", "byteInd", "bytePath", "stringPos", "fileNum", "stringindex", "filePos", "ileIndex", "stringIndex", "stringPath", "fileInd", "bytePos", "ileNum", "byteNum", "byteIndex", "ileInd", " filePos", " fileindex", " fileInd", "fileindex"], "url": ["f", "browser", "hl", "gl", "dl", "con", "bl", "resource", "obj", "www", "client", "https", "bel", "ls", "web", "ll", "connection", "link", "build", "net", "sl", "open", "cert", "rel", "ur", "cp", "uri", "URL", "name", "get", "rl", "str", "l", "cmd", "nl", "ul", "g", "r", "ssl", "ret", "http", "socket", "il", "Url"], "conn": ["access", "en", "nt", "handle", "ctx", "con", "pas", "oss", "cb", "cn", "comm", "enc", "obj", "ln", "ws", "nec", "sys", "conv", "connection", "addr", "net", "c", "open", "ca", "pg", "ctr", "iw", "cp", "act", "Conn", "l", "Connection", "ens", "ch", "cmd", "connect", "nc", "nw", "socket", "Con"], "is": ["ist", "ms", "us", "iris", "res", "ins", "Is", "im", "js", "nis", "ri", "ws", "fs", "sys", "bs", "ls", "isa", "ais", "in", "bits", "i", "its", "serv", "rs", "ris", "os", "IS", "out", "or", "has", "was", "it", "iter", "are", "isc", "ir", "isl", "si", "lis", "s", "bis", "ip", "isf", "info", "http", "ists", "isi", "as", "ios", "iso", "iss", "id", "ib", "es"], "filePath": ["ioPath", " filePATH", "fileFile", "FileSystem", "familyPath", "FileName", "ioFile", "familypath", "fPath", "Filepath", "ioName", "FilePATH", " fileSystem", "filePATH", "FileFile", "fName", "fFile", "familySystem", "fileName", "fileSystem", "filepath", "FilePath", "fSystem", "ioSystem", " filepath", "familyPATH"], "pw": [" pwt", "pwe", "cpwd", " pW", "pW", "apwh", "mwh", "pwt", "jW", " pws", " pwb", "Pwd", "apw", "cpwp", "Pws", "fW", "Pw", "npwd", "cpw", "npv", "fwd", "wpwt", "jwb", "apwd", " pwr", "pwd", "pws", "apwb", "pwp", "mw", "pwh", " pv", "wpv", "fw", "npwe", "fws", "PW", "Pwb", "jwd", "npwr", " pwh", "jw", " pwp", "wpwe", "mwd", "pv", " pwe", "wpw", "mwb", "pwb", " pwd", "pwr", "npwp", "npw", "npwt", "cpwr"], "fos": ["foss", "bo", "flos", "floses", "foses", "flOs", "eOs", " fo", "eoss", "fOs", "boses", " foses", "wOS", "wos", "fOS", "bos", "fo", "wOs", "flo", "eos", "woss", " fOs", " fOS", "bOs", " foss", "eOS"], "writer": ["wr", "ser", "window", "author", "worker", "nt", "Writer", "output", "console", "rw", "reader", "builder", "usher", "wright", "writing", "wb", "aver", "aster", "editor", "write", "buffer", "writ", "woman", "master", "println", "widget", "liner", "fw", "out", "written", "wn", "walker", "handler", "desc", "member", "nw", "wrote", "width", "wp", "riter", "player", "rew", "ter", "w"], "bReader": ["aWriter", "rbReader", "rbR", "bR", " bRead", "bcReader", "bhClient", "bcBuffer", "aRead", "rbRead", "bhReader", "aReader", "rbWriter", " bWriter", " bClient", "bBuffer", " bBuffer", "bRead", "bClient", "bcClient", "aR", "bhBuffer", "bWriter", " bR"], "sb": ["bt", "pb", "bf", "bg", "sp", "cb", "zb", "lb", "bh", "bs", "bsp", "wb", "sa", "CB", "sq", "sg", "b", "bb", "bj", "SB", "nb", "sv", "kb", "rb", "sf", "eb", "sw", "lp", "mb", "stab", "bis", "ssl", "erb", "rob", "gb", "ib", "bd", "sth"], "rLine": ["brLine", "bLink", "srLe", " rFrame", "srChan", " rline", "lRow", " rLe", "brRow", "brL", "rRow", "rline", "rrLine", "rrChan", " rEl", " rRow", "srEl", "lLink", "lLine", " rLink", "brFrame", "rrLe", "rFrame", "srL", "rEl", " rL", " rChan", "rL", "bRow", "rLe", "rLink", "bline", "rrEl", "srRow", "rChan", "srFrame", "lline", "bLine", "srLine"], "tmp_rLine": ["tmp_lObj", "tmp_rVal", "tmp_hLine", "tmp_rline", "tmp_rRow", "tmp_nBlock", "tmp_cline", "tmp_cObj", "tmp_lVal", "tmp_rOrig", "tmp_lRow", "tmp_pSet", "tmp_drLin", "tmp_rgLine", "tmp_lline", "tmp_RVal", "tmp_bline", "tmp_eLine", "tmp_eRow", "tmp_RChain", "tmp_eObj", "tmp_pLine", "tmp_rRecord", "tmp_bLin", "tmp_bRow", "tmp_rL", "tmp_cRow", "tmp_pL", "tmp_rChain", "tmp_hRule", "tmp_hOrig", "tmp_rnLine", "tmp_RLine", "tmp_eRecord", "tmp_rObj", "tmp_nrRow", "tmp_cLine", "tmp_lLine", "tmp_RRow", "tmp_pBlock", "tmp_RRecord", "tmp_rRule", "tmp_nrChain", "tmp_drRow", "tmp_rnRule", "tmp_rgRule", "tmp_RSet", "tmp_pLin", "tmp_drline", "tmp_nSet", "tmp_hLin", "tmp_Rline", "tmp_lChain", "tmp_nrLine", "tmp_RBlock", "tmp_RL", "tmp_drLine", "tmp_nLine", "tmp_pRow", "tmp_rBlock", "tmp_nrVal", "tmp_nL", "tmp_rgOrig", "tmp_eline", "tmp_rnLin", "tmp_lRecord", "tmp_rgLin", "tmp_bLine", "tmp_rSet", "tmp_rLin", "tmp_rnOrig", "tmp_pline"], "str_len": ["str__ls", "string3vec", "str2ll", "str_ll", "string_len", "str3vec", " str2ls", "str_ls", " str2ll", "string3length", "str__ll", "str3ls", "str3length", "string3ls", " str_Len", "string_ls", "str_length", "str2Len", "str__Len", "str2ls", "str3len", "str_vec", " str2len", " str_ll", " str2Len", "string_length", "string3len", "str_Len", "string_vec", " str_ls", "str2len", "str__len"]}}
{"id1": "18489832", "id2": "17974661", "code1": "    private static URL downLoadZippedFile(URL url, File destDir) throws Exception {\n        URLConnection urlConnection = url.openConnection();\n        File tmpFile = null;\n        try {\n            tmpFile = File.createTempFile(\"remoteLib_\", null);\n            InputStream in = null;\n            FileOutputStream out = null;\n            try {\n                in = urlConnection.getInputStream();\n                out = new FileOutputStream(tmpFile);\n                IOUtils.copy(in, out);\n            } finally {\n                if (out != null) {\n                    out.close();\n                }\n                if (in != null) {\n                    in.close();\n                }\n            }\n            unzip(tmpFile, destDir);\n        } finally {\n            if (tmpFile != null) {\n                tmpFile.delete();\n            }\n        }\n        URL localURL = destDir.toURI().toURL();\n        return localURL;\n    }\n", "code2": "    public boolean requestServerModifications(UUID sessionId, OutputStream out) throws SynchronizationException {\n        HttpClient client = new SSLHttpClient();\n        StringBuilder builder = new StringBuilder(url).append(\"?\" + SESSION_PARAM + \"=\" + sessionId).append(\"&\" + CMD_PARAM + \"=\" + CMD_SERVERMODIF);\n        HttpGet method = httpGetMethod(builder.toString());\n        try {\n            HttpResponse response = client.execute(method);\n            Header header = response.getFirstHeader(HEADER_NAME);\n            if (header != null && HEADER_VALUE.equals(header.getValue())) {\n                int code = response.getStatusLine().getStatusCode();\n                if (code == HttpStatus.SC_OK) {\n                    long expectedLength = response.getEntity().getContentLength();\n                    InputStream is = response.getEntity().getContent();\n                    FileUtils.writeInFile(is, out, expectedLength);\n                    return true;\n                } else {\n                    throw new SynchronizationException(\"Command 'receive' : HTTP error code returned.\" + code, SynchronizationException.ERROR_RECEIVE);\n                }\n            } else {\n                throw new SynchronizationException(\"HTTP header is invalid\", SynchronizationException.ERROR_RECEIVE);\n            }\n        } catch (Exception e) {\n            throw new SynchronizationException(\"Command 'receive' -> \", e, SynchronizationException.ERROR_RECEIVE);\n        }\n    }\n", "label": 0, "substitutes": {"downLoadZippedFile": [" tryLoadXippedFile", " tryLoadZZipfile", " tryLoadZippedfile", " tryLoadZressedImage", " tryLoadXippedImage", " tryLoadZppedFile", " tryLoadXZipfile", " tryLoadZZipImage", " tryLoadZressedfile", " tryLoadZressedDir", " tryLoadXZipDir", " tryLoadXippedDir", " tryLoadZZipDir", " tryLoadZppedDir", " tryLoadXZipImage", " tryLoadZppedfile", " tryLoadZippedDir", " tryLoadZressedFile", " tryLoadXippedfile", " tryLoadZZipFile", " tryLoadZppedImage", " tryLoadXZipFile", " tryLoadZippedFile", " tryLoadZippedImage"], "url": ["browser", "ref", "address", "dl", "request", "https", "raw", "web", "ll", "base", "char", "link", "build", "err", "log", "open", "b", "sl", "call", "un", "ur", "mount", "xml", "uri", "URL", "name", "get", "external", "str", "l", "nl", "ul", "parse", "r", "ssl", "ret", "row", "http", "location", "key", "file", "Url", "loader"], "destDir": ["originDIR", "destDIR", "distDirectory", "sourceFile", "srcFolder", " destDIR", "destFolder", " destFolder", "originDirectory", "srcDir", "distDir", "targetDir", "sourceDir", "destDirectory", "targetDirectory", "srcDIR", "distFolder", "sourceDirectory", "destFile", "distDIR", "originDir", " destDirectory", "originFolder", "targetFolder", "srcDirectory", "sourceFolder", "targetDIR", " destFile", "srcFile"], "urlConnection": ["streamConnection", "URLConnection", "streamConnector", "UrlDialog", " urlConnect", "urlDialog", "urlClient", "httpDialog", " urlDialog", " urlConnector", " urlCompany", "httpLink", "httpConnect", "UrlConnect", "URLClient", "UrlLink", "URLConnector", " urlClient", "urlLink", "httpConnection", "streamCompany", "UrlConnection", " urlLink", "urlConnector", "urlConnect", "urlCompany", "streamClient", "URLCompany"], "tmpFile": ["tempDir", " tmpPage", " tmpFilename", "empTile", "destfile", "mpfile", " tmpfile", "tempChain", "tmpTile", "thisfile", "thisFile", "tmpBe", "tmpChain", "destBe", "tempView", "tmpfile", "empFilename", "tempFilename", "empFile", "cmpFile", "destPage", "mpFile", "empChain", "empView", "tmpDir", "thisFilename", "empDir", " tmpDir", "thisChain", "tempfile", "destFile", "cmpfile", "cmpFilename", "empfile", "tempTile", " tmpTile", "tempFile", "tmpPage", " tmpView", "tempBe", "tmpFilename", "tmpView", "tempPage", " tmpBe", "cmpPage"], "in": ["ze", "all", "mi", "co", "rin", "en", "win", "inn", "ini", "by", "gin", "con", "ie", "IN", "ins", "im", "ln", "on", "oin", "ains", "al", "In", "init", "inside", "inner", "one", "old", "ai", "re", "up", "i", "none", "bin", "inc", "l", "input", "or", "sin", "iter", "it", "query", "st", "ain", "ind", "ma", "el", "info", "n", "din", "inf", "is", "isin", "source", "as", "cin", "index", "from", "pass"], "out": ["all", "co", "na", "nt", "flush", "con", "output", "cos", "oe", "oss", "cn", "obj", "client", "on", "sys", "tmp", "col", "conv", "t", "po", "one", "net", "write", "print", "to", "up", "v", "writer", "os", "external", "outer", "or", "ent", "it", "ch", "OU", "note", "exit", "null", "ou", "at", "outs", "aos", "o", "n", "io", "no", "Out", "OUT", "can", "ne", "ex"], "localURL": ["localURI", "LocalUR", " localUL", "localUR", "publicUR", "LocalUL", " localID", "localUL", "publicURL", "LocalID", "localhostID", "localhostLL", "localID", "LocalURI", "localUrl", " localUR", " localURI", "LocalUrl", "LocalURL", "LocalLL", "localhostURL", " localUrl", " localLL", "publicUrl", "localhostUL", "localLL", "publicURI"]}}
{"id1": "4481712", "id2": "14464131", "code1": "    public void deleteObject(String id) throws SQLException {\n        boolean selfConnection = true;\n        Connection conn = null;\n        PreparedStatement stmt = null;\n        try {\n            if (dbConnection == null) {\n                DatabaseConn dbConn = new DatabaseConn();\n                conn = dbConn.getConnection();\n                conn.setAutoCommit(false);\n            } else {\n                conn = dbConnection;\n                selfConnection = false;\n            }\n            stmt = conn.prepareStatement(this.deleteSql);\n            stmt.setString(1, id);\n            stmt.executeUpdate();\n            if (selfConnection) conn.commit();\n        } catch (Exception e) {\n            if (selfConnection && conn != null) conn.rollback();\n            throw new SQLException(e.getMessage());\n        } finally {\n            if (stmt != null) {\n                stmt.close();\n                stmt = null;\n            }\n            if (selfConnection && conn != null) {\n                conn.close();\n                conn = null;\n            }\n        }\n    }\n", "code2": "    public static void main(String[] args) {\n        try {\n            URL url = new URL(\"http://hostname:80\");\n            URLConnection conn = url.openConnection();\n            for (int i = 0; ; i++) {\n                String headerName = conn.getHeaderFieldKey(i);\n                String headerValue = conn.getHeaderField(i);\n                if (headerName == null && headerValue == null) {\n                    break;\n                }\n                if (headerName == null) {\n                }\n            }\n        } catch (Exception e) {\n        }\n    }\n", "label": 0, "substitutes": {"deleteObject": ["getObj", "destroyobject", " deleteObj", " deleteobject", "deleteObj", "destroyObj", "getobject", " deleteItem", "deleteItem", "destroyObject", "destroyItem", "getItem", "getObject", "deleteobject"], "id": ["event", "type", "kid", "f", "ID", "ref", "value", "pid", "d", "h", "description", "tag", "vid", "t", "sid", "k", "md", "link", "mid", "message", "db", "i", "url", "name", "oid", "hash", "ids", "rid", "it", "data", "object", "path", "uid", "ident", "info", "Id", "key", "n", "row", "p", "delete"], "conn": [" con", " mem", "ctx", "comm", "cb", "enc", "gate", "port", "ns", "connection", "cons", " dc", "err", "c", " ex", "db", "rel", "conf", "pt", " cx", "ens", " cont", "ctrl", "jp", "core", "nw", "n", "wp", " core", "dc", " cp", "en", " mc", "nt", "win", "cat", "pub", "pas", "bo", "obj", " connection", "ws", "lang", "here", "conv", "col", "ce", "net", "cur", " c", "act", "coll", "ch", "cmd", "priv", "connect", "ssl", "mn", "nc", "local", " cs", " ac", "cc", "con", "cn", "sys", "ll", "ann", "addr", "open", "resp", "cert", "cp", "cf", "host", "gen", "nick", "canon", "co", "tp", " conv", "oss", " compat", " comm", " cmd", "client", "urg", "ca", "pkg", "pg", "close", "org", "com", "ct", "Conn", "pos", " pc", " win", "auth", " cc", " col", "cfg", " rc", "mc", "socket", " net", " ch", " db", " ce", "loc", "ld"], "stmt": ["STst", "astm", "statpt", "Stm", "stm", "stMT", "formm", "Stmn", "statmb", "statmt", "STmp", "strmt", "stmm", "utmp", "formMT", "ststat", " stmm", "ostmt", "Stst", "astmt", "astpt", "strmn", "StMT", "stst", " stmb", "Stmp", "Ststat", " ststat", "stmp", "utst", "strm", "STm", " stm", "STMT", "ostm", "formstat", "stmb", " stpt", "strmb", "ostpt", "Stpt", "utm", "STmm", "stpt", "astmm", "Stmm", " stMT", "Stmt", "Stmb", "utmt", " stmn", "stmn", "formmt", "STmt", "strMT", "ostmm", "statm"], "dbConn": ["DbRec", "dbConnect", "DbConn", "dbCt", "dbCon", "DbConnect", " dbObj", "dbObj", "DbColl", "dsConnect", "DbObj", "DBColl", "dsConn", " dbCon", " dbConnect", " dbCt", "DBObj", " dbRec", "dsCon", "DbCon", "DBRec", " dbColl", "dbRec", "dsCt", "DBConn", "dbColl", "DbCt"], "selfConnection": [" selfConnect", "SelfConnection", "SelfInfo", "Selfconnection", "selfconnection", "selfFree", " selfconnection", "SelfThread", " selfCategory", "ownLink", " selfLink", "selfInfo", "reconnection", "SelfCategory", "SelfConnect", "SelfLink", "selfThread", "SelfFree", "selfLink", "ownFree", "ownOnly", "ownConnect", "ownConnection", " selfOnly", "SelfOnly", " selfFree", "ownThread", "alsoConnect", " selfInfo", "alsoCategory", "selfOnly", "reConnect", " selfThread", "selfConnect", "reConnection", "alsoConnection", "reLink", "alsoLink", "selfCategory"]}}
{"id1": "17202158", "id2": "5759961", "code1": "    static HashSet<Integer> readZoneIDs(String zoneFileName) {\n        HashSet<Integer> zoneids = new HashSet<Integer>();\n        try {\n            URL url = zoneFileName.getClass().getResource(zoneFileName);\n            LineNumberReader lnr = new LineNumberReader(new InputStreamReader(url.openStream()));\n            String line = null;\n            while ((line = lnr.readLine()) != null) zoneids.add(Integer.parseInt(line));\n        } catch (Exception xc) {\n            xc.printStackTrace();\n        }\n        return zoneids;\n    }\n", "code2": "    @Override\n    public User saveUser(User user) {\n        try {\n            MessageDigest digest = java.security.MessageDigest.getInstance(\"MD5\");\n            digest.update(user.getPassword().getBytes(\"UTF-8\"));\n            byte[] hash = digest.digest();\n            BigInteger bigInt = new BigInteger(1, hash);\n            String hashtext = bigInt.toString(16);\n            while (hashtext.length() < 32) {\n                hashtext = \"0\" + hashtext;\n            }\n            user.setPassword(hashtext);\n            user.setDataRegjistrimit(new Date());\n            return em.merge(user);\n        } catch (Exception e) {\n            throw new NestedException(e.getMessage(), e);\n        }\n    }\n", "label": 0, "substitutes": {"readZoneIDs": ["readZoneNames", "readLineIDS", "readObjectID", "readLineIDs", "findZoneIDS", "readLocalNames", "readObjectNames", "readLineNames", "findZoneNames", "readZoneIDS", "findLocalIDS", "findLocalNames", "readZoneID", "readLineID", "findZoneIDs", "findLocalIDs", "readObjectIDS", "readObjectIDs", "readLocalIDS", "readLocalIDs", "readLocalID", "findLocalID", "findZoneID"], "zoneFileName": ["zonefileSource", "zoneFilenamePath", "zoneFileChain", "zoneFilenameSource", "ZoneFileSource", "ZonefileSpec", "zonefileChain", "zoneFILEType", "ZoneFilePath", "zonefileType", "zoneFilenameName", "ZonefileType", "ZonefileName", "zoneFileNames", "zoneDirPath", "zoneFILEPath", "zonefileNames", "zoneFilesNames", "zoneFolderFilename", "zoneFilesPath", "zonefileSpec", "ZonefileFilename", "zoneFolderName", "ZonefileSource", "zoneFilesName", " zoneFileNames", "zoneFILENames", "zoneDirName", "zoneFolderPath", "ZoneFileSpec", "zoneFileSpec", "zoneDirSpec", "zonefileFilename", "zoneDirSource", "zoneFileFilename", " zonefileNames", "zoneFilesChain", "ZonefilePath", "zoneFolderType", "ZoneFileFilename", "ZoneFileType", " zonefileChain", "ZoneFileName", "zoneFILEFilename", "zoneFileSource", "zoneFilenameSpec", "zoneFILEChain", "zonefileName", " zoneFileChain", " zonefileName", "zonefilePath", " zoneFilePath", "zoneFileType", " zonefilePath", "zoneFILEName", "zoneFilePath"], "zoneids": ["zoneIDs", "zonelines", "tznaires", "zaoids", " zoneuploads", "tzids", "znames", "zipIDs", "elementcodes", " zonecodes", "tzoids", "elementuploads", "zuploads", " zoneoids", "zoneoids", " zonenaires", "zids", "zanaires", "zaIDs", "zlines", " zonelines", "elementids", "tzIDs", "zIDs", "elementlines", "zoneuploads", "zaids", "zcodes", "zonenames", " zoneIDs", "zipnames", " zonenames", "zonecodes", "ziplines", "zonenaires", "zipids"], "url": ["f", "browser", "ref", "dl", "resource", "lb", "bel", "ls", "web", "ll", "base", "char", "q", "build", "log", "sl", "open", "lr", "result", "rel", "ur", "mount", "uri", "URL", "name", "str", "rl", "l", "this", "nl", "ul", "r", "ssl", "ret", "http", "file", "loc", "Url", "user", "loader", "cl"], "lnr": ["olndr", "lnn", "linr", "lenr", "lncr", "olnr", "cnp", "lndr", "nln", "lnR", "nlp", "lnp", "lendr", "olnn", "nlR", "nlcr", "lenn", "linp", "nldr", "olnR", "lenR", "nlr", "cnr", "cncr", "linrar", "nlrar", "cnrar", "lincr", "lnrar"], "line": ["phrase", "LINE", "style", "block", "lin", "text", "eline", "entry", "ine", "sample", "next", "part", "comment", "frame", "lane", "word", "ln", "sequence", "page", "stream", "stroke", "day", "char", "code", "range", "link", "log", "net", "chain", "message", "cell", "number", "e", "le", "liner", "l", "section", "nl", "point", "normal", "continue", "Line", "ge", "row", "string", "display", "inline", "file", "online", "print", "header"]}}
{"id1": "10728243", "id2": "481364", "code1": "    private byte[] scramble411(String password, String seed) {\n        MessageDigest md;\n        try {\n            md = MessageDigest.getInstance(\"SHA-1\");\n            byte[] passwordHashStage1 = md.digest(password.getBytes());\n            md.reset();\n            byte[] passwordHashStage2 = md.digest(passwordHashStage1);\n            md.reset();\n            md.update(seed.getBytes());\n            md.update(passwordHashStage2);\n            byte[] toBeXord = md.digest();\n            int numToXor = toBeXord.length;\n            for (int i = 0; i < numToXor; i++) {\n                toBeXord[i] = (byte) (toBeXord[i] ^ passwordHashStage1[i]);\n            }\n            return toBeXord;\n        } catch (NoSuchAlgorithmException e) {\n            if (logger.isLoggable(Level.SEVERE)) {\n                logger.log(Level.SEVERE, e.getMessage(), e);\n            }\n        }\n        return null;\n    }\n", "code2": "    private void downloadFiles() {\n        SwingWorker<Double, RaphPhotoGalleryPhoto> downloadFilesWorker = new SwingWorker<Double, RaphPhotoGalleryPhoto>() {\n\n            Date startDownloadDate;\n\n            @Override\n            public Double doInBackground() {\n                startDownloadDate = new Date();\n                refreshSpeed = 0;\n                lastDate = null;\n                try {\n                    int totalSizeRead = 0;\n                    int totalNumberRead = 0;\n                    for (RaphPhotoGalleryPhoto photo : photoList) {\n                        URL url = new URL(getCodeBase().toString() + photo.getUrl());\n                        HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n                        DataInputStream dis = new DataInputStream(connection.getInputStream());\n                        FileOutputStream fos = new FileOutputStream(destinationDirectory.toString() + \"/\" + photo.getFileName());\n                        byte[] b = new byte[65536];\n                        int sizeRead;\n                        photo.setProcessedSize(0);\n                        totalNumberRead++;\n                        while ((sizeRead = dis.read(b)) > -1) {\n                            fos.write(b, 0, sizeRead);\n                            totalSizeRead += sizeRead;\n                            photo.addToProcessedSize(sizeRead);\n                            photo.setTotalProcessedSize(totalSizeRead);\n                            photo.setTotalProcessedNumber(totalNumberRead);\n                            publish(photo);\n                            try {\n                            } catch (Exception ignore) {\n                            }\n                        }\n                        fos.close();\n                    }\n                } catch (MalformedURLException e1) {\n                    System.err.println(\"MalformedURLException: \" + e1);\n                } catch (IOException e2) {\n                    System.err.println(\"IOException: \" + e2);\n                }\n                long totalDiffTime = (new Date()).getTime() - startDownloadDate.getTime();\n                double totalSpeed = photoListTotalSize / (totalDiffTime / 1000);\n                return new Double(totalSpeed);\n            }\n\n            @Override\n            protected void process(List<RaphPhotoGalleryPhoto> list) {\n                RaphPhotoGalleryPhoto photo = list.get(list.size() - 1);\n                progressBarTotal.setMaximum(photoListTotalSize);\n                progressBarTotal.setValue(photo.getTotalProcessedSize());\n                setProgressBarTotalLabels(photo.getTotalProcessedNumber(), photoList.size(), photoListTotalSize - photo.getTotalProcessedSize());\n                progressBarCurrent.setMaximum(photo.getFileSize());\n                progressBarCurrent.setValue(photo.getProcessedSize());\n                progressBarCurrentLabel.setText(photo.getFileName());\n                long diffTime = 0;\n                if (lastDate == null) lastDate = new Date();\n                diffTime = (new Date()).getTime() - lastDate.getTime();\n                if (diffTime > 1000) {\n                    double currentSpeed = (photo.getTotalProcessedSize() - lastTotalSize) / (diffTime / 1000.0);\n                    if (currentSpeed > 0) lastSpeed.add(new Double(currentSpeed));\n                    if (lastSpeed.size() == 10) lastSpeed.removeFirst();\n                    double speed = 0;\n                    for (Double d : lastSpeed) {\n                        speed += d.doubleValue();\n                    }\n                    speed = Math.round(speed / lastSpeed.size());\n                    if (refreshSpeed == 0) {\n                        long totalDiffTime = (new Date()).getTime() - startDownloadDate.getTime();\n                        double totalSpeed = (photo.getTotalProcessedSize()) / (totalDiffTime / 1000.0);\n                        remainingTime = (photoListTotalSize - photo.getTotalProcessedSize()) / totalSpeed;\n                        if (remainingTime < 8) refreshSpeed = 0; else refreshSpeed = 3;\n                    } else {\n                        refreshSpeed--;\n                        remainingTime -= diffTime / 1000.0;\n                    }\n                    speedLabel.setText(String.format(\"%.0f\", speed / 1024) + \" \" + getParameter(\"i18n_speedUnit\") + \" :  \" + String.format(\"%.0f\", remainingTime) + \" s\");\n                    lastDate = new Date();\n                    lastTotalSize = photo.getTotalProcessedSize();\n                }\n            }\n\n            @Override\n            protected void done() {\n                try {\n                    speedLabel.setText(String.format(\"%.0f\", get().doubleValue() / 1024) + \" \" + getParameter(\"i18n_speedUnit\"));\n                    downloadButton.setText(getParameter(\"i18n_finished\"));\n                    downloadState = 2;\n                } catch (Exception ignore) {\n                }\n            }\n        };\n        downloadFilesWorker.execute();\n    }\n", "label": 0, "substitutes": {"scramble411": ["scramle ", "scamblePassword", "scrambled ", "scambles ", "scambleBasic", "scamblesPassword", "scramble ", "scramlepassword", "scrambleBasic", "scrambledBasic", "scamblepassword", "scramblespassword", "scramblepassword", "scamble ", "scramleBasic", "scrambles ", "scrambledpassword", "scamblesBasic", "scrambledPassword", "scramblePassword", "scramblesPassword", "scamblespassword", "scramlePassword", "scramblesBasic"], "password": ["phrase", "address", "text", "reset", "email", "hello", "word", "description", "secret", "shadow", "profile", "attribute", "Password", "message", "primary", "wd", "words", "token", "hash", "auth", "sword", "database", "pattern", "padding", "key", "string", "user", "remember", "username", "data", "prefix", "crypt", "pass"], "seed": ["phrase", "needs", "ser", " seeds", " seeded", "vector", "reset", "sample", "random", "test", "Salt", "rand", "entry", "derived", "se", "sequence", "secret", "create", "setup", "sudo", "eder", "feed", "shadow", "template", "sex", "example", "hash", "initial", "sql", "offset", "mix", "padding", "key", "start", "eed", "source", "prime", "index", "df"], "md": ["nt", "sm", "pd", "img", "ms", "od", "di", "d", "der", "mt", "amd", "m", "managed", "sha", "mod", "ann", "mg", "red", "addr", "mp", "esm", "mind", "pkg", "multi", "dr", "rm", "det", "rd", "dm", "sd", "def", "ct", "td", "nd", "cm", "pt", "gm", "dd", "cmd", "mand", "metadata", "mb", "cd", "hd", "MD", "ind", "dig", "ad", "rpm", "mn", "mc", "mm", "grad", "desc", "pm", "ma", "mk", "de", "msg", "exec", "ld", "pdf", "med", "bd", "df", "dh"], "passwordHashStage1": ["passwordHashStage5", "passwordHashPage0", "passwordhashStage2", "passwordHashSHA1", "passwordhashstage0", "passwordHashstage2", "passwordHashstage01", "passwordHashPage2", "passwordHashStageOne", "passwordHashstageOne", "passwordHashStage01", "passwordHashPage5", "passwordHashPhase0", "passwordhashstageOne", "passwordhashStageOne", "passwordHashStage0", "passwordhashStage1", "passwordHashPhase1", "passwordHashstage0", "passwordhashStage0", "passwordHashPage1", "passwordHashstage5", "passwordHashSHA0", "passwordHashstage1", "passwordHashSHA2", "passwordHashSHA01", "passwordHashPhase2", "passwordhashstage1", "passwordhashstage2", "passwordHashPhaseOne"], "passwordHashStage2": ["passwordHashstage4", "passwordSaltStage3", "passwordHashStyle3", "passwordHashStageTwo", "passwordHashStyle62", "passwordHashstage2", "passwordHashStyleTwo", "passwordSaltStageTwo", "passwordHashStyle2", "passwordHashStage4", "passwordHashPhase4", "passwordHashVersion4", "passwordHashVersion1", "passwordHashScene2", "passwordHashVersion2", "passwordSaltStage2", "passwordHashPhase1", "passwordHashScene3", "passwordSaltStage62", "passwordHashStage62", "passwordHashScene62", "passwordHashVersionTwo", "passwordHashstage1", "passwordHashstageTwo", "passwordHashPhaseTwo", "passwordHashPhase2", "passwordHashSceneTwo", "passwordHashStage3"], "toBeXord": ["toBexorg", "toBeXords", "toBeTxord", "toBeTxorg", "toBEXor", "toBexor", "toBeTxords", "toBeZXor", "tobeYord", "toBeXLor", "toBeZXold", "toBeXor", "toBeXLord", "tobeYords", "toBexord", "tobeYold", "toBEXords", "toBeZor", "toBEXord", "toBexond", "toBeYod", "toBeZords", "toBeYor", "tobeXorg", "toBeXold", "toBEXod", "toBeYold", "toBeZXord", "toBeZord", "toBeXLod", "toBeXLords", "toBeXod", "toBeYord", "toBexords", "toBeXond", "toBeTxond", "tobeYor", "toBeYorg", "toBeYords", "toBeZorg", "toBEXond", "tobeYorg", "tobeXold", "tobeXord", "toBeZXords", "tobeXords", "toBeXorg", "tobeXor", "toBEXorg"], "numToXor": ["num2Restor", "numtoXors", "numToZors", "num2Xors", "numToXore", "numToZore", "numToXors", "numtoXor", "numToXOR", "numToRestore", "num2XOR", "numToxOR", "numToYOR", "numtoXord", "numToRestors", "numToYors", "numtoYord", "numToxord", "numtoYor", "num2Restore", "num2Restors", "numToYord", "numToRestor", "numToRestOR", "numtoXOR", "numToxor", "numtoYOR", "numToZord", "num2Xore", "numToxore", "numToZor", "numtoYors", "num2RestOR", "numToYor", "num2Xor", "numToXord", "numToZOR", "numToxors"], "i": ["mi", "span", "fi", "u", "j", "ms", "us", "y", "ini", "I", "ie", "qi", "di", "z", "im", "ri", "ei", "m", "sequence", "set", "t", "x", "init", "ti", "in", "k", "bi", "cli", "ic", "multi", "ci", "ai", "sim", "gi", "ui", "e", "uri", "pi", "it", "phi", "ji", "ni", "li", "xi", "\u0438", "si", "s", "batch", "ind", "g", "ip", "o", "info", "n", "io", "ii", "is", "zi", "ix", "ex"]}}
{"id1": "12389873", "id2": "19378010", "code1": "    private void load() throws SQLException {\n        Connection conn = null;\n        Statement stmt = null;\n        try {\n            conn = FidoDataSource.getConnection();\n            conn.setAutoCommit(false);\n            stmt = conn.createStatement();\n            ClearData.clearTables(stmt);\n            stmt.executeUpdate(\"insert into Objects (ObjectId, Description) values (100, 'Living Thing')\");\n            stmt.executeUpdate(\"insert into Objects (ObjectId, Description) values (200, 'Inanimate Object')\");\n            stmt.executeUpdate(\"insert into Objects (ObjectId, Description) values (300, 'Dog')\");\n            stmt.executeUpdate(\"insert into Objects (ObjectId, Description) values (400, 'Sheltie')\");\n            stmt.executeUpdate(\"insert into Objects (ObjectId, Description) values (500, 'Eskimo')\");\n            stmt.executeUpdate(\"insert into Objects (ObjectId, Description) values (600, 'Person')\");\n            stmt.executeUpdate(\"insert into Objects (ObjectId, Description) values (700, 'Collar')\");\n            stmt.executeUpdate(\"insert into Objects (ObjectId, Description) values (800, 'Ball')\");\n            stmt.executeUpdate(\"insert into Objects (ObjectId, Description) values (401, 'Fido')\");\n            stmt.executeUpdate(\"insert into Objects (ObjectId, Description) values (501, 'Samantha')\");\n            stmt.executeUpdate(\"insert into Objects (ObjectId, Description) values (801, 'A collar')\");\n            stmt.executeQuery(\"select setval('objects_objectid_seq', 1000)\");\n            stmt.executeUpdate(\"insert into ClassLinkTypes (LinkName, LinkType) values ('hasa', 2)\");\n            stmt.executeUpdate(\"insert into ClassLinkTypes (LinkName, LinkType) values ('partof', 2)\");\n            stmt.executeUpdate(\"insert into ObjectLinks (ObjectId, LinkName, LinkToObject) values (100, 'isa', 1)\");\n            stmt.executeUpdate(\"insert into ObjectLinks (ObjectId, LinkName, LinkToObject) values (200, 'isa', 1)\");\n            stmt.executeUpdate(\"insert into ObjectLinks (ObjectId, LinkName, LinkToObject) values (300, 'isa', 100)\");\n            stmt.executeUpdate(\"insert into ObjectLinks (ObjectId, LinkName, LinkToObject) values (400, 'isa', 300)\");\n            stmt.executeUpdate(\"insert into ObjectLinks (ObjectId, LinkName, LinkToObject) values (500, 'isa', 300)\");\n            stmt.executeUpdate(\"insert into ObjectLinks (ObjectId, LinkName, LinkToObject) values (600, 'isa', 100)\");\n            stmt.executeUpdate(\"insert into ObjectLinks (ObjectId, LinkName, LinkToObject) values (700, 'isa', 200)\");\n            stmt.executeUpdate(\"insert into ObjectLinks (ObjectId, LinkName, LinkToObject) values (800, 'isa', 200)\");\n            stmt.executeUpdate(\"insert into ObjectLinks (ObjectId, LinkName, LinkToObject) values (401, 'instance', 400)\");\n            stmt.executeUpdate(\"insert into ObjectLinks (ObjectId, LinkName, LinkToObject) values (501, 'instance', 500)\");\n            stmt.executeUpdate(\"insert into ObjectLinks (ObjectId, LinkName, LinkToObject) values (801, 'instance', 800)\");\n            stmt.executeUpdate(\"insert into ObjectLinks (ObjectId, LinkName, LinkToObject) values (401, 'hasa', 801)\");\n            stmt.executeUpdate(\"insert into AttributeCategories (CategoryName) values ('color')\");\n            stmt.executeUpdate(\"insert into AttributeCategories (CategoryName) values ('weight')\");\n            stmt.executeUpdate(\"insert into AttributeCategories (CategoryName) values ('length')\");\n            stmt.executeUpdate(\"insert into Attributes (AttributeName, Category) values ('green', 'color')\");\n            stmt.executeUpdate(\"insert into Attributes (AttributeName, Category) values ('blue', 'color')\");\n            stmt.executeUpdate(\"insert into Attributes (AttributeName, Category) values ('light', 'weight')\");\n            stmt.executeUpdate(\"insert into Attributes (AttributeName, Category) values ('heavy', 'weight')\");\n            stmt.executeUpdate(\"insert into Attributes (AttributeName, Category) values ('short', 'length')\");\n            stmt.executeUpdate(\"insert into Attributes (AttributeName, Category) values ('long', 'length')\");\n            stmt.executeUpdate(\"insert into ObjectAttributes (ObjectId, AttributeName) values (401, 'light')\");\n            stmt.executeUpdate(\"insert into ObjectAttributes (ObjectId, AttributeName) values (401, 'short')\");\n            stmt.executeUpdate(\"insert into ObjectAttributes (ObjectId, AttributeName) values (801, 'blue')\");\n            stmt.executeUpdate(\"insert into Dictionary (Word, SenseNumber, GrammarString, ObjectId) values ('LEFT-WALL', '1', 'AV+ | NP+', 1)\");\n            stmt.executeUpdate(\"insert into Dictionary (Word, SenseNumber, GrammarString, ObjectId) values ('the', '1', 'D+', 1)\");\n            stmt.executeUpdate(\"insert into Dictionary (Word, SenseNumber, GrammarString, ObjectId) values ('big', '1', 'ADJ+', 400)\");\n            stmt.executeUpdate(\"insert into Dictionary (Word, SenseNumber, GrammarString, ObjectId) values ('dog', '1', '[@ADJ-] & [D-] & (S+ | DO- | PO- | NP-)', 700)\");\n            stmt.executeUpdate(\"insert into Dictionary (Word, SenseNumber, GrammarString, ObjectId) values ('run', '1', '[S-] & AV- & [PREP+]', 800)\");\n            stmt.executeUpdate(\"insert into Dictionary (Word, SenseNumber, GrammarString, ObjectId) values ('across', '1', 'PREP- & PO+', 800)\");\n            stmt.executeUpdate(\"insert into Dictionary (Word, SenseNumber, GrammarString, ObjectId) values ('street', '1', '[@ADJ-] & [D-] & (S+ | DO- | PO- | NP-)', 800)\");\n            stmt.executeUpdate(\"insert into AdjectivePrepositions (PrepositionName, ObjectId, LinkName) values ('with', 100, 'hasa')\");\n            stmt.executeUpdate(\"insert into AdjectivePrepositions (PrepositionName, ObjectId, LinkName) values ('in', 200, 'partof')\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'superlative', 1, 'good', 'best', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'superlative', 2, '*y', '*iest', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'superlative', 3, '*e', '*est', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'superlative', 4, '*', '*est', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'comparative', 1, 'good', 'better', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'comparative', 2, '*y', '*ier', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'comparative', 3, '*e', '*er', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'comparative', 4, '*', '*er', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'possessive', 1, '*s', '*s\\\\'', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'possessive', 2, '*', '*\\\\'s', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'present perfect', 1, 'be', 'being', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'present perfect', 2, '*Vy', '*Vying', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'present perfect', 3, '*c', '*cking', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'present perfect', 4, '*VVC', '*VVCing', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'present perfect', 5, '*VC', '*VCCing', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'present perfect', 6, '*ie', '*ying', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'present perfect', 7, '*e', '*ing', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'present perfect', 8, '*', '*ing', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past', 1, 'sing', 'sang', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past', 2, 'give', 'gave', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past', 3, 'swim', 'swam', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past', 4, 'have', 'had', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past', 5, 'run', 'ran', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past', 6, 'do', 'did', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past', 7, 'be', 'was', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past', 8, 'throw', 'threw', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past', 9, 'sleep', 'slept', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past', 10, '*c', '*cked', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past', 11, '*VVC', '*VVCed', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past', 12, '*VC', '*VCCed', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past', 13, '*y', '*ied', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past', 14, '*oe', '*oed', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past', 15, '*e', '*ed', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past', 16, '*', '*ed', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past perfect', 1, 'sing', 'sung', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past perfect', 2, 'give', 'given', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past perfect', 3, 'swim', 'swum', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past perfect', 4, 'have', 'had', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past perfect', 5, 'do', 'done', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past perfect', 6, 'be', 'been', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past perfect', 7, 'sleep', 'slept', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past perfect', 8, '*e', '*ed', FALSE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past perfect', 9, '*', '*ed', FALSE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'first singular', 1, 'be', 'am', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'first singular', 2, 'have', 'have', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'first singular', 3, '*', '*', FALSE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'second singular', 1, 'be', 'are', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'second singular', 2, 'have', 'have', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'second singular', 3, '*', '*', FALSE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'third singular', 1, 'be', 'is', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'third singular', 2, 'have', 'has', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'third singular', 3, 'do', 'do', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'third singular', 4, '*ch', '*ches', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'third singular', 5, '*sh', '*shes', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'third singular', 6, '*x', '*xes', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'third singular', 7, '*z', '*zes', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'third singular', 8, '*Cy', '*Cies', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'third singular', 9, '*s', '*ses', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'third singular', 10, '*o', '*oes', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'third singular', 11, '*', '*s', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'first plural', 1, 'be', 'are', FALSE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'first plural', 2, 'have', 'have', FALSE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'first plural', 3, '*', '*', FALSE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'third plural', 1, 'be', 'are', FALSE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'third plural', 2, 'have', 'have', FALSE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'third plural', 3, '*', '*', FALSE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 1, 'leaf', 'leaves', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 2, 'knife', 'knives', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 3, 'elf', 'elves', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 4, 'half', 'halves', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 5, 'loaf', 'loaves', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 6, 'shelf', 'shelves', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 7, 'wife', 'wives', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 8, 'person', 'people', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 9, 'deer', 'deer', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 10, 'child', 'children', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 11, '*Co', '*Coes', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 12, '*s', '*ses', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 13, '*ch', '*ches', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 14, '*sh', '*shes', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 15, '*x', '*xes', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 16, '*z', '*zes', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 17, '*Cy', '*Cies', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 18, '*', '*s', TRUE)\");\n            stmt.executeUpdate(\"insert into WordClassifications (Rank, Pattern, GrammarString, ObjectId, Description) values (1, '$N[.N]', 'D+', 100, 'money')\");\n            stmt.executeUpdate(\"insert into WordClassifications (Rank, Pattern, GrammarString, ObjectId, Description) values (2, 'N/N/N', 'D+', 200, 'date')\");\n            stmt.executeUpdate(\"insert into WordClassifications (Rank, Pattern, GrammarString, ObjectId, Description) values (3, '[/](C/)C', 'D+', 300, 'unix path')\");\n            stmt.executeUpdate(\"insert into WordClassifications (Rank, Pattern, GrammarString, ObjectId, Description) values (4, '[A:](C\\\\\\\\)C', 'D+', 400, 'dos path')\");\n            stmt.executeUpdate(\"insert into WordClassifications (Rank, Pattern, GrammarString, ObjectId, Description) values (5, 'N:N', 'D+', 500, 'time')\");\n            stmt.executeUpdate(\"insert into WordClassifications (Rank, Pattern, GrammarString, ObjectId, Description) values (6, 'N.N.N.N', 'D+', 600, 'internet')\");\n            stmt.executeUpdate(\"insert into WordClassifications (Rank, Pattern, GrammarString, ObjectId, Description) values (7, 'E(.E)', 'D+', 700, 'hostname')\");\n            stmt.executeUpdate(\"insert into WordClassifications (Rank, Pattern, GrammarString, ObjectId, Description) values (8, '{+-}N[.N]', 'D+', 800, 'number')\");\n            stmt.executeUpdate(\"insert into Pronouns (Pronoun, Person, Gender, Plural) values ('i', 1, 3, FALSE)\");\n            stmt.executeUpdate(\"insert into Pronouns (Pronoun, Person, Gender, Plural) values ('we', 1, 3, TRUE)\");\n            stmt.executeUpdate(\"insert into Pronouns (Pronoun, Person, Gender, Plural) values ('they', 3, 3, TRUE)\");\n            stmt.executeUpdate(\"insert into Pronouns (Pronoun, Person, Gender, Plural) values ('he', 3, 1, FALSE)\");\n            stmt.executeUpdate(\"insert into Pronouns (Pronoun, Person, Gender, Plural) values ('she', 3, 2, FALSE)\");\n            stmt.executeUpdate(\"insert into Pronouns (Pronoun, Person, Gender, Plural) values ('it', 3, 3, FALSE)\");\n            stmt.executeUpdate(\"insert into Pronouns (Pronoun, Person, Gender, Plural) values ('you', 2, 3, FALSE)\");\n            stmt.executeUpdate(\"insert into FrameSlots (SlotName) values ('actor')\");\n            stmt.executeUpdate(\"insert into FrameSlots (SlotName) values ('origin')\");\n            stmt.executeUpdate(\"insert into FrameSlots (SlotName) values ('destination')\");\n            stmt.executeUpdate(\"insert into FrameSlots (SlotName) values ('object')\");\n            stmt.executeUpdate(\"insert into FrameSlots (SlotName) values ('instrument')\");\n            stmt.executeUpdate(\"insert into FrameSlots (SlotName) values ('beneficiary')\");\n            stmt.executeUpdate(\"insert into FrameSlots (SlotName) values ('location')\");\n            stmt.executeUpdate(\"insert into Verbs (VerbName, SubjectSlot, IndirectObjectSlot, PredicateNounSlot) values ('throw', 'actor', 'destination', 'object')\");\n            stmt.executeUpdate(\"insert into Verbs (VerbName, SubjectSlot, IndirectObjectSlot, PredicateNounSlot) values ('melt', 'actor', '', '')\");\n            stmt.executeUpdate(\"insert into Verbs (VerbName, SubjectSlot, IndirectObjectSlot, PredicateNounSlot) values ('kill', 'actor', '', 'object')\");\n            stmt.executeUpdate(\"insert into AdverbPrepositions (PrepositionName, ObjectId, FrameSlot) values ('with', 200, 'instrument')\");\n            stmt.executeUpdate(\"insert into AdverbPrepositions (PrepositionName, ObjectId, FrameSlot) values ('at', 1, 'location')\");\n            stmt.executeUpdate(\"insert into Articles (ArticleName, Dereference) values ('the', 1)\");\n            stmt.executeUpdate(\"insert into Articles (ArticleName, Dereference) values ('a', 2)\");\n            stmt.executeUpdate(\"insert into Articles (ArticleName, Dereference) values ('an', 2)\");\n            stmt.executeUpdate(\"insert into GrammarLinks (LinkName, LinkType) values ('S', 1)\");\n            stmt.executeUpdate(\"insert into GrammarLinks (LinkName, LinkType) values ('PN', 2)\");\n            stmt.executeUpdate(\"insert into GrammarLinks (LinkName, LinkType) values ('DO', 3)\");\n            stmt.executeUpdate(\"insert into GrammarLinks (LinkName, LinkType) values ('IO', 4)\");\n            stmt.executeUpdate(\"insert into GrammarLinks (LinkName, LinkType) values ('PO', 5)\");\n            stmt.executeUpdate(\"insert into GrammarLinks (LinkName, LinkType) values ('NP', 6)\");\n            stmt.executeUpdate(\"insert into GrammarLinks (LinkName, LinkType) values ('AV', 7)\");\n            stmt.executeUpdate(\"insert into GrammarLinks (LinkName, LinkType) values ('LV', 8)\");\n            stmt.executeUpdate(\"insert into GrammarLinks (LinkName, LinkType) values ('PREP', 9)\");\n            stmt.executeUpdate(\"insert into GrammarLinks (LinkName, LinkType) values ('D', 10)\");\n            stmt.executeUpdate(\"insert into GrammarLinks (LinkName, LinkType) values ('ADJ', 11)\");\n            stmt.executeUpdate(\"insert into GrammarLinks (LinkName, LinkType) values ('ADV', 12)\");\n            stmt.executeUpdate(\"insert into GrammarLinks (LinkName, LinkType) values ('CONJ', 13)\");\n            stmt.executeUpdate(\"insert into GrammarLinks (LinkName, LinkType) values ('INTJ', 14)\");\n            stmt.executeUpdate(\"insert into GrammarLinks (LinkName, LinkType) values ('PA', 15)\");\n            stmt.executeUpdate(\"insert into GrammarLinks (LinkName, LinkType) values ('HV', 16)\");\n            stmt.executeQuery(\"select setval('instructions_instructionid_seq', 1)\");\n            int next = 2;\n            stmt.executeUpdate(\"insert into Instructions (Type, ExecuteString, FrameSlot, Operator, LinkName, ObjectId, AttributeName) \" + \"values (3, 'throw', null, 0, null, null, null)\");\n            stmt.executeUpdate(\"insert into Instructions (Type, ExecuteString, FrameSlot, Operator, LinkName, ObjectId, AttributeName) \" + \"values (3, 'test', null, 0, null, null, null)\");\n            stmt.executeUpdate(\"insert into Instructions (Type, ExecuteString, FrameSlot, Operator, LinkName, ObjectId, AttributeName) \" + \"values (2, null, 'actor', 1, 'hasa', '300', '')\");\n            stmt.executeUpdate(\"insert into Instructions (Type, ExecuteString, FrameSlot, Operator, LinkName, ObjectId, AttributeName) \" + \"values (2, null, 'instrument', 3, null, null, 'blue')\");\n            stmt.executeUpdate(\"insert into Instructions (Type, ExecuteString, FrameSlot, Operator, LinkName, ObjectId, AttributeName) \" + \"values (1, null, null, 0, null, null, null)\");\n            stmt.executeUpdate(\"insert into Instructions (Type, ExecuteString, FrameSlot, Operator, LinkName, ObjectId, AttributeName) \" + \"values (3, 'get', null, 0, null, null, null)\");\n            stmt.executeUpdate(\"insert into Instructions (Type, ExecuteString, FrameSlot, Operator, LinkName, ObjectId, AttributeName) \" + \"values (3, 'drop', null, 0, null, null, null)\");\n            stmt.executeUpdate(\"insert into InstructionGroups (InstructionId, Rank, GroupInstruction) values (\" + (next + 2) + \", 1, \" + (next + 0) + \")\");\n            stmt.executeUpdate(\"insert into InstructionGroups (InstructionId, Rank, GroupInstruction) values (\" + (next + 2) + \", 2, \" + (next + 1) + \")\");\n            stmt.executeUpdate(\"insert into InstructionGroups (InstructionId, Rank, GroupInstruction) values (\" + (next + 3) + \", 1, \" + (next + 1) + \")\");\n            stmt.executeUpdate(\"insert into InstructionGroups (InstructionId, Rank, GroupInstruction) values (\" + (next + 3) + \", 2, \" + (next + 0) + \")\");\n            stmt.executeUpdate(\"insert into InstructionGroups (InstructionId, Rank, GroupInstruction) values (\" + (next + 4) + \", 1, \" + (next + 2) + \")\");\n            stmt.executeUpdate(\"insert into InstructionGroups (InstructionId, Rank, GroupInstruction) values (\" + (next + 4) + \", 2, \" + (next + 3) + \")\");\n            stmt.executeQuery(\"select setval('transactions_transactionid_seq', 1)\");\n            stmt.executeUpdate(\"insert into Transactions (InstructionId, Description) values (\" + (next + 4) + \", 'throw something')\");\n            stmt.executeUpdate(\"insert into Transactions (InstructionId, Description) values (\" + (next + 5) + \", 'get something')\");\n            stmt.executeUpdate(\"insert into Transactions (InstructionId, Description) values (\" + (next + 6) + \", 'drop something')\");\n            stmt.executeUpdate(\"insert into TransactionPreconditions (TransactionId, IfFrameSlot, Operator, LinkName, LinkFrameSlot, AttributeName, SatisfyTransactionId) \" + \"values (2, 'actor', 1, 'hasa', 'object', '', 3)\");\n            stmt.executeUpdate(\"insert into TransactionPreconditions (TransactionId, IfFrameSlot, Operator, LinkName, LinkFrameSlot, AttributeName, SatisfyTransactionId) \" + \"values (2, 'object', 4, '', '', 'heavy', 4)\");\n            stmt.executeUpdate(\"insert into TransactionSlots (TransactionId, FrameSlot, InstructionId) values (2, 'object', \" + (next + 6) + \")\");\n            stmt.executeUpdate(\"insert into TransactionSlots (TransactionId, FrameSlot, InstructionId) values (2, 'destination', \" + (next + 5) + \")\");\n            stmt.executeQuery(\"select setval('verbtransactions_verbid_seq', 1)\");\n            stmt.executeUpdate(\"insert into VerbTransactions (VerbString, MoodType, TransactionId) values ('throw', 2, 2)\");\n            stmt.executeUpdate(\"insert into VerbConstraints (VerbId, FrameSlot, ObjectId) values (2, 'object', 200)\");\n            stmt.executeUpdate(\"update SystemProperties set value = 'Play Data' where name = 'DB Data Version'\");\n            conn.commit();\n        } catch (SQLException e) {\n            if (conn != null) conn.rollback();\n            throw e;\n        } finally {\n            if (stmt != null) stmt.close();\n            if (conn != null) conn.close();\n        }\n    }\n", "code2": "    public static Multimap<String, String> getProteins(final Set<String> queries, final int taxon) throws ParserConfigurationException, XPathExpressionException {\n        final DocumentBuilder parser = DocumentBuilderFactory.newInstance().newDocumentBuilder();\n        final XPathExpression xpe = XPathFactory.newInstance().newXPath().compile(__xpath);\n        final Multimap<String, String> proteins = HashMultimap.create();\n        for (final String query : queries) {\n            HttpURLConnection connection = null;\n            try {\n                final String encoded = URLEncoder.encode(query.trim(), \"UTF-8\");\n                final URL url = new URL(String.format(__urlTempl2, encoded, taxon));\n                connection = (HttpURLConnection) url.openConnection();\n                connection.setConnectTimeout(__connTimeout);\n                connection.setReadTimeout(__readTimeout);\n                connection.setRequestProperty(\"Connection\", \"close\");\n                connection.connect();\n                final InputStream stream = connection.getInputStream();\n                final Document doc = parser.parse(stream);\n                final NodeList nodes = (NodeList) xpe.evaluate(doc, XPathConstants.NODESET);\n                if (nodes != null) {\n                    final int n = nodes.getLength();\n                    for (int i = 0; i < n; i++) {\n                        final Node node = nodes.item(i);\n                        proteins.put(node.getTextContent().trim(), query.trim());\n                    }\n                }\n            } catch (final Exception ex) {\n                continue;\n            } finally {\n                if (connection != null) connection.disconnect();\n            }\n        }\n        return proteins;\n    }\n", "label": 0, "substitutes": {"load": [" validate", " dump", " fetch", " parse", " build", " find", "insert", " read", " startup", " fill", " Init", " scan", " recover", "execute", " reload", "init", " refresh", " destroy", " cleanup", " ingest", " construct", " test", "construct", " search", " register", "save", " ping"], "conn": ["wr", "co", "en", "nt", "ctx", "con", "pas", "comm", "cn", "cb", "mt", "enc", "obj", "yn", "ln", "client", "gate", "dn", "conv", "col", "ann", "ns", "connection", "die", "c", "open", "pg", "cert", "cur", "ctr", "db", "close", "rel", "org", "conf", "com", "ct", "cp", "act", "Conn", "pt", "coll", "Connection", "ds", "pen", "ch", "ens", "cmd", "cfg", "connect", "mn", "nc", "mc", "n", "Con", "cc"], "stmt": ["STgt", " stgr", "ostmem", "estmt", " sttr", "stMT", " superstmt", "histtry", "constmt", "strmt", "restmg", "Sttry", " stmm", "restpt", "putmp", "putolt", "styMT", "istmt", "strmn", "stymg", "staddr", "stackpt", "puttx", " superstm", "stmb", "stcmd", "ostpt", "stackolt", " stmem", "histgt", "estmm", "constm", "stymt", "stymb", "Stmt", "ostgr", " stolt", "Stmsg", "constst", "styaddr", "stgr", " staddr", "histmt", "stm", "stytx", "constMT", "istMT", "esttx", "ostolt", "putmm", "stackMT", " superstmg", "restMT", "ststat", "Stst", " Sttr", "estgr", "stym", "stst", " stmb", "restmm", "restgt", "stackmm", "histcmd", "estmb", "STMT", " superststat", "restaddr", "stacktab", "stgt", "stpt", " sttry", "putmt", " stmn", "istgt", "ostmm", " Stm", "stmg", "Stgr", "stolt", "Stmem", "stmid", "ostmid", "Stm", "restmt", " Stmt", "Stcmd", "stopmt", "stmm", "ostmt", "stygt", "restmp", "restgr", " sttx", "STmb", "strmg", " stmsg", "estgt", "stmp", "resttx", "strm", "stymsg", "ostrm", " stm", " superstmn", " stcmd", "stymem", " stpt", " stmid", "stopmn", "stmsg", "stmem", " strm", "Stgt", "estm", "stackmid", " stst", "osttab", "ostmn", "ostgt", "stoprm", " stmp", "stackmt", " stgt", "sttx", "putMT", "estmg", "sttab", " superstMT", "puttab", "StMT", "STtx", " ststat", "strstat", "stopmm", "stackgt", " supersttr", "sttry", " StMT", "STmsg", " stmg", "sttr", "Stmm", " stMT", "Stmb", "stmn", "STmt"]}}
{"id1": "13233761", "id2": "17773263", "code1": "    public void executeUpdateTransaction(List queries) throws SQLException {\n        assert connection != null;\n        boolean autoCommit = connection.getAutoCommit();\n        connection.setAutoCommit(false);\n        try {\n            Iterator iterator = queries.iterator();\n            while (iterator.hasNext()) {\n                String query = (String) iterator.next();\n                Statement statement = connection.createStatement();\n                statement.executeUpdate(query);\n            }\n            connection.commit();\n            connection.setAutoCommit(autoCommit);\n        } catch (SQLException e) {\n            connection.rollback();\n            throw new SQLException(e.getMessage());\n        }\n    }\n", "code2": "    public boolean visar() throws SQLException, ClassNotFoundException, Exception {\n        Connection conn = null;\n        PreparedStatement ps = null;\n        Date fechaSystem = new Date();\n        DateFormat aaaammdd = new SimpleDateFormat(\"yyyyMMdd\");\n        DateFormat hhmmss = new SimpleDateFormat(\"HHmmss\");\n        DateFormat sss = new SimpleDateFormat(\"S\");\n        String ss = sss.format(fechaSystem);\n        if (ss.length() > 2) {\n            ss = ss.substring(0, 2);\n        }\n        boolean visado = false;\n        try {\n            conn = ToolsBD.getConn();\n            conn.setAutoCommit(false);\n            String sentenciaSql = \"UPDATE BZMODIF SET FZJCUSVI=?, FZJFVISA=?, FZJHVISA=?\" + ((hayVisadoExtracto) ? \", FZJIEXTR=?\" : \"\") + ((hayVisadoRemitente) ? \", FZJIREMI=?\" : \"\") + \" WHERE FZJCENSA='S' AND FZJCAGCO=? AND FZJNUMEN=? AND FZJANOEN=? AND FZJFMODI=? AND FZJHMODI=?\";\n            ps = conn.prepareStatement(sentenciaSql);\n            ps.setString(1, usuarioVisado);\n            ps.setInt(2, Integer.parseInt(aaaammdd.format(fechaSystem)));\n            ps.setInt(3, Integer.parseInt(hhmmss.format(fechaSystem) + ss));\n            int contador = 4;\n            if (hayVisadoExtracto) {\n                ps.setString(contador++, \"X\");\n            }\n            if (hayVisadoRemitente) {\n                ps.setString(contador++, \"X\");\n            }\n            ps.setInt(contador++, oficina);\n            ps.setInt(contador++, numeroRegistro);\n            ps.setInt(contador++, anoSalida);\n            ps.setString(contador++, fechaModificacion);\n            ps.setString(contador++, horaModificacion);\n            int registrosAfectados = ps.executeUpdate();\n            if (registrosAfectados > 0 && !hayVisadoExtracto && !hayVisadoRemitente) {\n                visado = true;\n            }\n            if (registrosAfectados > 0 && (hayVisadoExtracto || hayVisadoRemitente)) {\n                boolean generado = generarBZVISAD(conn, Integer.parseInt(aaaammdd.format(fechaSystem)), Integer.parseInt(hhmmss.format(fechaSystem) + ss));\n                if (generado) {\n                    visado = actualizarBZSALIDA(conn);\n                }\n                String rem = \"\";\n                String com = \"\";\n                if (hayVisadoRemitente) {\n                    if (!remitente.trim().equals(\"\")) {\n                        rem = remitente;\n                    } else {\n                        javax.naming.InitialContext contexto = new javax.naming.InitialContext();\n                        Object ref = contexto.lookup(\"es.caib.regweb.ValoresHome\");\n                        ValoresHome home = (ValoresHome) javax.rmi.PortableRemoteObject.narrow(ref, ValoresHome.class);\n                        Valores valor = home.create();\n                        rem = valor.recuperaRemitenteCastellano(entidad1, entidad2 + \"\");\n                        valor.remove();\n                    }\n                } else {\n                    if (!altres.trim().equals(\"\")) {\n                        rem = remitente;\n                    } else {\n                        javax.naming.InitialContext contexto = new javax.naming.InitialContext();\n                        Object ref = contexto.lookup(\"es.caib.regweb.ValoresHome\");\n                        ValoresHome home = (ValoresHome) javax.rmi.PortableRemoteObject.narrow(ref, ValoresHome.class);\n                        Valores valor = home.create();\n                        rem = valor.recuperaRemitenteCastellano(entidad1Old, entidad2Old + \"\");\n                        valor.remove();\n                    }\n                }\n                if (hayVisadoExtracto) {\n                    com = extracto;\n                } else {\n                    com = comentario;\n                }\n                try {\n                    Class t = Class.forName(\"es.caib.regweb.module.PluginHook\");\n                    Class[] partypes = { String.class, Integer.class, Integer.class, Integer.class, Integer.class, String.class, String.class, String.class, Integer.class, Integer.class, String.class, Integer.class, String.class };\n                    Object[] params = { \"V\", new Integer(anoSalida), new Integer(numeroRegistro), new Integer(oficina), new Integer(fechaDocumento), rem, com, tipoDocumento, new Integer(fechaRegistro), new Integer(fzacagge), fora, new Integer(destinatario), idioma };\n                    java.lang.reflect.Method metodo = t.getMethod(\"salida\", partypes);\n                    metodo.invoke(null, params);\n                } catch (IllegalAccessException iae) {\n                } catch (IllegalArgumentException iae) {\n                } catch (InvocationTargetException ite) {\n                } catch (NullPointerException npe) {\n                } catch (ExceptionInInitializerError eiie) {\n                } catch (NoSuchMethodException nsme) {\n                } catch (SecurityException se) {\n                } catch (LinkageError le) {\n                } catch (ClassNotFoundException le) {\n                }\n            }\n            conn.commit();\n            int fzahsis = Integer.parseInt(hhmmss.format(fechaSystem) + ss);\n            String Stringsss = sss.format(fechaSystem);\n            switch(Stringsss.length()) {\n                case (1):\n                    Stringsss = \"00\" + Stringsss;\n                    break;\n                case (2):\n                    Stringsss = \"0\" + Stringsss;\n                    break;\n            }\n            int horamili = Integer.parseInt(hhmmss.format(fechaSystem) + Stringsss);\n            int fzafsis = Integer.parseInt(aaaammdd.format(fechaSystem));\n            logLopdBZMODIF(\"UPDATE\", sessioEjb.getCallerPrincipal().getName().toUpperCase(), fzafsis, horamili, 'S', numeroRegistro, anoSalida, oficina, Integer.parseInt(fechaModificacion), Integer.parseInt(horaModificacion));\n        } catch (Exception e) {\n            System.out.println(\"Error: \" + e.getMessage());\n            e.printStackTrace();\n            visado = false;\n            try {\n                if (conn != null) conn.rollback(); else System.out.println(\"ERROR: No es pot fer rollback sense connexi\u00f3!\");\n            } catch (Exception ex) {\n                System.out.println(\"Error: \" + e.getMessage());\n                ex.printStackTrace();\n            }\n        } finally {\n            ToolsBD.closeConn(conn, ps, null);\n        }\n        return visado;\n    }\n", "label": 1, "substitutes": {"executeUpdateTransaction": ["executeUpdateTask", "executeWriteTask", "startQueryStatement", "executeQueryTransaction", "startQueryTransaction", "startUpdateTransaction", "executeInsertStatement", "startUpdateStatement", "executeWriteStatement", "executeUpdateStatement", "executeQueryTx", "startUpdateTask", "startQueryTask", "executeInsertTransaction", "executeWriteTx", "startUpdateTx", "startQueryTx", "executeInsertTx", "executeUpdateTx", "executeQueryStatement", "executeQueryTask", "executeInsertTask", "executeWriteTransaction"], "queries": ["quenges", "galleries", "queues", "Quarks", " Quues", "qualeries", "qualenges", "gallands", "aqueries", "aquands", "qualands", " Queries", "quands", "quues", "aquenges", "gallenges", "qualiries", "aquiries", " Quarks", "queands", "Quands", "queeries", "quarks", "quiries", " Quands", "galliries", "Quues", "quearks", "Queries"], "autoCommit": ["AutoCommits", "autoCommcommit", "autoAbsate", "autoCompate", "automaticCommit", "AutoCommit", "autoCommmit", "autoCompcommit", "autoAbsist", "autoAbscommit", "automaticCommist", "autoCommport", "autoAmport", "autoCompit", "automaticCompit", "AutoClmit", "autoAbsit", "AutoCommport", "autoCommist", "autoCommate", "autoAmits", "AutoCommmit", "autoAmmit", "autoClits", "autoClport", "autoDebist", "autoAmit", "autoBeits", "autoCommits", "autoClit", "autoClmit", "autoDebate", "autoDebit", "AutoClits", "AutoClit", "automaticCompate", "autoBemit", "automaticCommate", "autoCompist", "autoBeit", "autoDebcommit", "AutoClport", "automaticCommcommit", "automaticCompcommit", "autoBeport", "automaticCompist"], "iterator": ["runner", "series", "video", "interstitial", "creator", "vector", "ski", "sample", "rows", "next", "storage", "internet", "reader", "seconds", "giving", "sequence", "processor", "river", "set", "stream", "page", "finder", "trace", "inner", "menu", "directory", "issues", "starter", "integer", "current", "Iterator", "immigrant", "list", "number", "information", "udder", "started", "ator", "liner", "writer", "operator", "outer", "iter", "former", "walker", "encer", "upper", "members", "pler", "gener", "taker", "continue", "pour", "instance", "bis", "collection", "ner", "pee", "values", "size", "folder", "oser", "rounder", "zero", "loop", "loader", "ter", "pie"], "query": ["series", "lock", "subject", "test", "task", "comment", "request", "execute", "description", "resource", "sequence", "quest", "table", "script", "sq", "menu", "q", "command", "code", "message", "join", "result", "family", "escape", "Query", "name", "condition", "sql", "parse", "term", "question", "qu", "key", "string", "row", "quote", "password", "version", "check", "update", "prefix", "title"], "statement": ["phrase", "rule", "block", "task", "comment", "mt", "resource", "execute", "word", "description", "sequence", "set", "status", "table", "fire", "connection", "template", "ment", "command", "message", "call", "system", "minute", "state", "condition", "expression", "sql", "parse", "continue", "binary", "confirmed", "batch", "group", "line", "Statement", "slot", "quote", "usage", "shell", "print", "session"]}}
{"id1": "21642215", "id2": "9267602", "code1": "    private int addIDs(PeakListRow row, String name) {\n        {\n            BufferedReader in = null;\n            try {\n                String urlName = \"http://gmd.mpimp-golm.mpg.de/search.aspx?query=\" + name;\n                URL url = new URL(urlName);\n                in = new BufferedReader(new InputStreamReader(url.openStream()));\n                String inputLine, score = \"0\";\n                while ((inputLine = in.readLine()) != null) {\n                    String metaboliteID = \"\";\n                    if (inputLine.contains(\"href=\\\"Metabolites/\")) {\n                        String[] dataScore = inputLine.split(\"</td><td>\");\n                        score = dataScore[0].substring(dataScore[0].indexOf(\"<td>\") + 4);\n                        metaboliteID = inputLine.substring(inputLine.indexOf(\"href=\\\"Metabolites/\") + 18, inputLine.indexOf(\"aspx\\\">\") + 4);\n                        urlName = \"http://gmd.mpimp-golm.mpg.de/Metabolites/\" + metaboliteID;\n                        inputLine = in.readLine();\n                        inputLine = in.readLine();\n                        String[] data = inputLine.split(\"</td><td>\");\n                        String molecularWeight = data[data.length - 1].replaceAll(\"&nbsp;\", \"\");\n                        row.setVar(GCGCColumnName.MOLWEIGHT.getSetFunctionName(), molecularWeight);\n                        break;\n                    } else if (inputLine.contains(\"href=\\\"Analytes/\")) {\n                        String[] dataScore = inputLine.split(\"</td><td>\");\n                        score = dataScore[0].substring(dataScore[0].indexOf(\"<td>\") + 4);\n                        metaboliteID = inputLine.substring(inputLine.indexOf(\"href=\\\"Analytes/\") + 15, inputLine.indexOf(\"aspx\\\">\") + 4);\n                        urlName = \"http://gmd.mpimp-golm.mpg.de/Analytes/\" + metaboliteID;\n                        inputLine = in.readLine();\n                        inputLine = in.readLine();\n                        String[] data = inputLine.split(\"</td><td>\");\n                        String molecularWeight = data[data.length - 1].replaceAll(\"&nbsp;\", \"\");\n                        row.setVar(GCGCColumnName.MOLWEIGHT.getSetFunctionName(), molecularWeight);\n                        break;\n                    } else if (inputLine.contains(\"href=\\\"ReferenceSubstances/\")) {\n                        String[] dataScore = inputLine.split(\"</td><td>\");\n                        score = dataScore[0].substring(dataScore[0].indexOf(\"<td>\") + 4);\n                        metaboliteID = inputLine.substring(inputLine.indexOf(\"href=\\\"ReferenceSubstances/\") + 26, inputLine.indexOf(\"aspx\\\">\") + 4);\n                        urlName = \"http://gmd.mpimp-golm.mpg.de/ReferenceSubstances/\" + metaboliteID;\n                        inputLine = in.readLine();\n                        inputLine = in.readLine();\n                        String[] data = inputLine.split(\"</td><td>\");\n                        String molecularWeight = data[data.length - 1].replaceAll(\"&nbsp;\", \"\");\n                        row.setVar(GCGCColumnName.MOLWEIGHT.getSetFunctionName(), molecularWeight);\n                        break;\n                    }\n                }\n                in.close();\n                urlName = searchMetabolite(urlName);\n                if (urlName != null && urlName.contains(\".aspx\")) {\n                    url = new URL(urlName);\n                    in = new BufferedReader(new InputStreamReader(url.openStream()));\n                    while ((inputLine = in.readLine()) != null) {\n                        if (inputLine.contains(\"<meta http-equiv=\\\"keywords\\\" content=\")) {\n                            String line = inputLine.substring(inputLine.indexOf(\"<meta http-equiv=\\\"keywords\\\" content=\") + 37, inputLine.indexOf(\"\\\" /></head>\"));\n                            String[] names = line.split(\", \");\n                            for (String id : names) {\n                                if (id.contains(\"PubChem\")) {\n                                    id = id.substring(id.indexOf(\"PubChem\") + 8);\n                                    String pubChem = (String) row.getVar(GCGCColumnName.PUBCHEM.getGetFunctionName());\n                                    if (pubChem.length() == 0) {\n                                        pubChem += id;\n                                    } else {\n                                        pubChem += \", \" + id;\n                                    }\n                                    row.setVar(GCGCColumnName.PUBCHEM.getSetFunctionName(), pubChem);\n                                } else if (id.contains(\"ChEBI\")) {\n                                    id = id.substring(id.indexOf(\"ChEBI:\") + 6);\n                                    row.setVar(GCGCColumnName.ChEBI.getSetFunctionName(), id);\n                                } else if (id.contains(\"KEGG\")) {\n                                    id = id.substring(id.indexOf(\"KEGG:\") + 6);\n                                    row.setVar(GCGCColumnName.KEGG.getSetFunctionName(), id);\n                                } else if (id.contains(\"CAS\")) {\n                                    id = id.substring(id.indexOf(\"CAS:\") + 5);\n                                    row.setVar(GCGCColumnName.CAS2.getSetFunctionName(), id);\n                                } else if (id.contains(\"ChemSpider\") || id.contains(\"MAPMAN\") || id.contains(\"Beilstein:\")) {\n                                } else {\n                                    String synonym = (String) row.getVar(GCGCColumnName.SYNONYM.getGetFunctionName());\n                                    if (synonym.length() == 0) {\n                                        synonym += id;\n                                    } else {\n                                        synonym += \" // \" + id;\n                                    }\n                                    synonym = synonym.replaceAll(\"&amp;#39;\", \"'\");\n                                    row.setVar(GCGCColumnName.SYNONYM.getSetFunctionName(), synonym);\n                                }\n                            }\n                            break;\n                        }\n                    }\n                    in.close();\n                }\n                return Integer.parseInt(score);\n            } catch (IOException ex) {\n                Logger.getLogger(GetGolmIDsTask.class.getName()).log(Level.SEVERE, null, ex);\n                return 0;\n            }\n        }\n    }\n", "code2": "    public static void main(String[] args) throws IOException {\n        String urltext = \"http://www.vogella.de\";\n        URL url = new URL(urltext);\n        BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream()));\n        String inputLine;\n        while ((inputLine = in.readLine()) != null) {\n            System.out.println(inputLine);\n        }\n        in.close();\n    }\n", "label": 1, "substitutes": {"addIDs": ["setIDs", "setIDS", "setNames", " addNames", "addID", " addIDS", "processNames", "processIDs", "processID", "addIDS", "addNames", "setID", "processIDS", " addID"], "row": ["report", "ows", "tr", "pair", "block", "roll", "item", "entry", "rows", "ow", "raw", "ro", "table", "col", "box", "rank", "buffer", "result", "cell", "post", "list", "node", "skip", "error", "rown", "out", "ry", "Row", "group", "record", "instance", "batch", "r", "channel", "star", "job", "week", "user", "board", "ack"], "name": ["type", "address", "value", "text", "image", "item", "named", "word", "description", "a", "create", "template", "label", "filename", "format", "NAME", "query", "search", "path", "question", "ame", "key", "n", "string", "file", "password", "source", "version", "Name", "prefix", "title"], "in": ["scan", "rin", "en", "win", "inn", "ini", "gin", "con", "IN", "vin", "ins", "pin", "reader", "m", "on", "ln", "al", "In", "t", "inner", "init", "log", "ic", "db", "re", "xml", "conf", "i", "up", "bin", "copy", "serv", "get", "inc", "l", "out", "input", "it", " IN", "sql", "form", "conn", "ain", "again", "at", "s", "nin", "r", "ssl", "el", "mc", "local", "n", "din", "inf", "er", "is", "isin", "source", "file", "il", "cin", "check", "update", "ex"], "urlName": ["UrlNames", " urlNAME", "implNames", "logName", "lNAME", " urlPath", "logname", "logKey", "implNAME", "lname", "urlNAME", "UrlNAME", "lNames", "implName", "urlKey", " urlname", "Urlname", "urlname", "logNAME", " urlNames", "UrlName", "urlNames", "implPath", "lName", "lPath", "lKey", "implname", "UrlKey", "urlPath"], "url": ["browser", "gl", "ref", " URL", "con", "resource", "reader", "client", "ls", "web", "ll", "t", "base", "char", "link", "sl", "open", "b", "result", "rel", "ur", "mount", "uri", "URL", "str", "rl", "l", "nl", "ul", "r", "ssl", "el", "channel", "ret", "http", "file", "il", "Url", "loader", "cl"], "inputLine": ["keyline", "InputRow", " InputLINE", " inputRow", "commandLine", "inputLINE", "inputNet", "dataFile", "inputLink", "tempLINE", "inputLin", "InputLine", "inputNode", "inputRow", "inputPage", "listEntry", "statusline", " Inputline", "intBlock", " inputline", "submitDe", "viewRow", "InputLINE", "inL", "commandBlock", "keyL", "patternLine", "sourcePage", "operationLINE", " InputLine", "inputL", " inputNet", " inputLink", "singleLine", "inputFrame", "cacheLINE", "inRecord", "formLINE", "listLine", "formFrame", "operationLine", " inputEntry", "tableLink", "keyLine", "helloLine", "dataLINE", "inputBlock", "formLine", "inputPort", "cacheNode", " inputRecord", "viewLINE", "InputBlock", "dataBlock", "helloEntry", "InputL", "intLINE", "sourceLINE", "singleDe", "inputFile", " inputNode", "inputDe", " inputPage", "commandLINE", "firstLINE", "intline", "latLine", "singleBlock", "viewLine", "tableLine", "singleLINE", "latRecord", "templine", "keyLINE", "inputRecord", "contextLINE", "listPort", " inputPort", " InputLin", "inputEntry", "operationNet", "submitLine", "submitLINE", "cacheLine", "inline", "intLin", "dataFrame", "inLINE", "patternRow", "dataNet", "helloLINE", "tableLINE", "firstBlock", "dataLine", "latline", "tablePort", "dataLink", " inputDe", "inLine", "tempLine", "formBlock", "sourceLine", "intLine", "contextRow", " inputFile", "submitBlock", "latLINE", " inputLINE", "inputline", "InputFile", " inputFrame", " inputBlock", "Inputline", "dataline", "statusLINE", " inputLin", "statusLine", "patternLINE", "listLINE", "sourceNode", "cachePage", "firstLine", "contextLine", "patternline", "helloPort", "dataPort", "statusFile"], "score": ["report", "style", "scan", "value", "match", "test", "Score", "draw", "goal", "distance", "depth", "sum", "set", "status", "level", "rank", "average", "price", "strength", "err", "confidence", "message", "loss", "result", " scores", "scroll", "error", "success", "grade", "sc", "rate", "search", "length", "scoring", "weight", "count", "core", "scale", "source", "index", "check", " Score", "display"], "metaboliteID": ["metaboliteIN", "metabolitateid", "metabiliteid", "metmboliteIN", "metabolicITEID", "metabiliteName", "metabolitableID", "metabolitationInfo", "metabolitateInfo", "metabolisticID", "metabolitableHandle", "metabolitateId", "metabolitionName", "metaboliceID", "metaboliterName", "metabiliterID", "metabolicitationId", "metaboliterId", "metmbolitationIN", "metabolitesName", "metmboliteId", "metaboliciteType", "metaboliteType", "metabolitableUID", "metabolicitationInfo", "metmboliteID", "metabolitionid", "metabolicitationID", "metabolitionID", "metabolteUID", "metaboliteInfo", "metabolteID", "metabolicITEName", "metabolITEId", "metaboliteid", "metaboliceInfo", "metabolteHandle", "metabolitableId", "metaboliciteid", "metabolitesid", "metabolicITEType", "metaboliciteName", "metaboliciteID", "metaboliceid", "metaboliterIN", "metaboliciteInfo", "metaboliterid", "metabolisticIN", "metabiliterName", "metabolitationId", "metaboliceId", "metabolitateID", "metabolteId", "metaboliteName", "metaboliteUID", "metabiliterid", "metaboliterHandle", "metabiliterUID", "metaboliterType", "metabiliteUID", "metaboliterUID", "metabolITEName", "metabolicITEId", "metabolITEID", "metaboliciteId", "metabolisticId", "metmbolitationID", "metabiliterHandle", "metabolitationid", "metabolitationIN", "metabiliterId", "metabolitationName", "metabolITEType", "metaboliterID", "metaboliteHandle", "metabolicitationid", "metmbolitationId", "metabiliteID", "metaboliteId", "metabiliteId", "metabolitationID", "metabiliteHandle", "metabolitationType", "metabolitesID"], "dataScore": ["dataSpeed", "tdScore", "errorScore", "arrayScore", "arraySpeed", "blockSpeed", "errorSize", "dataTest", "DataRank", " dataRank", " dataTest", "divSc", "relationScore", "datascore", "ataSc", " datascore", "ataSize", " dataStyle", "tdAge", "blockStyle", "DATATest", "DataSize", "ataTransfer", "dataSc", " dataSize", " dataWeight", "divRank", "deviceTransfer", "relationWeight", "dataRank", " dataSpeed", "DATAScore", "dataAge", "deviceSc", "dataWeight", " dataAge", "dataSize", "DATASc", "dataTransfer", "divSize", "tdSc", "parentSc", "relationSize", "arrayAge", "DataScore", "arrayStyle", "relationscore", "parentScore", "blockScore", " dataTransfer", "divScore", "blockSc", "dataStyle", " dataSc", "DataSc", "ataScore", "deviceSize", "parentRank", "errorscore", "DATARank", "arraySc", "parentTest", "errorWeight", "deviceScore"], "data": ["extra", "series", "all", "window", "video", "json", "step", "image", "DATA", "value", "text", "params", "draw", "users", "keys", "details", "description", "ata", "lines", "raw", "set", "table", "ns", "base", "chain", "buffer", "available", "missing", "words", "array", "supported", "none", "cache", "content", "td", "hash", "bytes", "valid", "hex", "mu", "space", "dat", "batch", "info", "html", "string", "multiple", "values", "size", "zero", "rew", "map", "results"], "molecularWeight": ["molecularweight", "moleularWater", "molecularWater", "mlecularScore", "mlecularWeight", "moleudoWater", "moleculeWeight", "molecularData", "molecularFont", "moleularScore", "moleculeData", "mleularScore", "mleularWater", "moleculeweight", "moleculeFont", "moleularWeight", "moleuralWater", "moleuralWeight", "mlecularWater", "molellularweight", "mleularData", "moleularData", "moleularweight", "molecularScore", "moleudoWeight", "mleularweight", "mleularWeight", "molellularWeight", "mlecularweight", "moleularFont", "molellularData", "moleuralScore", "moleudoScore", "mlecularData", "mleularFont", "molellularFont", "mlecularFont"]}}
{"id1": "16825994", "id2": "19096138", "code1": "    public int run(String[] args) throws Exception {\n        if (args.length < 2) {\n            System.err.println(\"Download dir local\");\n            return 1;\n        }\n        OutputStream out = new FileOutputStream(args[1]);\n        Path srcDir = new Path(args[0]);\n        Configuration conf = new Configuration();\n        FileSystem srcFS = FileSystem.get(conf);\n        if (!srcFS.getFileStatus(srcDir).isDirectory()) {\n            System.err.println(args[0] + \" is not a directory.\");\n            return 1;\n        }\n        try {\n            FileStatus contents[] = srcFS.listStatus(srcDir);\n            for (int i = 0; i < contents.length; i++) {\n                if (contents[i].isFile()) {\n                    System.err.println(contents[i].getPath());\n                    InputStream in = srcFS.open(contents[i].getPath());\n                    try {\n                        IOUtils.copyBytes(in, out, conf, false);\n                    } finally {\n                        in.close();\n                    }\n                }\n            }\n        } finally {\n            out.close();\n        }\n        return 0;\n    }\n", "code2": "    public static void main(String[] args) {\n        String logFileName = args[0];\n        int extractLineEvery = new Integer(args[1]).intValue();\n        String filterToken = \"P0\";\n        if (args.length > 2) {\n            filterToken = args[2];\n        }\n        try {\n            BufferedReader br = new BufferedReader(new FileReader(logFileName));\n            BufferedWriter bw = new BufferedWriter(new FileWriter(new File(logFileName + \".trim\")));\n            String readLine;\n            int x = 0;\n            while ((readLine = br.readLine()) != null) {\n                if ((x++ % extractLineEvery == 0) && readLine.startsWith(filterToken)) {\n                    bw.write(readLine + \"\\n\");\n                }\n            }\n            bw.flush();\n            bw.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n", "label": 1, "substitutes": {"run": ["runner", "spawn", "process", "su", "con", "test", "execute", "runs", "work", "exe", "thin", "call", "sun", "un", "name", "after", "cmd", "running", " Run", "Run", "exec", "fn", "version", "unit", "check"], "out": ["all", "con", "output", "res", "cb", "obj", "client", "sys", "sum", "t", "net", "we", "log", "b", "to", "err", "write", "end", "result", "up", "v", "cache", " Out", "writer", "os", " OUT", "outer", "OU", "ch", "gt", "conn", "null", "ou", "outs", "aos", "o", "r", "auto", "n", "io", "Out", "file", "OUT", "print", "ex", "w"], "srcDir": ["srcdir", "socDir", "sceneDIR", "sceneDir", "sourcePath", "srcD", "socdir", "rcDIR", "socDiv", "srcPath", "distDir", "distD", "sceneD", "sourceDir", "socPath", "sbD", "sourcedir", "srcDIR", "rcDir", " srcDiv", "distDIR", "rcD", "sbDir", "sourceDiv", "rcdir", "sbdir", "srcDiv", "sourceD", " srcPath", " srcdir"], "conf": ["f", "ref", "ctx", "con", "default", "func", "cb", "cn", "cr", "share", "obj", "fs", "lang", "conv", "context", "ca", "c", "log", " Conf", "err", "Config", "com", "cache", "def", "state", "cm", "const", "ch", "auth", "Conf", "sch", "conn", "cfg", "etc", "inv", "local", "info", "config", "cf", "job", "pool", "gb", "map", "acc", "Con", "cc"], "srcFS": ["sourceFS", "rcfs", "reqFs", " srcLS", " srcCS", " srcfs", "reqFS", "srcKS", "sysOS", "rcFs", "srcfs", "sourceCS", "sysKS", "sourceLS", "srcCS", "newTS", "sysFS", "srcFs", "srcOS", "rcFS", "sysfs", " srcOS", "sysTS", " srcKS", " srcFs", "reqfs", "rcOS", "sourcefs", "newFS", "reqCS", "sourceTS", "srcTS", "sysFs", "newFs", "newKS", "srcLS", "sysLS", "sourceFs", " srcTS"], "contents": ["CONTens", "condENTS", "stENT", "consent", "constacts", "CONTains", "condents", "consENT", "stent", " contens", "Contacts", "CONTent", "constensions", "contensions", "consents", "condent", "Contensions", "contens", "constent", "continent", "Contens", "contenses", "contains", "continENTS", "continents", "constents", "ContENTS", "content", "contENT", "CONTENTS", "CONTacts", "stents", "Content", "CONTents", "CONTensions", "stENTS", "Contents", "contENTS", " contenses", "condains", "condENT", " content", "continains", "condensions", "Contenses", "consENTS", "contacts", "CONTenses"], "i": ["mi", "u", "ini", "j", "ski", "y", "I", "qi", "di", "im", "ri", "ei", "m", "ki", "ami", "ti", "base", "hi", "me", "x", "q", "iu", "bi", "cli", "ic", "cgi", "multi", "ci", "ai", "sim", "gi", "ui", "v", "uri", "pi", "ij", "ix", "it", "ji", "li", "xi", "\u0438", "ori", "si", "my", "batch", "ind", "g", "o", "ma", "key", "remote", "ii", "is", "oi", "index", "id", "phi"], "in": ["ze", "mi", "rin", "en", "inn", "ini", "gin", "con", "min", "IN", "ins", "m", "on", "oin", "In", "inner", "inside", "one", "re", "up", "read", "bin", "pi", "inc", "l", "input", "sin", "it", " din", "ind", "r", "ma", "mm", "io", "din", "is", "isin", "file", "source", "body", "cin", "from"]}}
{"id1": "12236729", "id2": "2668634", "code1": "        private void copy(File inputFile, File outputFile) throws Exception {\n            FileReader in = new FileReader(inputFile);\n            FileWriter out = new FileWriter(outputFile);\n            int c;\n            while ((c = in.read()) != -1) out.write(c);\n            in.close();\n            out.close();\n        }\n", "code2": "    public WebmillDeploy(String inputName, String outputName, boolean stripLoggers) throws Exception {\n        File tempFile = null;\n        JarFile jin = null;\n        JarOutputStream jout = null;\n        FileChannel srcChannel = null;\n        FileChannel dstChannel = null;\n        try {\n            String portletApplicationName = getPortletApplicationName(outputName);\n            System.out.println(\"portletApplicationName = \" + portletApplicationName);\n            tempFile = File.createTempFile(\"webmill-delpoy-\", \"\");\n            tempFile.deleteOnExit();\n            jin = new JarFile(inputName);\n            jout = new JarOutputStream(new FileOutputStream(tempFile));\n            Document webXml = null;\n            Document portletXml = null;\n            Document contextXml = null;\n            ZipEntry src;\n            InputStream source;\n            Enumeration zipEntries = jin.entries();\n            while (zipEntries.hasMoreElements()) {\n                src = (ZipEntry) zipEntries.nextElement();\n                source = jin.getInputStream(src);\n                try {\n                    String target = src.getName();\n                    if (WEB_INF_WEB_XML.equals(target)) {\n                        System.out.println(\"Found web.xml\");\n                        webXml = parseXml(source);\n                    } else if (WEB_INF_PORTLET_XML.equals(target)) {\n                        System.out.println(\"Found WEB-INF/portlet.xml\");\n                        portletXml = parseXml(source);\n                    } else if (META_INF_CONTEXT_XML.equals(target)) {\n                        System.out.println(\"Found META-INF/context.xml\");\n                        contextXml = parseXml(source);\n                    }\n                } finally {\n                    source.close();\n                }\n            }\n            if (webXml == null) {\n                throw new IllegalArgumentException(\"WEB-INF/web.xml not found\");\n            }\n            if (portletXml == null) {\n                throw new IllegalArgumentException(\"WEB-INF/portlet.xml not found\");\n            }\n            WebmillWebApplicationRewriter webRewriter = new WebmillWebApplicationRewriter(webXml);\n            webRewriter.processWebXML();\n            WebmillContextRewriter contextRewriter = new WebmillContextRewriter(contextXml, portletApplicationName);\n            contextRewriter.processContextXML();\n            jin = new JarFile(inputName);\n            zipEntries = jin.entries();\n            while (zipEntries.hasMoreElements()) {\n                src = (ZipEntry) zipEntries.nextElement();\n                source = jin.getInputStream(src);\n                try {\n                    String target = src.getName();\n                    String fullTarget = '/' + target;\n                    if (stripLoggers && target.endsWith(\".jar\") && (target.startsWith(\"WEB-INF/lib/commons-logging\") || target.startsWith(\"WEB-INF/lib/log4j\"))) {\n                        System.out.println(\"Skip logger \" + target);\n                        continue;\n                    } else {\n                        if (webRewriter.getRealPortletTldFile() != null && fullTarget.equals(webRewriter.getRealPortletTldFile())) {\n                            System.out.println(\"Skip portlet tld file \" + fullTarget);\n                            continue;\n                        } else if (target.equals(WEB_INF_WEB_XML)) {\n                            System.out.println(\"Skip web.xml file \" + target);\n                            continue;\n                        } else if (target.equals(WEB_INF_PORTLET_XML)) {\n                            System.out.println(\"Skip portlet.xml file \" + target);\n                            continue;\n                        } else if (target.equals(META_INF_CONTEXT_XML)) {\n                            System.out.println(\"Skip context.xml file \" + target);\n                            continue;\n                        }\n                        System.out.println(\"Add file \" + target);\n                    }\n                    addFile(target, source, jout);\n                } finally {\n                    source.close();\n                }\n            }\n            addFile(WEB_INF_WEB_XML, webXml, jout);\n            addFile(WEB_INF_PORTLET_XML, portletXml, jout);\n            addFile(META_INF_CONTEXT_XML, contextXml, jout);\n            System.out.println(\"Attempting to add portlet.tld to war...\");\n            InputStream is = this.getClass().getResourceAsStream(\"/org/riverock/webmill/container/tags/portlet.tld\");\n            if (is == null) {\n                System.out.println(\"Failed to find portlet.tld in classpath\");\n            } else {\n                String portletTldFile = webRewriter.getRealPortletTldFile();\n                if (portletTldFile.charAt(0) == '/') {\n                    portletTldFile = portletTldFile.substring(1);\n                }\n                System.out.println(\"Adding file \" + portletTldFile);\n                try {\n                    addFile(portletTldFile, is, jout);\n                } finally {\n                    is.close();\n                }\n            }\n            jout.close();\n            jin.close();\n            jin = null;\n            jout = null;\n            System.out.println(\"Creating war \" + outputName + \" ...\");\n            System.out.flush();\n            srcChannel = new FileInputStream(tempFile).getChannel();\n            dstChannel = new FileOutputStream(outputName).getChannel();\n            dstChannel.transferFrom(srcChannel, 0, srcChannel.size());\n            srcChannel.close();\n            srcChannel = null;\n            dstChannel.close();\n            dstChannel = null;\n            tempFile.delete();\n            tempFile = null;\n            System.out.println(\"War \" + outputName + \" created\");\n            System.out.flush();\n        } finally {\n            if (srcChannel != null && srcChannel.isOpen()) {\n                try {\n                    srcChannel.close();\n                } catch (IOException e1) {\n                }\n            }\n            if (dstChannel != null && dstChannel.isOpen()) {\n                try {\n                    dstChannel.close();\n                } catch (IOException e1) {\n                }\n            }\n            if (jin != null) {\n                try {\n                    jin.close();\n                    jin = null;\n                } catch (IOException e1) {\n                }\n            }\n            if (jout != null) {\n                try {\n                    jout.close();\n                    jout = null;\n                } catch (IOException e1) {\n                }\n            }\n            if (tempFile != null && tempFile.exists()) {\n                tempFile.delete();\n            }\n        }\n    }\n", "label": 1, "substitutes": {"copy": [" replicate", " combine", " operate", " recover", " merge", " transfer", " Copy", "transfer", "Copy", " restore", " seek", " upload", "cp", "read", " copying", " move", "paste", " append", " join", " parallel", " duplicate", " paste", " delete", " clone", " dup", " download", " cp", " cat"], "inputFile": [" inputfile", "outputDir", "outputPath", "configPost", "argumentfile", "inputPost", "argumentPath", "inile", "inputDir", " inputPost", " inputile", "inPath", "argumentFile", " inputPath", " inputDir", "inFile", "configfile", "configPath", "inputfile", "argumentPost", "outputile", "configFile", "inputPath", "inputile", "inDir"], "outputFile": ["outputDir", "outputPath", "outputPlace", " outputFilename", "outputfile", "outFile", "targetFile", "inputDir", "outputFilename", "writeFilename", "outfile", "targetDir", "writeDir", "outFilename", "targetfile", "targetPath", "writeFile", " outputPlace", "writePlace", "inputfile", "outPath", "inputPath", " outputDir", "outPlace", "outDir"], "in": ["ze", "all", "rin", "en", "inn", "ini", "min", "gin", "con", "IN", "ins", "ri", "reader", "on", "al", "In", "init", "inner", "inside", "old", "ic", "ai", "up", "i", "read", "bin", "inc", "input", "sin", "iter", "it", "per", " din", "ir", "ind", "info", "din", "inf", "is", "isin", "cin", "from"], "out": ["co", "en", "nt", "flush", "by", "con", "output", "res", "cos", "cn", "obj", "on", "client", "sys", "dis", "one", "net", "write", "print", "to", "end", "log", "ot", "v", "cache", "writer", "os", "outer", "it", "null", "ou", "at", "outs", "aos", "o", "g", "auto", "n", "io", "Out", "user", "check", "OUT", "can", "ne", "ex"], "c": ["f", "rc", "u", "z", "con", "cos", "character", "cb", "d", "cont", "cr", "C", "bc", "t", "x", "ce", "char", "code", "k", "cc", "chain", "cu", "current", "v", "i", "conf", "cp", "ct", "ac", "gc", "pc", "cache", "cm", "l", "ec", "cod", "ch", "lc", "cd", "unc", "r", "nc", "count", "n", "uc", "arc", "mc", "cap", "cf", "cs", "cl"]}}
{"id1": "23672408", "id2": "23452437", "code1": "    private void copyIconFiles(UmlClass clazz) {\n        if (clazz.hasAnnotation(\"icon16\")) {\n            String i16 = clazz.annotationValue(\"icon16\");\n            String fileType = \".png\";\n            if (i16.endsWith(\".jpg\")) fileType = \".jpg\";\n            if (i16.endsWith(\".gif\")) fileType = \".gif\";\n            String desti16 = output_dir + \"/../resources/images/\" + clazz.getName() + \"16\" + fileType;\n            try {\n                FileChannel src = new FileInputStream(i16).getChannel();\n                FileChannel dst = new FileOutputStream(desti16).getChannel();\n                dst.transferFrom(src, 0, src.size());\n                src.close();\n                dst.close();\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        }\n        if (clazz.hasAnnotation(\"icon32\")) {\n            String i32 = clazz.annotationValue(\"icon32\");\n            String fileType = \".png\";\n            if (i32.endsWith(\".jpg\")) fileType = \".jpg\";\n            if (i32.endsWith(\".gif\")) fileType = \".gif\";\n            String desti32 = output_dir + \"/../resources/images/\" + clazz.getName() + \"32\" + fileType;\n            try {\n                FileChannel src = new FileInputStream(i32).getChannel();\n                FileChannel dst = new FileOutputStream(desti32).getChannel();\n                dst.transferFrom(src, 0, src.size());\n                src.close();\n                dst.close();\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        }\n    }\n", "code2": "        private void internalCopy(File fSource, File file) throws FileNotFoundException, IOException {\n            if (fSource.getName().equals(\"Thums.db\")) return;\n            System.out.println(\"copying \" + fSource + \" in \" + file);\n            OutputStream o = new BufferedOutputStream(new FileOutputStream(file));\n            InputStream i = new BufferedInputStream(new FileInputStream(fSource));\n            byte[] b = new byte[8192];\n            int n;\n            while ((n = i.read(b)) > 0) o.write(b, 0, n);\n            i.close();\n            o.close();\n        }\n", "label": 1, "substitutes": {"copyIconFiles": ["copyIndexfiles", "copyiconImages", " copyiconImages", "copyiconDocuments", " copyiconfiles", "copyiconfiles", " copyIconDocuments", "copyIconImages", " copyiconFiles", " copyiconDocuments", "copyIconfiles", "copyIndexFiles", " copyIconImages", "copyIndexDocuments", "copyIconDocuments", "copyiconFiles", " copyIconfiles", "copyIndexImages"], "clazz": ["classuddy", "sclace", "pkgasse", "classazz", "Claz", "escace", "closer", "plasse", "Clace", "crus", "callazz", "pkgaz", "Close", " classe", "cluddy", "clojure", "sclazz", " clbean", "clbo", "plashed", "chojure", "callace", "descazz", "escazz", "clotted", "scloser", " clbo", "CLoser", "clab", "CLace", "colluddy", "crazz", " plub", "chotted", " closer", "classe", " plus", "clbean", " claz", "chazz", "relose", " cluddy", "chace", " clace", "relaz", "Clazz", "claz", " club", "relazz", "CLazz", "crub", "clace", "relab", " clus", "cluster", "Clbo", "club", "Clab", "pkgazz", "clashed", "classotted", "clus", "collazz", "pkgashed", "CLbean", "descab", " cluster", " plazz", "callbo", "callaz", "sclbean", " clojure", "close", "craz", "descose", "descaz", "escotted", " clashed", "colluster", "escojure", "classuster", " clotted", "plazz", "collotted", "plaz", " plaz"], "i16": ["ami16", " i160", "ji63", "ri16", " i216", "i63", "ri157", "iri6", "ini160", "ami6", "li19", "liShort", "i157", "pi63", "iri157", "ii160", "ii16", "ji150", "ini19", "li16", "i24", "ji16", "i19", "ami2016", "iri16", "i216", "li2016", "ami150", "ami63", "pi6", " i157", "amiShort", "ini24", "iniShort", "i160", "i2016", "ri2016", " i24", "pi150", "iri2016", "ini2016", " i6", "ii216", "i150", "ji6", "ii24", "ini216", " i2016", "pi16", "ini16", "ri6", "i6", "iShort", "ami19"], "fileType": ["fieldTyp", "formatValue", " filePattern", " fileFormat", "fieldDef", "FILEtype", "resourceUnit", "formatTime", "iletype", " fileValue", "fileFormat", "policyTyp", "ileTyp", "fileList", "issuetype", "fileUnit", "webDef", "policyType", "formType", " fileList", "FILEType", " fileTYPE", "webTYPE", "eventFormat", "coreType", "formName", "FileType", "fieldType", "formtype", "treeTYPE", "coreDef", "relationType", "relationFamily", "fileDef", "coreTYPE", "formattype", "fileTime", "viewtype", "coreTyp", "policyFamily", "fileName", "eventUnit", "issueTyp", "fieldTYPE", "formatTYPE", "fileHandler", " fileTyp", "Filetype", "filePattern", "FileName", "relationTyp", "eventList", "fileTyp", "eventType", "policyHandler", "viewValue", "FILEName", "fileValue", " fileTime", "formatType", " filetype", "viewTYPE", "viewType", "issueType", "filetype", "fileTYPE", "ilePattern", "issuePattern", "resourceType", "treeTime", "resourceFormat", "webTyp", "coreHandler", "relationHandler", "fileFamily", " fileUnit", "coreFamily", "webList", "treeType", "webType", "treetype", "eventTYPE", "resourceTYPE", "ileType"], "desti16": ["desti18", " desti18", "destii2016", "resulti16", "destgi24", "destsi32", "destgi2016", "destsi16", "destui160", "destui32", "resultii216", " destsi18", "desti160", "destsi18", "destsi160", "desti24", "desti2016", "destii16", "destii24", " desti160", "destui18", " destsi160", "destui16", "destxi16", "destui24", "resultii2016", "destii216", "resulti24", "destui216", " destsi32", " destsi16", "resulti216", "destxi32", "destxi160", "destui2016", "resulti2016", "destgi16", "destxi18", "destgi216", "desti216", "resultii24", "resultii16"], "src": ["ser", "rc", "hl", "via", "txt", "usr", "sb", "scan", "ctx", "cmp", "img", "sync", "bg", "rg", "sit", "sp", "ins", "cont", "ibl", "cb", "dest", "ln", "bh", "sys", "tmp", "ls", "bc", "inner", "urg", "sq", "rest", "addr", "sl", "pkg", "fc", "ctr", "cli", "cur", "sr", "rel", "sec", "req", "ptr", "bin", "rb", "sel", "rl", "rs", "std", "input", "proc", "comp", "iter", "sol", "nl", "sc", "gs", "isl", "rx", "st", "obs", "sn", "iv", "syn", "etc", "ssl", "desc", "vr", "sub", "rob", "source", "loc", "inst"], "dst": ["dernd", " dbl", "ddmn", "dLnet", "dmn", "dgt", "ndmt", "rdest", "rst", "dsest", " dnet", " ddr", "tnd", "dsnet", "Ddest", "derdest", "dest", "fdr", "nput", "ddest", " dput", "dsst", "ddst", "ddr", "derst", "dermn", "nnd", "ngt", "dddest", "ndest", " dmt", "rcut", "dcut", "dLdest", "fnd", "dLot", "tgt", "rdmt", "Dnd", "Ddr", " ddest", " dnd", "dput", "Dst", "dLst", "dsot", "tput", "rdsts", "dbl", "tst", "dmt", "dsts", "rbl", " dcut", " dsts", " dmn", " dest", "dot", "dLcut", "rdst", "dnet", " dot", "ndsts", "fdest", " dgt", "dLest", "ddnd", "dLbl", "ndst", "dnd", "nst", "fst"], "i32": ["ip32", "pi31", "ic31", "ii342", "ic86", "xi31", "xi32", "pi64", "isi86", " i86", "i342", "i86", "ini22", "ii32", " i34", "pi34", " i64", "pi32", "ini48", " i31", "ii34", "xi22", "ic64", "ip64", "ini31", "isi40", "ic342", "ii28", "ic40", "isi64", "ic48", " i28", "i31", "i64", "i40", "ic28", "ip34", "i22", "isi32", "ic32", " i342", "ic22", "ic34", "ip31", "xi48", "i48", "i28", "ini32", "i34", " i40"], "desti32": ["targetpi30", "desti256", "destu31", "destI32", "Desti31", "DestI31", "destI31", "destdi32", "destdi34", "destu90", "Desti256", "targetpi31", "desti34", "destI256", "DestI32", "destI90", "destu32", "destic34", "destic31", "desti31", "targetpi32", "destpi31", "Desti90", "targeti34", "destic30", "destdi31", "targeti30", "DestI256", "destpi32", "destic32", "targetpi34", "destu256", "desti30", "targeti31", "destpi34", "targeti32", "destdi30", "DestI90", "desti90", "destpi30", "Desti32"]}}
{"id1": "14188043", "id2": "3375718", "code1": "    public static byte[] openHttpResult(String urlPath, boolean retry) throws IOException {\n        AQUtility.debug(\"net\", urlPath);\n        URL url = new URL(urlPath);\n        HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n        connection.setUseCaches(false);\n        connection.setInstanceFollowRedirects(true);\n        connection.setConnectTimeout(NET_TIMEOUT);\n        int code = connection.getResponseCode();\n        if (code == 307 && retry) {\n            String redirect = connection.getHeaderField(\"Location\");\n            return openHttpResult(redirect, false);\n        }\n        if (code == -1 && retry) {\n            return openHttpResult(urlPath, false);\n        }\n        AQUtility.debug(\"response\", code);\n        if (code == -1 || code < 200 || code >= 300) {\n            throw new IOException();\n        }\n        byte[] result = AQUtility.toBytes(connection.getInputStream());\n        return result;\n    }\n", "code2": "    public void importarHistoricoDeCotacoesDoDolar(Andamento pAndamento) throws FileNotFoundException, SQLException, Exception {\n        pAndamento.delimitarIntervaloDeVariacao(0, 49);\n        WSValorSerieVO[] cotacoesPendentesDoDolar = obterCotacoesPendentesDoDolar(pAndamento);\n        pAndamento.delimitarIntervaloDeVariacao(50, 100);\n        if (cotacoesPendentesDoDolar != null && cotacoesPendentesDoDolar.length > 0) {\n            String sql = \"INSERT INTO tmp_TB_COTACAO_DOLAR(DATA, PRECO) VALUES(:DATA, :PRECO)\";\n            OraclePreparedStatement stmtDestino = (OraclePreparedStatement) conDestino.prepareStatement(sql);\n            stmtDestino.setExecuteBatch(COMANDOS_POR_LOTE);\n            int quantidadeDeRegistrosASeremImportados = cotacoesPendentesDoDolar.length;\n            try {\n                int quantidadeDeRegistrosImportados = 0;\n                int numeroDoRegistro = 0;\n                for (WSValorSerieVO cotacaoPendenteDoDolar : cotacoesPendentesDoDolar) {\n                    ++numeroDoRegistro;\n                    stmtDestino.clearParameters();\n                    int ano = cotacaoPendenteDoDolar.getAno(), mes = cotacaoPendenteDoDolar.getMes() - 1, dia = cotacaoPendenteDoDolar.getDia();\n                    Calendar calendario = Calendar.getInstance();\n                    calendario.clear();\n                    calendario.set(ano, mes, dia);\n                    java.sql.Date vDATA = new java.sql.Date(calendario.getTimeInMillis());\n                    BigDecimal vPRECO = cotacaoPendenteDoDolar.getValor();\n                    stmtDestino.setDateAtName(\"DATA\", vDATA);\n                    stmtDestino.setBigDecimalAtName(\"PRECO\", vPRECO);\n                    int contagemDasInsercoes = stmtDestino.executeUpdate();\n                    quantidadeDeRegistrosImportados++;\n                    double percentualCompleto = (double) quantidadeDeRegistrosImportados / quantidadeDeRegistrosASeremImportados * 100;\n                    pAndamento.setPercentualCompleto((int) percentualCompleto);\n                }\n                conDestino.commit();\n            } catch (Exception ex) {\n                conDestino.rollback();\n                throw ex;\n            } finally {\n                if (stmtDestino != null && (!stmtDestino.isClosed())) {\n                    stmtDestino.close();\n                }\n            }\n        }\n        pAndamento.setPercentualCompleto(100);\n    }\n", "label": 0, "substitutes": {"openHttpResult": ["openHTTPRes", "openHTTPResults", "OpenHTTPRes", "openUrlResult", "getHttpRes", "openHTTPResponse", "openUrlRes", "OpenHTTPResult", "openhttpMessage", "openHTTPResult", "getHttpResponse", "openHttpResults", "openhttpResult", "openhttpResults", "openQueryResult", "OpenHttpResults", "openhttpRes", "openHttpMessage", "OpenHTTPResults", "getHttpResult", "getHTTPRes", "OpenHttpResponse", "openQueryResponse", "openUrlResponse", "OpenHttpResult", "openUrlResults", "openHttpRes", "OpenHttpRes", "openQueryRes", "openUrlMessage", "OpenHTTPResponse", "openhttpResponse", "openQueryResults", "OpenHTTPMessage", "OpenHttpMessage", "getHTTPResult", "getHTTPResults", "getHTTPResponse", "openHTTPMessage", "openHttpResponse", "getHttpResults"], "urlPath": ["urlpath", "URLCh", "urlName", "xmlStr", "nlP", "UrlString", "urlP", " urlString", "pathStr", "urlStr", "urlFile", " urlDir", " urlFile", "urlCh", "nlFile", "UrlFile", "nlpath", "URLString", "pathPath", "URLId", "urlDir", "urlId", "Urlpath", " urlName", "UrlPath", "xmlPath", "UrlId", "dlStr", "dlFile", "dlpath", "UrlCh", "URLPath", " urlId", "pathFile", "URLDir", "xmlpath", "UrlName", "urlString", "UrlP", " urlP", "URLName", "nlPath", "UrlDir", " urlCh", "xmlFile", " urlpath", "dlPath", "pathpath"], "retry": [" retri", "twrite", "pretrier", "Retrying", "rettry", "attried", "redrier", "retric", "redry", "retri", "redwrite", "rery", "reri", "retried", "Retry", "attrying", "pretwrite", "attry", "retrier", "terry", "retwrite", " retrying", "retrain", "Retri", "terrying", "terrain", " rettry", "pretried", "tric", "redric", "retrying", "Rettry", "pretrying", "trier", "terried", "pretry", "pretrain", "pretric", "attrain", "rerying"], "url": ["dl", "service", "www", "https", "web", "ls", "ll", "base", "char", "link", "pl", "log", "sl", "open", "ur", "org", "mount", "uri", "URL", "get", "rl", "str", "l", "nl", "ul", "li", "conn", "r", "ssl", "http", "location", "job", "file", "loc", "il", "Url", "user", "loader"], "connection": ["ion", "generation", "computer", "response", "creator", "subject", "con", "connected", "entry", "character", "pointer", "operation", "city", "resource", "application", "description", "builder", "client", "create", "set", "using", "context", "directory", "link", "command", "c", "open", "to", "message", "close", "number", "uri", "condition", "position", "writer", "statement", "Connection", "l", "creation", "cone", "controller", "conn", "created", "network", "connect", "relation", "channel", "nc", "database", "http", "io", "usage", "socket", "communication", "online", "translation", "server", "session", "established"], "code": ["type", "cycle", "ode", "rc", "co", "zone", "dec", "ord", "entry", "ie", "test", "cast", "time", "cont", "se", "sequence", "currency", "create", "force", "status", "page", "level", "x", "ce", "Code", "one", "c", "go", "message", "call", "close", "mode", "xx", "number", "ct", "sec", "e", "state", "now", "coe", "name", "error", "success", "cod", "ch", "controller", "rate", "change", "component", "length", "cd", "xxx", "num", "zip", "nc", "count", "desc", "codes", "size", "zero", "coded", "check", "id", "cause", "a", "ne", "cc"], "redirect": ["Redistant", "promistant", "promirection", "reduction", "predirection", "promir", "Redirection", " reduction", "Redirect", "redistant", "regirect", " redirection", " redir", "regirection", "predistant", "promirect", "Reduction", "redir", "predirect", "regir", "predir", "reguction", "redirection", "Redir"], "result": ["report", "transform", "mask", "process", "value", "vector", "output", "match", "res", "test", "params", "comment", "feature", "request", "description", "other", "currency", "sequence", "table", "reason", "profile", "date", "command", "buffer", "cert", "message", "complete", "cup", "meg", "total", "success", "out", "proc", "true", "answer", "length", "r", "ret", "password", "memory", "root", "data", "results", "Result"]}}
{"id1": "10131427", "id2": "14598566", "code1": "    public static void copyFile(File in, File out) throws IOException {\n        FileChannel sourceChannel = new FileInputStream(in).getChannel();\n        FileChannel destinationChannel = new FileOutputStream(out).getChannel();\n        sourceChannel.transferTo(0, sourceChannel.size(), destinationChannel);\n        sourceChannel.close();\n        destinationChannel.close();\n    }\n", "code2": "    public static void copyFileByNIO(File in, File out) throws IOException {\n        FileChannel sourceChannel = new FileInputStream(in).getChannel();\n        FileChannel destinationChannel = new FileOutputStream(out).getChannel();\n        sourceChannel.transferTo(0, sourceChannel.size(), destinationChannel);\n        sourceChannel.close();\n        destinationChannel.close();\n    }\n", "label": 1, "substitutes": {"copyFile": [" cpfile", "CopyImage", " copyfile", "CopyStream", " copyStream", " cpFile", " CopyStream", " cpImage", " Copyfile", " copyImage", "CopyFile", " CopyFile", "Copyfile", " cpStream", " CopyImage"], "in": ["rin", "en", "inn", "gin", "IN", "vin", "ins", "ar", "on", "In", "old", "b", "ic", "edIn", "up", "i", "inc", "l", "input", "it", "st", "s", "ind", "o", "r", "el", "mm", "n", "din", "inf", "is", "isin", "source", "cin", "from"], "out": ["nt", "output", "oss", "w", "help", "t", "po", "log", "net", "err", "b", "to", "v", "i", "serv", "str", "os", "l", "it", "ch", "gt", "ou", "s", "outs", "o", "ex", "n", "io", "Out", "file", "OUT", "check", "ne", "ot"], "sourceChannel": ["ourceButton", "seedChannel", "matchApplication", " sourceButton", "sourceChuck", "sourceConnection", "resourcechannel", "ourceChannel", "resourceChannel", "srcchannel", "ourceConnection", "sourceApplication", "srcStream", "sourcechannel", "ourceStream", "seedApplication", "ourceChain", "sourceChain", "inputChannel", " sourceChain", " sourcechannel", "resourceConnection", "matchChuck", "inputChain", "ourceChan", "sourceButton", "SourceChannel", "matchButton", "singleApplication", "singleChannel", "srcChannel", "inputConnection", "ourcechannel", "singleChuck", "SourceConnection", "inputChan", " sourceConnection", "singleButton", " sourceStream", "seedChuck", "Sourcechannel", "SourceStream", "sourceChan", "srcButton", "sourceStream", "matchChannel", "resourceStream", " sourceChan", "seedButton"], "destinationChannel": ["desticationChan", "destinatoryBlock", "destensionChan", "destinatedContext", "destinationBlock", "DestinationContext", "destinatoryChan", "destationContext", "destroyConnection", "destationChannel", "DestensionConnection", "DestationContext", "destinationsConnection", "destinationsContext", "DestationCow", "destationBlock", "destroyClient", "destensionConnection", "destinationsChan", "destationChan", "DestensionChan", "DestinationChan", "DestinationBlock", "DestinationCow", "desticationBlock", "DestationChannel", "destinationCow", "destroyChannel", "destensionChannel", "destinationContext", "destinatedChan", "destroyChan", "DestinationChannel", "destinationChan", "destinatoryCow", "DestationConnection", "destinatedConnection", "DestensionClient", "destinatedChannel", "destinationConnection", "DestinationClient", "destationConnection", "destationCow", "DestationChan", "desticationCow", "destationClient", "DestensionChannel", "destinationClient", "DestationBlock", "destinatoryChannel", "destinationsChannel", "DestinationConnection", "destensionClient", "desticationChannel"]}}
{"id1": "10385815", "id2": "6421904", "code1": "    public static void copy(String fileFrom, String fileTo) throws IOException {\n        FileInputStream inputStream = null;\n        FileOutputStream outputStream = null;\n        FileChannel inputChannel = null;\n        FileChannel outputChannel = null;\n        try {\n            inputStream = new FileInputStream(fileFrom);\n            outputStream = new FileOutputStream(fileTo);\n            inputChannel = inputStream.getChannel();\n            outputChannel = outputStream.getChannel();\n            inputChannel.transferTo(0, inputChannel.size(), outputChannel);\n        } finally {\n            try {\n                inputChannel.close();\n            } finally {\n                try {\n                    outputChannel.close();\n                } finally {\n                    try {\n                        inputStream.close();\n                    } finally {\n                        outputStream.close();\n                    }\n                }\n            }\n        }\n    }\n", "code2": "    public DataRecord addRecord(InputStream input) throws DataStoreException {\n        File temporary = null;\n        try {\n            temporary = newTemporaryFile();\n            DataIdentifier tempId = new DataIdentifier(temporary.getName());\n            usesIdentifier(tempId);\n            long length = 0;\n            MessageDigest digest = MessageDigest.getInstance(DIGEST);\n            OutputStream output = new DigestOutputStream(new FileOutputStream(temporary), digest);\n            try {\n                length = IOUtils.copyLarge(input, output);\n            } finally {\n                output.close();\n            }\n            DataIdentifier identifier = new DataIdentifier(digest.digest());\n            File file;\n            synchronized (this) {\n                usesIdentifier(identifier);\n                file = getFile(identifier);\n                if (!file.exists()) {\n                    File parent = file.getParentFile();\n                    parent.mkdirs();\n                    if (temporary.renameTo(file)) {\n                        temporary = null;\n                    } else {\n                        throw new IOException(\"Can not rename \" + temporary.getAbsolutePath() + \" to \" + file.getAbsolutePath() + \" (media read only?)\");\n                    }\n                } else {\n                    long now = System.currentTimeMillis();\n                    if (getLastModified(file) < now + ACCESS_TIME_RESOLUTION) {\n                        setLastModified(file, now + ACCESS_TIME_RESOLUTION);\n                    }\n                }\n                if (file.length() != length) {\n                    if (!file.isFile()) {\n                        throw new IOException(\"Not a file: \" + file);\n                    }\n                    throw new IOException(DIGEST + \" collision: \" + file);\n                }\n            }\n            inUse.remove(tempId);\n            return new FileDataRecord(identifier, file);\n        } catch (NoSuchAlgorithmException e) {\n            throw new DataStoreException(DIGEST + \" not available\", e);\n        } catch (IOException e) {\n            throw new DataStoreException(\"Could not add record\", e);\n        } finally {\n            if (temporary != null) {\n                temporary.delete();\n            }\n        }\n    }\n", "label": 1, "substitutes": {"copy": ["csv", "cop", "cat", "sync", "create", "Copy", "transfer", "write", "slice", "load", "replace", "rm", "cp", "read", " copying", "upload", "paste", "opy", "Cop", "download", "save", " duplicate", "file", "clip", "clone", "delete", "move"], "fileFrom": ["inputForm", "projectA", " fileStart", "ileFrom", "sampleFrom", "inputTo", "projectStart", "ileForm", " fileA", "FileFrom", "ileObject", "FileObject", "fileForm", "FileForm", "projectInitial", "projectFrom", "ileTo", "fileA", "fileStart", " fileInitial", "sampleStart", "FileTo", "inputObject", "sampleInitial", "fileInitial", "sampleA", "fileObject", "inputFrom"], "fileTo": ["File2", "fileTarget", "fileDest", "modelDest", "file2", " fileTarget", " fileTO", " fileDest", "modelTarget", "ile2", " file2", "fileTO", "modelTO", "FileTO", "ileTo", "modelTo", "FileTo", "ileTarget", "FileDest", "ileDest", "FileTarget"], "inputStream": ["sourceSteam", "inputStreamer", "InputChannel", "audioSteam", "InputStream", " inputSource", "InputSource", "inputFile", "sourceChannel", "eventStreamer", "InputStreamer", "eventStream", " inputSteam", "inputSteam", "activeSteam", "imageStreamer", "importStream", " inputFile", "eventstream", "eventSteam", "audioStream", "InputFile", "imageStream", "sourceSource", "importSteam", "inputstream", "activeChannel", "imageSteam", "imageChannel", "imagestream", "importChannel", "audiostream", "sourceStream", "InputSteam", "audioStreamer", "inputSource", "activeStream", "importFile", "activeStreamer"], "outputStream": [" outputString", "writeChannel", "resultSteam", "inputSteam", "displayChannel", "Outputstream", "outputFile", "webChannel", "OutputStream", "webStream", "resultChannel", "resultStream", "writeSocket", "displayStream", "displaySteam", "resultSocket", "writeStream", "OutputChannel", "displaystream", "webSteam", "OutputSteam", " outputSteam", "webString", "outputSteam", "OutputFile", "outputstream", " outputSocket", "inputstream", "outputString", "outputSocket", "writeSteam", " outputFile", "webFile", "inputString"], "inputChannel": ["currentChan", "inputCamera", "InputChannel", "outputConnection", "InputStream", "readableChan", "InputConnection", "InputCamera", "createChannel", "operatorConnection", " inputCamera", " inputSteam", "inputSteam", "createStream", "createChan", "inputChain", "operatorChannel", "operatorStream", "readableChannel", "readChan", "readableConnection", "readChannel", "inputConnection", "outputSteam", " inputChain", "inputChan", "currentChain", "localConnection", " inputChan", " inputConnection", "inputCategory", "localChan", "currentChannel", " inputCategory", "InputChan", "currentCategory", "readCategory", "readChain", "localChannel", "createSteam", "operatorCamera", "outputChan"], "outputChannel": ["OutputContext", "outputConnection", "successChannel", " outputChan", "putStream", "writeChannel", "writeChan", "outputchannel", "OutputStream", " outputchannel", "Outputchannel", "writeConnection", "writeContext", "putChannel", "putChan", "successConnection", "putchannel", "OutputChan", "hiddenChannel", " outputConnection", "updatechannel", "hiddenCategory", "OutputCategory", "updateChannel", "OutputConnection", "hiddenchannel", "outputCategory", " outputContext", "hiddenChan", "updateChan", "successStream", "outputContext", "OutputChannel", "updateCategory", "successchannel", "outputChan"]}}
{"id1": "19584877", "id2": "5414088", "code1": "    public static boolean encodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.ENCODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "code2": "    public static void saveFileData(File file, File destination, java.io.File newDataFile) throws Exception {\n        String fileName = file.getFileName();\n        String assetsPath = FileFactory.getRealAssetsRootPath();\n        new java.io.File(assetsPath).mkdir();\n        java.io.File workingFile = getAssetIOFile(file);\n        DotResourceCache vc = CacheLocator.getVeloctyResourceCache();\n        vc.remove(ResourceManager.RESOURCE_TEMPLATE + workingFile.getPath());\n        if (destination != null && destination.getInode() > 0) {\n            FileInputStream is = new FileInputStream(workingFile);\n            FileChannel channelFrom = is.getChannel();\n            java.io.File newVersionFile = getAssetIOFile(destination);\n            FileChannel channelTo = new FileOutputStream(newVersionFile).getChannel();\n            channelFrom.transferTo(0, channelFrom.size(), channelTo);\n            channelTo.force(false);\n            channelTo.close();\n            channelFrom.close();\n        }\n        if (newDataFile != null) {\n            FileChannel writeCurrentChannel = new FileOutputStream(workingFile).getChannel();\n            writeCurrentChannel.truncate(0);\n            FileChannel fromChannel = new FileInputStream(newDataFile).getChannel();\n            fromChannel.transferTo(0, fromChannel.size(), writeCurrentChannel);\n            writeCurrentChannel.force(false);\n            writeCurrentChannel.close();\n            fromChannel.close();\n            if (UtilMethods.isImage(fileName)) {\n                BufferedImage img = javax.imageio.ImageIO.read(workingFile);\n                int height = img.getHeight();\n                file.setHeight(height);\n                int width = img.getWidth();\n                file.setWidth(width);\n            }\n            String folderPath = workingFile.getParentFile().getAbsolutePath();\n            Identifier identifier = IdentifierCache.getIdentifierFromIdentifierCache(file);\n            java.io.File directory = new java.io.File(folderPath);\n            java.io.File[] files = directory.listFiles((new FileFactory()).new ThumbnailsFileNamesFilter(identifier));\n            for (java.io.File iofile : files) {\n                try {\n                    iofile.delete();\n                } catch (SecurityException e) {\n                    Logger.error(FileFactory.class, \"EditFileAction._saveWorkingFileData(): \" + iofile.getName() + \" cannot be erased. Please check the file permissions.\");\n                } catch (Exception e) {\n                    Logger.error(FileFactory.class, \"EditFileAction._saveWorkingFileData(): \" + e.getMessage());\n                }\n            }\n        }\n    }\n", "label": 1, "substitutes": {"encodeFileToFile": ["encodeStringAsFile", "encodeFileToFiles", "encodeFileToDisk", "encodeFileAsFile", "encodeStringToFile", "encodeFileToStream", "encodeFileFromFiles", "encodeStringAsDisk", "encodeStringAsStream", "encodeFiletoFile", "encodeFileAsStream", "encodeStringToDisk", "encodeFileAsDisk", "encodeFiletoDisk", "encodeFiletoFiles", "encodeStringToFiles", "encodeFileFromStream", "encodeFileAsFiles", "encodeFileFromDisk", "encodeStringAsFiles", "encodeFiletoStream", "encodeFileFromFile", "encodeStringToStream"], "infile": ["inputfilename", "inputFile", "outbase", "outFile", " inFile", "inpath", " inbase", " infilename", "outfilename", "inbase", "InFile", "infilename", "inFile", "inputfile", "Inbase", "inputpath", " inpath", "Inpath", "outpath", "Infile"], "outfile": ["outfp", "newFile", "outname", "newfile", "indir", " outname", "outFile", "outdir", "fromfile", "outfilename", "inname", "newname", " outfilename", "tofp", "infilename", "todir", "inFile", "infp", "toFile", "newfilename", "fromfp", " outFile", "fromdir", "tofile", "fromFile"], "in": ["rin", "en", "image", "inn", "ini", "by", "gin", "con", "IN", "ins", "pin", "im", "ar", "on", "oin", "ro", "al", "In", "t", "inner", "inside", "init", "re", "up", "i", "bin", "get", "inc", "input", "amin", "or", "iter", "it", "per", " din", "form", "conn", "ain", "ind", "nin", "info", "din", "inf", "is", "isin", "source", "cin", "id", "from"], "out": ["ion", "co", "en", "nt", "flush", "con", "output", "res", "oss", "cn", "on", "sys", "t", "inner", "net", "write", "print", "b", "to", "end", "opt", "up", "writer", "os", "outer", "it", "OU", "gt", "null", "ou", "at", "outs", "g", "o", "aos", "ex", "n", "io", "Out", "file", "fn", "OUT", "can", "ne", "ot"], "buffer": ["phrase", "buf", "window", "bone", "block", "buff", "sample", "column", "frame", "comment", "view", "sequence", "append", "table", "pad", "library", "mem", "base", "template", "command", "attribute", "document", "message", "available", "stack", "number", "cache", "Buffer", "variable", "black", "total", "initial", "note", "history", "paste", "queue", "length", "binary", "batch", "bar", "padding", "info", "row", "display", "temp", "button", "password", "memory", "print", "header", "character"], "read": ["first", "each", "text", "find", "select", "reader", "wait", "allow", "raw", "stream", "set", "run", "before", "range", "write", "open", "push", "readable", "load", "print", "reads", "hold", "seek", "close", "i", "req", "skip", "get", " Read", "give", "input", "need", "iter", "through", "query", "len", "length", "Read", "ind", "add", "connect", "count", "n", "ready", "start", "size", "reading", "send", "check", "index", "READ", "end", "ok"], "success": ["first", "same", "good", "response", "value", " succ", "ceed", "cess", "positive", "fail", "city", "release", " successful", "summary", "please", "status", " Success", "ith", "accept", "Success", "danger", "done", "ratulations", "ccess", "growth", "warning", "primary", "result", "safe", " okay", "second", "unity", "crit", "condition", "successful", " failure", "sufficient", "error", "valid", "complete", "commit", "snap", "democracy", "continue", "photo", "surv", "successfully", "town", "submit", "support", " successes", "setup", "ok"]}}
{"id1": "22855019", "id2": "8801182", "code1": "    public static MessageService getMessageService(String fileId) {\n        MessageService ms = null;\n        if (serviceCache == null) init();\n        if (serviceCache.containsKey(fileId)) return serviceCache.get(fileId);\n        Properties p = new Properties();\n        try {\n            URL url = I18nPlugin.getFileURL(fileId);\n            p.load(url.openStream());\n            ms = new MessageService(p);\n        } catch (Exception e) {\n            ms = new MessageService();\n        }\n        serviceCache.put(fileId, ms);\n        return ms;\n    }\n", "code2": "    private static void downloadImages(String uriPrefix, String fileWithListOfImages, String outputDir) throws Exception {\n        Properties list = new Properties();\n        list.load(new FileInputStream(fileWithListOfImages));\n        long current = 0;\n        long startTime = System.currentTimeMillis();\n        System.out.println(\"Downloading files from \" + uriPrefix + \" to \" + outputDir);\n        System.out.println(\"Total \" + list.size() + \" files, think of 1 sec per file\");\n        System.out.println(\"Images with the same size as the 'no-image' image are ignored and not displayed\");\n        for (Iterator<Object> it = list.keySet().iterator(); it.hasNext(); ) {\n            String urlString = it.next().toString().replace('\\\\', '/');\n            if (urlString.contains(\"=\")) throw new Exception(\"Symbol '=' found in file names, while it is reserved for denoting '/' in flat-file names\");\n        }\n        for (Iterator<Object> it = list.keySet().iterator(); it.hasNext(); ) {\n            String urlString = it.next().toString().replace('\\\\', '/');\n            URL url = new URL(uriPrefix + urlString);\n            File file = new File(outputDir + \"/\" + imageNameToFileName(urlString));\n            current++;\n            if (!file.exists()) {\n                try {\n                    BufferedInputStream in = new BufferedInputStream(url.openStream(), 64000);\n                    BufferedOutputStream out = new BufferedOutputStream(new FileOutputStream(file), 64000);\n                    int c;\n                    while ((c = in.read()) != -1) {\n                        out.write(c);\n                    }\n                    out.close();\n                    in.close();\n                    System.out.print(current + \" /\" + list.size() + \". \" + file.getName() + \", \");\n                    System.out.println(\"saved\");\n                } catch (Exception e) {\n                    System.out.print(current + \" /\" + list.size() + \". \" + file.getName() + \", FAILED, error: \" + e.getMessage());\n                }\n            } else {\n                System.out.print(current + \" /\" + list.size() + \". \" + file.getName() + \", \");\n                System.out.println(\"already exists\");\n            }\n            if (current / 100 == current / 100.0) {\n                long delta = (System.currentTimeMillis() - startTime);\n                System.out.println(\"Total time \" + delta + \" ms, \" + (delta / current) + \" ms/file\");\n            }\n        }\n        long delta = (System.currentTimeMillis() - startTime);\n        System.out.println(\"Total time \" + delta + \" ms, \" + (delta / list.size()) + \" ms/file\");\n    }\n", "label": 0, "substitutes": {"getMessageService": ["getFileManager", "getFileInfo", "getFileService", "getMsgManager", "getMsgService", "getMediaInfo", "readMessageService", "getFileServices", "readMediaInfo", "getMessageServices", "readMediaService", "readMediaServices", "getMsgInfo", "getMediaServices", "getMediaService", "readMessageServices", "readMessageInfo", "getMessageInfo", "getMsgServices", "readMessageManager", "getMessageManager", "getMediaManager", "readMediaManager"], "fileId": ["projectOr", "serviceID", " fileIn", "FILEID", "projectID", "FILERef", "imageId", "serviceReference", "wordId", "projectMid", "wordPart", "fileOr", "FILEUrl", "FileUrl", "imageIn", "fileReference", " fileUrl", " filePart", "wordid", "blockId", "fileUrl", "serviceById", "localID", "fileid", "wordString", "fileIn", "imageById", "wordReference", "filePart", "fileById", "localMid", "fileID", "serviceId", "localId", " fileRef", "fileRef", "FileRef", "serviceIn", "serviceString", " fileById", "imageid", "wordID", "blockString", "FILEMid", "FILEOr", "fileMid", " fileid", "FileById", " fileReference", "FileId", "localOr", "blockID", "blockid", "servicePart", "FILEId", "fileString", "serviceid", " fileID", "projectId", "FILEById"], "ms": ["terms", "mi", "ics", " mc", "ss", "sm", "us", "mr", "mill", "mos", " mo", "mt", "MS", "cms", "ws", " mm", "mo", "m", " m", "fs", "mx", "helps", "hs", "ns", "me", "uts", "md", "mp", "mes", "ps", "arm", "sim", "aps", "pc", " MS", "cm", "ys", "gm", "acs", "ims", "ems", "mb", "aos", "ap", " mt", "ma", "mn", "mc", "mm", "vs", "Ms", "pm", "is", "iss", "ks", "arms", "ears", "ml", "med", "cs", " ns"], "p": ["exp", "f", "php", "pa", "pb", "prop", "tp", "y", "policy", "vp", "sp", "params", "h", "op", "pp", "m", "app", "q", "pl", "c", "pkg", "mp", "ps", "pro", "bp", "v", "cp", "properties", "proc", "comp", "per", "parse", "np", "project", "P", "pers", "lp", "hp", "g", "pre", "ip", "jp", "wp", "pr", "pe", "ap"], "url": ["f", "browser", "gl", "address", "u", "ref", "dl", "resource", "obj", "m", "ls", "web", "ll", "char", "build", "log", "sl", "open", "b", "result", "re", "ur", "v", "mount", "uri", "URL", "str", "rl", "l", "input", "nl", "r", "ssl", "ret", "n", "http", "location", "row", "file", "loc", "Url", "user", "data", "abs"]}}
{"id1": "8046691", "id2": "23677142", "code1": "    private void retrieveFile(URL url, RSLink link) {\n        link.setStatus(RSLink.STATUS_DOWNLOADING);\n        HttpURLConnection httpConn = null;\n        DataOutputStream outs = null;\n        BufferedInputStream bins = null;\n        BufferedOutputStream bouts = null;\n        try {\n            String postData = URLEncoder.encode(\"mirror\", \"UTF-8\") + \"=\" + URLEncoder.encode(url.toString(), \"UTF-8\");\n            httpConn = (HttpURLConnection) url.openConnection();\n            httpConn.setRequestMethod(\"POST\");\n            httpConn.setRequestProperty(\"Content-Type\", \"application/x-www-form-urlencoded\");\n            httpConn.setRequestProperty(\"Content-Length\", \"\" + Integer.toString(postData.getBytes().length));\n            httpConn.setRequestProperty(\"Content-Language\", \"en-US\");\n            httpConn.setDoOutput(true);\n            httpConn.setDoInput(true);\n            outs = new DataOutputStream(httpConn.getOutputStream());\n            outs.writeBytes(postData);\n            outs.flush();\n            Pattern mimePattern = Pattern.compile(\".+/html.+\");\n            Matcher matcher = mimePattern.matcher(httpConn.getContentType());\n            if (matcher.find()) {\n                log(\"Can not download, maybe all RS slots are busy!\");\n                return;\n            }\n            link.setSize(httpConn.getContentLength());\n            bins = new BufferedInputStream(httpConn.getInputStream(), 4096);\n            bouts = new BufferedOutputStream(new FileOutputStream(link.getFile()), 4096);\n            link.setStatus(RSLink.STATUS_DOWNLOADING);\n            link.setDown(0);\n            byte[] byteBuffer = new byte[4096];\n            int count;\n            while ((count = bins.read(byteBuffer)) != -1) {\n                bouts.write(byteBuffer, 0, count);\n                link.setDown(link.getDown() + count);\n                if (!Main.start.get()) {\n                    link.setStatus(RSLink.STATUS_NOTHING);\n                    return;\n                }\n            }\n            link.setStatus(RSLink.STATUS_DONE);\n        } catch (IOException ex) {\n            log(\"I/O Exception!\");\n            link.setStatus(RSLink.STATUS_NOTHING);\n        } finally {\n            try {\n                if (outs != null) outs.close();\n                if (bouts != null) bouts.close();\n                if (bins != null) bins.close();\n            } catch (IOException ex) {\n                JOptionPane.showMessageDialog(null, \"Can not close some connections:\\n\" + ex.getMessage(), \"ERROR\", JOptionPane.ERROR_MESSAGE);\n            }\n            if (httpConn != null) httpConn.disconnect();\n        }\n    }\n", "code2": "\tpublic static void BubbleSortShort2(short[] num) {\n\t\tint last_exchange;\n\t\tint right_border = num.length - 1;\n\t\tdo {\n\t\t\tlast_exchange = 0;\n\t\t\tfor (int j = 0; j < num.length - 1; j++) {\n\t\t\t\tif (num[j] > num[j + 1])\n\t\t\t\t{\n\t\t\t\t\tshort temp = num[j];\n\t\t\t\t\tnum[j] = num[j + 1];\n\t\t\t\t\tnum[j + 1] = temp;\n\t\t\t\t\tlast_exchange = j;\n\t\t\t\t}\n\t\t\t}\n\t\t\tright_border = last_exchange;\n\t\t} while (right_border > 0);\n\t}\n", "label": 0, "substitutes": {"retrieveFile": ["retrieveLink", "detrieveLocal", "retrievedImage", "retrieveLocal", "detrievedLink", "retireFile", "retrievedFile", "retractLocal", "retrieveImage", "detrievedImage", "detrievedFile", "detrieveFile", "retireLocal", "retireLink", "detrievedLocal", "retractLink", "retrievedLink", "detrieveLink", "retireImage", "detrieveImage", "retractImage", "retrievedLocal", "retractFile"], "url": ["f", "address", "image", "ref", "u", "dl", "resource", "m", "bel", "web", "ls", "ll", "run", "base", "char", "build", "pl", "sl", "call", "un", "ur", "cp", "uri", "URL", "name", "get", "rl", "str", "l", "nl", "path", "rect", "ssl", "el", "row", "http", "string", "location", "remote", "job", "arl", "file", "Url", "id", "ml", "host", "abs"], "link": ["links", " LINK", "page", "base", "label", "build", "linked", " check", "system", "db", "post", "rel", "detail", "lib", "get", "Link", "relation", " load", "info", "msg", "index", "loop", "map", "ml", "loader", "type", "handle", "lock", "ink", "mark", "thread", "tool", "log", "list", "def", "sign", "line", " relay", "ssl", "local", "key", "file", "check", " jump", "block", "dl", "entry", " block", "let", "share", "light", " reload", "stream", "ls", "library", "ment", "write", "open", "master", "cp", "le", "error", "query", "pack", "path", "network", "download", "install", " delay", " lock", "style", "image", "task", "set", "status", "tag", "init", "go", "load", "message", "l", "li", "mail", "add", "self", "remote", "ld"], "httpConn": ["httpconn", "realConnect", "appConnect", "ttpSyn", "httpsCons", "htmlCt", "ttpconn", "appConn", "internalCt", "realCt", " httpconn", "realconn", "htmlConn", " httpCons", "httpsConn", "htmlconn", "internalConn", "hoverConnection", "HTTPCon", "HttpConnection", "htmlConnect", "HttpCon", "ttpConnect", "internalConnection", "hoverCt", "ttpCt", "hoverSyn", "socketconn", "localCon", "appconn", "internalconn", "HTTPConn", "httpsCon", "httpCon", "localConn", "appConnection", "ttpCons", "ttpConn", " httpCt", "HTTPCons", "httpConnect", "httpsConnection", "internalCon", "httpCt", "httpsConnect", " httpConnection", "realConn", "socketConnect", "localconn", "socketConnection", "localConnection", "httpConnection", "hoverConnect", "hoverConn", "httpCons", "httpCmd", "HttpConn", "ttpCmd", "hoverCon", "internalConnect", "HTTPConnect", "httpsCmd", " httpConnect", " httpCmd", " httpCon", "ttpConnection", "socketConn", "hoverCons", "ttpCon", " httpSyn", "HttpConnect", "httpsconn", "httpSyn"], "outs": ["ows", "ches", "dates", "vals", "ends", "cos", "ins", " layouts", "aches", "cells", "tops", "orts", "sets", "bs", "qs", "ls", "ns", "uts", "bits", "fits", "uploads", "ts", "boxes", "aps", "its", "ips", "locks", "lists", "ats", "os", "out", "plays", "eps", "ds", " ops", "ops", "gs", "ims", "obs", "s", " out", "aos", "ports", " outputs", "als", "uns", "gets", "uds", "nets", "offs", "lets", "ios", "ks", "nos", "yout", "checks"], "bins": [" bkins", "louts", "rins", "blinn", "lin", "hin", "win", "bids", "bkins", "blkins", "rkins", "blids", "lids", "linn", "wins", "binn", "routs", " binos", "wobs", "blans", "bans", "blinos", "hins", "bin", "rans", "blins", " binn", "hobs", "binos", "houts", "lins", " bids", "linos", "wouts", "blouts", "bobs", "lobs", " bans"], "bouts": ["fbouts", "bout", "wonds", "obins", "wbonds", "obbs", "bbyout", "bbbs", "wins", " bonds", "wout", "fbbs", "bonds", " baos", " bout", "bbouts", "fbyout", "wbaos", "Bins", "bbs", "obouts", "obyout", "Baos", "wbout", "Baints", " baints", "wbouts", "Bouts", "baints", "byout", "waints", "bbins", "wouts", "fbins", "baos", "waos"], "postData": ["postDATA", "postBytes", "Postdata", " postBytes", "postsData", "postDat", "postBody", " postQuery", "PostBytes", "formDat", "formDATA", "postQuery", "POSTData", "PostBody", "POSTdata", " postdata", "PostDATA", "POSTQuery", "postsDATA", "POSTBytes", "postdata", " postBody", " postDat", "POSTBody", "postsBytes", "postsdata", "formData", " postDATA", "formdata", "PostData", "PostQuery", "POSTDATA", "POSTDat"], "mimePattern": ["smimePattern", "mimeFormat", "muxpattern", "smetypattern", " muxPattern", "metyFormat", "smimeFormat", "mIMEPattern", " muxpattern", "metyTemplate", "smetyPattern", "metyPattern", "mIMEFormat", "smimepattern", "mIMEpattern", "mimesPattern", "muxTemplate", "mimepattern", "smetyFormat", "mimeTemplate", " muxTemplate", " mimeTemplate", "mimesFormat", " mimepattern", "muxPattern", "mimesTemplate", "metypattern", "mimespattern"], "matcher": [" mather", " matter", " matmatch", "stather", "Matches", "match", "Matcher", " match", "Matmatch", " matching", "mature", "statching", "Matter", "matmatch", "disches", "matter", "statter", "disure", "matches", " matches", "patcher", "Match", "Mature", "matching", "statcher", "Matching", "pather", "Mather", " mature", "discher", "patch", "patter", "mather", "dismatch"], "byteBuffer": ["wordBuffer", "byteMatrix", " byteFrame", "bFFER", "byteBuilder", " byteVar", "charBuilder", "byteFrame", "wordbuffer", "letterFrame", " bytebuffer", " byteFFER", "byteVar", "charBuffer", "charVar", "ByteBuffer", " byteBuilder", "letterMatrix", "bBuff", "noteBuilder", "ByteBuff", "letterbuffer", "bBuffer", "Bytebuffer", "noteBuffer", " byteMatrix", "charBuff", "ByteFFER", "bytebuffer", "wordMatrix", "noteVar", "wordFrame", "letterBuffer", "noteBuff", "byteBuff", " byteBuff", "bbuffer", "byteFFER"], "count": ["first", "all", "cycle", "nt", "find", "cont", "comment", "depth", "force", "C", "sum", "char", "code", "c", "err", "buffer", "ctr", "loop", "current", "call", "result", "max", "list", "conf", "number", "read", "counter", "cache", "child", "ount", "total", "last", "ch", "iter", "len", "val", "length", "continue", "amount", "found", "Count", "ind", "batch", "num", "add", "n", "core", "cap", "start", "size", "more", "index", "check", "acc", "cc"]}}
{"id1": "7872659", "id2": "11968328", "code1": "    private static boolean genCustRatingFileAndMovieIndexFile(String completePath, String masterFile, String CustRatingFileName, String MovieIndexFileName) {\n        try {\n            File inFile = new File(completePath + fSep + \"SmartGRAPE\" + fSep + masterFile);\n            FileChannel inC = new FileInputStream(inFile).getChannel();\n            File outFile1 = new File(completePath + fSep + \"SmartGRAPE\" + fSep + MovieIndexFileName);\n            FileChannel outC1 = new FileOutputStream(outFile1, true).getChannel();\n            File outFile2 = new File(completePath + fSep + \"SmartGRAPE\" + fSep + CustRatingFileName);\n            FileChannel outC2 = new FileOutputStream(outFile2, true).getChannel();\n            int fileSize = (int) inC.size();\n            int totalNoDataRows = fileSize / 7;\n            ByteBuffer mappedBuffer = inC.map(FileChannel.MapMode.READ_ONLY, 0, fileSize);\n            int startIndex = 1, count = 0;\n            short currentMovie = 1;\n            while (mappedBuffer.hasRemaining()) {\n                count++;\n                short movieName = mappedBuffer.getShort();\n                int customer = mappedBuffer.getInt();\n                byte rating = mappedBuffer.get();\n                if (movieName != currentMovie) {\n                    ByteBuffer outBuf1 = ByteBuffer.allocate(10);\n                    outBuf1.putShort(currentMovie);\n                    outBuf1.putInt(startIndex);\n                    outBuf1.putInt(count - 1);\n                    outBuf1.flip();\n                    outC1.write(outBuf1);\n                    currentMovie = movieName;\n                    startIndex = count;\n                }\n                ByteBuffer outBuf2 = ByteBuffer.allocate(5);\n                outBuf2.putInt(customer);\n                outBuf2.put(rating);\n                outBuf2.flip();\n                outC2.write(outBuf2);\n            }\n            ByteBuffer endOfIndexFile = ByteBuffer.allocate(10);\n            endOfIndexFile.putShort(currentMovie);\n            endOfIndexFile.putInt(startIndex);\n            endOfIndexFile.putInt(100480506);\n            endOfIndexFile.flip();\n            outC1.write(endOfIndexFile);\n            outC1.close();\n            outC2.close();\n            return true;\n        } catch (IOException e) {\n            System.err.println(e);\n            return false;\n        }\n    }\n", "code2": "    public static String getMD5(String _pwd) {\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"MD5\");\n            md.update(_pwd.getBytes());\n            return toHexadecimal(new String(md.digest()).getBytes());\n        } catch (NoSuchAlgorithmException x) {\n            x.printStackTrace();\n            return \"\";\n        }\n    }\n", "label": 0, "substitutes": {"genCustRatingFileAndMovieIndexFile": [" genCustRatingFileAndMovieVersionfile", " genCustRatingFileAndMovieindexTable", " genCustRatingFileAndVideoindexFiles", " genCustRatingFileAndMovieIndexFiles", " genCustRatingFileAndVideoIndexfile", " genCustRatingFileAndMovieVersionFile", " genCustRatingFileAndVideoindexfile", " genCustRatingFileAndMovieIndexfile", " genCustRatingFileAndVideoIndexTable", " genCustRatingFileAndVideoindexFile", " genCustRatingFileAndVideoIndexFile", " genCustRatingFileAndMovieVersionTable", " genCustRatingFileAndMovieindexfile", " genCustRatingFileAndMovieindexFiles", " genCustRatingFileAndMovieindexFile", " genCustRatingFileAndMovieIndexTable", " genCustRatingFileAndMovieVersionFiles", " genCustRatingFileAndVideoIndexFiles", " genCustRatingFileAndVideoindexTable"], "completePath": [" completeDirectory", "completeScript", "fullLocation", "COMPLELog", "completeDir", " completesLocation", "completePod", "pleteLocation", "pleteDir", "completeDirectory", "pletionProject", "CompleteDirectory", "pletionPath", "totalRoot", "totalLocation", "CompleteLog", " completeLocation", "CompleteDir", "COMPLEScript", "fullPath", "completeRoot", "pletePath", " completesDirectory", "CompleteScript", "CompletePath", "CompleteLocation", "pleteRoot", "fullPod", " completesPath", "completeNow", "completeProject", "totalPod", "pletionNow", "pleteScript", "totalPath", "COMPLEPath", "pleteProject", "completeLocation", "fullRoot", "pletePod", "pleteNow", "COMPLEDir", " completesDir", "pletionDir", "CompleteProject", "completeLog", "CompleteNow", " completeDir", "pleteLog"], "masterFile": ["currentName", "masterfile", "masterFilename", "managerPath", "MasterFile", " masterFilename", " masterPath", "completeName", "managerfile", "MasterName", "completefile", "managerFile", "currentfile", "managerFilename", "currentPath", "MasterPath", "Masterfile", " masterfile", "masterName", "MasterFilename", "completeFile", "masterPath", "currentFile"], "CustRatingFileName": ["CustRatingFilesName", "CustRankFilename", "CustRatingTableNames", "CustRatedFileSet", "CustRatingFilesInfo", "CustRatingFilesType", "CustRatedfileNames", "CustRatingFilenameNames", "CustRatedFileNames", "CustRatedfileType", "CustRankFileName", "CustRatedfileName", "CustRatingfileName", "CustRatingFileInfo", "CustRatingTablename", "CustRatingTableName", "CustRatingFilenameName", "CustRatingFileSet", "CustRankFileInfo", "CustRatingTableType", "CustRatingFilenameType", "CustRatingfileSet", "CustRatingFieldType", "CustRatingFieldInfo", "CustRatingFileNames", "CustRatingFileType", "CustRankFilesType", "CustRankFilesInfo", "CustRatedFileType", "CustRatedfileSet", "CustRankFilesName", "CustRatingFilesname", "CustRatingTableSet", "CustRatingFieldName", "CustRatedFileName", "CustRankFileType", "CustRatingfileType", "CustRatingfileNames", "CustRatingFieldname", "CustRatingTableInfo", "CustRatingFilename", "CustRatingFilenameSet", "CustRankFilesname"], "MovieIndexFileName": ["MovieIndexFileNumber", "MovieIndexFILEName", "MovieIndexfileType", "MovieindexFileNumber", "MovieindexFileNames", "MovieindexfileName", "MovieIndexFieldNames", "MovieindexFileKey", "MovieIndexFILEType", "MovieIndexFileKey", "MovieindexfileNumber", "MovieIndexfileName", "MovieIndexFileType", "MovieIndexTableKey", "MovieindexfileNames", "MovieindexfileKey", "MovieIndexFieldName", "MovieIndexFILENames", "MovieindexFileType", "MovieindexFileName", "MovieIndexFILENumber", "MovieIndexFileNames", "MovieIndexFieldType", "MovieIndexTableType", "MovieIndexFieldKey", "MovieIndexTableNames", "MovieIndexTableName", "MovieIndexfileKey", "MovieindexfileType", "MovieIndexfileNames", "MovieIndexfileNumber"], "inFile": ["inF", " infile", "INF", "outFile", "INFILE", "localFILE", "outfile", "localFile", "INfile", "localC", "localfile", "inFILE", "outC", "INFile", "outF", "INC", " inFILE", " inF", "infile"], "inC": [" outL", " inCI", "inF", "intC", " outC", "inputFile", " inG", " outF", "intCI", "outFile", "inCL", " inCS", "outG", "iCI", "outL", "iCS", "iR", " outCL", "inG", "inputF", "outC", "inputC", "inR", "outCL", "iC", "outF", "intR", "intCS", "inL", "inCS", " inL", " inF", "inCI", " inR", " inCL", "inputG"], "outFile1": ["outFile0", "outFile9", "outPage2", "outfile2", "outputFileOne", "outFileOnce", "outPage1", "outFILE1", "outputFile9", "outFileOne", "outputFile1", "outChannel9", "outFILE6", " outFile6", "outChannel1", "outPage9", "outfile0", "outfile1", "outFILE2", "outPage6", " outfile1", "outPageOne", "outputPage9", "outputPageOnce", " outfile6", "outFILE0", "outputPageOne", " outfile0", "outfile6", "outFile6", "outChannelOnce", "outPageOnce", " outFile0", "outputFileOnce", "outChannelOne", "outPage0", "outputPage1", " outfile2"], "outC1": ["inFile3", "inFileOne", "outROne", "outc3", "outC3", "outCB3", "outR3", "outc2", "outFileOne", "outPOne", "outc1", "outP1", "outCB1", "outP3", "outR1", "outR2", "inC0", "inC1", "outCB2", "outCOne", "inC2", "outFile3", "inCOne", "outCB0", "outP2", "inFile2", "outC0", "inC3", "inFile1", "outc0"], "outFile2": ["outFile0", "outF2", "outfile2", "outF1", " outFile02", " outFileTwo", "outF3", "outTable2", "exFile3", "exChannel2", "outChannel1", "exChannel3", "outfile0", "outfile1", "outTable3", "outFile02", "exFile1", "outChannel3", "outChannel0", "outChannel2", "exFile2", "outfile02", "outfileTwo", "outFileTwo", "exChannel1", "outFile3", " outFile3", "outF0", "exFile0", "outTable02", "exChannel0", "outTableTwo", "outfile3"], "outC2": ["allCTwo", "OutR1", "outE3", "outM22", "OutR2", "outE2", "outB22", "allB3", "outC3", "allC3", "outE4", "outC22", "outR3", "allC2", "OutR4", "outS2", "outS22", "OutC4", "allBTwo", "outR1", "outR2", "OutC1", "outM2", "outE1", "outBTwo", "outR4", "OutC2", "outMTwo", "allB22", "outB2", "allB2", "outS3", "outC4", "allC22", "outCTwo", "OutC3", "outSTwo", "outB3", "OutR3", "outM3"], "fileSize": ["byteLength", "baseSize", "fileSIZE", "FileName", "issueSize", " fileCount", "FileSIZE", "baseName", "baseSIZE", " fileSIZE", "issueName", "fileCount", "FileCount", " fileName", "issueSIZE", "FileSize", "byteName", "FileLength", "issueLength", "fileName", "fileLength", " fileLength", "byteSize", "byteSIZE", "baseCount"], "totalNoDataRows": ["totalNoDataRecoles", "totalNoDataRocks", "totalNoDataRecues", "totalNoDataSlues", "totalNodataRecocks", "totalNoDataRues", "totalNodataRecues", "totalNoDataRecocks", "totalNodataRues", "totalNodataRoles", "totalNodataRecows", "totalNoDataSloles", "totalNoDataSlows", "totalNoDataBocks", "totalNoDataSlocks", "totalNoDataBows", "totalNoDataBues", "totalNoDataRecows", "totalNoDataRoles", "totalNodataRocks", "totalNodataRecoles", "totalNodataRows", "totalNoDataBoles"], "mappedBuffer": ["mappingBuff", "mapperBuff", " mapedBuffer", "mmappedBuff", "MapedBB", " mapperCounter", "mapedCallback", " mapedBuff", "mapedQueue", "mattedData", "mappingData", "mmappingBuffer", "mappedQueue", "mressedBuff", "mappedBuff", "mappingBuffer", "mressedFB", "mmappedQueue", "maphBuff", "mapedBuffer", "mapedbuffer", " mappedFB", "maphCallback", "mapBuff", "mapperQueue", "matchedCounter", "maphBuffer", "matchedBuffer", "mappingCounter", " mapedFB", "mappedbuffer", " mapedCallback", "mattedBuff", "mappedData", "mattedBuffer", "mappingBB", "mappedCallback", "MapedData", "MapedBuff", "MappedData", "MappedBuffer", "mappingbuffer", " mapperBuff", "mressedBuffer", "mmappedBuffer", "mmappingbuffer", "mappedFB", "mapperBB", "mapedFB", "mmappingQueue", " mappedCallback", " mappedBuff", "mappingQueue", "mapedData", "mapBuffer", "matchedQueue", "mappedBB", "MapperBB", "MappedBB", "mapperbuffer", "MapperBuff", "MapedBuffer", "mressedCallback", "MappedBuff", "maphFB", "mmappingBuff", " mappedQueue", "mapedBB", "mapBB", "MapperBuffer", "matchedBuff", "mattedBB", "mapperCounter", "mapperBuffer", "mappedCounter", " mapperBuffer", " mappedCounter", "mmappedbuffer", " mapperQueue", "mapedBuff"], "startIndex": ["initindex", "StartIndex", "startIter", "StartInd", "StartPoint", "StartPosition", "firstIndex", "startPage", "startPos", "endPage", " startPage", "StartIter", " startPoint", "firstindex", " startPosition", "startPosition", " startPos", "initIndex", "firstPosition", "startInd", "Startindex", "endIter", "currentPoint", " startindex", "currentIndex", "currentPosition", "StartPos", "endIndex", " startInd", "initPosition", "startPoint", "currentPos", "StartPage", "startindex", "firstInd", " startIter", "endPosition"], "count": ["type", "first", "cloud", "process", "find", "con", "cast", "next", "depth", "force", "sum", "category", "status", "page", "limit", "code", "c", "ctr", "current", "call", "result", "max", "list", "conf", "mount", "number", "i", "counter", "act", "state", "name", "ount", "coll", "now", "total", "last", "order", "length", "continue", "amount", "batch", "Count", "ind", "found", "num", "add", "created", "n", "core", "info", "id", "start", "size", "more", "index", "check", "user"], "currentMovie": ["activeMovie", "reportedMusic", "activeSpider", "firstMouse", "currentDate", "currentMusic", "currentlyMovie", "firstMovie", "currentPlayer", "currentlySpider", "reportedMouse", "firstMonster", " currentMedia", "presentMusic", " currentPlayer", "currentlyHero", "reportedHero", " currentMonster", "presentHero", "currentlyDate", " currentVideo", "primaryMovie", "currentlyMonster", "currentMouse", "currentVideo", "primaryHero", "firstDate", "currentImage", "currentSpider", "reportedMovie", "currentlyPlayer", "reportedMedia", "presentImage", " currentSpider", " currentHero", " currentMouse", "currentMonster", "firstMedia", "primaryVideo", "activeVideo", "currentHero", "reportedImage", " currentImage", " currentMusic", "presentMovie", "currentlyVideo", "currentMedia", "activePlayer", "primaryDate", "firstVideo", "firstHero"], "movieName": ["ovieGroup", "filmName", "ovieNAME", " moviename", "movieNAME", "mpegNAME", "oviename", "filmNAME", "filmname", "mpegGroup", "moviename", "movieGroup", "httpname", "MovieType", " movieNAME", "monsterNAME", " movieTitle", "Moviename", "httpNAME", "MovieName", "MovieTitle", "movieTitle", " movieType", "ovieName", "filmType", "httpName", "mpegname", "filmGroup", "monsterName", "monstername", "movieType", "filmTitle", "mpegName"], "customer": ["CustomER", "customER", "sticker", " customator", "customity", "stickity", "developity", " customER", "Customity", "customator", "ustomator", "developorder", "customorder", "developizer", "stickizer", "stickER", "ustomer", "Customizer", "developer", "developER", "ustomorder", " customorder", "developator", "ustomER", "Customer", "customizer"], "rating": ["type", "playing", "boarding", "setting", "score", "option", " Rating", "credit", "tag", "ating", "rank", "average", "rat", "strength", "attribute", "ping", "rated", "testing", "review", "format", "rage", "having", "saving", "error", "Rating", "rate", "ranking", "scoring", "term", "weight", "core", "scale", "heading", "reading", "user", "reporting", "card", "translation"], "outBuf1": ["outBool3", "outBbufOne", "outBfx0", "outBuc5", "outBuff0", "outBdf1", "outBBuff0", "outBBuff11", "outBurg0", "outBuf64", "outBuff1", "outBuf5", "outBuffy1", "outBurg3", "outBdf64", "outRbuf0", "outBurg1", "outBulp64", "outBlf3", "outBulp3", "outRbuf18", "outBbuf18", "outBuf11", "outBuffy0", "outBbuf11", "outBufOnce", "outBooll", "outDuf11", "outBuffyl", "outBbufone", "outBulp1", "outDbuf0", "outBulpOnce", "outRufOne", "outBuff3", "outDuf0", "outBuffy3", "outRbufOne", "outBbufOnce", "outDuf1", "outBBuff1", "outBbuf0", "outBuf3", "outBbuf5", "outBufone", "outBbuf64", "outDbuf3", "outBbuf3", "outBuff2", "outBurg18", "outRuf3", "outBfx11", "outRuf18", "outBuffy18", "outDbuf1", "outBuffyone", "outBucOne", "outRuf5", "outBlf2", "outBbufl", "outBfx1", "outBool1", "outRuf1", "outBdfOnce", "outRbuf3", "outDuf3", "outBuf0", "outBlf1", "outBBuff3", "outBfx3", "outBlf0", "outRbuf1", "outRuf0", "outBufOne", "outBoolone", "outDbuf11", "outBuc1", "outBuc0", "outBdf3", "outBufl", "outBbuf1", "outBuf18", "outRbuf5"], "outBuf2": ["outBufTwo", "outBbuff15", "outBuf02", "outBuffj", "outMuf2", "outBuffy02", "outMuf3", "outBuffTwo", "outBbuf02", "outBfx15", "outBuffy4", "outBfgTwo", "outMbuf15", "outFbuf2", "outBfx1", "outBuf3", "outBbuf15", "outFufTwo", "outBuff4", "outBfg02", "outFbuf4", "outBuf15", "outBfg2", "outBbuff3", "outBfx3", "outBbufTwo", "outBbuf3", "outMuf15", "outMbuf2", "outBfx2", "outMbuf1", "outBuff2", "outFbufTwo", "outBuf42", "outBuff42", "outFuf4", "outFbuf02", "outBbuff2", "outFuf02", "outBuff3", "outMbuf3", "outBuff1", "outBuf4", "outBbuf2", "outBbufj", "outBbuff1", "outBbuff4", "outBbuf42", "outBuffy2", "outBuffyTwo", "outBbuff42", "outBbuf4", "outBufj", "outBbuffj", "outBuffy3", "outBbuf1", "outMuf1", "outFuf2", "outBfg4"], "endOfIndexFile": ["endOfIndLine", "endOfErrorF", "endofindexFile", "endOfIndexfile", "endFile", "endOfErrorFile", "endOfIndfile", "endofIndexfile", "endOfPositionFiles", "endOFIndexFile", "endOFIndexLine", "EndFile", "endOfindexTable", "endOfErrorFiles", "endOFindexFile", "endOfindexLine", "endOFindexfile", "endofIndexTable", "endofIndexF", "endOFindexLine", "endOfErrorfile", " endFile", "endofindexTable", "endofindexfile", "endofindexF", "endOfindexF", "endOfIndexFiles", "endOfindexfile", "endofIndexFile", "endOfIndFile", "endOfIndexLine", "endofindexFiles", "endofIndexFiles", "endOFIndexfile", "endOfPositionFile", "endOfindexFiles", "endOfIndexF", "endOfPositionfile", "endOfPositionTable", "endOfIndexTable", "endOfindexFile", "endedFile"]}}
{"id1": "742465", "id2": "10212189", "code1": "    public static void doVersionCheck(View view) {\n        view.showWaitCursor();\n        try {\n            URL url = new URL(jEdit.getProperty(\"version-check.url\"));\n            InputStream in = url.openStream();\n            BufferedReader bin = new BufferedReader(new InputStreamReader(in));\n            String line;\n            String version = null;\n            String build = null;\n            while ((line = bin.readLine()) != null) {\n                if (line.startsWith(\".version\")) version = line.substring(8).trim(); else if (line.startsWith(\".build\")) build = line.substring(6).trim();\n            }\n            bin.close();\n            if (version != null && build != null) {\n                if (jEdit.getBuild().compareTo(build) < 0) newVersionAvailable(view, version, url); else {\n                    GUIUtilities.message(view, \"version-check\" + \".up-to-date\", new String[0]);\n                }\n            }\n        } catch (IOException e) {\n            String[] args = { jEdit.getProperty(\"version-check.url\"), e.toString() };\n            GUIUtilities.error(view, \"read-error\", args);\n        }\n        view.hideWaitCursor();\n    }\n", "code2": "    public String getXML(String servletURL, String request) {\n        StringBuffer stringBuffer = new StringBuffer();\n        try {\n            String encodedRequest = URLEncoder.encode(request, \"UTF-8\");\n            URL url = new URL(servletURL + request);\n            BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream()));\n            String inputLine;\n            while ((inputLine = in.readLine()) != null) {\n                stringBuffer.append(inputLine);\n            }\n            in.close();\n        } catch (MalformedURLException ex) {\n            return null;\n        } catch (UnsupportedEncodingException ex) {\n            return null;\n        } catch (IOException ex) {\n            return null;\n        }\n        return stringBuffer.toString();\n    }\n", "label": 1, "substitutes": {"doVersionCheck": ["DoDatecheck", "doDateCheck", "doVersionsCheck", "DoDateFix", "doVersionFix", "doLicensecheck", "DoVersioncheck", "DoVersionCheck", "DoVersionFix", "DoDateCheck", "doDateUpdate", "doDateFix", "DoDateUpdate", "DoVersionUpdate", "doVersionsUpdate", "doVersionsFix", "doDatecheck", "doVersionUpdate", "doLicenseFix", "doVersionscheck", "doLicenseCheck", "doVersioncheck", "doLicenseUpdate"], "view": ["browser", "report", "window", "hl", "cv", "layout", "image", "block", "subject", "util", "console", "engine", "client", "doc", "VIEW", "tv", "views", "table", "help", "context", "web", "page", "update", "q", "buffer", "open", "document", "call", "cell", "v", "widget", "review", "see", "iew", "host", "get", "input", "out", "wrapper", "query", "this", "controller", "tree", "form", "show", "component", "blade", "eye", "model", "View", "manager", "self", "row", "http", "html", "server", "file", "check", "index", "print", "display"], "url": ["f", "browser", "hl", "gl", "address", "json", "dl", "lb", "client", "bel", "web", "ls", "ll", "char", "date", "link", "pl", "sl", "log", "b", "lr", "rel", "ur", "v", "mount", "org", "uri", "URL", "str", "rl", "l", "oul", "nl", "ul", "path", "null", "language", "github", "r", "ssl", "http", "html", "socket", "string", "location", "file", "loc", "Url", "id", "host"], "in": ["f", "rin", "inn", "gin", "IN", "vin", "ins", "reader", "ln", "stream", "In", "init", "inner", "b", "asin", "kin", "i", "mat", "inc", "l", "input", "out", "sin", " IN", " din", "ain", "mn", "info", "n", "din", "inf", "is", "isin", "source", "file", "body", "cin"], "bin": ["rin", " Bin", "win", "inn", "buff", "stock", "by", "gin", "con", "bl", "bg", "cos", "obin", "reader", "bur", "ln", "bed", "pipe", "inner", "mem", "bi", "spin", "buffer", "b", "mon", "thin", "ran", "nb", " bins", "lib", "abin", "cache", "rb", "out", "sin", "len", " din", "conn", "binary", "local", "din", "sam", "file", "bn", "cin", "ebin", "loader"], "line": ["LINE", "lo", "style", "lin", "block", "text", "cat", "eline", "entry", "ine", "sample", "column", "part", "comment", "frame", "lane", "se", "ln", "ide", "word", "lines", "page", "ls", "col", "level", "base", "trace", "char", "chain", "range", "link", "log", "code", "one", "err", "load", "port", "cell", "ice", "state", "le", "liner", "l", "section", "iter", "cmd", "point", "path", "record", "Line", "el", "channel", " Line", "row", "string", "job", "no", "field", "inline", "file", "body", "store", "print"], "version": ["type", "browser", "ion", "translation", "major", "video", "license", "image", "value", "virtual", "match", "test", "versions", "serial", "release", "feature", "resource", "description", "client", "sequence", "river", "status", "tag", "VER", "Version", "software", "spec", "date", "command", "v", "number", "format", "vision", "name", "position", "hash", "project", "form", "language", "info", "key", "volume", "string", "scale", "vers", "usage", "iso", "VERSION", "latest", "index", "ver", "update", "python", "title"], "build": ["building", "style", "built", "match", "test", "fail", "util", "release", "builder", "other", "update", "tag", "work", "date", "link", "round", "ship", "log", "th", "load", "b", "old", "be", "db", "hold", "lib", "hash", "last", "Build", "project", "boost", "binary", "add", "use", "bor", "ble", "full", "make", "uild", "arch", "dist", "bug", "develop", "install", "where", "latest", "ward", "ver", "unit", "dev", "print", "struct"]}}
{"id1": "3958807", "id2": "13886238", "code1": "        private void loadBinaryStream(String streamName, InputStream streamToLoad, long sz, HttpServletRequest req, HttpServletResponse resp) throws IOException {\n            resp.setContentType(getContentType(req, streamName));\n            resp.setHeader(\"Content-Disposition\", \"inline;filename=\" + streamName);\n            resp.setContentLength((int) sz);\n            OutputStream out = resp.getOutputStream();\n            BufferedOutputStream bos = new BufferedOutputStream(out, 2048);\n            try {\n                IOUtils.copy(streamToLoad, bos);\n            } finally {\n                IOUtils.closeQuietly(streamToLoad);\n                IOUtils.closeQuietly(bos);\n            }\n            getCargo().put(GWT_ENTRY_POINT_PAGE_PARAM, null);\n        }\n", "code2": "    public void init() throws GateException {\n        if (reportFile == null) throw new GateException(\"No report file set!\");\n        boolean restarting = false;\n        if (!reportFile.getParentFile().exists() && !reportFile.getParentFile().mkdirs()) {\n            throw new GateException(\"Could not create directories for \" + reportFile.getAbsolutePath());\n        }\n        File backupFile = new File(reportFile.getAbsolutePath() + \".bak\");\n        if (reportFile.exists()) {\n            restarting = true;\n            logger.info(\"Existing report file found at \\\"\" + reportFile.getAbsolutePath() + \"\\\", attempting to restart\");\n            if (!reportFile.renameTo(backupFile)) {\n                try {\n                    byte[] buff = new byte[32 * 1024];\n                    InputStream in = new BufferedInputStream(new FileInputStream(reportFile));\n                    try {\n                        OutputStream out = new BufferedOutputStream(new FileOutputStream(backupFile));\n                        try {\n                            int read = in.read(buff);\n                            while (read != -1) {\n                                out.write(buff, 0, read);\n                                read = in.read(buff);\n                            }\n                        } finally {\n                            out.close();\n                        }\n                    } finally {\n                        in.close();\n                    }\n                } catch (IOException e) {\n                    throw new GateException(\"Could not restart batch\", e);\n                }\n            }\n        }\n        try {\n            reportWriter = staxOutputFactory.createXMLStreamWriter(new BufferedOutputStream(new FileOutputStream(reportFile)));\n            reportWriter.writeStartDocument();\n            reportWriter.writeCharacters(\"\\n\");\n            reportWriter.setDefaultNamespace(Tools.REPORT_NAMESPACE);\n            reportWriter.writeStartElement(Tools.REPORT_NAMESPACE, \"cloudReport\");\n            reportWriter.writeDefaultNamespace(Tools.REPORT_NAMESPACE);\n            reportWriter.writeCharacters(\"\\n\");\n            reportWriter.writeStartElement(Tools.REPORT_NAMESPACE, \"documents\");\n        } catch (XMLStreamException e) {\n            throw new GateException(\"Cannot write to the report file!\", e);\n        } catch (IOException e) {\n            throw new GateException(\"Cannot write to the report file!\", e);\n        }\n        if (restarting) {\n            try {\n                Set<String> completedDocuments = new HashSet<String>();\n                logger.debug(\"Processing existing report file\");\n                InputStream bakIn = new BufferedInputStream(new FileInputStream(backupFile));\n                XMLEventReader xer = staxInputFactory.createXMLEventReader(bakIn);\n                try {\n                    XMLEvent event;\n                    while (xer.hasNext()) {\n                        event = xer.nextEvent();\n                        if (event.isStartElement() && event.asStartElement().getName().getLocalPart().equals(\"documents\")) {\n                            break;\n                        }\n                    }\n                    List<XMLEvent> events = new LinkedList<XMLEvent>();\n                    String currentReturnCode = null;\n                    String currentDocid = null;\n                    while (xer.hasNext()) {\n                        event = xer.nextEvent();\n                        events.add(event);\n                        if (event.isStartElement() && event.asStartElement().getName().getLocalPart().equals(\"processResult\")) {\n                            currentReturnCode = event.asStartElement().getAttributeByName(new QName(XMLConstants.NULL_NS_URI, \"returnCode\")).getValue();\n                            currentDocid = event.asStartElement().getAttributeByName(new QName(XMLConstants.NULL_NS_URI, \"id\")).getValue();\n                        }\n                        if (event.isEndElement() && event.asEndElement().getName().getLocalPart().equals(\"processResult\")) {\n                            if (currentReturnCode.equals(\"SUCCESS\") && currentDocid != null) {\n                                completedDocuments.add(currentDocid);\n                                for (XMLEvent evt : events) {\n                                    Tools.writeStaxEvent(evt, reportWriter);\n                                }\n                            }\n                            events.clear();\n                            currentReturnCode = null;\n                            currentDocid = null;\n                        }\n                        if (event.isEndElement() && event.asEndElement().getName().getLocalPart().equals(\"documents\")) {\n                            break;\n                        }\n                    }\n                } catch (Exception e) {\n                    logger.debug(\"Exception while parsing old report file - probably \" + \"reached the end of old report\", e);\n                } finally {\n                    xer.close();\n                    bakIn.close();\n                    backupFile.delete();\n                }\n                List<String> unprocessedDocs = new ArrayList<String>();\n                unprocessedDocs.addAll(Arrays.asList(documentIDs));\n                unprocessedDocs.removeAll(completedDocuments);\n                unprocessedDocumentIDs = unprocessedDocs.toArray(new String[unprocessedDocs.size()]);\n            } catch (XMLStreamException e) {\n                throw new GateException(\"Cannot write to the report file!\", e);\n            } catch (IOException e) {\n                throw new GateException(\"Cannot write to the report file!\", e);\n            }\n        } else {\n            unprocessedDocumentIDs = documentIDs;\n        }\n    }\n", "label": 1, "substitutes": {"loadBinaryStream": ["loadEmbbinaryStream", "loadEmbinaryStream", "loadBixedFile", "loadBixedInput", "loadBbinaryFile", "loadBinaryFile", "loadEmbinaryInput", "loadEmbbinaryInput", "loadEmbbinaryStreamer", "loadBbinaryStream", "loadEmbinaryFile", "loadBignedStream", "loadBinaryStreamer", "loadBignedFile", "loadBixedStream", "loadEmbbinaryFile", "loadBbinaryInput", "loadBignedInput", "loadBixedStreamer", "loadBignedStreamer", "loadBbinaryStreamer", "loadEmbinaryStreamer", "loadBinaryInput"], "streamName": ["fileNAME", "streamType", "streamPath", "Streamname", " streamNAME", "stringName", "resourceNAME", "streamname", "longName", " streamHandle", "longNAME", " streamPath", "StreamHandle", "StreamName", "stringType", "streamHandle", " streamType", "resourceName", "streamNAME", "stringNAME", "longPath", "filePath", "fileName", "recordName", "recordname", "recordHandle", "resourceType", " streamname", "recordNAME", "StreamNAME"], "streamToLoad": ["stringWillload", "streamtoload", "stream2Read", " streamToRead", "streamToUse", " streamWillload", "stream2Load", "stringWillLoad", "streamToAdd", "streamWillload", "stringToLoad", "streamtoAdd", "stringWillAdd", "stream2load", " stream2load", "stringToload", " stream2Read", "stream2Use", "streamWillLoad", " streamToUse", " streamWillLoad", "streamTORead", "streamWillAdd", " stream2Load", " stream2Use", "streamTOAdd", "stringToAdd", " streamToload", "streamToload", "streamToRead", "streamTOUse", "streamTOLoad", "streamtoLoad", "streamTOload"], "sz": ["sze", "Sch", "siz", " sch", " siz", "Sz", "Sze", "rsze", "rsld", "insz", "rsz", " sze", "sld", "sch", " sld", "insiz", "insch", "rsiz", "Siz", "insze", "Sld"], "req": ["seq", "attr", "usr", "ctx", "res", "quick", "pas", "comm", "request", "requ", "client", "fr", "qs", "quest", "wcs", "Requ", "urg", "sq", "q", "wx", "require", "pkg", "cur", "Request", "org", "qq", "proc", "comp", "query", "cmd", "rx", "inv", "jp", "http", "gr", "dq", "qt"], "resp": ["exp", "wr", "report", "nt", "respons", "response", "cmp", "vol", "res", "rep", "output", "pas", "sp", "comm", "request", "obj", "client", "fr", "https", "sys", "Response", "status", "fs", "conv", "dis", "wx", "rend", "soc", "Res", "result", "re", "rel", "content", " Resp", "serv", "os", "esp", "RES", "pos", "respond", "proc", "sol", "cmd", "conn", "Resp", "r", "inv", "ret", "gr", "http", "html", "jp", "msg", "compl", "body", "rec", "p", "cl"], "out": ["co", "nt", "us", "vol", "output", "res", "cos", "oss", "ins", "cn", "obj", "ws", "client", "sys", "bs", "conv", "t", "in", "net", "log", "to", "ts", "ot", "os", "gt", "sw", "gs", "null", "ou", "outs", "aos", "o", "utt", "n", "io", "Out", " outs", "OUT", "ex", "yout", "w"], "bos": ["bat", "dos", "buff", "bones", "mos", "oss", "bo", "js", "jas", "bh", "ws", "sys", "bs", "base", "bas", "uts", "los", "bi", "bits", "fits", "boards", "bles", "ts", "bin", "os", "ols", "des", "ys", "bes", "obs", "oops", "aos", "bis", "ods", "eros", "ubis", "ios", "oids", "banks", "oos", "BS", "tes", "nos", "bytes", "bot"]}}
{"id1": "4982745", "id2": "6866575", "code1": "    protected JSONObject doJSONRequest(JSONObject jsonRequest) throws JSONRPCException {\n        HttpPost request = new HttpPost(serviceUri);\n        HttpParams params = new BasicHttpParams();\n        HttpConnectionParams.setConnectionTimeout(params, getConnectionTimeout());\n        HttpConnectionParams.setSoTimeout(params, getSoTimeout());\n        HttpProtocolParams.setVersion(params, PROTOCOL_VERSION);\n        request.setParams(params);\n        request.addHeader(\"Authorization\", \"Basic \" + Base64Coder.encodeString(serviceUser + \":\" + servicePass));\n        HttpEntity entity;\n        try {\n            entity = new JSONEntity(jsonRequest);\n        } catch (UnsupportedEncodingException e1) {\n            throw new JSONRPCException(\"Unsupported encoding\", e1);\n        }\n        request.setEntity(entity);\n        try {\n            long t = System.currentTimeMillis();\n            HttpResponse response = httpClient.execute(request);\n            t = System.currentTimeMillis() - t;\n            Log.d(\"json-rpc\", \"Request time :\" + t);\n            String responseString = EntityUtils.toString(response.getEntity());\n            responseString = responseString.trim();\n            JSONObject jsonResponse = new JSONObject(responseString);\n            if (jsonResponse.has(\"error\")) {\n                Object jsonError = jsonResponse.get(\"error\");\n                if (!jsonError.equals(null)) throw new JSONRPCException(jsonResponse.get(\"error\"));\n                return jsonResponse;\n            } else {\n                return jsonResponse;\n            }\n        } catch (ClientProtocolException e) {\n            throw new JSONRPCException(\"HTTP error\", e);\n        } catch (IOException e) {\n            throw new JSONRPCException(\"IO error\", e);\n        } catch (JSONException e) {\n            throw new JSONRPCException(\"Invalid JSON response\", e);\n        }\n    }\n", "code2": "    @Primitive\n    public static Value caml_md5_string(final CodeRunner ctxt, final Value str, final Value ofs, final Value len) throws Fail.Exception {\n        try {\n            final MessageDigest md5 = MessageDigest.getInstance(Md5.ALGO);\n            md5.update(str.asBlock().getBytes(), ofs.asLong(), len.asLong());\n            return Value.createFromBlock(Block.createString(md5.digest()));\n        } catch (final NoSuchAlgorithmException nsae) {\n            Fail.invalidArgument(\"Digest.substring\");\n            return Value.UNIT;\n        }\n    }\n", "label": 0, "substitutes": {"doJSONRequest": ["dojsonResponse", " doHTTPQuery", "doHTTPRequest", " doJSONConnection", "doCustomQuery", "doHTTPConnection", "doCustomRequest", "doCustomResponse", "dojsonQuery", " doHTTPResponse", " doJSONQuery", " doJSONResponse", "doHTTPResponse", "doJSONQuery", "doHTTPQuery", "doCustomConnection", "doJSONConnection", "dojsonRequest", " doHTTPConnection", "doJSONResponse", " doHTTPRequest", "dojsonConnection"], "jsonRequest": ["jsonPost", "sonObject", "JSONObject", "JSONPost", "sonRequest", "rawResponse", "sonPost", "rawRequest", "sonResponse", "rawObject", "JSONRequest", " jsonPost", "rawPost", "JSONResponse", " jsonObject", "jsonObject"], "request": ["first", "report", "transform", "claim", "address", "pair", "reference", "insert", "reset", "hello", "resource", "application", "requ", "remove", "client", "create", "quest", "context", "q", "command", "document", "message", "call", "Request", "close", "post", "xml", "re", "req", "url", "name", "copy", "position", "get", "complete", "person", "condition", "initial", "input", "order", "query", "this", "project", "object", "search", "question", "record", "instance", "add", "use", "self", "remote", "http", "begin", "job", "start", "QUEST", "update", "setup"], "params": ["terms", "services", "amps", "tags", "json", "prop", "settings", "ctx", "par", "options", "pas", "parts", "details", "types", "sys", "lines", "tmp", "names", "changes", "spec", "phys", "pins", "stats", "rules", "pkg", "ps", "shape", "multi", "cas", "styles", "cp", "ams", "param", "properties", "rs", "pps", "caps", "eps", "proc", " parameters", "actions", "members", "Parameters", "pres", "pers", "ims", "chains", "gs", "parent", "headers", "ports", "ars", "mm", "groups", "cap", "posts", "eters", "as", "pool", "points"], "entity": ["event", "type", "ITY", "json", "om", "entry", "oe", "email", "comment", "enc", "details", "application", "resource", "obj", "create", "environment", "ce", "ell", "code", "ae", "em", "buffer", "connection", "document", "available", "xml", "e", "ct", "eme", "le", "error", "person", "valid", "ent", "query", "note", "metadata", "object", "component", "encrypted", "null", "security", "ip", "model", "el", "activity", "iam", "account", "quote", "Entity", "iso", "ity", "orm", "shell", "user", "pe"], "t": ["f", "ut", "txt", "nt", "duration", "z", "tp", "y", "j", "elt", "time", "d", "et", "iat", "mt", "vt", "m", "w", "tick", "tt", "x", "ti", "c", "ts", "det", "i", "e", "ct", "ta", "now", "pt", "tf", "total", "l", "it", "dt", "wt", "st", "at", "s", "tc", "tim", "g", "n", "temp", "tw", "T", "qt", "p", "tm", "ot"], "response": ["report", "reply", "json", "output", "res", "reset", "next", "service", "frame", "application", "description", "client", "sequence", "Response", "status", "environment", "connection", "one", "resp", "document", "message", "result", "onse", "re", "e", "success", "out", "respond", "tree", "object", "answer", "network", "remote", "body", "memory", "version", "data", "given"], "responseString": ["messagestring", "replyStr", " responseObject", " responsestring", "responseStr", "ResponseArray", "responseObject", "ResponseText", "ResponseObject", " responseStr", "resultStr", "replySystem", "messageObject", "answerStr", "replystring", "responseText", " responseArray", "resultstring", "Responsestring", "responsestring", "messageStr", " responseText", " responseSystem", "answerString", "ResponseStr", "responseSystem", "outputStr", "answerstring", "messageString", "ResponseString", "answerObject", "responseArray", "outputString", "outputArray", "ResponseSystem", "outputText", "resultObject", "replyString", "resultString"], "jsonResponse": ["xmlResponse", "sonObject", "JSONObject", "sonError", " jsonResp", " jsonData", "sonStatus", "JSONAnswer", "xmlError", "sonRequest", "xmlResp", "JSONData", "jsonResp", "sonAnswer", "xmlObject", " jsonStatus", "sonResp", "sonResponse", " jsonresponse", "xmlRequest", "sonData", "jsonresponse", "csvResponse", "JSONRequest", "jsonStatus", "sonresponse", "xmlAnswer", " jsonAnswer", "csvStatus", "csvAnswer", "csvResp", "jsonData", "JSONresponse", "JSONResponse", " jsonObject", "JSONResp", "jsonObject", "jsonAnswer"], "jsonError": ["JSONError", "sonError", "javascriptError", "JSONAuth", "jsonQuery", "jsonAuth", "JSONEr", "jError", "javascriptQuery", "sonResponse", "jQuery", "jAuth", " jsonQuery", "javascriptAuth", "sonEvent", "JSONEvent", "jsonEvent", "jEr", " jsonEvent", "jsonEr", "JSONResponse", "sonQuery", "JSONQuery", "javascriptEr"]}}
{"id1": "4164833", "id2": "4750967", "code1": "    public static void buildDeb(File debFile, File controlFile, File dataFile) throws IOException {\n        long now = new Date().getTime() / 1000;\n        OutputStream deb = new FileOutputStream(debFile);\n        deb.write(\"!<arch>\\n\".getBytes());\n        startFileEntry(deb, DEBIAN_BINARY_NAME, now, DEBIAN_BINARY_CONTENT.length());\n        deb.write(DEBIAN_BINARY_CONTENT.getBytes());\n        endFileEntry(deb, DEBIAN_BINARY_CONTENT.length());\n        startFileEntry(deb, CONTROL_NAME, now, controlFile.length());\n        FileInputStream control = new FileInputStream(controlFile);\n        byte[] buffer = new byte[1024];\n        while (true) {\n            int read = control.read(buffer);\n            if (read == -1) break;\n            deb.write(buffer, 0, read);\n        }\n        control.close();\n        endFileEntry(deb, controlFile.length());\n        startFileEntry(deb, DATA_NAME, now, dataFile.length());\n        FileInputStream data = new FileInputStream(dataFile);\n        while (true) {\n            int read = data.read(buffer);\n            if (read == -1) break;\n            deb.write(buffer, 0, read);\n        }\n        data.close();\n        endFileEntry(deb, dataFile.length());\n        deb.close();\n    }\n", "code2": "    public void patch() throws IOException {\n        if (mods.isEmpty()) {\n            return;\n        }\n        IOUtils.copy(new FileInputStream(Paths.getMinecraftJarPath()), new FileOutputStream(new File(Paths.getMinecraftBackupPath())));\n        JarFile mcjar = new JarFile(Paths.getMinecraftJarPath());\n    }\n", "label": 1, "substitutes": {"buildDeb": [" rebuilddeb", "Builddeb", " builddeb", " buildAud", "buildDub", "builddeb", " buildDub", " rebuildAud", "buildAud", "BuildAud", "BuildDub", " rebuildDub", "BuildDeb", " rebuildDeb"], "debFile": ["ubFilename", "obile", "pkgFILE", "obFilename", "ubile", "audFile", "debFilename", " debFilename", " debFILE", "debFILE", "obFile", "ubFile", "pkgFilename", " debile", "ubfile", "audFILE", " debfile", "debfile", "debFiles", " debFiles", "debile", "audFiles", "obfile", "audFilename", "pkgFiles", "pkgFile"], "controlFile": [" controlFILE", " controlfile", "configFILE", "ctrlFILE", "configFiles", "controlfile", "rolFile", "dataChain", "scriptFILE", "controlLog", "controlFiles", "ctrlLog", "ctrlfile", "rolFILE", "controlChain", " controlLog", "scriptFile", " controlFiles", "controlFILE", "ctrlChain", "ctrlFile", "configfile", "datafile", "ctrlFiles", "scriptfile", "configFile", "dataLog", "scriptFiles", " controlChain", "dataFiles", "rolfile"], "dataFile": ["byFiles", "DataFile", "runFile", "runList", "helpfile", "dataStream", "DataFiles", "runLot", "byFile", "DataTable", "byLot", " datafile", "byFILE", "valueFiles", "datFILE", "helpLot", "valueFile", " dataList", "DATAFile", "dataFILE", "valueFILE", "DATAStream", "dataSet", "datFile", "datafile", "valueLot", "datSet", "DATATable", " dataLot", "dataList", "runSet", "DataStream", " dataTable", "DATAFiles", "datfile", " dataFILE", "dataLot", "runfile", " dataSet", "helpFile", " dataStream", "dataFiles", "runFILE", "dataTable", " dataFiles", "helpList"], "now": ["first", "stuff", "today", "and", "time", "ow", "then", "www", "wait", " Now", "on", "create", "set", "force", "here", "app", "date", "old", "cur", "current", "system", "post", "aj", "always", "off", "Now", "after", "since", "fx", " NOW", "age", "sw", "java", "present", "length", "aw", "num", "full", "NOW", "start", "percent", "size", "loc", "zero", "low", "store", "from"], "deb": ["dp", "bl", "cb", "comm", "be", "red", "aud", "db", "rel", "pay", "conf", "dm", "sd", "iban", "cm", "reb", "ub", "dt", "erb", "sub", "rob", "compl", "abs", "sb", "pub", "prep", "av", "bb", "req", "def", "cmd", "priv", "mb", "og", "cd", "eg", "bar", "desc", "dep", "fb", "ib", "debian", "gif", "report", "img", "dl", "put", "ob", "daily", "und", "web", "we", "jpg", "cp", "eb", "dat", "stab", "etc", "download", "de", "dev", "decl", "div", "dec", "debug", "del", "pkg", "com", "review", "dan", "Deb", " Deb", "broad", "fin", "gob", "df"], "control": ["rol", "controlled", "co", "rc", "ctl", "roll", "correct", "con", "console", "critical", "comm", "cont", "ro", "ll", "cons", "code", "trl", "ca", "command", "ctr", "current", "system", "cell", "rel", "content", "com", "scroll", "crit", "cm", "rl", "const", "cond", "comp", "cmd", "controller", "history", "form", "ctrl", "Control", "connect", "core", "config", "compl", "check", "setup", "cc"], "buffer": ["phrase", "rule", "buf", "window", "block", "buff", "match", "sample", "bridge", "bo", "resource", "comment", "frame", "view", "sequence", "stream", "table", "page", "append", "context", "library", "base", "directory", "template", "chain", "label", "command", "attribute", "function", "absolute", "document", "message", "shape", "result", "stack", "hold", "number", "cache", "scroll", "variable", "Buffer", "iter", "note", "parse", "history", "length", "queue", "term", "binary", "batch", "paste", "filter", "database", "bar", "row", "temp", "button", "memory", "print"], "read": ["play", "each", "draw", "remove", "then", "est", "red", "build", "print", "get", "bind", "iter", "ip", "core", "config", "io", "start", "size", "send", "index", "pe", "handle", "select", "rand", "cont", "se", "reader", "thread", "char", "reads", "seek", "req", " Read", "need", "through", "reflect", "height", "ind", "connect", "key", "exec", "check", "push", "report", "text", "fill", "raw", "stream", "run", "in", "ang", "write", "hold", "error", "input", "query", "len", "length", "mix", "count", "READ", "find", "match", "word", "depth", "ro", "old", "load", "readable", "close", "rd", "skip", "scroll", "give", "valid", "dd", "val", "search", "add", "ek", "ke", "end", "like", "pass"], "data": ["extra", "window", "na", "good", "video", "div", "image", "DATA", "test", "internal", "di", "d", "next", "share", "reader", "ata", "raw", "table", "help", "not", "feed", "bus", "one", "debug", "to", "db", "rel", "list", "def", "cache", "bin", "error", "valid", "meta", "query", "mu", "normal", "da", "dat", "news", "batch", "database", "auto", "info", "http", "no", "file", "dev"]}}
{"id1": "11341711", "id2": "10795866", "code1": "    public static void makeBackup(File dir, String sourcedir, String destinationdir, String destinationDirEnding) {\n        String[] files;\n        files = dir.list();\n        File checkdir = new File(destinationdir + System.getProperty(\"file.separator\") + destinationDirEnding);\n        if (!checkdir.isDirectory()) {\n            checkdir.mkdir();\n        }\n        ;\n        Date date = new Date();\n        long msec = date.getTime();\n        checkdir.setLastModified(msec);\n        File checkFile = new File(checkdir + System.getProperty(\"file.separator\") + \"azureus.config\");\n        if (checkFile.exists()) {\n            checkFile.setLastModified(msec);\n        }\n        try {\n            for (int i = 0; i < files.length; i++) {\n                File f = new File(dir, files[i]);\n                File g = new File(files[i]);\n                if (f.isDirectory()) {\n                } else {\n                    String destinationFile = checkdir + System.getProperty(\"file.separator\") + g;\n                    String sourceFile = sourcedir + System.getProperty(\"file.separator\") + g;\n                    FileInputStream infile = new FileInputStream(sourceFile);\n                    FileOutputStream outfile = new FileOutputStream(destinationFile);\n                    int c;\n                    while ((c = infile.read()) != -1) outfile.write(c);\n                    infile.close();\n                    outfile.close();\n                }\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n", "code2": "    public String upload() {\n        System.out.println(imgFile);\n        String destDir = \"E:\\\\ganymede_workspace\\\\training01\\\\web\\\\user_imgs\\\\map_bg.jpg\";\n        FileOutputStream fos;\n        try {\n            fos = new FileOutputStream(new File(destDir));\n            IOUtils.copy(new FileInputStream(imgFile), fos);\n            IOUtils.closeQuietly(fos);\n        } catch (FileNotFoundException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return \"show\";\n    }\n", "label": 1, "substitutes": {"makeBackup": ["createbackup", "makeDupid", "makeDup", "makeDups", "makebackupid", "makeStupid", "createbackups", "createbackupid", "makeStup", "createbackpoint", "makeStpoint", "createBackups", "makeBackups", "makebackup", "makeStups", "createBackpoint", "makeBackpoint", "createBackup", "createBackupid", "makeBackupid", "makebackups", "makeDpoint", "makebackpoint"], "dir": ["window", "handle", "dl", "y", "vol", "d", "draw", "disk", "doc", "Directory", "tmp", "in", "base", "directory", "dis", "store", "md", "del", "pkg", "addr", "fd", "dr", "db", "wd", "src", "dm", "url", "out", "or", "iter", "dd", "Dir", "ir", "path", "rad", "mail", "dat", "ind", "DIR", "zip", "local", " d", "dist", "file", "folder", "loc", "dep", "direct", "data"], "sourcedir": [" sourcesirs", "isourcedel", "isourcedr", "isourceir", "senderel", "soredir", "senderdir", " sourcedirs", "isourcedir", "isourceddir", " sourcesdir", "sourceire", "isourceel", " sourcedire", " sourcesir", "soreddir", "sourcedirs", "sourcesdir", "sourcesirs", "sourcedire", " sourceddir", "senderir", "sourcedr", "sourcedel", "sourcesel", "sourceirs", "sourcesir", " sourcesire", "sourceir", "sourceddir", "sourcesire", "sourcer", "soredire", "senderr", "isourcer", "sourceel", "sourcesr", "soredirs"], "destinationdir": ["stinationsir", "destensiondir", "stinationsdiv", "stinationdir", "estinationfolder", "destinatordir", "destinationfolder", "estinatordb", "estinationdir", "estinatorfolder", "destineddb", "stinationsdb", "destensionDir", "destinedir", "destinationsdb", "stinationsdir", "destinationdb", "stinationdb", "stinationdiv", "destinatordb", "destinatordiv", "destinationdiv", "destensionfolder", "destiondb", "destinatorir", "destinationir", "destinationsir", "destineddir", "destionfolder", "destensiondb", "destinationsdiv", "destionDir", "estinationDir", "estinatorDir", "destinatorfolder", "destineddiv", "destinationsdir", "destinationDir", "destinatorDir", "estinatordir", "destiondir", "estinationdb", "stinationir"], "destinationDirEnding": ["destinationDirENDing", "destinationDirectoryENDer", "destinationFileEvener", "destinationDirectoryEnding", "destinationDirENDer", "destinationDirENDiting", "destinationDirENDging", "destinationDirEnditing", "destinationDirServing", "destinationDirEnder", "destinationDirEvening", "destinationDirectoryEndging", "destinationDirServding", "destinationDirEveniting", "destinationDirENDding", "destinationDirServging", "destinationDirFeedING", "destinationDirEndING", "destinationFileEndING", "destinationFileEnditing", "destinationDirENDING", "destinationDirFeeder", "destinationDirEndding", "destinationFileEnder", "destinationFileEvenING", "destinationDirEvenING", "destinationFileEveniting", "destinationDirectoryEndding", "destinationFileEnding", "destinationDirectoryEnder", "destinationDirEvener", "destinationDirectoryENDding", "destinationFileEvening", "destinationDirFeediting", "destinationDirEvenging", "destinationDirectoryENDing", "destinationDirServer", "destinationDirectoryENDging", "destinationDirEndging", "destinationDirFeeding", "destinationDirEvending"], "files": ["parents", "forms", "prints", "reports", "links", "assets", "strings", "params", "parts", "users", "items", "facts", "plates", "keys", "tools", "details", "fs", "modules", "lines", "tests", "docs", "ls", "errors", "types", "bs", "names", "qs", "classes", "iles", "uploads", "issues", "list", "words", "filename", "ames", "its", "images", "ids", "fields", "resources", "actions", "members", "projects", "events", "obs", "fixes", "objects", "headers", "ports", "mails", "states", "Files", "pages", "sections", "features", "values", "file", "lets", "bytes", "faces"], "checkdir": ["keyroom", "Checkdb", "getdir", "workdir", "getfolder", "keydir", "Checkfolder", "checkDir", "workurl", "getdb", "ckDir", "checkblock", " checkfolder", "ckdb", " checkdb", " checkurl", "workthis", "checkedfolder", " checkDir", "CheckDir", "keydb", " checkblock", "checkeddb", " checkir", "checkroom", "checkedDir", "checkfolder", "workDir", "ckfolder", "checkthis", " checkdirectory", "Checkblock", "ckroom", "checkdirectory", "ckthis", "keyfolder", "checkeddirectory", "ckurl", "getblock", "ckdir", "ckdirectory", "checkurl", "Checkroom", " checkthis", "Checkir", "Checkdirectory", "checkedir", "checkdb", "checkir", "checkeddir", "Checkdir"], "date": ["event", "year", "today", "zone", "time", "d", "resource", "doc", "set", "tag", "day", "ate", "close", "none", "when", "now", "get", "Date", "dt", "note", "cal", "month", "dat", " day", "add", "late", "use", "te", "key", "msg", "de", " Date", "ATE", "start", "iso", "diff", "file", "user", "data"], "msec": ["mcl", "gmstr", " msc", "MSec", "gmsc", "mSec", "mtcl", "cmcl", "mtstr", "cmisec", "mtsec", "mtisec", " mct", "msc", " mcl", "mstr", " mSec", "cmsc", "mct", "gmSec", "mtsc", "Msec", "Mct", "misec", "cmsec", "mtct", " mstr", "mtSec", " misec", "gmsec"], "checkFile": ["CheckFiles", " checkfile", "Checkfile", " checkFILE", "readFiles", "readFILE", "checkfile", "readSourceFile", "CheckFILE", " checkSourceFile", "readFile", "checkFiles", "updateFiles", "updateFile", "readfile", "updateSourceFile", "checkSourceFile", "updateFILE", " checkFiles", "CheckFile", "checkFILE"], "i": ["exp", "mi", "major", "ini", "j", "y", "I", "ie", "qi", "di", "im", "ri", "ei", "m", "iq", "sequence", "ki", "init", "in", "base", "hi", "me", "iu", "ti", "x", "bi", "cli", "ic", "ci", "multi", "ai", "sim", "gi", "ui", "name", "pi", "ij", "ix", "it", "ji", "xi", "li", "my", "si", "batch", "ind", "ip", "info", "key", "id", "io", "ii", "is", "gu", "index", "zi", "phi", "ex"], "f": ["fi", "fe", "u", "bf", "j", "d", "m", "fs", "fr", "fp", "fac", "t", "lf", "b", "fc", "fd", "v", "e", "fg", "tf", "fw", "uf", "l", "fo", "o", "fa", "F", "cf", "file", "ft", "fb", "p", "df", "fl"], "g": ["gl", "tg", "G", "j", "gp", "bg", "d", "m", "gd", "t", "mg", "gg", "graph", "go", "pg", "b", "gi", "ga", "v", "vg", "gy", "gc", "fg", "e", "l", "out", "gm", "ig", "gs", "s", "group", "og", "eg", "ge", "cfg", "config", "msg", "file", "gb", "p", "gu", "w"], "destinationFile": ["destationFiles", "destinationsFiles", "DestationFile", "transinationDirectory", "DestationFilename", "transinatedFile", "transinationFilename", "destarationDirectory", "destarationFilename", "DestationFiles", "destinateEmail", "destationFilename", "destarationFile", "destinatedFiles", "destinatedFile", "destinatedFilename", "transinationFiles", "destinatorDirectory", "destinateFiles", "DestinationFiles", "transinatedFiles", "transinationFile", "DestinationFilename", "destinationsFile", "destarationFiles", "destinatorFile", "transinatedDirectory", "destationFile", "destinatorFiles", "destinatorFilename", "destinationsFilename", "transinatedFilename", "DestinationEmail", "destationEmail", "DestationEmail", "destinationDirectory", "destinatedDirectory", "destinateFile", "destinationFiles", "destinateFilename", "destinationEmail", "destinationFilename", "DestinationFile", "destinationsEmail"], "sourceFile": ["sourcefile", " sourcefile", "SourceFilename", "ourceFile", "srcFilename", "sourceLine", "sourceFilename", "SourceFile", " sourceFiles", "srcLine", "SourceLine", "ourcefile", "staticFiles", "staticFILE", "sourceFiles", "srcFile", "Sourcefile", "srcfile", "SourceFILE", "staticFile", "staticfile", "SourceFiles", " sourceFILE", "ourceFilename", "sourceFILE", "ourceLine"], "infile": ["instream", "inputFile", "Instream", "outline", " instream", " inFile", "insblock", "pinfield", "outFile", "INfield", "pinline", "Inblock", " inline", "InFile", "INline", "insfile", "outblock", "INfile", "inputline", "inFile", " inblock", "insstream", "insFile", "infield", "inputfile", "inblock", "INFile", " infield", "pinfile", "pinFile", "inline", "inputblock", "Infile"], "outfile": [" outstream", " outbuffer", "outpage", "instream", "inpage", "outline", "outputline", "inview", "outputfile", "outFile", "outstream", " outlink", "outerstream", "Outstream", "outerview", "outlink", "Outfile", "OutFile", "outerbuffer", "outerfile", "inFile", " outview", "outputstream", " outFile", "outview", "inbuffer", " outline", "inline", "outbuffer", "inlink", "outputpage", "Outlink", " outpage"], "c": ["rc", "u", "p", "z", "y", "cos", "\u00e7", "cb", "d", "cr", "m", "C", "bc", "col", "t", "x", "ce", "char", "code", "k", "ca", "err", "cs", "chain", "cu", "close", "v", "conf", "e", "ct", "cache", "ac", "cp", "pc", "gc", "cm", "out", "ec", "ch", "sc", "lc", "cd", "o", "r", "unc", "mc", "count", "n", "arc", "uc", "nc", "cf", "dc", "a", "cc", "cl"]}}
{"id1": "17202158", "id2": "10445819", "code1": "    static HashSet<Integer> readZoneIDs(String zoneFileName) {\n        HashSet<Integer> zoneids = new HashSet<Integer>();\n        try {\n            URL url = zoneFileName.getClass().getResource(zoneFileName);\n            LineNumberReader lnr = new LineNumberReader(new InputStreamReader(url.openStream()));\n            String line = null;\n            while ((line = lnr.readLine()) != null) zoneids.add(Integer.parseInt(line));\n        } catch (Exception xc) {\n            xc.printStackTrace();\n        }\n        return zoneids;\n    }\n", "code2": "    private Reader getReader() throws IOException {\n        if (data != null) {\n            if (url != null) throw new IllegalArgumentException(\"URL for source data and the data itself must never be specified together.\");\n            if (charset != null) throw new IllegalArgumentException(\"Charset has sense only for URL-based data\");\n            return new StringReader(data);\n        } else if (url != null) {\n            InputStream stream = url.openStream();\n            if (charset == null) return new InputStreamReader(stream); else return new InputStreamReader(stream, charset);\n        }\n        return null;\n    }\n", "label": 0, "substitutes": {"readZoneIDs": ["readZoneNames", "readLineIDS", "readObjectID", "readLineIDs", "findZoneIDS", "readLocalNames", "readObjectNames", "readLineNames", "findZoneNames", "readZoneIDS", "findLocalIDS", "findLocalNames", "readZoneID", "readLineID", "findZoneIDs", "findLocalIDs", "readObjectIDS", "readObjectIDs", "readLocalIDS", "readLocalIDs", "readLocalID", "findLocalID", "findZoneID"], "zoneFileName": ["zonefileSource", "zoneFilenamePath", "zoneFileChain", "zoneFilenameSource", "ZoneFileSource", "ZonefileSpec", "zonefileChain", "zoneFILEType", "ZoneFilePath", "zonefileType", "zoneFilenameName", "ZonefileType", "ZonefileName", "zoneFileNames", "zoneDirPath", "zoneFILEPath", "zonefileNames", "zoneFilesNames", "zoneFolderFilename", "zoneFilesPath", "zonefileSpec", "ZonefileFilename", "zoneFolderName", "ZonefileSource", "zoneFilesName", " zoneFileNames", "zoneFILENames", "zoneDirName", "zoneFolderPath", "ZoneFileSpec", "zoneFileSpec", "zoneDirSpec", "zonefileFilename", "zoneDirSource", "zoneFileFilename", " zonefileNames", "zoneFilesChain", "ZonefilePath", "zoneFolderType", "ZoneFileFilename", "ZoneFileType", " zonefileChain", "ZoneFileName", "zoneFILEFilename", "zoneFileSource", "zoneFilenameSpec", "zoneFILEChain", "zonefileName", " zoneFileChain", " zonefileName", "zonefilePath", " zoneFilePath", "zoneFileType", " zonefilePath", "zoneFILEName", "zoneFilePath"], "zoneids": ["zoneIDs", "zonelines", "tznaires", "zaoids", " zoneuploads", "tzids", "znames", "zipIDs", "elementcodes", " zonecodes", "tzoids", "elementuploads", "zuploads", " zoneoids", "zoneoids", " zonenaires", "zids", "zanaires", "zaIDs", "zlines", " zonelines", "elementids", "tzIDs", "zIDs", "elementlines", "zoneuploads", "zaids", "zcodes", "zonenames", " zoneIDs", "zipnames", " zonenames", "zonecodes", "ziplines", "zonenaires", "zipids"], "url": ["f", "browser", "ref", "dl", "resource", "lb", "bel", "ls", "web", "ll", "base", "char", "q", "build", "log", "sl", "open", "lr", "result", "rel", "ur", "mount", "uri", "URL", "name", "str", "rl", "l", "this", "nl", "ul", "r", "ssl", "ret", "http", "file", "loc", "Url", "user", "loader", "cl"], "lnr": ["olndr", "lnn", "linr", "lenr", "lncr", "olnr", "cnp", "lndr", "nln", "lnR", "nlp", "lnp", "lendr", "olnn", "nlR", "nlcr", "lenn", "linp", "nldr", "olnR", "lenR", "nlr", "cnr", "cncr", "linrar", "nlrar", "cnrar", "lincr", "lnrar"], "line": ["phrase", "LINE", "style", "block", "lin", "text", "eline", "entry", "ine", "sample", "next", "part", "comment", "frame", "lane", "word", "ln", "sequence", "page", "stream", "stroke", "day", "char", "code", "range", "link", "log", "net", "chain", "message", "cell", "number", "e", "le", "liner", "l", "section", "nl", "point", "normal", "continue", "Line", "ge", "row", "string", "display", "inline", "file", "online", "print", "header"]}}
{"id1": "3409084", "id2": "18358467", "code1": "    protected String getRequestContent(String urlText) throws Exception {\n        URL url = new URL(urlText);\n        HttpURLConnection urlcon = (HttpURLConnection) url.openConnection();\n        urlcon.connect();\n        BufferedReader reader = new BufferedReader(new InputStreamReader(urlcon.getInputStream()));\n        String line = reader.readLine();\n        reader.close();\n        urlcon.disconnect();\n        return line;\n    }\n", "code2": "    public DocumentSummary parseDocument(URL url) throws IOException, DocumentHandlerException {\n        InputStream inputStream = null;\n        try {\n            inputStream = url.openStream();\n            POIOLE2TextExtractor extractor = createExtractor(inputStream);\n            SummaryInformation info = extractor.getSummaryInformation();\n            DocumentSummary docSummary = new DocumentSummary();\n            docSummary.authors = DocSummaryPOIFSReaderListener.getAuthors(info);\n            docSummary.contentReader = new StringReader(extractor.getText());\n            docSummary.creationDate = info.getCreateDateTime();\n            docSummary.keywords = new ArrayList();\n            docSummary.keywords.add(info.getKeywords());\n            docSummary.modificationDate = new Date(info.getEditTime());\n            docSummary.title = info.getTitle();\n            return docSummary;\n        } catch (IOException e) {\n            if (e.getMessage().startsWith(\"Unable to read entire header\")) {\n                throw new DocumentHandlerException(\"Couldn't process document\", e);\n            } else {\n                throw e;\n            }\n        } finally {\n            if (inputStream != null) {\n                inputStream.close();\n            }\n        }\n    }\n", "label": 0, "substitutes": {"getRequestContent": ["getStringBody", "getRequestBody", "getRequestEntity", "getResponseData", "getStringContent", "getResponseBody", "getQueryBody", "getRequestData", "getQueryContent", "getQueryData", "postRequestContent", "getQueryEntity", "postResponseData", "postRequestBody", "postRequestData", "getStringData", "getResponseContent", "postRequestEntity", "getResponseEntity", "postResponseEntity", "postResponseBody", "postResponseContent", "getStringEntity"], "urlText": ["urlName", "UrlString", "textText", " urlString", "urlCh", "stringCh", "uriText", "uriCh", "uritext", " urlName", "urltext", "Urltext", "textString", "textName", "stringtext", "UrlName", "urlString", " urltext", "texttext", " urlCh", "stringText", "UrlText"], "url": ["f", "browser", "hl", "gl", "ref", "google", "dl", "email", "www", "lb", "bel", "ls", "web", "ll", "base", "char", "build", "sl", "pkg", "re", "ur", "mount", "org", "uri", "URL", "str", "rl", "l", "oul", "uu", "nl", "ul", "github", "r", "ssl", "el", "auto", "http", "atl", "loc", "il", "Url", "abs"], "urlcon": ["orgcon", "httpconn", " urlconv", " urlfun", "dllcon", " urlcom", "Urlcom", "urlres", "URLcom", " urlCon", "orgCon", "urlcom", "sslfun", "dllconn", "urlconst", "httpconv", "dllconst", "UrlCon", "urlCon", "sslcon", " urlconn", "httpCon", " urlconnect", "sslCon", "httpconnect", "httpfun", "urlfun", "URLconn", "orgconnect", "httpres", "dllCon", "sslconv", "URLcon", " urlres", "urlconv", "urlconnect", "httpcon", "urlconn", "Urlconst", "httpconst", "Urlcon", "Urlconn", "orgres"], "reader": ["runner", "rar", "rc", "worker", "image", "radio", "test", "parser", "comment", "view", "ro", "stream", "inner", "Reader", "red", "buffer", "master", "readable", "dr", "reads", "roller", "rd", "review", "read", "holder", "writer", "rl", "operator", "READ", "iter", "dd", "per", "rx", "upper", "ader", "handler", "instance", "iterator", "r", "info", "row", "ner", "er", "reading", "source", "wrapper", "older", "loader", "data", "draft"], "line": ["LINE", "response", "block", "lin", "text", "eline", "sample", "ine", "entry", "piece", "column", "comment", "frame", "request", "ln", "sequence", "lines", "page", "trace", "char", "chain", "link", "command", "log", "message", "result", "cell", "list", "detail", "content", "name", "str", "l", "out", "nl", "continue", "lc", "Line", "channel", "row", "string", "inline", "file", "print", "pe", "header"]}}
{"id1": "471804", "id2": "7425022", "code1": "    public static void doVersionCheck(View view) {\n        view.showWaitCursor();\n        try {\n            URL url = new URL(jEdit.getProperty(\"version-check.url\"));\n            InputStream in = url.openStream();\n            BufferedReader bin = new BufferedReader(new InputStreamReader(in));\n            String line;\n            String version = null;\n            String build = null;\n            while ((line = bin.readLine()) != null) {\n                if (line.startsWith(\".version\")) version = line.substring(8).trim(); else if (line.startsWith(\".build\")) build = line.substring(6).trim();\n            }\n            bin.close();\n            if (version != null && build != null) {\n                if (jEdit.getBuild().compareTo(build) < 0) newVersionAvailable(view, version, url); else {\n                    GUIUtilities.message(view, \"version-check\" + \".up-to-date\", new String[0]);\n                }\n            }\n        } catch (IOException e) {\n            String[] args = { jEdit.getProperty(\"version-check.url\"), e.toString() };\n            GUIUtilities.error(view, \"read-error\", args);\n        }\n        view.hideWaitCursor();\n    }\n", "code2": "    private String transferWSDL(String wsdlURL, String userPassword) throws WiseConnectionException {\n        String filePath = null;\n        try {\n            URL endpoint = new URL(wsdlURL);\n            HttpURLConnection conn = (HttpURLConnection) endpoint.openConnection();\n            conn.setDoOutput(false);\n            conn.setDoInput(true);\n            conn.setUseCaches(false);\n            conn.setRequestMethod(\"GET\");\n            conn.setRequestProperty(\"Accept\", \"text/xml,application/xml,application/xhtml+xml,text/html;q=0.9,text/plain;q=0.8,image/png,*/*;q=0.5\");\n            conn.setRequestProperty(\"Connection\", \"close\");\n            if (userPassword != null) {\n                conn.setRequestProperty(\"Authorization\", \"Basic \" + (new BASE64Encoder()).encode(userPassword.getBytes()));\n            }\n            InputStream is = null;\n            if (conn.getResponseCode() == 200) {\n                is = conn.getInputStream();\n            } else {\n                is = conn.getErrorStream();\n                InputStreamReader isr = new InputStreamReader(is);\n                StringWriter sw = new StringWriter();\n                char[] buf = new char[200];\n                int read = 0;\n                while (read != -1) {\n                    read = isr.read(buf);\n                    sw.write(buf);\n                }\n                throw new WiseConnectionException(\"Remote server's response is an error: \" + sw.toString());\n            }\n            File outputDir = new File(wiseProperties.getProperty(\"wise.tmpDir\"));\n            if (!outputDir.exists()) {\n                outputDir.mkdir();\n                wiseProperties.setProperty(\"wise.forceImportObject\", \"true\");\n            }\n            File file = new File(wiseProperties.getProperty(\"wise.tmpDir\"), new StringBuffer(\"Wise\").append(IDGenerator.nextVal()).append(\".xml\").toString());\n            OutputStream fos = new BufferedOutputStream(new FileOutputStream(file));\n            IOUtils.copyStream(fos, is);\n            fos.close();\n            is.close();\n            filePath = file.getPath();\n        } catch (WiseConnectionException wce) {\n            throw wce;\n        } catch (Exception e) {\n            throw new WiseConnectionException(\"Wsdl download failed!\", e);\n        }\n        return filePath;\n    }\n", "label": 0, "substitutes": {"doVersionCheck": ["DoDatecheck", "doDateCheck", "doVersionsCheck", "DoDateFix", "doVersionFix", "doLicensecheck", "DoVersioncheck", "DoVersionCheck", "DoVersionFix", "DoDateCheck", "doDateUpdate", "doDateFix", "DoDateUpdate", "DoVersionUpdate", "doVersionsUpdate", "doVersionsFix", "doDatecheck", "doVersionUpdate", "doLicenseFix", "doVersionscheck", "doLicenseCheck", "doVersioncheck", "doLicenseUpdate"], "view": ["browser", "report", "window", "hl", "cv", "layout", "image", "block", "subject", "util", "console", "engine", "client", "doc", "VIEW", "tv", "views", "table", "help", "context", "web", "page", "update", "q", "buffer", "open", "document", "call", "cell", "v", "widget", "review", "see", "iew", "host", "get", "input", "out", "wrapper", "query", "this", "controller", "tree", "form", "show", "component", "blade", "eye", "model", "View", "manager", "self", "row", "http", "html", "server", "file", "check", "index", "print", "display"], "url": ["f", "browser", "hl", "gl", "address", "json", "dl", "lb", "client", "bel", "web", "ls", "ll", "char", "date", "link", "pl", "sl", "log", "b", "lr", "rel", "ur", "v", "mount", "org", "uri", "URL", "str", "rl", "l", "oul", "nl", "ul", "path", "null", "language", "github", "r", "ssl", "http", "html", "socket", "string", "location", "file", "loc", "Url", "id", "host"], "in": ["f", "rin", "inn", "gin", "IN", "vin", "ins", "reader", "ln", "stream", "In", "init", "inner", "b", "asin", "kin", "i", "mat", "inc", "l", "input", "out", "sin", " IN", " din", "ain", "mn", "info", "n", "din", "inf", "is", "isin", "source", "file", "body", "cin"], "bin": ["rin", " Bin", "win", "inn", "buff", "stock", "by", "gin", "con", "bl", "bg", "cos", "obin", "reader", "bur", "ln", "bed", "pipe", "inner", "mem", "bi", "spin", "buffer", "b", "mon", "thin", "ran", "nb", " bins", "lib", "abin", "cache", "rb", "out", "sin", "len", " din", "conn", "binary", "local", "din", "sam", "file", "bn", "cin", "ebin", "loader"], "line": ["LINE", "lo", "style", "lin", "block", "text", "cat", "eline", "entry", "ine", "sample", "column", "part", "comment", "frame", "lane", "se", "ln", "ide", "word", "lines", "page", "ls", "col", "level", "base", "trace", "char", "chain", "range", "link", "log", "code", "one", "err", "load", "port", "cell", "ice", "state", "le", "liner", "l", "section", "iter", "cmd", "point", "path", "record", "Line", "el", "channel", " Line", "row", "string", "job", "no", "field", "inline", "file", "body", "store", "print"], "version": ["type", "browser", "ion", "translation", "major", "video", "license", "image", "value", "virtual", "match", "test", "versions", "serial", "release", "feature", "resource", "description", "client", "sequence", "river", "status", "tag", "VER", "Version", "software", "spec", "date", "command", "v", "number", "format", "vision", "name", "position", "hash", "project", "form", "language", "info", "key", "volume", "string", "scale", "vers", "usage", "iso", "VERSION", "latest", "index", "ver", "update", "python", "title"], "build": ["building", "style", "built", "match", "test", "fail", "util", "release", "builder", "other", "update", "tag", "work", "date", "link", "round", "ship", "log", "th", "load", "b", "old", "be", "db", "hold", "lib", "hash", "last", "Build", "project", "boost", "binary", "add", "use", "bor", "ble", "full", "make", "uild", "arch", "dist", "bug", "develop", "install", "where", "latest", "ward", "ver", "unit", "dev", "print", "struct"]}}
{"id1": "19584877", "id2": "19849797", "code1": "    public static boolean encodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.ENCODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "code2": "    public static void copyFile(File sourceFile, File destFile) throws IOException {\n        if (!destFile.exists()) {\n            destFile.createNewFile();\n        }\n        FileChannel source = null;\n        FileChannel destination = null;\n        try {\n            source = new FileInputStream(sourceFile).getChannel();\n            destination = new FileOutputStream(destFile).getChannel();\n            destination.transferFrom(source, 0, source.size());\n        } finally {\n            if (source != null) {\n                source.close();\n            }\n            if (destination != null) {\n                destination.close();\n            }\n        }\n    }\n", "label": 1, "substitutes": {"encodeFileToFile": ["encodeStringAsFile", "encodeFileToFiles", "encodeFileToDisk", "encodeFileAsFile", "encodeStringToFile", "encodeFileToStream", "encodeFileFromFiles", "encodeStringAsDisk", "encodeStringAsStream", "encodeFiletoFile", "encodeFileAsStream", "encodeStringToDisk", "encodeFileAsDisk", "encodeFiletoDisk", "encodeFiletoFiles", "encodeStringToFiles", "encodeFileFromStream", "encodeFileAsFiles", "encodeFileFromDisk", "encodeStringAsFiles", "encodeFiletoStream", "encodeFileFromFile", "encodeStringToStream"], "infile": ["inputfilename", "inputFile", "outbase", "outFile", " inFile", "inpath", " inbase", " infilename", "outfilename", "inbase", "InFile", "infilename", "inFile", "inputfile", "Inbase", "inputpath", " inpath", "Inpath", "outpath", "Infile"], "outfile": ["outfp", "newFile", "outname", "newfile", "indir", " outname", "outFile", "outdir", "fromfile", "outfilename", "inname", "newname", " outfilename", "tofp", "infilename", "todir", "inFile", "infp", "toFile", "newfilename", "fromfp", " outFile", "fromdir", "tofile", "fromFile"], "in": ["rin", "en", "image", "inn", "ini", "by", "gin", "con", "IN", "ins", "pin", "im", "ar", "on", "oin", "ro", "al", "In", "t", "inner", "inside", "init", "re", "up", "i", "bin", "get", "inc", "input", "amin", "or", "iter", "it", "per", " din", "form", "conn", "ain", "ind", "nin", "info", "din", "inf", "is", "isin", "source", "cin", "id", "from"], "out": ["ion", "co", "en", "nt", "flush", "con", "output", "res", "oss", "cn", "on", "sys", "t", "inner", "net", "write", "print", "b", "to", "end", "opt", "up", "writer", "os", "outer", "it", "OU", "gt", "null", "ou", "at", "outs", "g", "o", "aos", "ex", "n", "io", "Out", "file", "fn", "OUT", "can", "ne", "ot"], "buffer": ["phrase", "buf", "window", "bone", "block", "buff", "sample", "column", "frame", "comment", "view", "sequence", "append", "table", "pad", "library", "mem", "base", "template", "command", "attribute", "document", "message", "available", "stack", "number", "cache", "Buffer", "variable", "black", "total", "initial", "note", "history", "paste", "queue", "length", "binary", "batch", "bar", "padding", "info", "row", "display", "temp", "button", "password", "memory", "print", "header", "character"], "read": ["first", "each", "text", "find", "select", "reader", "wait", "allow", "raw", "stream", "set", "run", "before", "range", "write", "open", "push", "readable", "load", "print", "reads", "hold", "seek", "close", "i", "req", "skip", "get", " Read", "give", "input", "need", "iter", "through", "query", "len", "length", "Read", "ind", "add", "connect", "count", "n", "ready", "start", "size", "reading", "send", "check", "index", "READ", "end", "ok"], "success": ["first", "same", "good", "response", "value", " succ", "ceed", "cess", "positive", "fail", "city", "release", " successful", "summary", "please", "status", " Success", "ith", "accept", "Success", "danger", "done", "ratulations", "ccess", "growth", "warning", "primary", "result", "safe", " okay", "second", "unity", "crit", "condition", "successful", " failure", "sufficient", "error", "valid", "complete", "commit", "snap", "democracy", "continue", "photo", "surv", "successfully", "town", "submit", "support", " successes", "setup", "ok"]}}
{"id1": "693636", "id2": "8801436", "code1": "    public static int createEmptyCart() {\n        int SHOPPING_ID = 0;\n        Connection con = null;\n        try {\n            con = getConnection();\n        } catch (java.lang.Exception ex) {\n            ex.printStackTrace();\n        }\n        try {\n            PreparedStatement insert_cart = null;\n            SHOPPING_ID = Integer.parseInt(Sequence.getSequenceNumber(\"shopping_cart\"));\n            insert_cart = con.prepareStatement(\"INSERT INTO shopping_cart (sc_id, sc_time) VALUES ( ? , NOW() )\");\n            insert_cart.setInt(1, SHOPPING_ID);\n            insert_cart.executeUpdate();\n            con.commit();\n            insert_cart.close();\n            returnConnection(con);\n        } catch (java.lang.Exception ex) {\n            try {\n                con.rollback();\n                ex.printStackTrace();\n            } catch (Exception se) {\n                System.err.println(\"Transaction rollback failed.\");\n            }\n        }\n        return SHOPPING_ID;\n    }\n", "code2": "    public static void copy(File from_file, File to_file) throws IOException {\n        if (!from_file.exists()) abort(\"FileCopy: no such source file: \" + from_file.getName());\n        if (!from_file.isFile()) abort(\"FileCopy: can't copy directory: \" + from_file.getName());\n        if (!from_file.canRead()) abort(\"FileCopy: source file is unreadable: \" + from_file.getName());\n        if (to_file.isDirectory()) to_file = new File(to_file, from_file.getName());\n        if (to_file.exists()) {\n            if (!to_file.canWrite()) abort(\"FileCopy: destination file is unwriteable: \" + to_file.getName());\n        } else {\n            String parent = to_file.getParent();\n            if (parent == null) parent = System.getProperty(\"user.dir\");\n            File dir = new File(parent);\n            if (!dir.exists()) abort(\"FileCopy: destination directory doesn't exist: \" + parent);\n            if (dir.isFile()) abort(\"FileCopy: destination is not a directory: \" + parent);\n            if (!dir.canWrite()) abort(\"FileCopy: destination directory is unwriteable: \" + parent);\n        }\n        FileInputStream from = null;\n        FileOutputStream to = null;\n        try {\n            from = new FileInputStream(from_file);\n            to = new FileOutputStream(to_file);\n            byte[] buffer = new byte[4096];\n            int bytes_read;\n            while ((bytes_read = from.read(buffer)) != -1) {\n                to.write(buffer, 0, bytes_read);\n            }\n        } finally {\n            if (from != null) try {\n                from.close();\n            } catch (IOException e) {\n                ;\n            }\n            if (to != null) try {\n                to.close();\n            } catch (IOException e) {\n            }\n        }\n    }\n", "label": 0, "substitutes": {"createEmptyCart": ["createEmptyOrder", " createEmptyProduct", " createNewCart", "createThisTransaction", "createZeroTransaction", " createEmptyOrder", "createNewTransaction", "createThisCart", "createEmptyTransaction", "createNewProduct", "createNewCart", "createEmptyProduct", " createEmptyTransaction", "createThisProduct", "createZeroProduct", " createNewOrder", " createNewProduct", "createNewOrder", "createZeroOrder", " createNewTransaction", "createZeroCart", "createThisOrder"], "SHOPPING_ID": ["SHOPPAP_UID", "SHOPPING_URL", "SHOPPAP_ID", "SHOPPINGINGIDS", "SHOPPING_VID", "SHOPPAP_IDS", "SHOPPINGIdID", "SHOPPTINGIDID", "SHOPPINGINGNUM", "SHOPPING_NUM", "SHOPPING_IDS", "SHOPPINGIdVID", "SHOPPINGITNUM", "SHOPPINGINGID", "SHOPPINGVALID", "SHOPPOT_IDs", "SHOPPIP_UID", "SHOPPINGVALid", "SHOPPINGIDID", "SHOPPINGITUID", "SHOPPINGIdNAME", "SHOPPOT_UID", "SHOPPIP_id", "SHOPPTING_VID", "SHOPPINGINGId", "SHOPPTING_URL", "SHOPPINGITID", "SHOPPINGIDVID", "SHOPPING_id", "SHOPPINGIDId", "SHOPPTINGIDVID", "SHOPPTINGIDURL", "SHOPPTING_NAME", "SHOPPINGPUID", "SHOPPOT_ID", "SHOPPTINGIDNAME", "SHOPPOTINGNUM", "SHOPPOTINGIDs", "SHOPPINGITIDs", "SHOPPINGIDNAME", "SHOPPOT_NUM", "SHOPPINGINGIDs", "SHOPPINGPNUM", "SHOPPINGINGUID", "SHOPPINGIDIDS", "SHOPPAP_Id", "SHOPPOTINGUID", "SHOPPINGVALUID", "SHOPPOTINGID", "SHOPPING_UID", "SHOPPINGPIDs", "SHOPPINGIDURL", "SHOPPINGPID", "SHOPPING_Id", "SHOPPING_NAME", "SHOPPINGIDUID", "SHOPPINGIdURL", "SHOPPING_IDs", "SHOPPTING_ID", "SHOPPIP_ID"], "con": ["co", "en", "rc", "win", "cat", "ctx", "cos", "dial", "cn", "cont", "bo", "cover", "ln", "client", "col", "conv", "cons", "connection", "po", "CON", "c", "ca", "bon", "fc", "open", "pg", "cur", "soc", "db", "re", "un", "conf", "com", "xc", "ct", "ran", "cp", "gc", "Conn", "pc", "coll", "const", "pen", "ch", "cal", " conn", "conn", "ctrl", "ain", "connect", "ren", "mc", "nc", "cf", "pool", "can", "Con", "cc", "ex"], "insert_cart": ["insert___cart", "insert_art", "insert2cod", "import___art", "insertPpt", "insert_cod", "entryMemarticle", "insertMemarticle", "insertPcontroller", "entry_art", " insert_art", "insert_controller", "insert___pt", "insert2cart", " insert_quant", "entryMemcart", "insertptquant", "import_art", "entryMemprogress", " insert_start", "import_Cart", "insertThearticle", "insertptcart", "insertingstart", "insert_progress", "entry_article", " insert2pt", "insertPTcart", "entryMemart", " insert2art", "import_controller", "insert___art", " insert2quant", "insert_start", "insert_pt", "insertTheart", "insert_pot", "insertMemart", " insert_cod", "insert_article", "insert2Cart", "insert2art", "entry_cart", "import_cart", " insert2start", "insertTheprogress", " insert2cod", "insertingart", "insert2progress", "insertptart", "insertPTart", "import_pot", "insertMemcart", "insert2pot", "insertingcart", "insertPart", "insert2quant", "import_pt", "insert2start", "insertPTcod", "import___controller", "import___pt", "entry_progress", "insertPTquant", "insertThecart", "insertMemprogress", "insert2pt", "insert_Cart", "insert2controller", "insert___controller", "import___cart", "insertptcod", " insert_pt", "insert2article", "insert_quant", "insertPcart", "insertingpt", " insert2cart"]}}
{"id1": "1133123", "id2": "7149578", "code1": "            @Override\n            protected Reader openConnection(URL url) throws IOException {\n                try {\n                    if (limit != null) {\n                        limit.acquirePermit();\n                    }\n                    return super.openConnection(url);\n                } catch (InterruptedException e) {\n                    throw new IOException(e);\n                }\n            }\n", "code2": "    @Override\n    protected void parseContent(StreamLimiter streamLimiter, LanguageEnum forcedLang) throws IOException {\n        String charset = null;\n        IndexDocument sourceDocument = getSourceDocument();\n        if (sourceDocument != null && urlItemFieldEnum != null) {\n            FieldValueItem fieldValueItem = sourceDocument.getFieldValue(urlItemFieldEnum.contentTypeCharset.getName(), 0);\n            if (fieldValueItem != null) charset = fieldValueItem.getValue();\n            if (charset == null) {\n                fieldValueItem = sourceDocument.getFieldValue(urlItemFieldEnum.contentEncoding.getName(), 0);\n                if (fieldValueItem != null) charset = fieldValueItem.getValue();\n            }\n        }\n        boolean charsetWasNull = charset == null;\n        if (charsetWasNull) charset = getProperty(ClassPropertyEnum.DEFAULT_CHARSET).getValue();\n        StringWriter writer = new StringWriter();\n        IOUtils.copy(streamLimiter.getNewInputStream(), writer, charset);\n        addField(ParserFieldEnum.htmlSource, writer.toString());\n        writer.close();\n        HtmlDocumentProvider htmlProvider = findBestProvider(charset, streamLimiter);\n        if (htmlProvider == null) return;\n        addField(ParserFieldEnum.htmlProvider, htmlProvider.getName());\n        String contentType = htmlProvider.getMetaHttpEquiv(\"content-type\");\n        String contentTypeCharset = null;\n        if (contentType != null) {\n            contentTypeCharset = MimeUtils.extractContentTypeCharset(contentType);\n            if (contentTypeCharset != null && !contentTypeCharset.equals(charset)) charsetWasNull = true;\n        }\n        if (charsetWasNull) {\n            if (contentTypeCharset != null) charset = contentTypeCharset; else charset = htmlProvider.getMetaCharset();\n            if (charset != null) htmlProvider = findBestProvider(charset, streamLimiter);\n        }\n        HtmlNodeAbstract<?> rootNode = htmlProvider.getRootNode();\n        if (rootNode == null) return;\n        for (HtmlNodeAbstract<?> metaNode : htmlProvider.getMetas()) {\n            String metaName = metaNode.getAttributeText(\"name\");\n            if (metaName != null && metaName.startsWith(OPENSEARCHSERVER_FIELD)) {\n                String field = metaName.substring(OPENSEARCHSERVER_FIELD_LENGTH);\n                String[] fields = field.split(\"\\\\.\");\n                if (fields != null) {\n                    String content = metaNode.getAttributeText(\"content\");\n                    addDirectFields(fields, content);\n                }\n            }\n        }\n        addField(ParserFieldEnum.charset, charset);\n        addFieldTitle(htmlProvider.getTitle());\n        String metaRobots = null;\n        String metaDcLanguage = null;\n        String metaContentLanguage = null;\n        for (HtmlNodeAbstract<?> node : htmlProvider.getMetas()) {\n            String attr_name = node.getAttributeText(\"name\");\n            String attr_http_equiv = node.getAttributeText(\"http-equiv\");\n            if (\"keywords\".equalsIgnoreCase(attr_name)) addField(ParserFieldEnum.meta_keywords, HtmlDocumentProvider.getMetaContent(node)); else if (\"description\".equalsIgnoreCase(attr_name)) addField(ParserFieldEnum.meta_description, HtmlDocumentProvider.getMetaContent(node)); else if (\"robots\".equalsIgnoreCase(attr_name)) metaRobots = HtmlDocumentProvider.getMetaContent(node); else if (\"dc.language\".equalsIgnoreCase(attr_name)) metaDcLanguage = HtmlDocumentProvider.getMetaContent(node); else if (\"content-language\".equalsIgnoreCase(attr_http_equiv)) metaContentLanguage = HtmlDocumentProvider.getMetaContent(node);\n        }\n        boolean metaRobotsFollow = true;\n        boolean metaRobotsNoIndex = false;\n        if (metaRobots != null) {\n            metaRobots = metaRobots.toLowerCase();\n            if (metaRobots.contains(\"noindex\")) {\n                metaRobotsNoIndex = true;\n                addField(ParserFieldEnum.meta_robots, \"noindex\");\n            }\n            if (metaRobots.contains(\"nofollow\")) {\n                metaRobotsFollow = false;\n                addField(ParserFieldEnum.meta_robots, \"nofollow\");\n            }\n        }\n        UrlFilterItem[] urlFilterList = getUrlFilterList();\n        List<HtmlNodeAbstract<?>> nodes = rootNode.getAllNodes(\"a\", \"frame\");\n        IndexDocument srcDoc = getSourceDocument();\n        if (srcDoc != null && nodes != null && metaRobotsFollow) {\n            URL currentURL = htmlProvider.getBaseHref();\n            if (currentURL == null && urlItemFieldEnum != null) {\n                FieldValueItem fvi = srcDoc.getFieldValue(urlItemFieldEnum.url.getName(), 0);\n                if (fvi != null) currentURL = new URL(fvi.getValue());\n            }\n            for (HtmlNodeAbstract<?> node : nodes) {\n                String href = null;\n                String rel = null;\n                String nodeName = node.getNodeName();\n                if (\"a\".equals(nodeName)) {\n                    href = node.getAttributeText(\"href\");\n                    rel = node.getAttributeText(\"rel\");\n                } else if (\"frame\".equals(nodeName)) {\n                    href = node.getAttributeText(\"src\");\n                }\n                boolean follow = true;\n                if (rel != null) if (rel.contains(\"nofollow\")) follow = false;\n                URL newUrl = null;\n                if (href != null) if (!href.startsWith(\"javascript:\")) if (currentURL != null) newUrl = LinkUtils.getLink(currentURL, href, urlFilterList);\n                if (newUrl != null) {\n                    ParserFieldEnum field = null;\n                    if (newUrl.getHost().equalsIgnoreCase(currentURL.getHost())) {\n                        if (follow) field = ParserFieldEnum.internal_link; else field = ParserFieldEnum.internal_link_nofollow;\n                    } else {\n                        if (follow) field = ParserFieldEnum.external_link; else field = ParserFieldEnum.external_link_nofollow;\n                    }\n                    addField(field, newUrl.toExternalForm());\n                }\n            }\n        }\n        if (!metaRobotsNoIndex) {\n            nodes = rootNode.getNodes(\"html\", \"body\");\n            if (nodes == null || nodes.size() == 0) nodes = rootNode.getNodes(\"html\");\n            if (nodes != null && nodes.size() > 0) {\n                StringBuffer sb = new StringBuffer();\n                getBodyTextContent(sb, nodes.get(0), true, null);\n                addField(ParserFieldEnum.body, sb);\n            }\n        }\n        Locale lang = null;\n        String langMethod = null;\n        String[] pathHtml = { \"html\" };\n        nodes = rootNode.getNodes(pathHtml);\n        if (nodes != null && nodes.size() > 0) {\n            langMethod = \"html lang attribute\";\n            String l = nodes.get(0).getAttributeText(\"lang\");\n            if (l != null) lang = Lang.findLocaleISO639(l);\n        }\n        if (lang == null && metaContentLanguage != null) {\n            langMethod = \"meta http-equiv content-language\";\n            lang = Lang.findLocaleISO639(metaContentLanguage);\n        }\n        if (lang == null && metaDcLanguage != null) {\n            langMethod = \"meta dc.language\";\n            lang = Lang.findLocaleISO639(metaDcLanguage);\n        }\n        if (lang != null) {\n            addField(ParserFieldEnum.lang, lang.getLanguage());\n            addField(ParserFieldEnum.lang_method, langMethod);\n        } else if (!metaRobotsNoIndex) lang = langDetection(10000, ParserFieldEnum.body);\n    }\n", "label": 0, "substitutes": {"openConnection": ["OpenChannel", "OpenLink", "createChannel", "OpenConnection", "createClient", "openChannel", "createSession", "newConnection", " openSession", " openClient", "openSession", "readReader", "newSession", " openChannel", "openLink", "createConnection", "newChannel", " openLink", "openClient", "readChannel", "newClient", "readConnection", "openReader", "OpenReader", " openReader", "readLink"], "url": ["address", "ref", "dl", "util", "page", "web", "ll", "base", "link", "build", "log", "sl", "q", "b", "load", "pl", "xml", "ur", "uri", "URL", "name", "str", "rl", "l", "nl", "ul", "mail", "path", "rect", "ssl", "ret", "http", "location", "string", "file", "loc", "ld", "Url", "host"]}}
{"id1": "11546108", "id2": "5744992", "code1": "    @Override\n    public void run() {\n        try {\n            BufferedReader in = new BufferedReader(new InputStreamReader(new URL(urlInfo).openStream()));\n            String ligneEnCours;\n            int i = 0;\n            informations = \"\";\n            while ((ligneEnCours = in.readLine()) != null) {\n                switch(i) {\n                    case 0:\n                        version = ligneEnCours;\n                        break;\n                    case 1:\n                        url = ligneEnCours;\n                        break;\n                    default:\n                        informations += ligneEnCours + '\\n';\n                        break;\n                }\n                i++;\n            }\n            in.close();\n            erreur = false;\n        } catch (IOException e) {\n            erreur = true;\n            texteErreur = e.getMessage();\n            if (texteErreur.equals(\"Network is unreachable\")) {\n                texteErreur = \"Pas de r\u00e9seau\";\n                numErreur = 1;\n            }\n            if (e instanceof FileNotFoundException) {\n                texteErreur = \"Probl\u00e8me param\u00e9trage\";\n                numErreur = 2;\n            }\n            e.printStackTrace();\n        } finally {\n            for (ActionListener al : listeners) {\n                al.actionPerformed(null);\n            }\n        }\n    }\n", "code2": "    public void dorequest(Map<String, String> ps, String method) throws IOException {\n        StringBuffer httpResponse = new StringBuffer();\n        URL ourl = new URL(url);\n        HttpURLConnection httpConnection = (HttpURLConnection) ourl.openConnection();\n        httpConnection.setRequestMethod(method);\n        httpConnection.setDoOutput(true);\n        this.setCookie(httpConnection);\n        OutputStream httpOutputStream = httpConnection.getOutputStream();\n        StringBuffer postParams = new StringBuffer(\"\");\n        for (Entry<String, String> entry : ps.entrySet()) {\n            postParams.append(entry.getKey());\n            postParams.append(\"=\");\n            postParams.append(entry.getValue());\n            postParams.append(\"&\");\n        }\n        httpOutputStream.write(postParams.toString().getBytes());\n        BufferedReader httpBufferedReader = new BufferedReader(new InputStreamReader(httpConnection.getInputStream()));\n        httpResponse.append(this.readBufferedContent(httpBufferedReader));\n        text = httpResponse.toString();\n        this.readCookie(httpConnection);\n    }\n", "label": 0, "substitutes": {"run": ["runner", "scan", "block", "process", "find", " runs", "sample", "func", "hello", "execute", "wait", "launch", "runs", "go", "impl", "call", "invoke", "search", "running", " Run", "Run", "start", "exec", "submit", "apply", "evaluate", "loop", "render"], "in": ["f", "all", "rin", "inn", "and", "by", "gin", "IN", "ins", "reader", "ln", "on", "oin", "sum", "In", "inner", "asin", "conf", "read", "bin", "copy", "get", "inc", "l", "input", "out", " din", "again", "line", "add", "r", "ma", "mn", "mc", "info", "din", "inf", "er", "is", "isin", "source", "file", "fin", "cin", "p", "from"], "ligneEnCours": ["ligneEnNourses", "ligneEnNurs", "ligneENcours", "ligneEnCsurs", "ligneEnACears", "ligneEnCores", "ligneENConturs", "ligneENNourses", "ligneEnConturs", "ligneEnCRS", "ligneEnACour", "ligneENcour", "ligneENContRS", "ligneConCurs", "ligneEnContChamp", "ligneEnACours", "ligneEnCoons", "ligneENCears", "ligneEnNours", "ligneENContours", "ligneEnContours", "ligneEnCurs", "ligneConCour", "ligneENCurs", "ligneENcurs", "ligneEnCodes", "ligneEnCons", "ligneEnClours", "ligneEnCuours", "ligneENNres", "ligneEnCour", "ligneEnClRS", "ligneENCourses", "ligneEnCourses", "ligneEnCsour", "ligneEnCsours", "ligneEncurs", "ligneENCour", "ligneEnClurs", "ligneEnChour", "ligneENCChamp", "ligneEnClChamp", "ligneConCours", "ligneEnNres", "ligneENCons", "ligneEnCres", "ligneConCodes", "ligneEncears", "ligneEnChurs", "ligneENCsours", "ligneENCsour", "ligneENNurs", "ligneEnChours", "ligneEnCuChamp", "ligneEnChodes", "ligneConcodes", "ligneENCres", "ligneENCsons", "ligneEnCoours", "ligneEncons", "ligneEnCChamp", "ligneEnCoourses", "ligneEnCoodes", "ligneEnCoour", "ligneEnCsons", "ligneEnCuurs", "ligneENContChamp", "ligneENcears", "ligneENCsurs", "ligneEnCears", "ligneEnContRS", "ligneENNours", "ligneEnACurs", "ligneConcour", "ligneConcours", "ligneConcurs", "ligneEncour", "ligneEnCuRS", "ligneEncours", "ligneENCours", "ligneENCRS", "ligneEncodes"], "i": ["mi", "ini", "j", "y", "I", "di", "ei", "m", "init", "x", " j", "t", "iu", "ti", "bi", "b", "cli", "ci", "multi", "ai", "ui", "e", "off", "v", "asi", "pi", "l", "iter", "it", "phi", "li", "ori", "xi", "si", "continue", "g", "ind", "n", "io", "ii", "is", "oi", " I", "index", "p", "ix"], "informations": ["Informsators", "Informsation", "InformsATIONS", "Informates", "instrATIONS", "informsations", "inflions", "inflATIONS", "ingenerATIONS", "informATIONS", "inflates", "instrations", "inflators", "instrators", "informsions", "Informsions", "inflation", "InformATIONS", "information", "ingenerions", "informators", "Informators", "ingenerations", "inflations", "informsates", "Informsations", "Information", "Informions", "informsation", "informsATIONS", "informsators", "informates", "informions", "Informations", "instration", "Informsates", "ingenerates"], "version": ["type", "major", "value", "versions", "serial", "part", "description", "client", "sequence", "status", "port", "label", "action", "v", "format", "program", "number", "position", "channel", "id", "VERSION", "source", "edition", "index", "ver", "class", "server", "title"], "url": ["browser", "address", "resource", "base", "link", "label", "filename", "format", "uri", "URL", "str", "l", "path", "pattern", "domain", "href", "http", "location", "download", "file", "source", "loc", "Url", "id", "print", "host", "title"], "texteErreur": ["texteErbreure", "texteErreurred", "texteErruleurred", "texteErriur", "texteErreult", "texteErleur", "texteErreul", "texteCorreult", "texteErneur", "texteErrorbreur", "texteCorreut", "texteErneurred", "texteCorreure", "texteErrur", "texteErREur", "texteStrreurred", "texteErrorreuer", "texteStrneurs", "texteErrorreure", "texteErreura", "texteErrUR", "texteCorseult", "texteErbreur", "texteErrorbreUR", "texteCorseur", "texteIrbreura", "texteIrbreUR", "texteCorseure", "texteErseur", "texteErreure", "texteErrorreUR", "texteErleure", "texteErseul", "texteErleUR", "texteErseure", "texteErrerurs", "texteErruleurs", "texteErrorbreuer", "texteErbreuer", "texteErreurs", "texteErruer", "texteIrreura", "texteErrut", "texteIrbreur", "texteErREut", "texteErseult", "texteIrreUR", "texteErREult", "texteStrreur", "texteErrerur", "texteErneurs", "texteErriUR", "texteErruleur", "texteIrreur", "texteErrorreur", "texteCorseut", "texteErrure", "texteCorreur", "texteErbreUR", "texteErreUR", "texteStrreurs", "texteErrerurred", "texteErseura", "texteErreuer", "texteErseUR", "texteStrneurred", "texteErbreura", "texteStrneur", "texteErseut", "texteErriura", "texteIrbreul", "texteErrult", "texteIrreul", "texteErbreul", "texteErleuer", "texteErrorbreure", "texteErreut", "texteErriul", "texteErREure"], "numErreur": ["numErneau", "numErReur", "numErreUR", "numerReUR", "numErr\u00e9ur", "numErneurs", "numErbreau", "numErreurs", "numErReurs", "numerReiber", "numErbreur", "numErr\u00e9iber", "numErReUR", "numerreur", "numerReurs", "numErReau", "numerreurs", "numErr\u00e9UR", "numerreUR", "numErneur", "numErbreiber", "numErr\u00e9urs", "numerreiber", "numErbreUR", "numErbreurs", "numErReiber", "numErreiber", "numErneUR", "numErreau", "numerReur"], "al": ["all", "ali", "ale", "alf", "aval", " sal", " cal", "bl", "stal", "bal", "tal", "af", "ar", "wal", "sal", "alog", "alon", " mal", "Al", "ial", "fal", "atal", "hal", "mal", "sel", "l", "dal", " bl", "pal", "AL", "cal", "ap", "ad", " hal", "el", " bal", " recal", "alist", "als", " wal", "att", "ral", "ald", "a", " tal", " fal", " aval"]}}
{"id1": "20267500", "id2": "13657103", "code1": "    public static AudioInputStream getWavFromURL(String urlstr) {\n        URL url;\n        AudioInputStream ais = null;\n        try {\n            url = new URL(urlstr);\n            URLConnection c = url.openConnection();\n            c.connect();\n            InputStream stream = c.getInputStream();\n            ais = new AudioInputStream(stream, playFormat, AudioSystem.NOT_SPECIFIED);\n            LOG.debug(\"[getWavFromURL]Getting audio from URL: {0}\");\n        } catch (MalformedURLException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return ais;\n    }\n", "code2": "    private void forBundle(BundleManipulator manip) {\n        ByteArrayOutputStream bout = null;\n        try {\n            bout = new ByteArrayOutputStream();\n            ZipOutputStream zout = new ZipOutputStream(bout);\n            Bundle bundle = getBundle();\n            Enumeration<URL> files = bundle.findEntries(\"/\", \"*.vm\", false);\n            if (files != null) {\n                while (files.hasMoreElements()) {\n                    URL url = files.nextElement();\n                    String name = url.getFile();\n                    if (name.startsWith(\"/\")) {\n                        name = name.substring(1);\n                    }\n                    if (manip.includeEntry(name)) {\n                        zout.putNextEntry(new ZipEntry(name));\n                        IOUtils.copy(url.openStream(), zout);\n                    }\n                }\n            }\n            manip.finish(bundle, zout);\n            Manifest mf = new Manifest(bundle.getEntry(\"META-INF/MANIFEST.MF\").openStream());\n            zout.putNextEntry(new ZipEntry(\"META-INF/MANIFEST.MF\"));\n            mf.write(zout);\n            zout.close();\n            File tmpFile = File.createTempFile(TEMPLATES_SYMBOLIC_NAME, \".jar\");\n            FileUtils.writeByteArrayToFile(tmpFile, bout.toByteArray());\n            if (pluginAccessor.getPlugin(TEMPLATES_SYMBOLIC_NAME) != null) {\n                pluginController.uninstall(pluginAccessor.getPlugin(TEMPLATES_SYMBOLIC_NAME));\n            } else if (pluginAccessor.getPlugin(TEMPLATES_PLUGIN_KEY) != null) {\n                pluginController.uninstall(pluginAccessor.getPlugin(TEMPLATES_PLUGIN_KEY));\n            }\n            pluginController.installPlugin(new JarPluginArtifact(tmpFile));\n            ServiceReference ref = bundleContext.getServiceReference(PackageAdmin.class.getName());\n            ((PackageAdmin) bundleContext.getService(ref)).refreshPackages(null);\n            tmpFile.delete();\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            IOUtils.closeQuietly(bout);\n        }\n    }\n", "label": 0, "substitutes": {"getWavFromURL": ["getWapFromURI", "getWapfromString", "getWavFromUrl", "getWapFromString", "getWavfromURL", "getWavfromString", "getWavfromUrl", "getWapfromURI", "getWapFromUrl", "getWavByURI", "getWapfromUrl", "getWapfromURL", "getWavByString", "getWavByURL", "getWavFromString", "getWavByUrl", "getWavfromURI", "getWavFromURI", "getWapFromURL"], "urlstr": ["URLr", "strSTR", "strstring", "urlstring", "strr", " urlstring", "dlstring", "dlstr", "Urlstr", "URLSTR", "URLstring", "Urlstring", "Urlname", " urlname", "dlname", "URLstr", " urlSTR", "UrlSTR", "urlname", " urlr", "urlSTR", "dlSTR", "urlr", "strstr"], "url": ["f", "hl", "gl", "address", "u", "dl", "con", "res", "h", "cr", "https", "web", "ls", "ll", "base", "char", "q", "build", "sl", "open", "pl", "load", "lr", "rel", "xml", "ur", "mount", "com", "cp", "uri", "URL", "str", "l", "nl", "ul", "mail", "path", "cal", "r", "ssl", "http", "job", "file", "loc", "il", "Url", "ml", "host", "cl"], "ais": ["pa", "ava", "ois", "au", "us", "pai", "asis", "aer", "aus", "osi", "ei", "ws", "ians", "ia", "auc", "ami", "isa", "sa", "asia", "ias", "ca", "aci", "hz", "asar", "audi", "ai", "aa", " arra", " ain", "ac", "asi", "ris", "ua", "acs", "aida", "aim", "lis", "aos", "bis", "AI", "asm", "osa", "asio", "ahi", "aba", "wi", "iam", " ado", "ras", "is", "opus", "as", "oos", "sam", "a", "nas"], "c": ["f", "co", "rc", "con", "cos", "cb", "cont", "cr", "enc", "C", "bc", "col", "conv", "ce", "cc", "ca", "fc", "b", "cu", "ci", "cur", "v", "com", "cp", "ct", "ac", "cm", "coll", "l", "ec", "ch", "ctrl", "lc", "tc", "cd", "r", "nc", "mc", "n", "cin", "anc", "dc", "cs", "cl"], "stream": ["REAM", "f", "output", "sample", "console", "cont", "enc", "reader", "resource", "m", "Stream", "pipe", "t", "in", "context", "port", "chain", "sl", "buffer", "open", "result", "stack", "v", "ream", "content", "read", "input", "out", "st", "form", "path", "present", "channel", "iam", "row", "io", "is", "file", "source", "sam", "store", "data"]}}
{"id1": "62362", "id2": "2009072", "code1": "    public void convert(File src, File dest) throws IOException {\n        InputStream in = new BufferedInputStream(new FileInputStream(src));\n        DcmParser p = pfact.newDcmParser(in);\n        Dataset ds = fact.newDataset();\n        p.setDcmHandler(ds.getDcmHandler());\n        try {\n            FileFormat format = p.detectFileFormat();\n            if (format != FileFormat.ACRNEMA_STREAM) {\n                System.out.println(\"\\n\" + src + \": not an ACRNEMA stream!\");\n                return;\n            }\n            p.parseDcmFile(format, Tags.PixelData);\n            if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) {\n                System.out.println(\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n                return;\n            }\n            boolean hasPixelData = p.getReadTag() == Tags.PixelData;\n            boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12;\n            int pxlen = p.getReadLength();\n            if (hasPixelData) {\n                if (inflate) {\n                    ds.putUS(Tags.BitsAllocated, 16);\n                    pxlen = pxlen * 4 / 3;\n                }\n                if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) {\n                    System.out.println(\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                    return;\n                }\n            }\n            ds.putUI(Tags.StudyInstanceUID, uid(studyUID));\n            ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID));\n            ds.putUI(Tags.SOPInstanceUID, uid(instUID));\n            ds.putUI(Tags.SOPClassUID, classUID);\n            if (!ds.contains(Tags.NumberOfSamples)) {\n                ds.putUS(Tags.NumberOfSamples, 1);\n            }\n            if (!ds.contains(Tags.PhotometricInterpretation)) {\n                ds.putCS(Tags.PhotometricInterpretation, \"MONOCHROME2\");\n            }\n            if (fmi) {\n                ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian));\n            }\n            OutputStream out = new BufferedOutputStream(new FileOutputStream(dest));\n            try {\n            } finally {\n                ds.writeFile(out, encodeParam());\n                if (hasPixelData) {\n                    if (!skipGroupLen) {\n                        out.write(PXDATA_GROUPLEN);\n                        int grlen = pxlen + 8;\n                        out.write((byte) grlen);\n                        out.write((byte) (grlen >> 8));\n                        out.write((byte) (grlen >> 16));\n                        out.write((byte) (grlen >> 24));\n                    }\n                    out.write(PXDATA_TAG);\n                    out.write((byte) pxlen);\n                    out.write((byte) (pxlen >> 8));\n                    out.write((byte) (pxlen >> 16));\n                    out.write((byte) (pxlen >> 24));\n                }\n                if (inflate) {\n                    int b2, b3;\n                    for (; pxlen > 0; pxlen -= 3) {\n                        out.write(in.read());\n                        b2 = in.read();\n                        b3 = in.read();\n                        out.write(b2 & 0x0f);\n                        out.write(b2 >> 4 | ((b3 & 0x0f) << 4));\n                        out.write(b3 >> 4);\n                    }\n                } else {\n                    for (; pxlen > 0; --pxlen) {\n                        out.write(in.read());\n                    }\n                }\n                out.close();\n            }\n            System.out.print('.');\n        } finally {\n            in.close();\n        }\n    }\n", "code2": "    public InputStream openInput(Fragment path) throws IOException {\n        int len = path.words().size();\n        String p = Util.combine(\"/\", path.words().subList(1, len));\n        URL url = new URL(\"http\", path.words().get(0), p);\n        InputStream result = url.openStream();\n        return result;\n    }\n", "label": 0, "substitutes": {"convert": ["Converting", "compvert", "converts", "unverted", "consvert", "Conprocess", "CONversion", "converted", "Conversion", "unprocess", "confer", "unfer", "Confer", "unvert", "unverts", "compverts", "ConVERT", "Converted", "CONvert", "conversion", "conprocess", "CONfer", "Convert", "CONverted", "unversion", "compversion", "compprocess", "consversion", "converting", "CONverting", "consVERT", "consverting", "conVERT", "CONVERT", "Converts"], "src": ["ser", "buster", "rc", "txt", "hl", "scan", "usr", "attr", "img", "orig", "func", "ins", "sit", "cont", "sys", "stream", "SourceFile", "sq", "addr", "rest", "pkg", "cur", "sr", "rel", "filename", "ur", "Source", "its", "req", "url", "uri", "RC", "rs", "str", "SOURCE", "inst", "input", "upload", "sin", "rx", "sc", "st", "path", "ource", "s", "iv", "scene", "href", "http", "config", "dist", "start", "file", "source", "loc", "ipl", "ebin", "from", "host", "cc"], "dest": ["txt", "img", " destinations", "gin", "orig", "test", "disk", "est", "table", "port", "rest", "write", " Dest", "result", " dst", "mat", "target", "foreign", " orig", " destination", "dir", "dat", "Dest", "dist", "temp", " Destination", "source", "tif"], "in": ["en", "rin", "inn", "res", "IN", "ins", "d", "ar", "reader", "m", "stream", "In", "inner", "b", "up", "i", "bin", "serv", "l", "input", "sql", "st", "ind", "r", "el", "ad", "io", "din", "inf", "is", "isin", "source", "as", "file", "cin", "from"], "p": ["f", "php", "pa", "pb", "dp", "j", "pd", "tp", "rep", "vp", "sp", "d", "py", "parser", "part", "h", "op", "pp", "m", "fp", "t", "pl", "c", "pkg", "b", "pg", "ps", "ping", "post", "pro", "i", "cp", "ph", "pc", "pt", "pi", "l", "it", "per", "parse", "P", "pers", "at", "lp", "pre", "g", "r", "jp", "pm", "er", "wp", "prot", "pe", "ap"], "ds": ["dates", "dp", "di", " ads", "scripts", "loads", "yes", "qs", "tests", "ns", "ps", "drivers", "db", "dds", "sd", "ats", "dt", " DS", "ports", "ras", "terms", "ss", "DS", "ws", "bs", "docs", "hs", "workers", "iffs", "lists", "os", "edes", "gs", " dd", "hd", "vs", " d", "uds", "ils", "eds", "xs", "tags", "Ds", "dl", "els", "sets", "gd", "ls", "ts", "ags", "rs", " des", "obs", "s", "outs", "ods", "sts", "posts", "ands", "tes", "cs", "amps", "dos", "ads", "pd", "tp", "mys", "d", "cks", "js", " os", "its", "aws", "ys", "des", "eps", "dd", "ks", "points", "df", "nas", "dh"], "format": ["type", "f", "style", "layout", "settings", "output", "policy", "MAT", "feature", "mt", "fm", "set", "status", "table", "tag", "t", "feat", " Format", "module", "template", "sche", "spec", "fc", "shape", "mode", "Format", "ct", "act", "mat", "name", "ats", "pi", "top", "l", "it", "parse", "form", "path", "at", "filter", "lat", "pattern", "id", "cf", "file", "source", "size", "unit", "version", "pretty", "title"], "hasPixelData": ["HaspixelDATA", "hasixelData", "hasPixelDATA", "Haspixeldata", "hasPixeldata", "HasPixelDATA", "HaspixelData", "hasFrameData", "hasFrameDATA", "haspixelDATA", "hasFramedata", "HasPixeldata", "haspixeldata", " hasPixelDATA", " hasPixeldata", "hasixeldata", "hasixelDATA", "HasPixelData", "haspixelData"], "inflate": ["inFLated", "Inflate", "invalidATE", "inFLat", "inFLocate", "incelate", " invalidicate", "infolat", "Inflat", "invalidate", "inFlicate", "inflATE", "inflated", "incelicate", " inflocate", "incelocate", "Informocate", "Informated", "incelATE", "inFlATE", " inflicate", "inFlate", " invalidate", "informat", "infolated", "Inflocate", "inflicate", "inFlocate", "infolocate", "informocate", "informate", "Informat", "invalidicate", "Inflated", " inflATE", "inflocate", "informated", "Informate", "inFLate", "invalidocate", " invalidATE", "inflat", " invalidocate", "infolate"], "pxlen": ["pxln", "mmlin", "packlen", "pxlength", "cpln", "xplength", "cplength", "phpln", "pixellength", "pxlin", "cpden", "mxlength", "cplen", "packlength", "pexlength", "xylen", "mmlen", "pxdec", "tmpln", "packdec", "phplength", "pexln", "mxdec", "packfun", "pexls", "mxlen", "pxls", "pxfun", "xylin", "xyln", "tmplin", "xpden", "mxln", "tmplen", "pexlen", "pxden", "phplen", "pexfun", "mmlength", "pixelfun", "packls", "xpln", "phpdec", "pixells", "pexden", "tmplength", "xplen", "packln", "mmln", "pixellen", "xylength"], "out": ["output", "res", "obj", "ln", "client", "sys", "sum", "inter", "init", "net", "log", "print", "err", "list", "up", "crit", "name", "writer", "outer", "cmd", "conn", "gov", "ou", "group", "aos", "outs", "dir", "cfg", "inv", "screen", "gr", "io", "msg", "temp", "Out", "OUT", "user", "store", "pretty", "prefix", "ex"]}}
{"id1": "14450108", "id2": "22035737", "code1": "    public FTPFile[] connect() {\n        if (ftpe == null) {\n            ftpe = new FTPEvent(this);\n        }\n        if (ftp == null) {\n            ftp = new FTPClient();\n        } else if (ftp.isConnected()) {\n            path = \"\";\n            try {\n                ftp.disconnect();\n            } catch (IOException e1) {\n                log.error(\"could not disconnect -\" + e1.getMessage());\n            }\n        }\n        currentDir = new FTPFile[0];\n        log.debug(\"try to connect\");\n        try {\n            int reply;\n            ftp.connect(ftpsite);\n            reply = ftp.getReplyCode();\n            if (!FTPReply.isPositiveCompletion(reply)) {\n                ftp.disconnect();\n                log.error(\"FTP server refused connection.\");\n            }\n        } catch (IOException e) {\n            log.error(\"FTPConnection error: \" + e.getMessage());\n            if (ftp.isConnected()) {\n                try {\n                    ftp.disconnect();\n                } catch (IOException f) {\n                }\n            }\n        }\n        try {\n            if (!ftp.login(user, password)) {\n                log.error(\"could not login with: \" + user);\n                ftp.logout();\n            }\n            log.debug(\"Remote system is \" + ftp.getSystemName());\n            ftp.enterLocalPassiveMode();\n            currentDir = ftp.listFiles();\n        } catch (FTPConnectionClosedException e) {\n            log.error(\"FTPConnectionClosedException: \" + e.getMessage());\n        } catch (IOException e) {\n            log.error(\"IOException: \" + e.getMessage());\n        }\n        ftpe.setType(FTPEvent.CONNECT);\n        fireFTPEvent(ftpe);\n        return currentDir;\n    }\n", "code2": "    private static void loadMappings(Configuration cfg) {\n        try {\n            Enumeration en = LoadingUtils.getResources(MAPPINGS_FILE);\n            while (en.hasMoreElements()) {\n                URL url = (URL) en.nextElement();\n                logger.info(\"Found mapping module \" + url.toExternalForm());\n                InputStream inputStream = null;\n                try {\n                    inputStream = url.openStream();\n                    HibConfiguration hm = loadModuleMappings(inputStream);\n                    configureModuleMappings(cfg, hm.getSessionFactory());\n                } catch (IOException e) {\n                    logger.warn(\"Could not load mappings file \\\"\" + url.toExternalForm() + \"\\\"\", e);\n                } catch (JAXBException e) {\n                    logger.warn(\"Unable to instantiate JAXBContext \", e);\n                } finally {\n                    try {\n                        if (inputStream != null) inputStream.close();\n                    } catch (IOException e) {\n                        logger.debug(e);\n                    }\n                }\n            }\n        } catch (IOException e) {\n            logger.warn(\"Could not find any mappings file hibernate.mappings.xml\", e);\n        }\n    }\n", "label": 0, "substitutes": {"connect": ["Connect", "process", "dial", "connected", "con", "sync", "select", "reset", "client", "create", "set", "establish", "init", "connection", "build", "log", "write", "open", "secure", "ping", "join", "close", "read", "bind", "initial", "login", "pen", "construct", "conn", "network", "remote", "download", "config", "ssh", "attach", "setup"], "ftpe": [" ftpy", " ftme", "ftpa", "aftpe", "aptp", "aptse", "oftple", "aftpa", "etpe", "iftse", "aftcle", "iftpa", "iftpe", "aftse", "attpe", "ftpy", "aptcle", "oftme", "ftse", "etse", "attple", "aftp", " ftse", "ftple", "etpy", "ftcle", "oftse", "aftpy", "ftme", "iftple", " ftple", "oftpe", "aftme", "aptpe", "attp", "etp", "iftcle", "iftp", "attpa", "aftple"], "ftp": ["raftt", "ttport", "oftp", "raftphp", "toptp", "ffping", "ttr", "ftr", "htttp", "ftd", " fty", "aftt", "ottt", "ctp", "ftping", "aftk", "aftpi", "ftt", "ttpn", " ftP", "topp", "cttp", "threadtp", "iftp", "fttp", " ftpn", "ftP", "ffp", "ftc", "rotpe", " fttp", "afttp", "ftk", " ftt", "aftc", " ftport", "fabc", "threadpe", "iftt", "ftphp", "threadp", "ctr", "iftd", "ctcp", "rotp", "fabr", "ftpp", "raftp", "aftr", "http", "aftd", "afty", "ftport", "ftpn", "aftpn", "httr", "rotr", "aftport", "aftP", "aftpe", "fftp", "ffr", "iftk", " ftr", "oftr", "iftpe", "ttc", "ftpi", "aftpp", "oftt", "iftcp", "ttp", "fft", "fty", " ftd", "oftping", "ftcp", "aftcp", " ftc", "httpe", " ftpp", "topr", "raftpat", "iftpp", "toppe", "ottp", " ftcp", "ottphp", "ttpe", "fabp", "aftpat", "ottpat", "ffc", "rotk", " ftpi", "aftphp", "aftp", "ftpat", "aftping", "iftr", "threadc", "ffcp", "ifttp", "ifty", "ttP", "fabpi"], "path": ["ref", "prop", "dest", "ath", "context", "port", "directory", "chain", "c", "pkg", "PATH", "cert", "wd", "filename", "cp", "url", "name", "copy", "str", "cmd", "dir", "Path", "pattern", "full", "root", "p", "host", "prefix"], "currentDir": ["tempDir", " currentPath", " currentDirectory", "reportedDir", " currentFile", "tempDIR", "tempDirectory", "CurrentDirectory", "tempPath", "CurrentDir", "currentDIR", "reportedDirectory", "activePath", " currentDIR", "activeDIR", "activeDirectory", "reportedPos", " currentPos", "CurrentPos", "reportedFile", "currentPath", "activeDir", "activePos", "currentDirectory", "reportedDIR", "currentPos", "currentFile", "activeFile"], "reply": ["proxy", "echo", "back", "report", "mi", "pop", "response", "notice", "match", "sync", "reset", "next", "time", "status", "reason", "code", "ply", "consider", "err", "write", "transfer", "replace", "message", "call", "result", "close", "re", " Reply", "onse", "post", "nb", "state", "error", "trust", "respond", "ch", "vote", "query", "answer", "continue", "flag", "record", "nr", "ret", "info", "Reply", "pty", "repl", "send", "timeout", "shell", "zero", "print"]}}
{"id1": "19549489", "id2": "9033641", "code1": "    public static void copy(File sourceFile, File destinationFile) throws IOException {\n        FileChannel sourceFileChannel = (new FileInputStream(sourceFile)).getChannel();\n        FileChannel destinationFileChannel = (new FileOutputStream(destinationFile)).getChannel();\n        sourceFileChannel.transferTo(0, sourceFile.length(), destinationFileChannel);\n        sourceFileChannel.close();\n        destinationFileChannel.close();\n    }\n", "code2": "    public void testHttpsConnection_Not_Found_Response() throws Throwable {\n        setUpStoreProperties();\n        try {\n            SSLContext ctx = getContext();\n            ServerSocket ss = ctx.getServerSocketFactory().createServerSocket(0);\n            TestHostnameVerifier hnv = new TestHostnameVerifier();\n            HttpsURLConnection.setDefaultHostnameVerifier(hnv);\n            URL url = new URL(\"https://localhost:\" + ss.getLocalPort());\n            HttpsURLConnection connection = (HttpsURLConnection) url.openConnection();\n            try {\n                doInteraction(connection, ss, NOT_FOUND_CODE);\n                fail(\"Expected exception was not thrown.\");\n            } catch (FileNotFoundException e) {\n                if (DO_LOG) {\n                    System.out.println(\"Expected exception was thrown: \" + e.getMessage());\n                }\n            }\n            connection.connect();\n        } finally {\n            tearDownStoreProperties();\n        }\n    }\n", "label": 0, "substitutes": {"copy": ["export", "csv", "cat", "sync", "create", " Copy", "transfer", "Copy", "write", "slice", "delete", "load", "replace", "rm", "cp", "read", "upload", " mirror", "paste", "add", "Cop", "download", " duplicate", "save", "clone", "map", " cp", "move"], "sourceFile": [" sourceFilename", "inputFile", "sourcefile", " sourcefile", "SourceFilename", "ourceFile", "SourcePage", "sourceLine", "sourceFilename", "SourceFile", "inputPage", "SourceLine", "ourcefile", " sourceLine", "inputfile", "Sourcefile", " sourcePage", "ourceFilename", "ourcePage", "inputLine", "sourcePage", "ourceLine"], "destinationFile": ["destrativeFilename", "destrativePlace", "declinatorPath", "destrativePath", "destinatorPlace", "destinatePlace", "destinationPath", "declinationPlace", "destinatedPlace", "declinatorFilename", "estinationFile", "destinatedFile", "estinatedPlace", "destinatedFilename", "estinationfile", "declinatorPlace", "estinationFilename", "destinationfile", "destinationPlace", "declinationFile", "destinationsFile", "destinoFile", "estinatedfile", "destinatorFile", "destinationsfile", "destinoFilename", "declinatorFile", "destinatePath", "destinatorFilename", "estinatedFile", "destinationsFilename", "destrativeFile", "destinatedfile", "declinationFilename", "destinoPlace", "destinofile", "estinatedFilename", "destinateFile", "destinatorPath", "estinationPlace", "declinationPath", "destinateFilename", "destinationsPlace", "destinationFilename"], "sourceFileChannel": ["sourceStreamChannel", "ourceEntryChan", "sourceFileHandler", "sourceFilechannel", "sourceEntryConnection", "sourceLineEntry", "ourceEntryConnection", "srcBlockConnection", "srcBlockchannel", "sourceBlockEntry", "sourceBaseChuck", "sourceLineChannel", "sourceBytechannel", "ourceEntryChannel", "sourceStreamchannel", "sourceStreamConnection", "sourceByteEntry", "sourceFileEntry", "sourceEntryChan", " sourceFileApplication", "srcFileConnection", "sourceLineConnection", "srcFileEntry", "sourceBaseHandler", "sourceLinechannel", "sourceFileChuck", "ourceFileChannel", "sourceEntrychannel", "sourceFileChan", "sourceStreamChan", "srcFilechannel", "srcBlockChannel", "ourceEntrychannel", "sourceStreamChuck", "sourceBlockchannel", "srcFileChannel", "sourceBaseChannel", "ourceFilechannel", "sourceBlockConnection", "sourceLineChan", "sourceStreamApplication", "ourceFileChan", " sourceFileChuck", "sourceByteChannel", "sourceStreamHandler", "sourceFileApplication", "ourceFileConnection", "sourceBlockChannel", "sourceFileConnection", "sourceByteConnection", " sourceFileHandler", "srcBlockEntry", "sourceBaseApplication", "sourceEntryChannel"], "destinationFileChannel": ["destinationChannelCh", "destinationDirectoryChannel", "destinationFileCh", "destinatorFilesConnection", "destinationFilechannel", "destinationFileEntry", "destinationDirectoryChan", "destinatorFileChan", "destinationfileConnection", "destinationfileEntry", "destinationChannelChan", "destinationPageChan", "destmentPageEntry", "destinationChannelEntry", "destinationfileContext", "destinationfileChan", "destinationChannelConnection", "destinationPageChannel", "destmentResourceManager", "destmentFileContext", "destinationDirectoryManager", "destmentFileManager", "destmentFileChannel", "destinatorFileChannel", "destmentFileChan", "destinationResourceChannel", "destmentResourceChan", "destinationResourcechannel", "destmentResourcechannel", "destinationDirectorychannel", "destinatorFilesCh", "destinationfileManager", "destmentPageChannel", "destmentPageContext", "destinationResourceManager", "destinationfilechannel", "destinationfileCh", "destinationFilesConnection", "destmentFileEntry", "destinationResourceChan", "destinationFileConnection", "destinatorFileConnection", "destmentFilechannel", "destinationFileContext", "destinationPageContext", "destinationPageEntry", "destinationFileChan", "destinationChannelChannel", "destinationChannelContext", "destinationFileManager", "destinatorFilesChan", "destinationFilesCh", "destinatorFileCh", "destinatorFilesChannel", "destinationFilesChannel", "destmentResourceChannel", "destinationfileChannel", "destmentPageChan", "destinationFilesChan"]}}
{"id1": "14168494", "id2": "23611770", "code1": "    public static void copyFile(File dest, File src) throws IOException {\n        FileChannel srcChannel = new FileInputStream(src).getChannel();\n        FileChannel dstChannel = new FileOutputStream(dest).getChannel();\n        dstChannel.transferFrom(srcChannel, 0, srcChannel.size());\n        srcChannel.close();\n        dstChannel.close();\n    }\n", "code2": "                    public void handle() {\n                        FileChannel srcChannel, destChannel;\n                        String destOutFile = logFile + \".\" + System.currentTimeMillis();\n                        String destOutFileCompressed = logFile + \".\" + System.currentTimeMillis() + \".gz\";\n                        if (rotateDest != null) {\n                            (new File(rotateDest)).mkdirs();\n                            if (destOutFile.indexOf(\"/\") != -1) {\n                                destOutFile = rotateDest + \"/\" + destOutFile.substring(destOutFile.lastIndexOf(\"/\") + 1);\n                            }\n                            if (destOutFileCompressed.indexOf(\"/\") != -1) {\n                                destOutFileCompressed = rotateDest + \"/\" + destOutFileCompressed.substring(destOutFileCompressed.lastIndexOf(\"/\") + 1);\n                            }\n                        }\n                        if (rotateCompress) {\n                            try {\n                                GZIPOutputStream out = new GZIPOutputStream(new FileOutputStream(destOutFileCompressed));\n                                FileInputStream in = new FileInputStream(logFile);\n                                byte buf[] = new byte[1024];\n                                int len;\n                                while ((len = in.read(buf)) > 0) {\n                                    out.write(buf, 0, len);\n                                }\n                                in.close();\n                                out.finish();\n                                out.close();\n                                buf = null;\n                                in = null;\n                                out = null;\n                                Debug.debug(\"Rotated log file '\" + logFile + \"' to '\" + destOutFileCompressed + \"'\");\n                            } catch (Exception e) {\n                                Debug.debug(\"Unable to rotate log file '\" + logFile + \"': \" + e);\n                            }\n                        } else {\n                            try {\n                                srcChannel = new FileInputStream(logFile).getChannel();\n                            } catch (IOException e) {\n                                Debug.debug(\"Unable to read log file '\" + logFile + \"': \" + e.getMessage());\n                                return;\n                            }\n                            try {\n                                destChannel = new FileOutputStream(destOutFile).getChannel();\n                            } catch (IOException e) {\n                                Debug.debug(\"Unable to rotate log file to '\" + destOutFile + \"': \" + e.getMessage());\n                                return;\n                            }\n                            try {\n                                destChannel.transferFrom(srcChannel, 0, srcChannel.size());\n                                srcChannel.close();\n                                destChannel.close();\n                                srcChannel = null;\n                                destChannel = null;\n                            } catch (IOException e) {\n                                Debug.debug(\"Unable to copy data for file rotation: \" + e.getMessage());\n                                return;\n                            }\n                            Debug.debug(\"Rotated log file '\" + logFile + \"' to '\" + destOutFile + \"'\");\n                        }\n                        if (rotateDelete && isFile) {\n                            try {\n                                ps.close();\n                            } catch (Exception e) {\n                            }\n                            isFile = false;\n                            ps = null;\n                            (new File(logFile)).delete();\n                            reconfigureDebug();\n                        }\n                        if (rotateDest != null) {\n                            long comparisonTime = rotateDays * (60 * 60 * 24 * 1000);\n                            long currentTime = System.currentTimeMillis();\n                            File fileList[] = (new File(rotateDest)).listFiles();\n                            DateFormat format1 = new SimpleDateFormat(\"yyyy-MM-dd\");\n                            java.util.Date date = new java.util.Date(currentTime);\n                            String archiveFile = format1.format(date).toString() + \".zip\";\n                            if (rotateArchive != null) {\n                                archiveFile = rotateArchive + \"/\" + archiveFile;\n                                (new File(rotateArchive)).mkdirs();\n                            }\n                            Archive archive = new Archive(archiveFile);\n                            for (int i = 0; i < fileList.length; i++) {\n                                String currentFilename = fileList[i].getName();\n                                long timeDifference = (currentTime - fileList[i].lastModified());\n                                if ((rotateCompress && currentFilename.endsWith(\".gz\")) || (!rotateCompress && currentFilename.indexOf(logFile + \".\") != -1)) {\n                                    if (rotateDest != null) {\n                                        currentFilename = rotateDest + \"/\" + currentFilename;\n                                    }\n                                    if (timeDifference > comparisonTime) {\n                                        archive.addFile(fileList[i].getName(), currentFilename);\n                                        fileList[i].delete();\n                                    }\n                                }\n                            }\n                            archive = null;\n                            fileList = null;\n                            format1 = null;\n                            date = null;\n                        }\n                    }\n", "label": 1, "substitutes": {"copyFile": [" cpfile", " copyfile", "CopyStream", " copyStream", " cpByte", "CopyByte", " cpFile", " CopyStream", " CopyByte", " Copyfile", "CopyFile", " copyByte", " CopyFile", "Copyfile", " cpStream"], "dest": ["origin", "good", "nt", "usr", "img", "pub", "orig", "them", "d", "cont", "way", "www", "trans", "doc", "tmp", "del", "rest", "to", "master", "result", "v", "target", "out", "des", "gt", "np", "st", "dir", "nom", "etc", "nw", "Dest", "dist", "temp", "source", "loc", "w"], "src": ["ser", "rc", "usr", "sb", "img", "ins", "cont", "sys", "ls", "init", "sq", "sl", "cur", "sr", "rel", "Source", "req", "sec", "rs", "sel", "input", "upload", "sc", "rx", "st", "iv", "desc", "sub", "start", "file", "source", "loc", "inst", "from"], "srcChannel": ["sysChan", "instChannel", "srcChan", "srcCh", "rcMessage", "sourceChannel", "destChan", "destChain", "srcchannel", "bgChain", "rcChannel", "destChannel", "srcCan", "sysChannel", "rcchannel", "srcPanel", "bgPanel", "srcChain", " srcCommand", " srcCh", "sqCan", "sqChain", "rcChan", "instChain", "syschannel", " srcChain", "sqPanel", "bgCan", "sqChannel", "sysCommand", "sourceCh", "srcCommand", " srcchannel", "rcCommand", " srcChan", "instChan", "bgChannel", "sourceChan", "instPanel", "instCh", "destMessage", "instCan", " srcMessage", "srcMessage", "rcChain"], "dstChannel": ["destButton", "dbrChan", " dstHandler", "dotHandler", "pdestClient", " dstButton", "pstButton", "dndChannel", "ddestCh", "dotCh", "dndButton", "dotChannel", "ddestClient", "dstButton", "dstClient", "dndChan", "destChannel", "dndClient", "pstCommand", "destCommand", " dotCh", "dbrCh", " dstChan", "ddestButton", " dotHandler", "pdestCommand", "pdestChannel", "destClient", "pstChannel", "dstCh", "dbrHandler", "pdestButton", "pstClient", "ddestChannel", " dotChannel", " dotChan", "dstHandler", "dndCh", "ddestChan", " dstCh", "dotButton", " dotButton", "dndCommand", "dotChan", "dstCommand", "ddestCommand", "dbrChannel", "dstChan", "ddestHandler"]}}
{"id1": "884867", "id2": "6501291", "code1": "    public static void main(String[] args) {\n        if (args.length != 1) {\n            System.out.println(\"Usage: GZip source\");\n            return;\n        }\n        String zipname = args[0] + \".gz\";\n        GZIPOutputStream zipout;\n        try {\n            FileOutputStream out = new FileOutputStream(zipname);\n            zipout = new GZIPOutputStream(out);\n        } catch (IOException e) {\n            System.out.println(\"Couldn't create \" + zipname + \".\");\n            return;\n        }\n        byte[] buffer = new byte[sChunk];\n        try {\n            FileInputStream in = new FileInputStream(args[0]);\n            int length;\n            while ((length = in.read(buffer, 0, sChunk)) != -1) zipout.write(buffer, 0, length);\n            in.close();\n        } catch (IOException e) {\n            System.out.println(\"Couldn't compress \" + args[0] + \".\");\n        }\n        try {\n            zipout.close();\n        } catch (IOException e) {\n        }\n    }\n", "code2": "    public static void extractFile(String input, String output) throws ZipException, IOException {\n        FileReader reader = new FileReader(input);\n        InputStream in = reader.getInputStream();\n        OutputStream out = new FileOutputStream(new File(output));\n        byte[] buf = new byte[512];\n        int len;\n        while ((len = in.read(buf)) > 0) out.write(buf, 0, len);\n        reader.close();\n        out.close();\n    }\n", "label": 1, "substitutes": {"zipname": ["tarname", "gznamed", "znamed", "zipsize", "zname", "downloadName", "zipnamed", " zipbase", "zipbase", "archivebase", "archivename", "gzsize", " zipsize", "archiveout", "downloadname", "polyname", "polyName", "polynamed", " zipnamed", "gzroot", "zeout", "zipfilename", "tarsize", " zipName", "zename", "ziproot", "gzname", "zfilename", " ziproot", "zName", "zeName", "zebase", "tarroot", "downloadnamed", "tarnamed", "zipName", "downloadfilename", "polyfilename", "archiveName"], "zipout": ["zOut", "Zipclient", "sendclient", "sendin", "zall", "zname", "zipclient", "sendname", "zin", "zion", "gzin", "zipn", "zout", "Zipn", "zgen", "sendout", " zipall", "gzall", "gzobj", " zipoutput", "sendoutput", " zipobj", "Zipname", "zobj", " zipgen", "zipoutput", "zipobj", " zipOut", " zipclient", "Zipin", "Zipout", "zipOut", " zipin", "zipall", "zn", "gzion", "gzgen", "zipion", " zipion", "gzout", "zipin", "Zipoutput", "sendn", "gzOut", "zipgen"], "out": ["output", "ins", "ln", " bout", "t", "inner", "print", "to", "opt", "up", "conf", "ent", "dt", "gt", "ou", "n", "io", "msg", "inf", "Out", " outs", "all", "en", "nt", "res", "obj", " fmt", "on", "one", " abort", "net", "log", "list", "name", "os", "ch", "cmd", "conn", "at", "g", "auto", "desc", "w", " manager", "con", "cn", "sys", " say", "str", "writer", "group", "aos", "outs", "o", "OUT", "pretty", "gen", "co", "by", "cos", "oss", "client", "set", "init", "go", " Out", "ac", " sys", " OUT", "gov", "null", "cfg", "inv", "screen", "p", "can", " output", "ex"], "buffer": ["phrase", "buf", "window", "block", "buff", "output", "frame", "comment", "sequence", "page", "table", "append", "pad", "library", "mem", "template", "command", "attribute", "document", "message", "available", "stack", "cache", "Buffer", "variable", "total", "iter", "tree", "history", "paste", "queue", "binary", "batch", "filter", "line", "database", "bar", "row", "temp", "button", "memory"], "in": ["rin", "en", "inn", "ini", "and", "by", "gin", "con", "IN", "ins", "im", "reader", "on", "oin", "In", "init", "inner", "bi", "ic", "ai", "up", "i", "read", "bin", "ac", "get", "inc", "pi", "input", "or", "iter", "it", "query", "per", "form", "ind", "nin", "ma", "mc", "mm", "info", "din", "inf", "is", "isin", "cin", "check", "from", "like", "ex"], "length": ["type", "value", "vector", "match", "ENGTH", "shift", "character", "hello", "Length", "capacity", "depth", "distance", "sequence", "bow", "frequency", "library", "code", "print", "integer", "shape", "message", "load", "available", "impl", "join", "family", "maximum", "number", "read", "position", "tail", "total", "len", "history", "point", "present", "space", "component", "ength", "amount", "height", "language", "collection", "database", "full", "padding", "count", "volume", "string", "display", "no", "size", "class", "loc", "reading", "version", "needed", "angle", "duration", "phi"]}}
{"id1": "17475530", "id2": "3024992", "code1": "    @TestProperties(name = \"Simple test for adding different image files to report as link\")\n    public void testAddLinkToImage() throws Exception {\n        InputStream in = this.getClass().getClassLoader().getResourceAsStream(\"regression/generic/images/splash.jpg\");\n        report.report(report.getCurrentTestFolder() + System.getProperty(\"file.separator\") + \"splash.jpg\");\n        IOUtils.copy(in, new FileOutputStream(new File(report.getCurrentTestFolder() + System.getProperty(\"file.separator\") + \"splash.jpg\")));\n        in = this.getClass().getClassLoader().getResourceAsStream(\"regression/generic/images/blue.png\");\n        IOUtils.copy(in, new FileOutputStream(new File(report.getCurrentTestFolder() + System.getProperty(\"file.separator\") + \"blue.png\")));\n        in = this.getClass().getClassLoader().getResourceAsStream(\"regression/generic/images/classDir.gif\");\n        IOUtils.copy(in, new FileOutputStream(new File(report.getCurrentTestFolder() + System.getProperty(\"file.separator\") + \"classDir.gif\")));\n        report.addLink(\"Link to JPG\", \"splash.jpg\");\n        report.addLink(\"Link to PNG\", \"blue.png\");\n        report.addLink(\"Link to GIF\", \"classDir.gif\");\n    }\n", "code2": "    @Test\n    public void testCopy_readerToWriter_nullIn() throws Exception {\n        ByteArrayOutputStream baout = new ByteArrayOutputStream();\n        OutputStream out = new YellOnFlushAndCloseOutputStreamTest(baout, true, true);\n        Writer writer = new OutputStreamWriter(baout, \"US-ASCII\");\n        try {\n            IOUtils.copy((Reader) null, writer);\n            fail();\n        } catch (NullPointerException ex) {\n        }\n    }\n", "label": 1, "substitutes": {"testAddLinkToImage": ["testAddLinksToImages", "testAddLinkFromPicture", "testAddLinkForPicture", "testAddLinkToImages", "testAddLinktoImage", "testAddLinkFromImages", "testAddLinkForimage", "testAddLinktoImages", "testAddLinkstoImage", "testAddLinktoPicture", "testAddLinkToimage", "testAddLinkstoPicture", "testAddLinkFromImage", "testAddLinkFromimage", "testAddLinkForImage", "testAddLinkstoimage", "testAddLinkstoImages", "testAddLinkForImages", "testAddLinksToPicture", "testAddLinkToPicture", "testAddLinksToImage", "testAddLinksToimage", "testAddLinktoimage"], "in": ["all", "rin", "en", "include", "inn", "ini", "and", "by", "gin", "IN", "vin", "ins", "m", "on", "doc", "al", "set", "sum", "In", "init", "inner", "inside", "one", "k", "sein", "re", "up", "v", "i", "bin", "get", "inc", "pi", "input", "out", "or", "it", " din", "show", "at", "ind", "o", "nin", "add", "r", "ma", "ed", "mc", "info", "din", "er", "is", "isin", "source", "file", "password", "cin", "check", "from", "ex"]}}
{"id1": "4468255", "id2": "18974466", "code1": "    public static void copy(File from, File to) {\n        boolean result;\n        if (from.isDirectory()) {\n            File[] subFiles = from.listFiles();\n            for (int i = 0; i < subFiles.length; i++) {\n                File newDir = new File(to, subFiles[i].getName());\n                result = false;\n                if (subFiles[i].isDirectory()) {\n                    if (newDir.exists()) result = true; else result = newDir.mkdirs();\n                } else if (subFiles[i].isFile()) {\n                    try {\n                        result = newDir.createNewFile();\n                    } catch (IOException e) {\n                        log.error(\"unable to create new file: \" + newDir, e);\n                        result = false;\n                    }\n                }\n                if (result) copy(subFiles[i], newDir);\n            }\n        } else if (from.isFile()) {\n            FileInputStream in = null;\n            FileOutputStream out = null;\n            try {\n                in = new FileInputStream(from);\n                out = new FileOutputStream(to);\n                int fileLength = (int) from.length();\n                char charBuff[] = new char[fileLength];\n                int len;\n                int oneChar;\n                while ((oneChar = in.read()) != -1) {\n                    out.write(oneChar);\n                }\n            } catch (FileNotFoundException e) {\n                log.error(\"File not found!\", e);\n            } catch (IOException e) {\n                log.error(\"Unable to read from file!\", e);\n            } finally {\n                try {\n                    if (in != null) in.close();\n                    if (out != null) out.close();\n                } catch (IOException e1) {\n                    log.error(\"Error closing file reader/writer\", e1);\n                }\n            }\n        }\n    }\n", "code2": "    protected boolean copyFile(File sourceFile, File destinationFile) {\n        try {\n            FileChannel srcChannel = new FileInputStream(sourceFile).getChannel();\n            FileChannel dstChannel = new FileOutputStream(destinationFile).getChannel();\n            dstChannel.transferFrom(srcChannel, 0, srcChannel.size());\n            srcChannel.close();\n            dstChannel.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n            return false;\n        }\n        return true;\n    }\n", "label": 1, "substitutes": {"copy": ["csv", "cop", "cat", "sync", "py", "share", "single", "create", "link", "Copy", "write", "transfer", "slice", "replace", "cp", "gc", "get", "archive", "parse", "paste", "split", "opy", "zip", "Cop", "download", "core", "remote", "pixel", "save", "crop", "file", "clip", "clone", "map", "print", "delete", "move"], "from": ["original", "base", "range", "db", "of", "un", "or", "form", "normal", "el", "html", "config", "start", "low", "f", "part", "cont", "se", "on", "fr", "link", "only", "th", "when", "false", "name", "simple", "st", "at", "local", "file", "and", "small", "orig", "entry", "view", "bound", "raw", "stream", "url", "str", "initial", "input", "query", "path", "dir", "with", "a", "data", "empty", "ing", "by", "vol", "From", "left", "init", "old", "org", "without", "this", "add", "star", "zip", "self", "remote", "no", "as", "source", "so"], "to": ["annot", "output", "tom", "please", "tmp", "not", "t", "base", "xy", "tu", "pt", "top", "total", "or", "into", "io", "size", "zero", "all", "nt", "process", "that", "To", "two", "dest", "toc", "on", "tool", "dis", "one", "only", "list", "tty", "eto", "target", "st", "auto", "temp", "back", "let", "et", "ont", "table", "b", "pro", "dir", "o", "data", "phi", "by", "op", "TO", "po", "will", "go", "must", "color", "format", "too", "null", "te", "no", "p", "title", "ot"], "result": ["event", "rule", "mask", "su", "br", "test", "then", "launch", "ure", "perm", "answer", "continue", "term", "confirmed", "relation", "there", "functional", "zero", "Result", "type", "response", "res", "buffer", "only", "either", "stay", "cache", "false", "successful", "successfully", "results", "report", "same", "nil", "block", "ful", "comment", "goal", " successful", "table", "profile", "date", "chain", "journal", "important", "complete", "success", "region", "rue", "power", "duration", "brace", "json", "product", "match", "contact", "console", "mate", "request", "feature", "details", "description", "sequence", "status", "debug", "message", "current", "valid", "true", "bool", "null", "flag", "r"], "subFiles": ["latImages", "subPosts", "ubPosts", "ubNames", "latFiles", "singFiles", " subFile", " subDir", "ubOps", " subfiles", " subpFiles", "supfiles", " subpDir", " subCharacters", "ubValues", "singValues", "subOps", " subOps", "subImages", "subNames", "latCharacters", "subValues", "newfiles", "selFile", " subTags", "newTags", "subItems", "selNames", " subImages", "selFiles", " subValues", "subfiles", "supOps", "subFile", "supFiles", "ubFile", "subCharacters", "ubKeys", " subKeys", "ubTags", "subKeys", " subPosts", " subpItems", "latfiles", "newItems", " subpfiles", "newFiles", " subNames", "singPosts", " subItems", "subDir", "ubItems", "ubDir", "supFile", "ubFiles", "ubImages", "subTags", "ubCharacters", "singKeys", "ubfiles", "selDir"], "i": ["exp", "mi", "iy", "gl", "json", "u", "j", "ms", "us", "y", "x", "I", "ie", "qi", "di", "task", "im", "h", "ri", "m", "iq", "ami", "t", "base", "init", "me", "ti", "q", "hi", "c", "bi", "chain", "go", "ic", "multi", "ci", "ai", "sim", "gi", "ui", "e", "v", "uri", "pi", "ij", "ix", "iter", "ji", "li", "my", "point", "ori", "si", "xi", "g", "ind", "batch", "ip", "zi", "info", "key", "job", "gu", "is", "ii", "oi", " I", "index", "id", "print", "phi"], "newDir": ["newNet", " newObj", "nextFolder", "NEWDir", "newdir", "NewDir", "newFolder", "newFile", "NewServ", " newdir", " newComp", "Newdir", "newObj", "nextDir", " newJar", "newsNet", "subRel", " newFile", "NEWJar", "newsFile", "subFile", "newsObj", "NewNet", "NEWFile", "subFolder", "NewObj", "nextFile", "subJar", "newsRel", "newServ", " newNet", "newRel", "newsServ", "nextRel", "newComp", "NEWdir", "subNet", "subDir", "subComp", "nextComp", "subServ", "nextdir", "NewRel", " newRel", "newsDir", " newFolder", "NewFile", "subdir", "newJar"], "in": ["mi", "rin", "en", "win", "inn", "ini", "con", "gin", "IN", "internal", "ins", "ar", "ln", "on", "m", "doc", "al", "In", "init", "inner", "inside", "net", "print", "ai", "asin", "read", "bin", "pi", "inc", "l", "input", "iter", "it", "proc", "ain", "ind", "ma", "mc", "info", "local", "io", "din", "inf", "is", "isin", "source", "body", "cin"], "out": ["ion", "co", "en", "nt", "flush", "con", "output", "cos", "res", "oss", "cn", "obj", "ln", "on", "client", "sys", "conv", "t", "inner", "init", "one", "net", "write", "log", "b", "end", "print", "err", "up", "v", "cache", "writer", "os", "outer", "it", "OU", "note", "cmd", "ou", "at", "aos", "outs", "o", "ex", "n", "io", "Out", "file", "OUT", "user", "p", "can", "ne", "w"], "fileLength": ["treeLength", "fileFamily", "pageENGTH", "ilelength", "filelength", "FileFamily", "pagelength", " fileENGTH", "treeConstruction", "pageLength", "FileDuration", " filelength", "ileLength", "ileConstruction", "fileDuration", "FileConstruction", "Filelength", "fileENGTH", "fileConstruction", "FileLength", "treelength", " fileFamily", "ileDuration", "pageFamily", "treeDuration", "FileENGTH"], "charBuff": ["charBuffer", "intbuff", "charbuff", "Charbuffer", "charbuffer", " charbuff", "Charbuff", " charBuffer", "intbuffer", "intBuff", " charbuffer", "intBuffer", "CharBuffer", "CharBuff"], "len": ["en", "ref", "cmp", "et", "ln", "set", "ls", "ll", "mem", "char", "e", "name", "str", "l", "pos", "val", "length", "line", "syn", "el", "cap", "start", "Len", "fin", "gen", "cl"], "oneChar": [" oneCh", "oneByte", "oneCr", "OneInt", "OneCr", "OneCharacter", "OneChar", " oneCharacter", "oneCh", "Onechar", "oneCharacter", " oneByte", "OneByte", "oneInt", "OneCh", "onechar", "onceCh", " onechar", "onceCr", "onceChar", " oneCr", "onceCharacter", " oneInt"]}}
{"id1": "22993368", "id2": "13783549", "code1": "    public static boolean decodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.DECODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "code2": "    private static void copy(String sourceName, String destName) throws IOException {\n        File source = new File(sourceName);\n        File dest = new File(destName);\n        FileChannel in = null, out = null;\n        try {\n            in = new FileInputStream(source).getChannel();\n            out = new FileOutputStream(dest).getChannel();\n            long size = in.size();\n            MappedByteBuffer buf = in.map(FileChannel.MapMode.READ_ONLY, 0, size);\n            out.write(buf);\n        } finally {\n            if (in != null) in.close();\n            if (out != null) out.close();\n        }\n    }\n", "label": 1, "substitutes": {"decodeFileToFile": ["decodeFileTofile", "decodeStringToFile", "decodeFile2File", "decodeString2String", "decodeFileAsfile", "decodeString2Files", "decodeFile2file", "decodeFile2Files", "decodeFileAsFiles", "decodeFileToFiles", "decodeStringTofile", "decodeFileFilefile", "decodeFileAsFile", "decodeFile2String", "decodeFileAsString", "decodeFileFileFile", "decodeString2file", "decodeString2File", "decodeFileFileString", "decodeFileFileFiles", "decodeFileToString", "decodeStringToString", "decodeStringToFiles"], "infile": ["isinname", "infolder", "outfolder", "inputFile", "outbase", "outname", "isinfile", "inputfolder", "outFile", "fromfile", "isinfolder", "fromfilename", "inname", "outfilename", "inbase", "InFile", "inputname", "infilename", "inFile", "isinFile", "inputfile", "frombase", "Inbase", "Infilename", "fromFile", "Infile"], "outfile": ["outFILE", "outname", "indir", "Outdir", "Outfilename", " outname", "outFile", "tofilename", "outdir", "inname", "outfilename", "Outfile", "OutFile", "infilename", "todir", " outFILE", "inFILE", "inFile", "toFile", " outFile", "otFILE", "otFile", "tofile", "otfile", "otname"], "in": ["rin", "en", "inn", "ini", "by", "gin", "con", "IN", "ins", "pin", "im", "ar", "on", "oin", "al", "In", "t", "inner", "inside", "init", "re", "up", "i", "bin", "get", "inc", "input", "amin", "or", "iter", "it", "per", " din", "form", "conn", "ain", "ind", "nin", "info", "din", "inf", "is", "isin", "source", "cin", "id", "from"], "out": ["ion", "co", "en", "nt", "flush", "con", "output", "res", "oss", "cn", "on", "sys", "t", "inner", "net", "write", "print", "b", "to", "end", "opt", "writer", "os", "outer", "it", "OU", "gt", "null", "ou", "at", "aos", "outs", "o", "g", "ex", "auto", "n", "io", "Out", "file", "fn", "OUT", "can", "ne", "ot"], "buffer": ["phrase", "buf", "window", "bone", "block", "buff", "sample", "column", "frame", "comment", "view", "sequence", "append", "table", "pad", "library", "mem", "base", "template", "command", "attribute", "document", "message", "shape", "available", "stack", "number", "cache", "variable", "Buffer", "black", "total", "initial", "note", "history", "paste", "binary", "batch", "bar", "padding", "info", "row", "display", "temp", "button", "password", "memory", "print", "header", "character"], "read": ["first", "each", "text", "find", "select", "shift", "reader", "wait", "allow", "raw", "stream", "set", "run", "before", "range", "write", "open", "push", "readable", "load", "print", "reads", "hold", "seek", "close", "i", "req", "skip", "get", " Read", "give", "input", "need", "iter", "through", "query", "len", "length", "Read", "ind", "add", "connect", "count", "n", "ready", "start", "size", "send", "reading", "check", "index", "READ", "end", "ok"], "success": ["first", "same", "good", "response", "value", " succeed", "ceed", " succ", "cess", "positive", "fail", "city", "release", " successful", "summary", "please", "status", "accept", "Success", "danger", "exist", "ratulations", "done", "ccess", "growth", "scope", "primary", "result", "safe", " okay", "second", "unity", "crit", "condition", "successful", " failure", "sufficient", "error", "valid", "complete", "commit", " succeeds", "snap", "democracy", "continue", "photo", "surv", "successfully", "town", "submit", "support", " successes", "setup", "ok"]}}
{"id1": "14473781", "id2": "10158738", "code1": "        @Override\n        protected String doInBackground(Void... params) {\n            HttpClient httpClient = new DefaultHttpClient();\n            HttpContext localContext = new BasicHttpContext();\n            HttpPost httpPost = new HttpPost(urlFormated);\n            try {\n                MultipartEntity entity = new MultipartEntity(HttpMultipartMode.BROWSER_COMPATIBLE);\n                for (int index = 0; index < POSTparamList.size(); index++) {\n                    if (POSTparamList.get(index).getName().equalsIgnoreCase(\"image\")) {\n                        entity.addPart(POSTparamList.get(index).getName(), new FileBody(new File(POSTparamList.get(index).getValue())));\n                    } else {\n                        entity.addPart(POSTparamList.get(index).getName(), new StringBody(POSTparamList.get(index).getValue()));\n                    }\n                }\n                httpPost.setEntity(entity);\n                HttpResponse response = httpClient.execute(httpPost, localContext);\n                return processAnswer(response);\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            return null;\n        }\n", "code2": "    public void add(String language, String tag, String root, String surface) throws FidoDatabaseException, MorphologyTagNotFoundException {\n        try {\n            Connection conn = null;\n            Statement stmt = null;\n            try {\n                conn = FidoDataSource.getConnection();\n                conn.setAutoCommit(false);\n                stmt = conn.createStatement();\n                if (containsTag(stmt, tag) == false) throw new MorphologyTagNotFoundException(tag);\n                if (isRuleUnique(stmt, language, tag, root, surface) == false) return;\n                int row;\n                if (root.equals(\"*\") == true) row = getAppendRowForTag(stmt, language, tag); else if (root.indexOf('*') == -1) row = getFirstRowForTag(stmt, language, tag); else row = getFirstRegularFormForTag(stmt, language, tag);\n                boolean use = determineRecognitionUse(root, surface);\n                bumpAllRowsDown(stmt, language, tag, row);\n                String sql = \"insert into LanguageMorphologies (LanguageName, Rank, Root, Surface, MorphologyTag, Used) \" + \"values ('\" + language + \"', \" + row + \", '\" + root + \"', '\" + surface + \"', '\" + tag + \"', \";\n                if (use == true) sql = sql + \"TRUE)\"; else sql = sql + \"FALSE)\";\n                stmt.executeUpdate(sql);\n                conn.commit();\n            } catch (SQLException e) {\n                if (conn != null) conn.rollback();\n                throw e;\n            } finally {\n                if (stmt != null) stmt.close();\n                if (conn != null) conn.close();\n            }\n        } catch (SQLException e) {\n            throw new FidoDatabaseException(e);\n        }\n    }\n", "label": 0, "substitutes": {"doInBackground": ["doAsBackground", " doInsideAsync", " doOnAsync", " doInRequest", "doAsRequest", "doAsAsync", "doInAsync", " doAsAsync", " doOnBackground", " doOnFuture", " doAsRequest", " doInsideBackground", " doAsBackground", " doInsideRequest", " doInsideFuture", "doInFuture", " doInAsync", "doAsFuture", " doInFuture", "doInRequest", " doOnRequest", " doAsFuture"], "params": ["terms", "services", "tags", "vals", "settings", "ctx", "options", "parts", "details", "errors", "cas", "ps", "list", "conf", "ams", "param", "properties", "images", "proc", "Param", "sql", "Parameters", "config", "files", "values", "posts", "data"], "httpClient": [" httpSystem", "htmlSystem", "httpsSystem", "htmlContext", "hoverSystem", "htmlControl", " httpclient", "httpsControl", "httpclient", "httpsConnection", " httpConnection", "httpContext", "htmlClient", "httpConnection", "httpSystem", "hoverClient", "httpsContext", "httpControl", "ttpSystem", "httpsClient", "hoverControl", "ttpClient", "ttpConnection", "hoverContext", "httpsclient", "ttpclient"], "localContext": ["LocalContext", "currentContext", "sessionContext", "localState", "LocalPort", "sessionState", "currentCondition", "privateContext", " localCondition", "privatePort", "currentState", " localPort", "sessionCase", "localCondition", "privatecontext", "localcontext", " localState", "LocalState", " localCase", "sessionCondition", "Localcontext", "localPort", "localCase", " localcontext", "currentCase", "privateState"], "httpPost": ["httppost", "ttpPut", " httpPOST", "workPut", "hoverPOST", "hoverPost", "ttpPost", "httpPre", "workPre", "httpsPost", "HttpPre", "httpPOST", "HttpPut", "ttppost", "ttpPOST", "httpsPre", "ttpPre", "httpsPut", " httpPut", "workPOST", " httpPre", "HttpPost", " httppost", "httpsPOST", "HttpPOST", "httpPut", "workPost", "hoverpost"], "entity": ["event", "empty", "rule", "unique", "image", "and", "output", "entry", "oe", "email", "policy", "put", "internal", "comment", "details", "create", "table", "base", "ce", "template", "one", "ell", "command", "net", "ment", "secure", "document", "result", "xml", "eme", "person", "total", "or", "ent", "note", "metadata", "object", "encrypted", "component", "complex", "security", "group", "created", "line", "collection", "el", "activity", "channel", "iam", "intent", "auto", "quote", "member", "local", "Entity", "orm", "body", "unit", "needed", "translation", "data", "pe"], "index": ["exp", "author", "access", "active", "each", "insert", "column", "draw", "ax", "eight", "stick", "mount", "number", "state", "get", "inc", "EX", "iter", "lex", "row", "config", "size", "zero", "osit", "loop", "update", "all", "address", "select", "x", "slice", "document", "shape", "max", "seek", "i", "name", "position", "coll", "note", "height", "ind", "connect", "key", "version", "check", "ix", "major", "layout", "capacity", "unknown", "create", "axis", "date", "open", "ox", "see", "error", "success", "initial", "point", "length", "mix", "instance", "num", "scale", "prefix", "display", "empty", "image", "find", "match", "sync", "request", "sequence", "set", "IND", "context", "go", "Index", "scroll", "condition", "ask", "pos", "offset", "search", "add", "loc", "ex"], "response": ["reply", "respons", "json", "value", "image", "zone", "output", "res", "entry", "hello", "service", "request", "frame", "application", "view", "sequence", "Response", "page", "context", "connection", "resp", "document", "message", "result", "onse", "xml", "content", "e", "pos", "api", "respond", "tree", "object", "answer", "social", "still", "body", "data", "results"]}}
{"id1": "17627195", "id2": "7468827", "code1": "    public Document getContentAsDocument() {\n        synchronized (this.url) {\n            URLConnection connection = this.url.openConnection();\n            if (doReload(connection)) {\n                InputSource inputSource = new InputSource(connection.getInputStream());\n                DocumentBuilderFactory factory = new DocumentBuilderFactoryImpl();\n                this.document = factory.newDocumentBuilder().parse(inputSource);\n            }\n            return this.document;\n        }\n    }\n", "code2": "        public void run() {\n            try {\n                HttpURLConnection con = (HttpURLConnection) url.openConnection();\n                con.setRequestMethod(\"GET\");\n                con.setDoInput(true);\n                byte[] encodedPassword = (username + \":\" + password).getBytes();\n                BASE64Encoder encoder = new BASE64Encoder();\n                con.setRequestProperty(\"Authorization\", \"Basic \" + encoder.encode(encodedPassword));\n                BufferedInputStream in = new BufferedInputStream(con.getInputStream());\n                FileOutputStream fos = new FileOutputStream(toFile);\n                BufferedOutputStream bout = new BufferedOutputStream(fos, 1024);\n                byte[] data = new byte[1024];\n                int x = 0;\n                while ((x = in.read(data, 0, 1024)) >= 0) {\n                    bout.write(data, 0, x);\n                    lastIteraction = System.currentTimeMillis();\n                }\n                bout.flush();\n                bout.close();\n                fos.flush();\n                fos.close();\n                in.close();\n                con.disconnect();\n                finish = true;\n            } catch (Exception e) {\n                this.e = e;\n            }\n        }\n", "label": 0, "substitutes": {"getContentAsDocument": ["getContentasHTML", "getContentasDocument", "getContentsasDoc", "getContentasdocument", "getContentsasDocument", "getContentAsdocument", "getContentsAsDocument", "getContentsAsDoc", "getContentAsHTML", "getContentsAsHTML", "getContentAsDoc", "getContentsasHTML", "getContentsAsdocument", "getContentsasdocument", "getContentasDoc"], "connection": ["ion", "generation", "response", "connected", "con", "entry", "pointer", "resource", "application", "description", "client", "opening", "directory", "link", "command", "c", "associated", "open", "system", "close", "number", "established", "url", "information", "condition", "position", "statement", "Connection", "cone", "conn", "created", "network", "connect", "channel", "database", "relation", "successfully", "socket", "still", "communication", "session", "character"], "inputSource": ["inputSOURCE", "contentStream", "Inputsource", "InputStream", "InputSource", "inputStream", "dataStream", "outputSources", "webSource", "inputsource", "dataSource", "contentsource", "webSources", "webStream", "InputSOURCE", "outputSource", "webSOURCE", "datasource", "outputStream", "inputSources", "outputSOURCE", "InputSources", "dataList", "contentSource", "InputList", "inputList", "contentList"], "factory": ["Fixture", "FFactory", "Factory", " fFactory", "fitter", "Fitter", "voker", " fitter", "vitter", "facixture", "facFactory", "Foker", "facactory", " foker", "fFactory", "foker", "fixture", "vFactory", "vactory", " fixture", "facitter"], "document": ["browser", "window", "subject", "product", "element", "policy", "forward", "application", "article", "doc", "production", "status", "page", "context", "log", "message", "Document", "xml", "content", "number", "information", "node", "media", "person", "entity", "initial", "expression", "dom", "tree", "parent", "object", "component", "null", "ocument", "record", "language", "database", "channel", "file", "version", "session"]}}
{"id1": "16851955", "id2": "18238468", "code1": "    @Test\n    public void testTrainingBackprop() throws IOException {\n        File temp = File.createTempFile(\"fannj_\", \".tmp\");\n        temp.deleteOnExit();\n        IOUtils.copy(this.getClass().getResourceAsStream(\"xor.data\"), new FileOutputStream(temp));\n        List<Layer> layers = new ArrayList<Layer>();\n        layers.add(Layer.create(2));\n        layers.add(Layer.create(3, ActivationFunction.FANN_SIGMOID_SYMMETRIC));\n        layers.add(Layer.create(2, ActivationFunction.FANN_SIGMOID_SYMMETRIC));\n        layers.add(Layer.create(1, ActivationFunction.FANN_SIGMOID_SYMMETRIC));\n        Fann fann = new Fann(layers);\n        Trainer trainer = new Trainer(fann);\n        trainer.setTrainingAlgorithm(TrainingAlgorithm.FANN_TRAIN_INCREMENTAL);\n        float desiredError = .001f;\n        float mse = trainer.train(temp.getPath(), 500000, 1000, desiredError);\n        assertTrue(\"\" + mse, mse <= desiredError);\n    }\n", "code2": "    @Test\n    public void testLoadSource() throws IOException {\n        ArticleMetadata metadata = new ArticleMetadata();\n        metadata.setId(\"http://arxiv.org/abs/math/0205003v1\");\n        InputStream inputStream = arxivDAOFacade.loadSource(metadata);\n        Assert.assertNotNull(inputStream);\n        StringWriter writer = new StringWriter();\n        IOUtils.copy(inputStream, writer, \"utf8\");\n        String contents = writer.toString();\n        Assert.assertTrue(contents.contains(\"A strengthening of the Nyman\"));\n        inputStream.close();\n    }\n", "label": 1, "substitutes": {"testTrainingBackprop": ["testTestingBackProp", "testTrainingbackward", "testTrainingBackProp", "testTrainingBprop", "testTrainingBend", "testTestingbackward", "testTrainingBackward", "testTrainingbackprop", "testTestingbackend", "testTrainingBward", "testTestingbackProp", "testTrainingBProp", "testTrainingbackend", "testTestingBackward", "testTestingbackprop", "testTestingBackend", "testTestingBackprop", "testTrainingbackProp", "testTrainingBackend"], "temp": ["empty", "txt", "output", "orig", "test", "dest", "mt", "remove", "unt", "tar", "create", "tmp", "Temp", "t", " tmp", "mod", "template", "Tem", " Temp", "mp", "fake", "v", "cp", "cache", "copy", "pt", "partial", "complete", "tab", "out", " temporary", "this", "stem", "null", "dat", "tc", "created", "porary", "tem", "por", "full", "emp", "local", "make", "zip", "mk", "relative", "file", "loc", "EMP", "p", "tm", "prefix", "w"], "layers": [" lensions", " lpackages", "lienses", "slanguages", "lowers", "lsayers", "flanguages", "liacks", "leights", "listenses", "leayers", " lients", "listanes", "liumers", "llays", "lsenses", " lights", " Lensions", " lowers", "slayers", " lanes", "lights", " lenses", "vlumers", "lients", "listayers", " languages", "slensions", "flayers", "lsanes", "flenses", "liowers", "lpackages", " lenges", " lacks", "lsasks", "vlayers", "lumers", "lays", "lacks", "llowers", "leenges", "llients", "liights", " Layers", " lasks", "lenses", "llacks", "lensions", "flays", "lenges", "languages", " Languages", "liients", "lienges", " Lights", "slenses", "llenses", "liayers", "llayers", "vlpackages", "listasks", "lasks", "lanes", "vlenses", "llanguages", " lumers", "slays", "lepackages", "lipackages", "slights"], "fann": [" fain", "ffann", "cain", "flana", "ffain", "ffannot", "flannis", "fmanann", " farn", "cann", " fannot", "ffarn", "farn", "fANN", "Fana", "FANN", "cannot", "Fannis", "flann", "fana", "fannis", "Fann", "fmanana", "fmanannis", "flANN", "fmanANN", "carn", "fain", "fannot"], "trainer": ["formacer", "formainer", "rainer", "riner", "brainer", "bruner", "Trainer", "Tracy", "bracer", "trayer", "truner", "tracer", " trayer", "racer", "Trayer", "runer", " tracer", "Triner", "striner", "strrain", "stracer", "Tracer", "Truner", "triner", "strainer", "formayer", "rrain", "tracy", "Trrain", "bracy", "racy", "trrain"], "desiredError": ["DesiredError", "desiredException", "desuredEr", "desIREDException", "DesuredERROR", "demuredEvent", "demuredEr", "desuredException", "demireEvent", "deseedException", "desireEvent", "demireEr", "desIREDError", "desuredERROR", "desiringEvent", "demiredEr", "desuredValue", "DesuredError", "DesiredERROR", "deseedError", "desiredEvent", "demiredEvent", "DesiredException", "demuredError", "DesuredValue", "desireError", "deseedValue", "deseedERROR", "DesuredException", "desIREDERROR", "desiredValue", "DesiredValue", "desuredError", "desuredEvent", "demiredError", "desIREDValue", "desireEr", "demireError", "desiredERROR", "desiringEr", "desiringError", "desiredEr"], "mse": ["cmpe", "mese", " moe", "mSE", " mSE", " mte", "mrso", "mmse", "cmse", "mroe", "mte", "msem", "mpe", "Mse", "mmSE", "moe", "mso", "mrpe", "cmSE", " mso", "mmese", "Mso", "mrse", "dSE", "dsem", "MSE", " mese", "mmpe", "cmese", " msem", " mpe", "Moe", "dse", "Mpe", "Mte", "dte", "Msem"]}}
{"id1": "2009072", "id2": "4389475", "code1": "    public InputStream openInput(Fragment path) throws IOException {\n        int len = path.words().size();\n        String p = Util.combine(\"/\", path.words().subList(1, len));\n        URL url = new URL(\"http\", path.words().get(0), p);\n        InputStream result = url.openStream();\n        return result;\n    }\n", "code2": "    @Override\n    public URLConnection openConnection(URL url) throws IOException {\n        if (!url.getProtocol().equals(\"file\")) {\n            String name = url.getFile();\n            File f = new File(cacheFolder, ((name.charAt(0) == '/') ? name.substring(1) : name).replace('/', File.separatorChar));\n            if (!f.exists()) {\n                File f2 = new File(f.getParentFile(), f.getName() + \"-not_found\");\n                if (!f2.exists()) {\n                    try {\n                        f.getParentFile().mkdirs();\n                        downloadFile(url, f);\n                    } catch (IOException e) {\n                        f.delete();\n                        throw e;\n                    }\n                }\n            }\n            return f.toURI().toURL().openConnection();\n        }\n        return super.openConnection(url);\n    }\n", "label": 0, "substitutes": {"openInput": ["createinput", "Openinput", "createInput", " openRead", "createOutput", "OpenInput", "OpenOutput", " openinput", "createRead", "openRead", "openinput", "openOutput", " openOutput", "OpenRead"], "path": ["exp", "phrase", "f", "transform", "txt", "ref", " remainder", "text", "prop", "tx", "pointer", "platform", "test", "entry", "part", "request", " pat", "fr", "doc", "ath", " oath", "context", "app", "template", "log", "pkg", "PATH", "cert", "message", "mount", "com", "cp", "route", "mat", "name", " expansion", "pt", "progress", "query", "cmd", "form", "component", "conn", "rect", "Path", "full", "self", "desc", "pattern", "msg", "pat", " PATH", "patch", "w"], "len": ["seq", "en", "nt", "dec", "Length", "h", " length", "enc", "ln", " l", "ls", "ll", "t", "lf", "pl", "sl", "lan", "un", "l", " clen", "pos", "nl", "li", "length", "lp", "lon", "el", "count", "n", "L", "lim", "mil", "Len", "ld", "size", "fin", "il", "loc"], "p": ["f", "pa", "pb", "u", "j", "pid", "vp", "sp", "d", "h", "part", "pp", "m", "fp", "t", "q", "c", "pkg", "b", "ps", "v", "cp", "param", "l", "np", "P", "s", "lp", "pre", "press", "pattern", "n", "jp", "wp", "pr", "prefix", "ap"], "url": ["browser", "f", "window", "hl", "gl", "ref", "client", "bel", "web", "ls", "ll", "base", "char", "link", "build", "log", "sl", "b", "cert", "ur", "mount", "uri", "URL", "str", "l", "out", "nl", "ul", "mail", "null", "r", "ssl", "ret", "http", "html", "job", "loc", "Url", "user", "server"], "result": ["event", "report", "pak", "response", "pair", "value", "process", "product", "output", "res", "feature", "mate", "comment", "request", "currency", "sequence", "stream", "table", "profile", "open", "cert", "message", "current", "surface", "successful", "success", "cup", "proc", "region", "uu", "true", "answer", "instance", "database", "relation", "r", "ret", "results", "Result"]}}
{"id1": "7006052", "id2": "23370621", "code1": "    public static void copyFileTo(String src, String dest) throws FileNotFoundException, IOException {\n        File destFile = new File(dest);\n        InputStream in = new FileInputStream(new File(src));\n        OutputStream out = new FileOutputStream(destFile);\n        byte buf[] = new byte[1024];\n        int len;\n        while ((len = in.read(buf)) > 0) out.write(buf, 0, len);\n        in.close();\n        out.close();\n    }\n", "code2": "    private void downloadFile(File target, String s3key) throws IOException, S3ServiceException {\n        InputStream in = downloadData(s3key);\n        if (in == null) {\n            throw new IOException(\"No data found\");\n        }\n        in = new InflaterInputStream(new CryptInputStream(in, cipher, getDataEncryptionKey()));\n        File temp = File.createTempFile(\"dirsync\", null);\n        FileOutputStream fout = new FileOutputStream(temp);\n        try {\n            IOUtils.copy(in, fout);\n            if (target.exists()) {\n                target.delete();\n            }\n            IOUtils.closeQuietly(fout);\n            IOUtils.closeQuietly(in);\n            FileUtils.moveFile(temp, target);\n        } catch (IOException e) {\n            fetchStream(in);\n            throw e;\n        } finally {\n            IOUtils.closeQuietly(fout);\n            IOUtils.closeQuietly(in);\n        }\n    }\n", "label": 1, "substitutes": {"copyFileTo": [" copyFileOver", "copyToTo", "copyToThrough", "copyFilesTo", "copyFilesFrom", " copyFilesOver", "copyfileFrom", "copyFileThrough", "copyFileOver", "copyFileFrom", " copyFilesThrough", "copyToFrom", "copyFilesThrough", " copyFilesFrom", "copyfileTo", " copyFileThrough", "copyToOver", "copyfileOver", "copyFilesOver", "copyfileThrough", " copyFileFrom", " copyFilesTo"], "src": ["ser", "rc", "txt", "usr", "sb", "rt", "cos", "ins", "sit", "cont", "sys", "bs", "init", "sq", "pkg", "ctr", "cur", "sr", "rel", "Source", "req", "sec", "url", "rs", "rl", "sf", "input", "sin", "rx", "sc", "st", "obs", "iv", "http", "config", "start", "source", "ipl", "inst"], "dest": ["origin", "exp", "decl", "good", "nt", "usr", "home", "pub", "orig", "them", "test", "d", "cont", "way", "www", "trans", "tmp", "est", "port", "mem", "done", "rest", "del", "pl", "result", " dst", "req", "target", "des", "st", "dir", "dat", "desc", "Dest", "dist", "de", "source", "loc", "end"], "destFile": ["DestFiles", "destfile", "distPage", "newFile", "sourceFile", "newfile", "sourcefile", "srcFiles", "distFile", "destPage", "srcDir", "sourceDir", "distDo", "DestDir", "destDir", " destDo", "destDo", "sourceFiles", "srcfile", "Destfile", "newDo", "distfile", " destPage", "DestFile", "destFiles", "newPage", "srcFile", " destfile"], "in": ["ze", "rc", "rin", "en", "inn", "ini", "con", "gin", "IN", "ins", "im", "on", "al", "In", "init", "inside", "inner", "ic", "ai", "up", "i", "read", "bin", "act", "inc", "input", "sin", "iter", "it", "per", "ain", "ind", "el", "info", "mm", "io", "din", "inf", "is", "isin", "cin", "from"], "out": ["co", "en", "nt", "and", "by", "con", "output", "res", "cos", "oss", "cn", "obj", "on", "client", "sys", "t", "inner", "po", "net", "we", "write", "b", "to", "ot", "v", "writer", "os", "outer", "it", "gt", "null", "ou", "at", "outs", "g", "o", "aos", "auto", "n", "io", "Out", "OUT", "p", "can", "ne", "ex"], "buf": ["seq", "good", "cv", "block", "br", "buff", "var", "cat", "prop", "img", "tx", "cam", "cb", "obj", "bh", "bc", "pad", "conv", "box", "bus", "buffer", "log", "bag", "b", "pkg", "cur", "db", "aka", "cp", "bin", "Buffer", "uf", "rb", "str", "bytes", "tab", "alph", "cmd", "mu", "queue", "abet", "batch", "bar", "Buff", "cap", "msg", "cf", "arr", "vec", "data", "gen"], "len": ["seq", "exp", "en", "nt", "wid", "z", "dl", "cmp", "la", "ln", "lic", "ls", "ll", "mun", "t", "lf", "del", "pl", "mid", "lan", "rel", "lif", "v", "e", "le", "str", "coll", "l", "pos", "val", "length", "lon", "el", "count", "n", "cap", "no", "Len", "fin", "ld", "il", "compl", "size", "elt", "vec", "end"]}}
{"id1": "9275622", "id2": "255765", "code1": "    private boolean copyFile(File _file1, File _file2) {\n        FileInputStream fis;\n        FileOutputStream fos;\n        try {\n            fis = new FileInputStream(_file1);\n            fos = new FileOutputStream(_file2);\n            FileChannel canalFuente = fis.getChannel();\n            canalFuente.transferTo(0, canalFuente.size(), fos.getChannel());\n            fis.close();\n            fos.close();\n            return true;\n        } catch (FileNotFoundException e) {\n        } catch (IOException e) {\n        }\n        return false;\n    }\n", "code2": "    private static void main(String[] args) {\n        try {\n            File f = new File(\"test.txt\");\n            if (f.exists()) {\n                throw new IOException(f + \" already exists.  I don't want to overwrite it.\");\n            }\n            StraightStreamReader in;\n            char[] cbuf = new char[0x1000];\n            int read;\n            int totRead;\n            FileOutputStream out = new FileOutputStream(f);\n            for (int i = 0x00; i < 0x100; i++) {\n                out.write(i);\n            }\n            out.close();\n            in = new StraightStreamReader(new FileInputStream(f));\n            for (int i = 0x00; i < 0x100; i++) {\n                read = in.read();\n                if (read != i) {\n                    System.err.println(\"Error: \" + i + \" read as \" + read);\n                }\n            }\n            in.close();\n            in = new StraightStreamReader(new FileInputStream(f));\n            totRead = in.read(cbuf);\n            if (totRead != 0x100) {\n                System.err.println(\"Simple buffered read did not read the full amount: 0x\" + Integer.toHexString(totRead));\n            }\n            for (int i = 0x00; i < totRead; i++) {\n                if (cbuf[i] != i) {\n                    System.err.println(\"Error: 0x\" + i + \" read as 0x\" + cbuf[i]);\n                }\n            }\n            in.close();\n            in = new StraightStreamReader(new FileInputStream(f));\n            totRead = 0;\n            while (totRead <= 0x100 && (read = in.read(cbuf, totRead, 0x100 - totRead)) > 0) {\n                totRead += read;\n            }\n            if (totRead != 0x100) {\n                System.err.println(\"Not enough read. Bytes read: \" + Integer.toHexString(totRead));\n            }\n            for (int i = 0x00; i < totRead; i++) {\n                if (cbuf[i] != i) {\n                    System.err.println(\"Error: 0x\" + i + \" read as 0x\" + cbuf[i]);\n                }\n            }\n            in.close();\n            in = new StraightStreamReader(new FileInputStream(f));\n            totRead = 0;\n            while (totRead <= 0x100 && (read = in.read(cbuf, totRead + 0x123, 0x100 - totRead)) > 0) {\n                totRead += read;\n            }\n            if (totRead != 0x100) {\n                System.err.println(\"Not enough read. Bytes read: \" + Integer.toHexString(totRead));\n            }\n            for (int i = 0x00; i < totRead; i++) {\n                if (cbuf[i + 0x123] != i) {\n                    System.err.println(\"Error: 0x\" + i + \" read as 0x\" + cbuf[i + 0x123]);\n                }\n            }\n            in.close();\n            in = new StraightStreamReader(new FileInputStream(f));\n            totRead = 0;\n            while (totRead <= 0x100 && (read = in.read(cbuf, totRead + 0x123, 7)) > 0) {\n                totRead += read;\n            }\n            if (totRead != 0x100) {\n                System.err.println(\"Not enough read. Bytes read: \" + Integer.toHexString(totRead));\n            }\n            for (int i = 0x00; i < totRead; i++) {\n                if (cbuf[i + 0x123] != i) {\n                    System.err.println(\"Error: 0x\" + i + \" read as 0x\" + cbuf[i + 0x123]);\n                }\n            }\n            in.close();\n            f.delete();\n        } catch (IOException x) {\n            System.err.println(x.getMessage());\n        }\n    }\n", "label": 1, "substitutes": {"copyFile": [" cpfile", "copyFiles", " copyfile", " copyStream", " duplicatefile", " duplicateFiles", " cpFile", " duplicateFile", "copyStream", "copyfile", " copyFiles", " cpFiles", " cpStream", " duplicateStream"], "_file1": ["_FileInit", "_files1", "_ileOne", "_fileOne", "_linkInit", "_link2", "_fileInit", "_files2", "_link1", "_ile2", "_ileInit", "_File2", "_ile1", "_FileFirst", "_linkOne", "_File1", "_ileFirst", "_FileOne", "_filesOne", "_fileFirst", "_filesFirst"], "_file2": [" _file02", "_FILEb", "_FILE1", "_File02", "_file02", "_Fileb", "_image1", "_link2", "_linkTwo", "_link1", " _fileb", "_File2", " _File1", "_fileb", " _fileTwo", "_FILE2", " _FILEb", "_linktwo", "_fileTwo", "_image2", "_image02", "_Filetwo", "_FILE02", " _FileTwo", "_File1", " _File2", "_imageb", " _FILE2", " _filetwo", " _FILE02", " _Filetwo", "_filetwo", " _FILE1", "_FileTwo"], "fis": ["flis", "fais", "kis", "fi", "Fis", "ufi", "cfis", "qiss", "cos", "fris", " fris", "ufis", "Fris", "ufiss", "cfois", "cis", " fi", "ufios", "Fiss", "qis", "qios", "Fios", "cfiss", " fais", " fois", "kios", "fliss", "fli", "fiss", "Fos", "flios", "cios", "cais", "Fois", " fios", "fios", "qos", "fois", "kos", "cfris", " fiss", "kais"], "fos": ["flis", "ffos", "foes", "woes", "hose", "mos", "foss", "fose", "flos", " faos", " fows", "wis", "floss", "sfoss", "mows", "faos", " foes", "fows", "wos", "moes", "ffis", "hos", "wows", " fose", "hoes", "sfos", "floes", "ffoss", "woss", "sfoes", "maos", " foss", "sfose", "hoss", "ffoes", "waos"], "canalFuente": ["canalFalperor", "canallfuestro", "canallfuenza", "canalUteree", "canalTenente", "canalKuperor", "canalFalje", "canalfuent", "canalUtestro", "canallFuperor", "canalFuje", "canalFalestro", "canalUtente", "canalFiente", "canallFuent", "canalFueree", "canallfuperor", "canalfuenza", "canalKuje", "canallfuje", "canallFuestro", "canalTenent", "canalFuestro", "canalTenperor", "canalFient", "canalFalente", "canallFuenza", "canallFuje", "canallFueree", "canallFuente", "canallfuent", "canalFienza", "canalfuperor", "canalFuenza", "canalFalent", "canalfuente", "canallfuente", "canalfuje", "canalfuestro", "canalTenenza", "canalFiperor", "canalKuent", "canalFuperor", "canalKuente", "canalFuent", "canalFaleree", "canalUtent", "canallfueree", "canalfueree"]}}
{"id1": "9857412", "id2": "13368520", "code1": "    @Override\n    public void writeData(byte[] data, byte[] options, boolean transferMetaData) throws Throwable {\n        long startTime = System.currentTimeMillis();\n        long transferredBytesNum = 0;\n        long elapsedTime = 0;\n        Properties opts = PropertiesUtils.deserializeProperties(options);\n        String server = opts.getProperty(TRANSFER_OPTION_SERVER);\n        String username = opts.getProperty(TRANSFER_OPTION_USERNAME);\n        String password = opts.getProperty(TRANSFER_OPTION_PASSWORD);\n        String filePath = opts.getProperty(TRANSFER_OPTION_FILEPATH);\n        if (transferMetaData) {\n            int idx = filePath.lastIndexOf(PATH_SEPARATOR);\n            if (idx != -1) {\n                String fileName = filePath.substring(idx + 1) + META_DATA_FILE_SUFIX;\n                filePath = filePath.substring(0, idx);\n                filePath = filePath + PATH_SEPARATOR + fileName;\n            } else {\n                filePath += META_DATA_FILE_SUFIX;\n            }\n        }\n        URL url = new URL(PROTOCOL_PREFIX + username + \":\" + password + \"@\" + server + filePath + \";type=i\");\n        URLConnection urlc = url.openConnection(BackEnd.getProxy(Proxy.Type.SOCKS));\n        urlc.setConnectTimeout(Preferences.getInstance().preferredTimeOut * 1000);\n        urlc.setReadTimeout(Preferences.getInstance().preferredTimeOut * 1000);\n        OutputStream os = urlc.getOutputStream();\n        ByteArrayInputStream bis = new ByteArrayInputStream(data);\n        byte[] buffer = new byte[1024];\n        int br;\n        while ((br = bis.read(buffer)) > 0) {\n            os.write(buffer, 0, br);\n            if (!transferMetaData) {\n                transferredBytesNum += br;\n                elapsedTime = System.currentTimeMillis() - startTime;\n                fireOnProgressEvent(transferredBytesNum, elapsedTime);\n            }\n        }\n        bis.close();\n        os.close();\n    }\n", "code2": "    public void sendTextFile(String filename) throws IOException {\n        Checker.checkEmpty(filename, \"filename\");\n        URL url = _getFile(filename);\n        PrintWriter out = getWriter();\n        Streams.copy(new InputStreamReader(url.openStream()), out);\n        out.close();\n    }\n", "label": 0, "substitutes": {"writeData": [" writeContent", "exportFile", " writeFile", "exportData", "printRequest", "exportRequest", "writeContent", "writeFile", "printFile", "printData", " writeRequest", "writeRequest", "exportContent", "printContent"], "data": ["buf", "window", "response", "block", "value", "text", "DATA", "json", "reports", "output", "sample", "d", "items", "ata", "raw", "table", "what", "accept", "base", "bits", "device", "message", "result", "format", "content", "bin", "cache", "media", "partial", "input", "actions", "encrypted", "dat", "batch", "values", "body", "bytes"], "options": ["terms", "times", "tags", "settings", "flags", "params", "parts", "abilities", "IONS", "keys", "details", "option", "other", "currency", "types", "comes", "ices", "bits", "pins", "stats", "Options", "ts", "words", "styles", "properties", "caps", "ops", "meta", "metadata", "headers", "ports", "ptions", "info", "cases", "config", "features", "values", "bytes", "results", "faces"], "transferMetaData": ["transferMetData", "TransferMetaInfo", "transferSuperData", "transferMetadata", "TransferMetInfo", "transferMetdata", "TransferMetadata", "transferSuperInfo", "transferMetUpdate", "transferOKdata", " transferMetaDone", "transferMetDone", "transferDataInfo", "transferMetOnly", "transferOKInfo", "storeMetaData", "transferETAData", " transferMetData", "transferDataData", "transferSuperUpdate", "transferDatadata", "transfermetaData", "TransferMetaData", "transfermetaDone", "TransferMetData", "storeMetaUpdate", "transferOKData", "transferMetaUpdate", "transfermetaOnly", "TransferMetdata", "transferMetaDone", "transferMetaInfo", "transferMetaOnly", "storeMetaInfo", "transferMetInfo", " transferMetaOnly", "transferETADone", " transferMetDone", "transferETAOnly", " transferMetOnly"], "startTime": ["startingDef", "beforeTime", "startedTime", "startPath", "launchPath", "startingTimeout", "startedTim", "startingPath", "beforeDef", "startDef", "startingTime", "startTim", "launchDef", "StartTime", "launchTime", "StartTim", "StartType", " startTim", "launchTimeout", "beforePath", "beforeTimeout", " startType", "startType", "startTimeout", "startedType"], "transferredBytesNum": ["transferredBytesMon", "transformedBytesLen", "transferredbytesLen", "transportedBytesVal", "transformedBytesNo", "transferredDocumentsNUM", "translatedBytesN", "translatedBytesNum", "transferredbytesNum", "transferredbytesnum", "transferredPartsNo", "transportedBytesNum", "transferredItemsUn", "transferredbytesMsg", "transformedbytesNum", "transferredItemsNum", "transferredBytesnum", "transferredFilesMon", "transportedbytesNUM", "transportedbytesNum", "transferredItemsMsg", "transformedbytesLen", "transferredBlocksNum", "transferredbytesVal", "transferredBytesMsg", "transferredPartsNum", "transformedbytesNo", "transferredbytesNUM", "transferredFilesUn", "transferredTokensN", "transferredbytesNo", "transferredBytesVal", "transportedbytesVal", "transferredBytesUn", "translatedTokensNum", "translatedTokensMon", "transferredDocumentsMsg", "transferredDocumentsNum", "transferredBytesNUM", "transferredBlocksnum", "transferredTokensMon", "translatedTokensN", "translatedBytesMon", "transportedBytesMsg", "transferredItemsNUM", "transferredPartsnum", "transferredItemsN", "transferredDocumentsVal", "transferredFilesN", "transformedBytesNum", "transferredItemsVal", "transferredTokensUn", "transferredTokensNum", "transferredPartsLen", "transportedbytesMsg", "transferredBlocksLen", "transferredItemsMon", "transformedbytesnum", "transferredBlocksNo", "transportedBytesNUM", "translatedBytesUn", "transferredBytesLen", "transferredFilesNum", "translatedTokensUn", "transferredBytesNo", "transferredBytesN", "transformedBytesnum"], "elapsedTime": ["elapseTim", "elapsedTh", "elivedTh", "elapsesMem", "lapseTime", "elimatedTime", "elapseTime", "delimatedTime", "elimatedMem", "elapsedTim", "elpletedtime", "delpletedTime", "elapsesTimeout", "delpletedTim", "delapsedTime", "elpletedTimeout", "elapseTh", "delimatedTimeout", "lapseTimeout", "lapsedTime", "elivedTime", "delapsedtime", "elivedTimeout", "delpletedtime", "elpletedTim", "elpletedTh", "delimatedMem", "delapsedTim", "elapsedTimeout", "elapsetime", "delapsedMem", "elpletedTime", "elplayedtime", "lapseTh", "delapsedTimeout", "elapsedMem", "lapsedTh", "elplayedTim", "elimatedTimeout", "elapsesTime", "elplayedTime", "lapsedTimeout", "elapseTimeout", "elapseMem", "elapsedtime"], "opts": [" opTs", "popTS", "optTs", "oprs", "copps", "Opts", "optt", "ropty", "ropTs", "optTS", "opTS", "popTs", "Opms", "optty", "popts", "opms", "iopms", "Oppt", "OpTs", "optts", "optpt", "optps", "ropTS", "opt", "copms", "copTS", "opps", " oppt", "copts", "opty", " opms", "opTs", "poprs", "optrs", "optms", "popty", "ropts", "popt", "iopts", "ropt", "iopTS", "roprs", "iopps", "oppt"], "server": ["browser", "ser", "address", "center", "email", "console", "engine", "service", "resource", "client", "sys", "site", "port", "connection", "directory", "device", "system", "serving", "owner", "uri", "Server", "localhost", "handler", "database", "domain", "manager", "remote", "scale", "erver", "source", "folder", "root", "user", "host", "peer"], "username": ["nick", "author", "usr", "creator", "subject", "email", "uno", "application", "sudo", "USER", "human", "mitter", "basic", "master", "system", "filename", "number", "owner", "name", "phone", "ername", "token", "person", "localhost", "operator", "login", "john", "auth", "metadata", "consumer", "term", "sword", "monitor", "database", "account", "source", "User", "user", "prefix", "title"], "password": ["phrase", "worker", "PASS", "policy", "word", "resource", "description", "secret", "sudo", "help", "prefix", " Password", "shadow", "profile", "attribute", "command", "Password", "basic", "message", "wd", "words", "wordpress", "property", "number", "token", "hash", "auth", "path", "paste", "confirmed", "sword", "database", "padding", "key", "account", "pool", "ssh", "ass", "user", "remember", "power", "crypt", "pass"], "filePath": ["resourceSet", "ilePath", "basePATH", "ileSet", "resourceUrl", "fileStatus", "FILESet", "fileConfig", "FileType", "ileForm", "FileSystem", "issueDir", "FileName", "FileUrl", "FileDir", "baseName", " fileCh", "fileUrl", " fileUrl", "FileStatus", "FILEName", "fileSet", "ilepath", "Filepath", "fileDir", "issueName", "resourcepath", "fullPath", "fileType", "fileForm", "FileConfig", "fullName", "FilePATH", " fileSystem", " fileForm", "FileForm", "ileConfig", "filePATH", "FileSet", "baseSet", "FILEpath", " fileSet", "ileStatus", "fullpath", "basepath", " fileStatus", "fileCh", "resourceName", "ileCh", "issuePath", "ileSystem", "fullPATH", "ileDir", "resourceType", "ileName", "fileSystem", "filepath", "FilePath", "basePath", "FILEPath", "FileCh", "ileType", " fileType", "resourcePath", " fileConfig", " filepath"], "idx": [" idix", "hidewx", "IDn", " idy", "showX", " idex", "hiden", " idX", " idxc", "idexs", "edy", "idexx", " idxs", "edex", "showxx", "Idxx", "edxc", " idxes", " idxx", " idwx", "ordex", "Idx", "idxs", "edx", "ordy", "ordxc", "idmx", "erxx", "ordx", " idn", "erxs", "idix", "idwx", "IDwx", "idxx", "idex", "showix", "hidemx", "Idix", "idexes", "idxes", "idn", "showx", "hidex", "IDmx", " idmx", "erx", "IDx", "idxc", "idy", "IdX", "erxes", "idX"], "fileName": ["ilePath", "fileNAME", "fileFace", "playNames", "FileName", "FileNames", "playName", "ileMember", "playFace", "FileFace", "FileNAME", "playNAME", "fileMember", " fileData", " fileFace", "FileData", "FileMember", " fileNAME", "fileNames", "ileData", "ileName", " fileMember", " fileNames", "FilePath", "fileData"], "url": ["browser", "hl", "gl", "sb", "dl", "lb", "client", "https", "bel", "ls", "web", "ll", "link", "build", "log", "sl", "call", "lr", "rel", "xml", "ur", "gc", "uri", "URL", "str", "rl", "l", "nl", "ul", "li", "conn", "r", "ssl", "ret", "http", "ld", "loc", "il", "Url"], "urlc": ["urlcp", "cfcu", "Urlc", "callc", "sslcp", "callcache", "calC", " urlcm", "gifcon", "urlcache", "methodc", "sslfc", "callcp", "Urlfc", "sslcu", "calcu", "httpcs", "URLcm", "cfcon", "httpcp", "urlcon", "Urlci", "sslcon", "sslcache", " urlconn", "sslci", "urlC", "sslcs", "cfc", "sslc", "urlci", "URLconn", "sslC", "gifconn", "urlcm", "urlcs", "methodci", "cfC", "urlfc", "URLcon", "calcon", "calc", "httpc", "urlcu", "methodcon", "urlconn", "httpcache", " urlcon", "gifc", "Urlcon", "URLc", "callcs", "methodfc", "gifcm"], "os": ["dos", "Os", "ost", "us", "cos", "oss", "mos", "ob", "et", "osi", "oses", "fs", "sys", "bs", "ls", "ns", "los", "ose", "ps", "i", "oid", "otes", "ols", "out", "pos", "bos", "ops", "ris", "ds", "obs", "aos", "o", "oS", "OS", "io", "socket", "is", "ios", "iso", "oos", "cs", "ot"], "bis": ["dos", "sb", "ses", "bf", "ints", "oss", "ins", "js", "nis", "bps", "bh", "fs", "sys", "bs", "rison", "ls", "ais", "los", "bi", "pins", "bits", "fits", "orus", "bb", "basic", "soc", "its", "bin", "fps", "serv", "ris", "bid", "bos", "obs", "lis", "aos", "rots", "boot", "vs", "is", "oi", "ios", "isin", "bil", "lbs", "BS", "opus", "es", "vor", "sis"], "buffer": ["phrase", "extra", "buf", "window", "block", "buff", "sample", "FFER", "frame", "comment", "area", "word", "sequence", "append", "table", "base", "template", "char", "command", "document", "message", "face", "variable", "Buffer", "cache", "initial", "iter", "note", "history", "paste", "queue", "length", "binary", "batch", "filter", "database", "bar", "volume", "temp", "texture", "memory", "display", "character"], "br": ["browser", "buf", "hr", "span", "bt", "tr", "div", "block", "bf", "j", "p", "bl", "mr", "bridge", "bal", "bra", "bg", "next", "sp", "cr", "bh", "fr", "bs", "bc", "BR", "bsp", "ber", "bi", "b", "ctr", "bb", "dr", "lr", "rel", "rem", "bp", "i", "ptr", "xt", "ba", "str", "Br", "ch", "r", "bar", "nr", "ble", "gr", "n", "vr", "shr", "arr", "bn", "pr", "bre", "bd"]}}
{"id1": "12537270", "id2": "8665321", "code1": "    public Vector parse(String link) {\n        addMessage(\"Parsing: \" + link);\n        links.removeAllElements();\n        URLConnection conn = null;\n        Reader rd = null;\n        EditorKit kit = new HTMLEditorKit();\n        Document doc = kit.createDefaultDocument();\n        doc.putProperty(\"IgnoreCharsetDirective\", Boolean.TRUE);\n        URL url = null;\n        try {\n            url = new URL(link);\n        } catch (MalformedURLException err) {\n            System.out.println(\"Malformed URL\");\n            return links;\n        }\n        try {\n            conn = new URL(link).openConnection();\n            rd = new InputStreamReader(conn.getInputStream());\n        } catch (Exception err) {\n            err.printStackTrace();\n            return links;\n        }\n        try {\n            kit.read(rd, doc, 0);\n            ElementIterator it = new ElementIterator(doc);\n            javax.swing.text.Element elem;\n            while ((elem = it.next()) != null) {\n                SimpleAttributeSet s = (SimpleAttributeSet) elem.getAttributes().getAttribute(HTML.Tag.A);\n                if (s != null) {\n                    if (s.toString().indexOf(\"script\") >= 0) continue;\n                    String lnk = \"\";\n                    try {\n                        lnk = s.getAttribute(HTML.Attribute.HREF).toString();\n                    } catch (Exception err) {\n                        continue;\n                    }\n                    int j = 0;\n                    if ((j = lnk.indexOf('#')) >= 0) lnk = lnk.substring(0, j);\n                    URL urlLink = new URL(url, lnk);\n                    if (!url.getHost().equals(urlLink.getHost())) continue;\n                    String str = urlLink.toString();\n                    if (!str.startsWith(\"http\")) continue;\n                    if (str.endsWith(\".pdf\")) {\n                        continue;\n                    }\n                    for (int i = 0; i < leaveSuffix.length; i++) {\n                        if ((str.endsWith(leaveSuffix[i]))) continue;\n                    }\n                    boolean skip = false;\n                    for (int i = 0; i < suffix.length; i++) {\n                        if ((str.endsWith(suffix[i]))) skip = true;\n                    }\n                    if (!skip) {\n                        try {\n                            conn = urlLink.openConnection();\n                        } catch (Exception err) {\n                        }\n                        String contentType = null;\n                        if (contentType == null) contentType = conn.getContentType();\n                        if (contentType.equals(\"application/pdf\")) {\n                            continue;\n                        } else if (!contentType.equals(\"text/html\")) {\n                            continue;\n                        }\n                    }\n                    if (!links.contains(urlLink.toString())) {\n                        links.addElement(urlLink.toString());\n                    }\n                }\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return links;\n    }\n", "code2": "    public Vector<String> getNetworkServersIPs(String netaddress) {\n        Vector<String> result = new Vector<String>();\n        boolean serverline = false;\n        String line;\n        String[] splitline;\n        try {\n            URL url = new URL(netaddress);\n            URLConnection connection = url.openConnection();\n            BufferedReader reader = new BufferedReader(new InputStreamReader(connection.getInputStream()));\n            while ((line = reader.readLine()) != null) {\n                if ((serverline) && line.startsWith(\";\")) {\n                    serverline = false;\n                }\n                if (serverline) {\n                    splitline = line.split(\":\");\n                    result.add(splitline[1]);\n                }\n                if (line.startsWith(\"!SERVERS\")) {\n                    serverline = true;\n                }\n            }\n        } catch (MalformedURLException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return result;\n    }\n", "label": 0, "substitutes": {"parse": ["php", "handle", "pair", "process", "match", "layer", "parser", "se", "resource", "update", "build", "replace", "slice", "load", "ping", "close", "format", "read", "error", "arse", "split", "Parser", "check", "loop", "p", "print", "delete"], "link": ["type", "style", "image", "lock", "address", "block", "element", "links", "match", "entry", "sp", "let", "word", "frame", "ink", "se", "ln", "page", "tag", "script", "template", "char", "label", "linked", "action", "log", "load", "ping", "join", "rel", "e", "route", "uri", "name", "le", "l", "path", "Link", "line", "add", "ip", "pattern", "local", "html", "string", "start", "loc", "source", "index", "id"], "conn": ["txt", "nt", "ctx", "gn", "con", "res", "cat", "pas", "oss", "comm", "cn", "cb", "cont", "cr", "enc", "obj", "yn", "ln", "ws", "client", "nec", "ls", "conv", "ann", "ns", "connection", "addr", "err", "c", "open", "resp", "ctr", "rel", "org", "ct", "cp", "nav", "act", "Conn", "ait", "ch", "cmd", "ctrl", "connect", "nc", "ner", "socket", "loc", "cs"], "rd": ["wr", "hr", "rc", "rar", "usr", "rt", "mr", "raf", "rand", "d", "rer", "rw", "ri", "reader", "erd", "rog", "fr", "ro", "red", "ird", "sr", "dr", "lr", "rs", "rb", "rr", "rl", "rid", "dd", "rx", "rad", "r", "rn", "vr", "din", "ra", "rh", "rob", "ld", "nd"], "kit": ["Kit", "iz", "sky", "ctx", "cat", "rt", "webkit", "util", "cam", "sit", "tk", "et", "h", "js", "jit", "bh", "kt", "sys", "set", "t", "init", "box", "maker", "ang", "base", "k", "net", "pkg", "pot", "c", "ic", "cu", "iw", "lib", "shop", "iter", "ch", "rot", "pack", "sc", "tc", "kat", "boot", "html", "io", "mk", "ect", "qt", "bot", "ok"], "doc": ["window", "nt", "div", "dec", "json", "p", "tx", "di", "d", "sp", "js", "page", "t", "in", "md", "dc", "log", "man", "document", "dr", "db", "xml", "content", "def", "head", "Doc", "out", "ds", "tree", "mu", "dir", "dat", "og", "g", "ad", "n", "html", "config", "mk", "msg", "file", "body", "pdf", "data", "w"], "url": ["gl", "address", "ref", "git", "dl", "util", "resource", "ln", "https", "bel", "web", "ls", "ll", "t", "deb", "base", "addr", "pl", "sl", "open", "log", "cert", "impl", "lr", "xml", "org", "ur", "mount", "uri", "URL", "rl", "l", "api", "nl", "ul", "mail", "path", "mb", "hub", "r", "ssl", "blog", "domain", "el", "http", "html", "server", "loc", "Url", "user", "host", "peer"], "it": ["nt", "iz", "pit", "IT", "sit", "im", "et", "ite", "ert", "wait", "t", "init", "in", "ic", "ci", "lit", "you", "iw", "its", "ct", "l", "out", "iter", "li", "at", "rit", "ind", "ip", "io", "It", "he", "ot"], "elem": ["seem", "belem", " peom", "eom", "bem", "element", " element", "selement", "tlem", "seelt", "tom", "llem", "belt", "tlect", "eelt", "telement", " pelect", "em", "elect", "lelt", "belement", "eleem", " pelement", "tlement", "lem", "telem", "llement", "elelem", "tem", "elelement", "selem", "eem", " eom", " elect", "sem", "telt", "elt", " pelem", "selt", "eleelt"], "s": ["xs", "ss", "sb", "sm", "ms", "sp", "ins", "js", "se", "fs", "sys", "set", "ls", "sa", "ns", "ess", "sq", "sg", "spec", "sl", "stats", "sym", "ps", "S", "ts", "less", "sd", "sv", "ats", "rs", "os", "simple", "ys", "ds", "gs", "st", "si", "space", "als", "sts", "is", "sam", "es", "cs"], "lnk": ["lnj", "klke", "lnn", "lank", "lankt", "dnn", "dlk", "dln", "lnek", "nelko", "lnak", "olnck", "linke", "klek", "linj", "lnko", "dnko", "linko", "linn", "olnj", "lintk", "lnck", "nlko", "nlck", "lenk", "nln", "olnko", "dltk", "dlik", "lnke", "olnak", "olnn", "nlak", "olnkt", "dlck", "nelek", "klko", "lenj", "linck", "lenck", "lntk", "lann", "lnik", "nlk", "nltk", "linik", "olnk", "nelk", "olnik", "linak", "linek", "dnck", "lnkt", "dlak", "klk", "nelke", "lenak", "dnk", "nlkt", "lanak"], "j": ["div", "br", "dj", "z", "y", "ng", "uj", "h", "bo", "js", "obj", "jl", "t", "q", "jj", "k", "max", "je", "bj", "aj", "v", "adj", "ja", "jc", "off", "ij", "kj", "pos", "ji", "li", "jump", "g", "ind", "Ja", "o", "oj", "J", "jp", "n", "prime"], "urlLink": ["urlMatch", " urlLoad", " urllink", "emailLink", "sslLoad", "urllink", " urlLock", "emailSource", "emailLock", " urlMatch", "objRel", "urlLock", "urlLinks", "strRel", "urlStart", "strUrl", "emaillink", " urlRel", "objLink", "urlSource", " urlStart", "UrlSource", "objStart", " urlSource", "urlUrl", "httpLink", "UrlLock", "sslMatch", "strLink", "urlRel", "UrlLink", "httpLoad", "sslLinks", " urlLinks", "Urllink", "sslLink", "urlLoad", " urlUrl", "objUrl", "httpLinks", "strStart", "httpMatch"], "str": ["exp", "f", "wr", "txt", "tr", "div", "usr", "text", "br", "vol", "res", "elt", "comm", "part", "js", "m", "fr", "raw", "ocr", "ll", "t", "inner", "char", "spec", "chain", "stable", "pkg", "ctr", "Str", "dr", "list", "coll", "out", "hex", "tree", "st", "g", "stri", "r", "n", "string", "html", "STR", "msg", "temp", "arr", "inst", "p", "print", "prefix", "w"], "i": ["mi", "iy", "ini", "ms", "us", "y", "PI", "I", "ie", "qi", "di", "im", "ei", "area", "m", "ki", "ami", "init", "x", "ti", "hi", "me", "chain", "in", "iu", "bi", "cli", "ic", "multi", "ci", "ai", "sim", "gi", "ui", "pi", "ix", "iter", "xi", "li", "ims", "\u0438", "si", "length", "ori", "batch", "o", "ip", "info", "io", "ii", "start", "oi", "ity", "index", "zi", "p", "a", "phi", "ex"], "skip": [" bypass", "process", "fast", "cmp", " skipped", "deep", "stop", "op", " skipping", "kill", "write", "replace", "strip", "Skip", "sk", "ips", "copy", "complete", "ops", "iter", "note", "jump", "ip", "add", "warn", "clip", "loop", "pass"]}}
{"id1": "3024987", "id2": "22441244", "code1": "    @Test\n    public void testCopy_readerToOutputStream_Encoding() throws Exception {\n        InputStream in = new ByteArrayInputStream(inData);\n        in = new YellOnCloseInputStreamTest(in);\n        Reader reader = new InputStreamReader(in, \"US-ASCII\");\n        ByteArrayOutputStream baout = new ByteArrayOutputStream();\n        OutputStream out = new YellOnFlushAndCloseOutputStreamTest(baout, false, true);\n        IOUtils.copy(reader, out, \"UTF16\");\n        byte[] bytes = baout.toByteArray();\n        bytes = new String(bytes, \"UTF16\").getBytes(\"US-ASCII\");\n        assertTrue(\"Content differs\", Arrays.equals(inData, bytes));\n    }\n", "code2": "    public void send(org.hibernate.Session hsession, Session session, String repositoryName, int ideIdint, String to, String cc, String bcc, String subject, String body, Vector attachments, boolean isHtml, String charset, InternetHeaders headers, String priority) throws MailException {\n        try {\n            if (charset == null) {\n                charset = MimeUtility.javaCharset(Charset.defaultCharset().displayName());\n            }\n            if ((body == null) || body.trim().equals(\"\")) {\n                body = \" \";\n            }\n            Email email = null;\n            if (isHtml) {\n                email = new HtmlEmail();\n            } else {\n                email = new MultiPartEmail();\n            }\n            email.setCharset(charset);\n            Users user = getUser(hsession, repositoryName);\n            Identity identity = getIdentity(hsession, ideIdint, user);\n            InternetAddress _returnPath = new InternetAddress(identity.getIdeEmail(), identity.getIdeName());\n            InternetAddress _from = new InternetAddress(identity.getIdeEmail(), identity.getIdeName());\n            InternetAddress _replyTo = new InternetAddress(identity.getIdeReplyTo(), identity.getIdeName());\n            InternetAddress[] _to = MessageUtilities.encodeAddresses(to, null);\n            InternetAddress[] _cc = MessageUtilities.encodeAddresses(cc, null);\n            InternetAddress[] _bcc = MessageUtilities.encodeAddresses(bcc, null);\n            if (_from != null) {\n                email.setFrom(_from.getAddress(), _from.getPersonal());\n            }\n            if (_returnPath != null) {\n                email.addHeader(\"Return-Path\", _returnPath.getAddress());\n                email.addHeader(\"Errors-To\", _returnPath.getAddress());\n                email.addHeader(\"X-Errors-To\", _returnPath.getAddress());\n            }\n            if (_replyTo != null) {\n                email.addReplyTo(_replyTo.getAddress(), _replyTo.getPersonal());\n            }\n            if ((_to != null) && (_to.length > 0)) {\n                HashSet aux = new HashSet(_to.length);\n                Collections.addAll(aux, _to);\n                email.setTo(aux);\n            }\n            if ((_cc != null) && (_cc.length > 0)) {\n                HashSet aux = new HashSet(_cc.length);\n                Collections.addAll(aux, _cc);\n                email.setCc(aux);\n            }\n            if ((_bcc != null) && (_bcc.length > 0)) {\n                HashSet aux = new HashSet(_bcc.length);\n                Collections.addAll(aux, _bcc);\n                email.setBcc(aux);\n            }\n            email.setSubject(subject);\n            Date now = new Date();\n            email.setSentDate(now);\n            File dir = new File(System.getProperty(\"user.home\") + File.separator + \"tmp\");\n            if (!dir.exists()) {\n                dir.mkdir();\n            }\n            if ((attachments != null) && (attachments.size() > 0)) {\n                for (int i = 0; i < attachments.size(); i++) {\n                    ByteArrayInputStream bais = null;\n                    FileOutputStream fos = null;\n                    try {\n                        MailPartObj obj = (MailPartObj) attachments.get(i);\n                        File file = new File(dir, obj.getName());\n                        bais = new ByteArrayInputStream(obj.getAttachent());\n                        fos = new FileOutputStream(file);\n                        IOUtils.copy(bais, fos);\n                        EmailAttachment attachment = new EmailAttachment();\n                        attachment.setPath(file.getPath());\n                        attachment.setDisposition(EmailAttachment.ATTACHMENT);\n                        attachment.setDescription(\"File Attachment: \" + file.getName());\n                        attachment.setName(file.getName());\n                        if (email instanceof MultiPartEmail) {\n                            ((MultiPartEmail) email).attach(attachment);\n                        }\n                    } catch (Exception ex) {\n                    } finally {\n                        IOUtils.closeQuietly(bais);\n                        IOUtils.closeQuietly(fos);\n                    }\n                }\n            }\n            String mid = getId();\n            if (headers != null) {\n                Header xheader;\n                Enumeration xe = headers.getAllHeaders();\n                for (; xe.hasMoreElements(); ) {\n                    xheader = (Header) xe.nextElement();\n                    if (xheader.getName().equals(RFC2822Headers.IN_REPLY_TO)) {\n                        email.addHeader(xheader.getName(), xheader.getValue());\n                    } else if (xheader.getName().equals(RFC2822Headers.REFERENCES)) {\n                        email.addHeader(xheader.getName(), xheader.getValue());\n                    }\n                }\n            } else {\n                email.addHeader(RFC2822Headers.IN_REPLY_TO, \"<\" + mid + \".JavaMail.duroty@duroty\" + \">\");\n                email.addHeader(RFC2822Headers.REFERENCES, \"<\" + mid + \".JavaMail.duroty@duroty\" + \">\");\n            }\n            if (priority != null) {\n                if (priority.equals(\"high\")) {\n                    email.addHeader(\"Importance\", priority);\n                    email.addHeader(\"X-priority\", \"1\");\n                } else if (priority.equals(\"low\")) {\n                    email.addHeader(\"Importance\", priority);\n                    email.addHeader(\"X-priority\", \"5\");\n                }\n            }\n            if (email instanceof HtmlEmail) {\n                ((HtmlEmail) email).setHtmlMsg(body);\n            } else {\n                email.setMsg(body);\n            }\n            email.setMailSession(session);\n            email.buildMimeMessage();\n            MimeMessage mime = email.getMimeMessage();\n            int size = MessageUtilities.getMessageSize(mime);\n            if (!controlQuota(hsession, user, size)) {\n                throw new MailException(\"ErrorMessages.mail.quota.exceded\");\n            }\n            messageable.saveSentMessage(mid, mime, user);\n            Thread thread = new Thread(new SendMessageThread(email));\n            thread.start();\n        } catch (MailException e) {\n            throw e;\n        } catch (Exception e) {\n            throw new MailException(e);\n        } catch (java.lang.OutOfMemoryError ex) {\n            System.gc();\n            throw new MailException(ex);\n        } catch (Throwable e) {\n            throw new MailException(e);\n        } finally {\n            GeneralOperations.closeHibernateSession(hsession);\n        }\n    }\n", "label": 1, "substitutes": {"testCopy_readerToOutputStream_Encoding": ["testCopy_readerToOutputStream_Chending", "testCopy_readerToOutputStream_Decending", "testCopy_readerToOutputStreamWithDecoding", "testCopy_readerToOutputStream_Decoder", "testCopy_readerToOutputStream_Choder", "testCopy_readerToOutputStreamWithEncoding", "testCopy_readerToOutputStream_Encending", "testCopy_readerToOutputStream_Encoded", "testCopy_readerToOutputStreamWithDecending", "testCopy_readerToOutputStreamWithEncoded", "testCopy_readerToOutputStream_Decoding", "testCopy_readerToOutputStream_Choding", "testCopy_readerToOutputStreamWithEncending", "testCopy_readerToOutputStream_Decoded", "testCopy_readerToOutputStream_encoder", "testCopy_readerToOutputStreamWithEncoder", "testCopy_readerToOutputStream_encoding", "testCopy_readerToOutputStreamWithDecoder", "testCopy_readerToOutputStream_Choded", "testCopy_readerToOutputStream_Encoder", "testCopy_readerToOutputStreamWithDecoded", "testCopy_readerToOutputStream_encoded", "testCopy_readerToOutputStream_encending"], "in": ["mi", "rin", "inn", "ini", "gin", "con", "IN", "ins", "cont", "m", "In", "init", "inner", "inside", "Input", "up", "i", "read", "bin", "act", "ac", "copy", "inc", "l", "input", "sin", "iter", "it", " IN", "ind", "r", "mc", "mm", "n", "local", "info", "din", "inf", "is", "isin", "source", "as", "cin", "p", "from", "data"], "reader": ["phrase", "rar", "oe", "mr", "parser", "driver", "ro", "inner", "Reader", "red", "buffer", "rise", "dr", "req", "read", "writer", "rl", "rr", "input", "iter", "ocker", "rot", "query", "per", "rx", "handler", "r", "iterator", "Larry", "row", "ner", "io", "er", "file", "reading", "loader", "data"], "baout": ["beanouts", "yaout", "caout", "BAout", "cain", "boos", "oaOut", "BAin", "boin", "yares", "boout", "haOut", "yaot", "caouts", "oaout", "caos", "baOut", " baot", "baouts", " bain", "yain", "caOut", "bain", "boOut", "hain", "oain", "haouts", "bares", "beanOut", "BAot", "BAres", "oaos", " bares", "beanin", "baot", "baos", "haout", "beanout"], "out": ["all", "con", "output", "res", "cos", "oss", "ao", "cn", "bo", "client", "sys", " bout", "conv", "t", "stable", "net", "b", "to", " os", " Out", "copy", "os", " OUT", "outer", "OU", "gt", "cmd", "null", "ou", "outs", "batch", "o", "auto", "n", "io", "Out", " outs", "OUT", "update", "ne", " output", "ex"], "bytes": ["terms", "services", "vals", "frames", "Bytes", "reports", "versions", "strings", "parts", "cells", "users", "bps", "seconds", "bs", "lines", "ites", "les", "unks", "raw", "classes", "names", "letters", "ings", "comments", "bits", "pieces", "issues", "reads", "words", "units", "its", "ips", "blocks", "tes", "des", "resources", "ones", "gs", "binary", "outs", "objects", "groups", "pages", "files", "gets", "values", "latest", "videos", "pdf", "es", "data", "results", "ies", "faces"]}}
{"id1": "8000624", "id2": "13362846", "code1": "    private void CopyTo(File dest) throws IOException {\n        FileReader in = null;\n        FileWriter out = null;\n        int c;\n        try {\n            in = new FileReader(image);\n            out = new FileWriter(dest);\n            while ((c = in.read()) != -1) out.write(c);\n        } finally {\n            if (in != null) try {\n                in.close();\n            } catch (Exception e) {\n            }\n            if (out != null) try {\n                out.close();\n            } catch (Exception e) {\n            }\n        }\n    }\n", "code2": "    public static void setContenu(ContenuFichierElectronique contenuFichier, FichierElectronique fichierElectronique, UtilisateurIFGD utilisateurCourant) throws IOException, DocumentVideException {\n        if (contenuFichier != null) {\n            SupportDocument support = fichierElectronique.getSupport();\n            support.setFichierElectronique(fichierElectronique);\n            FicheDocument ficheDocument = support.getFicheDocument();\n            String nomFichier = contenuFichier.getNomFichier();\n            String extension = FilenameUtils.getExtension(nomFichier);\n            if (ficheDocument.getFichierElectronique(nomFichier) != null) {\n                FichierElectronique fichierElectroniqueExistant = ficheDocument.getFichierElectronique(nomFichier);\n                if (fichierElectroniqueExistant.getId() != null && !fichierElectroniqueExistant.getId().equals(fichierElectronique.getId())) {\n                    throw new FichierElectroniqueExistantException(nomFichier, ficheDocument);\n                }\n            }\n            if (fichierElectronique.getId() == null) {\n                if (OfficeDocumentPropertiesUtil.canWriteIdIGID(extension)) {\n                    Long idIgid = OfficeDocumentPropertiesUtil.getIdIGID(contenuFichier);\n                    if (idIgid != null) {\n                        throw new FichierElectroniqueExistantException(nomFichier, idIgid, ficheDocument);\n                    }\n                }\n            }\n            InputStream inputStream = contenuFichier.getInputStream();\n            OutputStream outputStream = fichierElectronique.getOutputStream();\n            try {\n                IOUtils.copy(inputStream, outputStream);\n            } finally {\n                try {\n                    inputStream.close();\n                } finally {\n                    outputStream.close();\n                }\n            }\n            String typeMime = contenuFichier.getContentType();\n            long tailleFichier = contenuFichier.getTailleFichier();\n            Date dateDerniereModification = new Date();\n            fichierElectronique.setNom(nomFichier);\n            fichierElectronique.setTypeMime(extension);\n            creerFormatSiNecessaire(typeMime, extension);\n            fichierElectronique.setTaille(tailleFichier);\n            fichierElectronique.setDateDerniereModification(dateDerniereModification);\n            fichierElectronique.setSoumetteur(utilisateurCourant);\n            if (extension.endsWith(\"msg\")) {\n                CourrielUtils.peuplerMetadonneesCourriel(fichierElectronique.getNom(), ficheDocument, contenuFichier.getInputStream(), utilisateurCourant);\n            } else if (extension.endsWith(\"eml\")) {\n                Map<String, Object> properties = new GestionnaireProprietesMimeMessageParser().parseMsg(contenuFichier.getInputStream());\n                CourrielUtils.peuplerMetadonneesCourriel(fichierElectronique.getNom(), ficheDocument, properties, utilisateurCourant);\n            } else {\n                FGDProprietesDocumentUtils.copierMetadonneesProprietes(fichierElectronique, ficheDocument);\n            }\n        }\n    }\n", "label": 1, "substitutes": {"CopyTo": [" copiesInt", "CopyInt", " copyInt", " copyFrom", " CopyFrom", " copiesFrom", " CopyInt", " copiesTo", " copyTo", "CopyFrom"], "dest": ["origin", "txt", "usr", "image", "img", "cat", "output", "orig", "them", "sp", "d", "cont", "tmp", "est", "pipe", "mem", "rest", "th", "result", "src", "opt", "v", "filename", "name", "copy", "target", "it", "st", "path", "null", "dir", "nom", "Dest", "temp", "fn", "source", "loc", "p", "w"], "in": ["mi", "rin", "en", "image", "win", "inn", "ini", "by", "gin", "min", "con", "IN", "internal", "ins", "ar", "reader", "m", "on", "client", "al", "In", "t", "inner", "inside", "init", "one", "net", "from", "thin", "ai", "re", "up", "i", "read", "bin", "ac", "inc", "l", "input", "sin", "login", "iter", "it", "per", " din", "ir", " input", "ain", "ind", "o", "nin", "r", "local", "din", "inf", "is", "isin", "source", "file", "cin", "ire"], "out": ["all", "co", "en", "nt", "na", "flush", "by", "con", "output", "cos", "oe", "res", "oss", "cn", "op", "other", "obj", "ln", "client", "w", "not", "t", "inner", "dis", "ns", "one", "conv", "net", "write", "b", "to", "end", "loss", "list", "up", "v", "e", "writer", "os", "outer", "it", "gt", "note", "null", "at", "ou", "outs", "aos", "o", "batch", "boot", "ex", "full", "n", "io", "Out", "fn", "OUT", "user", "can", "ne", "ot"], "c": ["f", "rc", "u", "cat", "z", "con", "character", "cb", "d", "cont", "cr", "C", "bc", "t", "ce", "char", "code", "k", "cc", "ca", "current", "v", "i", "e", "ct", "conf", "ac", "cp", "gc", "cm", "l", "ec", "cod", "ch", "sc", "lc", "cd", "g", "unc", "cut", "nc", "count", "n", "arc", "uc", "cap", "cf", "cs", "cl"]}}
{"id1": "9802073", "id2": "22752444", "code1": "    public void testAutoCommit() throws Exception {\n        Connection con = getConnectionOverrideProperties(new Properties());\n        try {\n            Statement stmt = con.createStatement();\n            assertEquals(0, stmt.executeUpdate(\"create table #testAutoCommit (i int)\"));\n            con.setAutoCommit(false);\n            assertEquals(1, stmt.executeUpdate(\"insert into #testAutoCommit (i) values (0)\"));\n            con.setAutoCommit(false);\n            con.rollback();\n            assertEquals(1, stmt.executeUpdate(\"insert into #testAutoCommit (i) values (1)\"));\n            con.setAutoCommit(true);\n            con.setAutoCommit(false);\n            con.rollback();\n            con.setAutoCommit(true);\n            ResultSet rs = stmt.executeQuery(\"select i from #testAutoCommit\");\n            assertTrue(rs.next());\n            assertEquals(1, rs.getInt(1));\n            assertFalse(rs.next());\n            rs.close();\n            stmt.close();\n        } finally {\n            con.close();\n        }\n    }\n", "code2": "    public synchronized String encrypt(String plainText) {\n        String hash = null;\n        try {\n            MessageDigest md = null;\n            try {\n                md = MessageDigest.getInstance(\"SHA\");\n            } catch (NoSuchAlgorithmException e) {\n                throw new NoSuchAlgorithmException();\n            }\n            try {\n                if (plainText != null) md.update(plainText.getBytes(\"UTF-8\"));\n            } catch (UnsupportedEncodingException e) {\n                throw new UnsupportedEncodingException();\n            }\n            byte raw[] = md.digest();\n            hash = (new BASE64Encoder()).encode(raw);\n        } catch (NoSuchAlgorithmException e) {\n            MessageLog.writeErrorMessage(e, this);\n        } catch (UnsupportedEncodingException e) {\n            MessageLog.writeErrorMessage(e, this);\n        }\n        return Util.stripChars(hash);\n    }\n", "label": 0, "substitutes": {"testAutoCommit": ["testAutoCompmit", "testAutoDebits", "testAutoCommmit", "testAutoComute", "testAutoDebute", "testAutoDebmit", "testAutoCompute", "testAutoCompits", "testAutoCompit", "testAutoDebit", "testAutoCommits", "testAutoComit", "testAutoCommute", "testAutoComits"], "con": ["canon", "co", "rc", "en", "win", "cat", "dial", "res", "cos", "ctx", "comm", "cn", "don", "bo", "enc", "obj", "ln", "client", "clean", "bc", "col", "conv", "fac", "cons", "connection", "cc", "CON", "c", "ca", "fc", "go", "cur", "call", "re", "conf", "com", "xc", "ct", "cp", "ran", "ac", "Conn", "act", "cm", "coll", "gc", "const", "out", "pen", "ver", "cal", " conn", "conn", "ctrl", "ain", "tc", "connect", "nc", "local", "mc", "cf", "rec", "can", "Con", "gen", "fl"], "stmt": [" stgr", "stgr", "Stm", "stm", "strmp", "stMT", " superstmb", "statmb", " superstmt", "statmt", "STmp", " stmp", "strmt", "stmm", " stmm", "statgr", "STmb", "stct", "strgr", "StMT", "Stmp", " stmb", "STpt", "stmp", "strm", "statct", "STm", " stm", "STMT", " superstm", "stmb", " stct", "strmb", " stpt", "Stpt", " superstarm", "statmm", "stpt", " starm", "Stct", "Stmm", "Starm", " stMT", "Stmt", "Stmb", "strmm", "starm", "STmt", "statm"], "rs": ["times", "xs", "rc", "ows", "ss", "usr", "rys", "ms", "ges", "res", "rt", "mr", "rows", "ins", "cks", "ubs", "Rs", "js", "ros", "ws", "fs", "bs", "sys", "qs", "ls", "ares", "hs", "icks", "irms", "stats", "sr", "ags", "dds", "ires", "rd", "its", "acks", "ats", "ris", "ys", "ds", "acs", "ims", "gs", "obs", "ers", "ems", "ars", "vs", "sts", "rates", "vers", "ras", "ra", "ks", "arms", "RS", "ues", "results", "cs"]}}
{"id1": "18339787", "id2": "8932510", "code1": "    private void reload() {\n        if (xml != null) {\n            try {\n                String currentDate = new SimpleDateFormat(\"yyyy-MM-dd\").format(new Date());\n                if (currentDate.equalsIgnoreCase(exchangeRateDate)) {\n                    return;\n                }\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        }\n        XPath xpath = null;\n        try {\n            DocumentBuilderFactory docBuilderFactory = DocumentBuilderFactory.newInstance();\n            DocumentBuilder docBuilder = docBuilderFactory.newDocumentBuilder();\n            URLConnection conn = null;\n            URL url = new URL(\"http://www.ecb.int/stats/eurofxref/eurofxref-daily.xml\");\n            conn = url.openConnection();\n            xml = docBuilder.parse(conn.getInputStream());\n            xpath = XPathFactory.newInstance().newXPath();\n            exchangeRateDate = xpath.evaluate(\"/Envelope/Cube/Cube/@time\", xml);\n            xpath = XPathFactory.newInstance().newXPath();\n            NodeList currenciesNode = (NodeList) xpath.evaluate(\"/Envelope/Cube/Cube/Cube[@currency]\", xml, XPathConstants.NODESET);\n            currencies = new String[currenciesNode.getLength()];\n            for (int i = 0; i < currencies.length; i++) {\n                currencies[i] = currenciesNode.item(i).getAttributes().getNamedItem(\"currency\").getTextContent();\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n", "code2": "    @Override\n    public void doPost(HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {\n        InputStream is = null;\n        InputStream page = null;\n        OutputStream os = null;\n        String rootUrl = null;\n        try {\n            boolean isMultipart = ServletFileUpload.isMultipartContent(request);\n            if (!isMultipart) {\n                request.setAttribute(\"error\", \"Form isn't a multipart form\");\n                RequestDispatcher rd = request.getRequestDispatcher(\"/WEB-INF/error.jsp\");\n                rd.forward(request, response);\n            }\n            ServletFileUpload upload = new ServletFileUpload();\n            String webUrl = null;\n            FileItemIterator iter = upload.getItemIterator(request);\n            while (iter.hasNext()) {\n                FileItemStream item = iter.next();\n                String name = item.getFieldName();\n                if (name.equals(\"webpage\")) {\n                    is = item.openStream();\n                    ByteArrayOutputStream baos = new ByteArrayOutputStream();\n                    IOUtils.copy(is, baos);\n                    page = new ByteArrayInputStream(baos.toByteArray());\n                } else if (name.equals(\"weburl\")) {\n                    InputStream wpIs = null;\n                    try {\n                        webUrl = Streams.asString(item.openStream());\n                        URL u = new URL(webUrl);\n                        wpIs = new BufferedInputStream(u.openStream());\n                        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n                        IOUtils.copy(wpIs, baos);\n                        page = new ByteArrayInputStream(baos.toByteArray());\n                    } finally {\n                        IOUtils.closeQuietly(wpIs);\n                    }\n                } else if (name.equals(\"rooturl\")) {\n                    rootUrl = Streams.asString(item.openStream());\n                }\n            }\n            if (page == null) {\n                request.setAttribute(\"error\", \"Form doesn't have an html file\");\n                RequestDispatcher rd = request.getRequestDispatcher(\"/WEB-INF/error.jsp\");\n                rd.forward(request, response);\n            }\n            ToMailerDelegate delegate = new ToMailerDelegate(page, rootUrl);\n            os = new BufferedOutputStream(response.getOutputStream());\n            os.write(delegate.getMailer());\n            os.flush();\n        } catch (Exception e) {\n            streamException(request, response, e);\n        } finally {\n            IOUtils.closeQuietly(page);\n            IOUtils.closeQuietly(is);\n            IOUtils.closeQuietly(os);\n        }\n    }\n", "label": 0, "substitutes": {"reload": ["rebuild", "overload", "disbuild", "Reload", "disLoad", "disload", "Rebuild", "overbuild", "overLoad", "ReLoad", "replay", "overplay", "Replay", "reLoad", "display"], "currentDate": [" currentDoc", "reportedYear", " currentTime", "currentTime", "currentYear", " CurrentData", "reportedTime", " CurrentDoc", "reportedDate", "CurrentYear", " CurrentTime", "CurrentDate", " CurrentDate", "reportedData", "currentData", "CurrentTime", " currentData", "reportedDoc", "currentDoc", " currentYear"], "xpath": ["txgraph", "txpath", "axwhere", "rxpointer", " xpt", "axpointer", "axpath", "txPath", "wwhere", "xxpath", "xgraph", "xxtrace", "xpr", "dxprop", " xwhere", "xxpt", "expath", "exPath", "dxpath", "ixath", "xxwhere", "rxpath", "axtrace", "xxath", "ixpointer", "axPath", "ixpt", " xath", "dxwhere", "ixpath", "xwhere", "xath", "axgraph", "rxPath", "expr", "expointer", "rxpr", "xpointer", " xgraph", " xpr", " xprop", "wpath", "xtrace", "dxPath", "txpointer", "xPath", "xpt", "xxpointer", " xPath", "wprop", "xprop", " xtrace", "wPath", " xpointer"], "docBuilderFactory": ["docBuildFactor", "docPathClass", "docBuilderInterface", "docMakerFactor", "docPathFactor", " docBuilderClass", " docBuilderInterface", "docMakerFactory", "docMakerFact", "docBuilderClass", "docBuildFact", " docBuilderFactor", " docBuilderFact", "docBuilderFactor", "docBuilderFact", "docBuildInterface", "docBuildClass", "docBuildFactory", "docMakerInterface", "docPathFactory", "docPathFact"], "docBuilder": ["DocBu", "DocBuild", "DocBuilder", " docParser", "documentBuild", "DocumentBu", "documentBu", " docbuilder", "docBuild", "documentbuilder", " DOCBu", " DOCBuild", "DocumentParser", "Docbuilder", " docBu", "documentBuilder", "docParser", "DocumentBuilder", "DocumentBuild", " DOCParser", "docBu", " docBuild", "docbuilder", " DOCBuilder"], "conn": ["handle", "nt", "ctx", "con", "res", "oss", "cb", "cn", "comm", "enc", "obj", "client", "ws", "lang", "ls", "gate", "conv", "ann", "connection", "link", "addr", "c", "open", "resp", "cert", "opens", "db", "close", "iw", "ct", "cp", "Conn", "cm", "Connection", "out", "ch", "cmd", "syn", "connect", "ssl", "nc", "n", "jp", "socket", "loc"], "url": ["f", "browser", "window", "gl", "sb", "u", "ref", "dl", "con", "util", "obj", "lb", "client", "https", "bel", "web", "ls", "ll", "base", "connection", "char", "link", "net", "sl", "open", "b", "cert", "rel", "ur", "mount", "cp", "URL", "str", "rl", "l", "sql", "nl", "ul", "mb", "r", "ssl", "n", "http", "socket", "Url", "abs"], "xml": ["event", "php", "txt", "rss", "json", "image", "response", "text", "xf", "element", "dl", "output", "item", "p", "email", "details", "ws", "doc", "raw", "page", "context", "x", "feed", "template", "date", "log", "cert", "document", "tm", "list", "content", "format", "node", "str", "input", "eps", "dom", "pdf", "tml", "tree", "parse", "wt", "mail", "path", "news", "model", "el", "full", "zip", "http", "html", "config", "xp", "file", "body", "px", "ml", "print", "data"], "exchangeRateDate": ["excelrateDay", "exchangerateMessage", "exchangeRateTime", "exchangerateDays", "exactionRateDay", "exactionrateDate", "exchangeTimeDay", "exchangeRuleDate", "exchangeCountMessage", "exchangeRuleMessage", "exchangeRuleTime", "exchangeTimeDays", "exactionrateTime", "exchangerateDate", "exchangeRangeDate", "excelRateMessage", "exchangeCountDate", "exchangeRateDays", "exactionRateDate", "excelRateDate", "exchangeRangeTime", "exchangerateDay", "exchangeCountTime", "exactionRateDays", "exchangeRangeDay", "exchangeTimeTime", "exchangeRateMessage", "exactionrateDay", "exchangeCountDay", "exactionRateTime", "excelrateMessage", "exchangeRuleDay", "exchangeRateDay", "exchangeRangeDays", "excelrateDate", "exchangerateTime", "excelRateDay", "exchangeTimeDate", "exactionrateDays", "excelrateTime", "excelRateTime"], "currenciesNode": ["curriesEvent", "curthsN", "currencyCard", "cururrenciesNode", "currenciesN", "curriersList", "cururrenciesCard", "curriersNode", " curriesCard", "currsList", "currenciesCard", "curriesChan", " curriesChan", "CurrenciesCard", "curriesNode", "CurrenciesList", "currencyNode", "currenciesChan", "curthsList", "curreditsN", "curriesN", "curthsCard", "currsNode", "currencyChan", "CurriesEvent", " currenciesChan", "CurriesN", "curriesCard", "CurrenciesN", "CurrenciesNode", "curreditsEvent", "curriesList", "CurrenciesEvent", "cururrenciesChan", "CurriesNode", "curreditsList", "currenciesList", " currenciesCard", "CurriesList", "curriersN", "currenciesEvent", "currsEvent", "currsN", "CurriesCard", "curreditsNode", "curthsNode", " curriesNode", "curriersCard"], "currencies": ["chpora", " cururrencies", "Currencies", "constries", "carractions", "constpora", "charrates", "carrencies", "curables", "Cururrencies", "charurrencies", "cables", "corurrencies", "curarters", "carries", "curries", "Curarters", "correncies", "corarters", "chrencies", "corries", "curpora", " curries", "Curries", "chries", "crencies", "carpora", "chractions", "currates", "curractions", "constrencies", "corrates", "crates", "corables", "charables", "cururrencies", "constractions", " curarters", "charrencies"], "i": ["mi", "span", "u", "ini", "j", "ms", "y", "I", "ie", "qi", "di", "ri", "m", "iq", "sequence", "ki", "yi", "status", "ami", "init", "x", "ti", "in", "me", "bi", "c", "cli", "ic", "multi", "ci", "ai", "sim", "gi", "ui", "e", "uri", "pi", "ix", "it", "ji", "li", "xi", "\u0438", "si", "batch", "o", "ip", "n", "key", "io", "gu", "is", "ii", "oi", "index", "id", "a", "phi"]}}
{"id1": "2982747", "id2": "15166511", "code1": "    public FileParse(String fileStr, String type) throws MalformedURLException, IOException {\n        this.inFile = fileStr;\n        this.type = type;\n        System.out.println(\"File str \" + fileStr);\n        if (fileStr.indexOf(\"http://\") == 0) {\n            URL url = new URL(fileStr);\n            urlconn = url.openConnection();\n            inStream = urlconn.getInputStream();\n            bufReader = new BufferedReader(new InputStreamReader(inStream));\n        } else if (type.equals(\"File\")) {\n            File inFile = new File(fileStr);\n            size = inFile.length();\n            inStream = new FileInputStream(inFile);\n            bufReader = new BufferedReader(new InputStreamReader(inStream));\n        } else if (type.equals(\"URL\")) {\n            URL url = new URL(fileStr);\n            urlconn = url.openConnection();\n            inStream = urlconn.getInputStream();\n            bufReader = new BufferedReader(new InputStreamReader(inStream));\n        } else if (type.equals(\"URLZip\")) {\n            URL url = new URL(fileStr);\n            inStream = new GZIPInputStream(url.openStream(), 16384);\n            InputStreamReader zis = new InputStreamReader(inStream);\n            bufReader = new BufferedReader(zis, 16384);\n        } else {\n            System.out.println(\"Unknown FileParse inType \" + type);\n        }\n    }\n", "code2": "    private void getRandomGUID(boolean secure) {\n        MessageDigest md5 = null;\n        StringBuffer sbValueBeforeMD5 = new StringBuffer();\n        try {\n            md5 = MessageDigest.getInstance(\"MD5\");\n        } catch (NoSuchAlgorithmException e) {\n            System.out.println(\"Error: \" + e);\n        }\n        try {\n            long time = System.currentTimeMillis();\n            long rand = 0;\n            if (secure) {\n                rand = mySecureRand.nextLong();\n            } else {\n                rand = myRand.nextLong();\n            }\n            sbValueBeforeMD5.append(s_id);\n            sbValueBeforeMD5.append(\":\");\n            sbValueBeforeMD5.append(Long.toString(time));\n            sbValueBeforeMD5.append(\":\");\n            sbValueBeforeMD5.append(Long.toString(rand));\n            valueBeforeMD5 = sbValueBeforeMD5.toString();\n            md5.update(valueBeforeMD5.getBytes());\n            byte[] array = md5.digest();\n            StringBuffer sb = new StringBuffer();\n            for (int j = 0; j < array.length; ++j) {\n                int b = array[j] & 0xFF;\n                if (b < 0x10) sb.append('0');\n                sb.append(Integer.toHexString(b));\n            }\n            valueAfterMD5 = sb.toString();\n        } catch (Exception e) {\n            System.out.println(\"Error:\" + e);\n        }\n    }\n", "label": 0, "substitutes": {"fileStr": ["valueStr", "whereSTR", "wherePar", "stringSyn", "ileSt", "FILEstr", "Filestr", "ileStr", "FileRest", "fromString", "fromSTR", "ilestr", "FileName", "fileRest", "valueSTR", "FileSyn", "channelSTR", "FileSTR", "ileString", "filestr", "FILESt", "placeStr", "ileRest", "FileSt", "FileString", "valueString", " fileString", "filePar", " fileName", "fromstr", "FILEString", "fileSt", "channelSt", " fileRest", "stringSTR", "stringString", "placestr", "whereString", "FilePar", "whereStr", "placeString", "FileStr", "ilePar", "channelString", "fileSyn", "fileName", "placeSt", "ileSyn", "FILESTR", "ileSTR", "ileName", "valueName", " fileSTR", "FILEStr", "channelStr", " fileSt", "stringStr", "fromStr", "fileString", "fileSTR"], "type": ["phrase", "rule", "style", "value", "p", "y", "test", "time", "comment", "other", "description", "client", "types", "sequence", "create", "tag", "what", "t", "module", "port", "template", "code", "range", "buffer", "scope", "function", "shape", "ping", "family", "rel", "format", "right", "name", "state", "token", "error", "total", "out", "TYPE", "ty", "ver", "parent", "length", "instance", "o", "role", "kind", "model", "relation", "typ", "info", "key", "core", "id", "Type", "file", "class", "where", "source", "ype", "index", "version", "unit", "pretty", "user", "pe", "title"], "inFile": ["cinStream", " inString", "iniResource", " inFilename", " inLe", "inputFilename", "inFilename", " INStream", "inputFile", " infile", "inUser", "cinfile", "cinUser", "outFile", " inSet", " inputStream", " inResource", " inputFile", "InFile", "outFilename", " INFile", "cinFile", "inString", "inPath", "InStream", "intfile", "inResource", "outString", " inUser", " inFormat", "intFile", "intResource", "inFormat", " INFormat", "inLe", "InUser", " inputFormat", "inSet", " INLe", "outPath", "inputPath", "intSet", "iniSet", "iniFile", " inputLe", "Infile", "infile", "inifile", " inPath", "inputString"], "url": ["browser", "back", "hl", "gl", "ref", "dl", "client", "bel", "web", "ls", "ll", "help", "run", "deb", "char", "link", "build", "log", "net", "open", "pkg", "cert", "addr", "impl", "call", "lr", "db", "rel", "ur", "mount", "org", "uri", "URL", "name", "str", "external", "rl", "l", "kl", "cmd", "nl", "cal", "mail", "ul", "conn", "term", "norm", "bool", "mb", "ol", "null", "ctrl", "ssl", "el", "http", "job", "Url", "ml", "host", "cl"], "urlconn": ["consoleconn", "urlconnection", "httpconn", " urljp", "urlll", "consoleconf", "urldb", " urldb", "UrlConn", "belconf", "sslConn", "sslconnection", "consolecomm", "Urlconnection", "webcon", "urlConn", "httpdb", "URLConn", "Urlopen", "urlcon", " urlConn", " urlcomm", "urlopen", "urlcomm", "urljp", "implconn", "URLopen", "URLconn", "impldb", "httpConn", "belconn", "webconn", "sslconn", "impljp", "belcomm", "consolell", "URLcon", "belll", "webConn", "urlconf", "Urlcon", "URLconnection", "webconnection", "httpjp", "Urlconn", " urlconf", "sslopen", "implConn", " urlll"], "inStream": ["cinStream", "dinSteam", "indView", "instream", "innList", "inSteam", "inputStream", "dinStream", "actSteam", "cinView", "scanStream", "innSteam", " inSt", " instream", " inSet", "inputSteam", "inSt", "actStream", "iSt", "innSt", "InView", "dinView", " inFrame", "rinSt", "INStream", "inFrame", "InFile", "cinFile", "InStream", "inputSet", "dinFile", "innSet", "innStream", "InSteam", "innFrame", "INSet", "inView", "scanFile", "scanView", "INSteam", " inView", "cinSteam", "cinFrame", "istream", "innFile", "rinList", "iSteam", " inList", "actView", "inputstream", "inSet", "indSet", "inputView", "rinSteam", "iStream", "inList", "INView", "inputSt", " inSteam", "indSteam", "scanSteam", "rinStream", "cinSet", "indStream", "innView", "actSet"], "bufReader": ["ufHelper", " bufLoader", "buffDr", "funcDr", "bufWriter", "funcDriver", "buffBuilder", "buffWriter", "buffDriver", "buffRead", "errHelper", "ufWriter", " bufWriter", "matBuilder", " bufHelper", " bufDr", "errWriter", "ufStreamer", "buffLoader", "bufferRead", "funcLoader", "bufLoader", "funcReader", "ufBuilder", " bufDriver", "bufDriver", "bufDr", "ufLoader", "errLoader", "bufferLoader", "bufferWriter", "bufHelper", "bufBuilder", "bufRead", "bufferReader", "buffStreamer", "matWriter", "buffReader", "matStreamer", "errReader", "ufReader", "matReader", "ufRead", "bufStreamer"], "size": ["empty", "gz", "small", "sum", "set", "buffer", "c", "fd", "shape", "max", "read", "name", "SIZE", "pos", "data", "offset", "nl", "len", "length", "space", "height", "sn", "count", "n", "Size", "start", "ize", "bytes"], "zis": ["jisl", "zisl", "ziiss", "zipisi", "zisi", "zIS", "gzisc", "ziis", " zisi", "zerisl", "ziIS", "ziisl", "jIS", "gzis", "zeris", "zipisc", "jis", "zipis", "jiss", "zerIS", "gzisi", "zeriss", " zisc", "zisc", "ziss"]}}
{"id1": "4468255", "id2": "7149578", "code1": "    public static void copy(File from, File to) {\n        boolean result;\n        if (from.isDirectory()) {\n            File[] subFiles = from.listFiles();\n            for (int i = 0; i < subFiles.length; i++) {\n                File newDir = new File(to, subFiles[i].getName());\n                result = false;\n                if (subFiles[i].isDirectory()) {\n                    if (newDir.exists()) result = true; else result = newDir.mkdirs();\n                } else if (subFiles[i].isFile()) {\n                    try {\n                        result = newDir.createNewFile();\n                    } catch (IOException e) {\n                        log.error(\"unable to create new file: \" + newDir, e);\n                        result = false;\n                    }\n                }\n                if (result) copy(subFiles[i], newDir);\n            }\n        } else if (from.isFile()) {\n            FileInputStream in = null;\n            FileOutputStream out = null;\n            try {\n                in = new FileInputStream(from);\n                out = new FileOutputStream(to);\n                int fileLength = (int) from.length();\n                char charBuff[] = new char[fileLength];\n                int len;\n                int oneChar;\n                while ((oneChar = in.read()) != -1) {\n                    out.write(oneChar);\n                }\n            } catch (FileNotFoundException e) {\n                log.error(\"File not found!\", e);\n            } catch (IOException e) {\n                log.error(\"Unable to read from file!\", e);\n            } finally {\n                try {\n                    if (in != null) in.close();\n                    if (out != null) out.close();\n                } catch (IOException e1) {\n                    log.error(\"Error closing file reader/writer\", e1);\n                }\n            }\n        }\n    }\n", "code2": "    @Override\n    protected void parseContent(StreamLimiter streamLimiter, LanguageEnum forcedLang) throws IOException {\n        String charset = null;\n        IndexDocument sourceDocument = getSourceDocument();\n        if (sourceDocument != null && urlItemFieldEnum != null) {\n            FieldValueItem fieldValueItem = sourceDocument.getFieldValue(urlItemFieldEnum.contentTypeCharset.getName(), 0);\n            if (fieldValueItem != null) charset = fieldValueItem.getValue();\n            if (charset == null) {\n                fieldValueItem = sourceDocument.getFieldValue(urlItemFieldEnum.contentEncoding.getName(), 0);\n                if (fieldValueItem != null) charset = fieldValueItem.getValue();\n            }\n        }\n        boolean charsetWasNull = charset == null;\n        if (charsetWasNull) charset = getProperty(ClassPropertyEnum.DEFAULT_CHARSET).getValue();\n        StringWriter writer = new StringWriter();\n        IOUtils.copy(streamLimiter.getNewInputStream(), writer, charset);\n        addField(ParserFieldEnum.htmlSource, writer.toString());\n        writer.close();\n        HtmlDocumentProvider htmlProvider = findBestProvider(charset, streamLimiter);\n        if (htmlProvider == null) return;\n        addField(ParserFieldEnum.htmlProvider, htmlProvider.getName());\n        String contentType = htmlProvider.getMetaHttpEquiv(\"content-type\");\n        String contentTypeCharset = null;\n        if (contentType != null) {\n            contentTypeCharset = MimeUtils.extractContentTypeCharset(contentType);\n            if (contentTypeCharset != null && !contentTypeCharset.equals(charset)) charsetWasNull = true;\n        }\n        if (charsetWasNull) {\n            if (contentTypeCharset != null) charset = contentTypeCharset; else charset = htmlProvider.getMetaCharset();\n            if (charset != null) htmlProvider = findBestProvider(charset, streamLimiter);\n        }\n        HtmlNodeAbstract<?> rootNode = htmlProvider.getRootNode();\n        if (rootNode == null) return;\n        for (HtmlNodeAbstract<?> metaNode : htmlProvider.getMetas()) {\n            String metaName = metaNode.getAttributeText(\"name\");\n            if (metaName != null && metaName.startsWith(OPENSEARCHSERVER_FIELD)) {\n                String field = metaName.substring(OPENSEARCHSERVER_FIELD_LENGTH);\n                String[] fields = field.split(\"\\\\.\");\n                if (fields != null) {\n                    String content = metaNode.getAttributeText(\"content\");\n                    addDirectFields(fields, content);\n                }\n            }\n        }\n        addField(ParserFieldEnum.charset, charset);\n        addFieldTitle(htmlProvider.getTitle());\n        String metaRobots = null;\n        String metaDcLanguage = null;\n        String metaContentLanguage = null;\n        for (HtmlNodeAbstract<?> node : htmlProvider.getMetas()) {\n            String attr_name = node.getAttributeText(\"name\");\n            String attr_http_equiv = node.getAttributeText(\"http-equiv\");\n            if (\"keywords\".equalsIgnoreCase(attr_name)) addField(ParserFieldEnum.meta_keywords, HtmlDocumentProvider.getMetaContent(node)); else if (\"description\".equalsIgnoreCase(attr_name)) addField(ParserFieldEnum.meta_description, HtmlDocumentProvider.getMetaContent(node)); else if (\"robots\".equalsIgnoreCase(attr_name)) metaRobots = HtmlDocumentProvider.getMetaContent(node); else if (\"dc.language\".equalsIgnoreCase(attr_name)) metaDcLanguage = HtmlDocumentProvider.getMetaContent(node); else if (\"content-language\".equalsIgnoreCase(attr_http_equiv)) metaContentLanguage = HtmlDocumentProvider.getMetaContent(node);\n        }\n        boolean metaRobotsFollow = true;\n        boolean metaRobotsNoIndex = false;\n        if (metaRobots != null) {\n            metaRobots = metaRobots.toLowerCase();\n            if (metaRobots.contains(\"noindex\")) {\n                metaRobotsNoIndex = true;\n                addField(ParserFieldEnum.meta_robots, \"noindex\");\n            }\n            if (metaRobots.contains(\"nofollow\")) {\n                metaRobotsFollow = false;\n                addField(ParserFieldEnum.meta_robots, \"nofollow\");\n            }\n        }\n        UrlFilterItem[] urlFilterList = getUrlFilterList();\n        List<HtmlNodeAbstract<?>> nodes = rootNode.getAllNodes(\"a\", \"frame\");\n        IndexDocument srcDoc = getSourceDocument();\n        if (srcDoc != null && nodes != null && metaRobotsFollow) {\n            URL currentURL = htmlProvider.getBaseHref();\n            if (currentURL == null && urlItemFieldEnum != null) {\n                FieldValueItem fvi = srcDoc.getFieldValue(urlItemFieldEnum.url.getName(), 0);\n                if (fvi != null) currentURL = new URL(fvi.getValue());\n            }\n            for (HtmlNodeAbstract<?> node : nodes) {\n                String href = null;\n                String rel = null;\n                String nodeName = node.getNodeName();\n                if (\"a\".equals(nodeName)) {\n                    href = node.getAttributeText(\"href\");\n                    rel = node.getAttributeText(\"rel\");\n                } else if (\"frame\".equals(nodeName)) {\n                    href = node.getAttributeText(\"src\");\n                }\n                boolean follow = true;\n                if (rel != null) if (rel.contains(\"nofollow\")) follow = false;\n                URL newUrl = null;\n                if (href != null) if (!href.startsWith(\"javascript:\")) if (currentURL != null) newUrl = LinkUtils.getLink(currentURL, href, urlFilterList);\n                if (newUrl != null) {\n                    ParserFieldEnum field = null;\n                    if (newUrl.getHost().equalsIgnoreCase(currentURL.getHost())) {\n                        if (follow) field = ParserFieldEnum.internal_link; else field = ParserFieldEnum.internal_link_nofollow;\n                    } else {\n                        if (follow) field = ParserFieldEnum.external_link; else field = ParserFieldEnum.external_link_nofollow;\n                    }\n                    addField(field, newUrl.toExternalForm());\n                }\n            }\n        }\n        if (!metaRobotsNoIndex) {\n            nodes = rootNode.getNodes(\"html\", \"body\");\n            if (nodes == null || nodes.size() == 0) nodes = rootNode.getNodes(\"html\");\n            if (nodes != null && nodes.size() > 0) {\n                StringBuffer sb = new StringBuffer();\n                getBodyTextContent(sb, nodes.get(0), true, null);\n                addField(ParserFieldEnum.body, sb);\n            }\n        }\n        Locale lang = null;\n        String langMethod = null;\n        String[] pathHtml = { \"html\" };\n        nodes = rootNode.getNodes(pathHtml);\n        if (nodes != null && nodes.size() > 0) {\n            langMethod = \"html lang attribute\";\n            String l = nodes.get(0).getAttributeText(\"lang\");\n            if (l != null) lang = Lang.findLocaleISO639(l);\n        }\n        if (lang == null && metaContentLanguage != null) {\n            langMethod = \"meta http-equiv content-language\";\n            lang = Lang.findLocaleISO639(metaContentLanguage);\n        }\n        if (lang == null && metaDcLanguage != null) {\n            langMethod = \"meta dc.language\";\n            lang = Lang.findLocaleISO639(metaDcLanguage);\n        }\n        if (lang != null) {\n            addField(ParserFieldEnum.lang, lang.getLanguage());\n            addField(ParserFieldEnum.lang_method, langMethod);\n        } else if (!metaRobotsNoIndex) lang = langDetection(10000, ParserFieldEnum.body);\n    }\n", "label": 1, "substitutes": {"copy": ["csv", "cop", "cat", "sync", "py", "share", "single", "create", "link", "Copy", "write", "transfer", "slice", "replace", "cp", "gc", "get", "archive", "parse", "paste", "split", "opy", "zip", "Cop", "download", "core", "remote", "pixel", "save", "crop", "file", "clip", "clone", "map", "print", "delete", "move"], "from": ["original", "base", "range", "db", "of", "un", "or", "form", "normal", "el", "html", "config", "start", "low", "f", "part", "cont", "se", "on", "fr", "link", "only", "th", "when", "false", "name", "simple", "st", "at", "local", "file", "and", "small", "orig", "entry", "view", "bound", "raw", "stream", "url", "str", "initial", "input", "query", "path", "dir", "with", "a", "data", "empty", "ing", "by", "vol", "From", "left", "init", "old", "org", "without", "this", "add", "star", "zip", "self", "remote", "no", "as", "source", "so"], "to": ["annot", "output", "tom", "please", "tmp", "not", "t", "base", "xy", "tu", "pt", "top", "total", "or", "into", "io", "size", "zero", "all", "nt", "process", "that", "To", "two", "dest", "toc", "on", "tool", "dis", "one", "only", "list", "tty", "eto", "target", "st", "auto", "temp", "back", "let", "et", "ont", "table", "b", "pro", "dir", "o", "data", "phi", "by", "op", "TO", "po", "will", "go", "must", "color", "format", "too", "null", "te", "no", "p", "title", "ot"], "result": ["event", "rule", "mask", "su", "br", "test", "then", "launch", "ure", "perm", "answer", "continue", "term", "confirmed", "relation", "there", "functional", "zero", "Result", "type", "response", "res", "buffer", "only", "either", "stay", "cache", "false", "successful", "successfully", "results", "report", "same", "nil", "block", "ful", "comment", "goal", " successful", "table", "profile", "date", "chain", "journal", "important", "complete", "success", "region", "rue", "power", "duration", "brace", "json", "product", "match", "contact", "console", "mate", "request", "feature", "details", "description", "sequence", "status", "debug", "message", "current", "valid", "true", "bool", "null", "flag", "r"], "subFiles": ["latImages", "subPosts", "ubPosts", "ubNames", "latFiles", "singFiles", " subFile", " subDir", "ubOps", " subfiles", " subpFiles", "supfiles", " subpDir", " subCharacters", "ubValues", "singValues", "subOps", " subOps", "subImages", "subNames", "latCharacters", "subValues", "newfiles", "selFile", " subTags", "newTags", "subItems", "selNames", " subImages", "selFiles", " subValues", "subfiles", "supOps", "subFile", "supFiles", "ubFile", "subCharacters", "ubKeys", " subKeys", "ubTags", "subKeys", " subPosts", " subpItems", "latfiles", "newItems", " subpfiles", "newFiles", " subNames", "singPosts", " subItems", "subDir", "ubItems", "ubDir", "supFile", "ubFiles", "ubImages", "subTags", "ubCharacters", "singKeys", "ubfiles", "selDir"], "i": ["exp", "mi", "iy", "gl", "json", "u", "j", "ms", "us", "y", "x", "I", "ie", "qi", "di", "task", "im", "h", "ri", "m", "iq", "ami", "t", "base", "init", "me", "ti", "q", "hi", "c", "bi", "chain", "go", "ic", "multi", "ci", "ai", "sim", "gi", "ui", "e", "v", "uri", "pi", "ij", "ix", "iter", "ji", "li", "my", "point", "ori", "si", "xi", "g", "ind", "batch", "ip", "zi", "info", "key", "job", "gu", "is", "ii", "oi", " I", "index", "id", "print", "phi"], "newDir": ["newNet", " newObj", "nextFolder", "NEWDir", "newdir", "NewDir", "newFolder", "newFile", "NewServ", " newdir", " newComp", "Newdir", "newObj", "nextDir", " newJar", "newsNet", "subRel", " newFile", "NEWJar", "newsFile", "subFile", "newsObj", "NewNet", "NEWFile", "subFolder", "NewObj", "nextFile", "subJar", "newsRel", "newServ", " newNet", "newRel", "newsServ", "nextRel", "newComp", "NEWdir", "subNet", "subDir", "subComp", "nextComp", "subServ", "nextdir", "NewRel", " newRel", "newsDir", " newFolder", "NewFile", "subdir", "newJar"], "in": ["mi", "rin", "en", "win", "inn", "ini", "con", "gin", "IN", "internal", "ins", "ar", "ln", "on", "m", "doc", "al", "In", "init", "inner", "inside", "net", "print", "ai", "asin", "read", "bin", "pi", "inc", "l", "input", "iter", "it", "proc", "ain", "ind", "ma", "mc", "info", "local", "io", "din", "inf", "is", "isin", "source", "body", "cin"], "out": ["ion", "co", "en", "nt", "flush", "con", "output", "cos", "res", "oss", "cn", "obj", "ln", "on", "client", "sys", "conv", "t", "inner", "init", "one", "net", "write", "log", "b", "end", "print", "err", "up", "v", "cache", "writer", "os", "outer", "it", "OU", "note", "cmd", "ou", "at", "aos", "outs", "o", "ex", "n", "io", "Out", "file", "OUT", "user", "p", "can", "ne", "w"], "fileLength": ["treeLength", "fileFamily", "pageENGTH", "ilelength", "filelength", "FileFamily", "pagelength", " fileENGTH", "treeConstruction", "pageLength", "FileDuration", " filelength", "ileLength", "ileConstruction", "fileDuration", "FileConstruction", "Filelength", "fileENGTH", "fileConstruction", "FileLength", "treelength", " fileFamily", "ileDuration", "pageFamily", "treeDuration", "FileENGTH"], "charBuff": ["charBuffer", "intbuff", "charbuff", "Charbuffer", "charbuffer", " charbuff", "Charbuff", " charBuffer", "intbuffer", "intBuff", " charbuffer", "intBuffer", "CharBuffer", "CharBuff"], "len": ["en", "ref", "cmp", "et", "ln", "set", "ls", "ll", "mem", "char", "e", "name", "str", "l", "pos", "val", "length", "line", "syn", "el", "cap", "start", "Len", "fin", "gen", "cl"], "oneChar": [" oneCh", "oneByte", "oneCr", "OneInt", "OneCr", "OneCharacter", "OneChar", " oneCharacter", "oneCh", "Onechar", "oneCharacter", " oneByte", "OneByte", "oneInt", "OneCh", "onechar", "onceCh", " onechar", "onceCr", "onceChar", " oneCr", "onceCharacter", " oneInt"]}}
{"id1": "9109613", "id2": "20920051", "code1": "    public static void fileCopy(String from_name, String to_name) throws IOException {\n        File fromFile = new File(from_name);\n        File toFile = new File(to_name);\n        if (fromFile.equals(toFile)) abort(\"cannot copy on itself: \" + from_name);\n        if (!fromFile.exists()) abort(\"no such currentSourcepartName file: \" + from_name);\n        if (!fromFile.isFile()) abort(\"can't copy directory: \" + from_name);\n        if (!fromFile.canRead()) abort(\"currentSourcepartName file is unreadable: \" + from_name);\n        if (toFile.isDirectory()) toFile = new File(toFile, fromFile.getName());\n        if (toFile.exists()) {\n            if (!toFile.canWrite()) abort(\"destination file is unwriteable: \" + to_name);\n        } else {\n            String parent = toFile.getParent();\n            if (parent == null) abort(\"destination directory doesn't exist: \" + parent);\n            File dir = new File(parent);\n            if (!dir.exists()) abort(\"destination directory doesn't exist: \" + parent);\n            if (dir.isFile()) abort(\"destination is not a directory: \" + parent);\n            if (!dir.canWrite()) abort(\"destination directory is unwriteable: \" + parent);\n        }\n        FileInputStream from = null;\n        FileOutputStream to = null;\n        try {\n            from = new FileInputStream(fromFile);\n            to = new FileOutputStream(toFile);\n            byte[] buffer = new byte[4096];\n            int bytes_read;\n            while ((bytes_read = from.read(buffer)) != -1) to.write(buffer, 0, bytes_read);\n        } finally {\n            if (from != null) try {\n                from.close();\n            } catch (IOException e) {\n                ;\n            }\n            if (to != null) try {\n                to.close();\n            } catch (IOException e) {\n                ;\n            }\n        }\n    }\n", "code2": "    public static void copyTo(File source, File dest) {\n        if (source.isHidden()) ; else if (source.isDirectory()) {\n            File temp = new File(dest.getPath() + \"/\" + source.getName());\n            temp.mkdir();\n            for (File sel : source.listFiles()) copyTo(sel, temp);\n        } else {\n            try {\n                File tempDest = new File(dest.getPath() + \"/\" + source.getName());\n                tempDest.createNewFile();\n                FileChannel sourceCh = new FileInputStream(source).getChannel();\n                FileChannel destCh = new FileOutputStream(tempDest).getChannel();\n                sourceCh.transferTo(0, sourceCh.size(), destCh);\n                sourceCh.close();\n                destCh.close();\n            } catch (IOException ex) {\n                Logger.getLogger(EditorUtil.class.getName()).log(Level.SEVERE, null, ex);\n            }\n        }\n    }\n", "label": 1, "substitutes": {"fileCopy": ["FileCop", "Filecopy", "FileCopy", "doUpload", "fileCop", " fileCop", " fileUpload", "fileUpload", " filecopy", "doCopy", "docopy", "doCop", "filecopy", "FileUpload"], "from_name": ["fromptadmin", " from_base", " from_admin", "from_value", "from_type", "to_world", "to_case", " from_size", " from__names", "from_case", "from_user", "from__size", "fromptname", " from__name", " from_names", "from_admin", "from_client", " from__size", "from_names", "from__names", " from_client", " from_user", "from_size", "from__name", "fromptnames", "from_base", " from_no", " from_value", "from_no", "from_world", " from_type"], "to_name": ["toNamecode", "to_long", "toNamename", "into_num", "into_code", "to_num", "toNamenames", "intoNamecode", "to_Name", "into_name", "to_names", "to_path", " to_Name", "into_names", "into_path", "intoNamepath", "intoNamename", "intoNamenames", "to_code", "toNamepath", " to_long", " to_names"], "fromFile": ["onFile", "smallFiles", "entryfile", "fromPlace", "fromfile", "toField", "boundFiles", "onfile", "entryName", "normalTime", "normalfile", "sentFile", "startName", "tofile", "newPage", "fromTime", "fromFiles", "sentfile", " fromFILE", "formName", "newFile", "normalLine", "smallFile", "givenGlobal", "entryFile", " fromLine", "entryFilename", "sentField", "toPage", "oldLine", "normalFile", "newGlobal", "startFile", "FromFile", " fromPage", "orPage", " fromPlace", "formFilename", "startfile", "boundFile", "newfile", "givenfile", "onFILE", "fromFilename", "FromDo", "fromLine", "boundPlace", " fromTime", "oldfile", "formFile", "oldFile", "fromName", " fromFiles", "orLine", "startFilename", "fromPage", "formfile", "oldDo", " fromfile", "givenFile", " fromDo", "FromLine", "smallFILE", "boundFILE", "fromGlobal", "normalPage", "fromFILE", "fromField", "givenPage", "orFile", "Fromfile", " fromGlobal", "sentPage", "FromFILE", "orTime", "smallPlace", "fromDo", "normalField"], "toFile": ["targetModel", "ToFiles", "intoProcess", "toTime", "ToFILE", "thatfile", "toMessage", "toDo", "toFilename", "etoFile", "thatFILE", "toProcess", "toName", "targetTable", "tofile", "twoTime", "fromFiles", " tofile", " toFiles", "newFile", "toTable", "TOTime", "intoTable", "fromPort", "intoName", "toDefault", " toTime", "twofile", "TOPort", " toSourceFile", "targetPlace", "templateModel", "intoPort", "TOFiles", "twoPort", "Tofile", "toPort", "etoDefault", "intoMessage", "TOPath", "fromMessage", "intoFiles", " toPath", "twoSourceFile", "ToTable", "toPlace", " toDefault", "newfile", "etoMessage", "twoFiles", "toFiles", " toPlace", "TOPlace", "bySourceFile", "targetFile", "targetDo", "templateFile", " toFilename", "TOFile", "templateTable", "twoFile", "fromProcess", "ToModel", "TOSourceFile", "TOfile", "fromName", "etoFILE", "byfile", "toFILE", "etofile", "newSourceFile", "byPlace", "twoPath", "newPlace", "toModel", "intoFile", "byFile", " toPort", " toTable", " toDo", " toFILE", "targetFILE", "templateFILE", "ToFile", "toSourceFile", "ToFilename", "thatDefault", "etoName", "toPath", "thatFile", "etoProcess", "fromTable"], "parent": ["event", "parents", "exp", "rule", "origin", "central", "layout", "tip", "prop", "home", "pid", "sp", "params", "mt", "tar", "m", "page", "tmp", "module", "port", "directory", "chain", "spec", "man", "shape", "master", "form", "family", "up", "filename", "holder", "owner", "def", "child", "name", "position", "pi", "global", "pos", "timeout", "snap", "this", "my", "tree", "path", "mother", "null", "component", "per", "point", "uid", "instance", "ip", "ma", "desc", "remote", "temp", "server", "file", "folder", "Parent", "root", "pool", "source", "id", "unit", "p", "where", "host", "prefix", "peer", "paren"], "dir": ["good", "div", "tr", "dl", "vol", "di", "d", "dict", "cont", "tmp", "mod", "module", "init", "directory", "md", "red", "del", "addr", "dc", "fd", "cur", "dr", "db", "rel", "det", "wd", "dim", "def", "crit", "coll", "str", "out", "odd", "cond", "ds", "iter", "or", "dd", "Dir", "ir", "path", "cd", "ind", "DIR", "dist", "fin", "file", "folder", "loc", "dep", "rec", "direct", "dev"], "from": ["origin", "empty", "back", "window", "style", "en", "and", "by", "min", "reset", "con", "orig", "From", "vol", "entry", "left", "on", "bound", "fr", "clean", "create", "stream", "set", "client", "before", "in", "init", "ce", "inner", "base", "link", "c", "old", "only", "com", "false", "out", "or", "pos", "ent", "fun", "input", "initial", "query", "st", "form", "normal", "term", "sent", "local", "ra", "start", "no", "with", "source", "so", "check", "user", "store"], "to": ["lo", "co", "tg", "that", "by", "To", "output", "tto", "two", "test", "writer", "about", "toc", "tom", "client", "on", "can", "TO", "please", "table", "t", "base", "po", "done", "write", "go", "ts", "tty", "ta", "eto", "pi", "token", "top", "total", "out", "or", "too", "target", "phi", "tree", "into", "this", "null", "news", "o", "auto", "te", "ato", "no", "with", "so", "pretty", "title"], "buffer": ["event", "phrase", "buf", "window", "block", "buff", "sample", "entry", "frame", "word", "comment", "sequence", "page", "table", "append", "stroke", "base", "template", "char", "command", "attribute", "device", "document", "message", "result", "stack", "available", "number", "cache", "variable", "Buffer", "initial", "parse", "length", "queue", "paste", "binary", "batch", "database", "bar", "row", "temp", "button", "memory", "character"], "bytes_read": ["bytes2Read", "bytes_q", "bytes5need", "Bytes_write", "Bytes_find", "bytes2read", "Bytes_have", "bytes_need", "bytes_have", "bytes_Read", "bytes5read", "bytes2need", "bytes__q", "Bytes_need", "bytes_write", "bytes_find", "bytes5write", "bytes__read", "Bytes_read", "bytes__write", "bytes5Read", "bytes2write", "bytes__find", "Bytes_Read", "Bytes_q"]}}
{"id1": "20128728", "id2": "13516684", "code1": "    void copyFile(File src, File dst) throws IOException {\n        FileChannel inChannel = new FileInputStream(src).getChannel();\n        FileChannel outChannel = new FileOutputStream(dst).getChannel();\n        try {\n            inChannel.transferTo(0, inChannel.size(), outChannel);\n        } finally {\n            if (inChannel != null) inChannel.close();\n            if (outChannel != null) outChannel.close();\n        }\n    }\n", "code2": "    void run(PseudolocalizerArguments arguments) throws IOException {\n        List<String> fileNames = arguments.getFileNames();\n        PseudolocalizationPipeline pipeline = arguments.getPipeline();\n        if (arguments.isInteractive()) {\n            runStdin(pipeline);\n            return;\n        }\n        if (fileNames.size() == 0) {\n            MessageCatalog msgCat = FormatRegistry.getMessageCatalog(arguments.getType());\n            writeMessages(msgCat, readAndProcessMessages(pipeline, msgCat, System.in), System.out);\n            return;\n        }\n        String suffix = arguments.getVariant();\n        if (suffix == null) {\n            suffix = \"_pseudo\";\n        } else {\n            suffix = \"_\" + suffix;\n        }\n        for (String fileName : fileNames) {\n            File file = new File(fileName);\n            if (!file.exists()) {\n                System.err.println(\"File \" + fileName + \" not found\");\n                continue;\n            }\n            int lastDot = fileName.lastIndexOf('.');\n            String extension;\n            String outFileName;\n            if (lastDot >= 0) {\n                extension = fileName.substring(lastDot + 1);\n                outFileName = fileName.substring(0, lastDot) + suffix + \".\" + extension;\n            } else {\n                extension = \"\";\n                outFileName = fileName + suffix;\n            }\n            System.out.println(\"Processing \" + fileName + \" into \" + outFileName);\n            String fileType = arguments.getType();\n            if (fileType == null) {\n                fileType = extension;\n            }\n            MessageCatalog msgCat = FormatRegistry.getMessageCatalog(fileType);\n            InputStream inputStream = new FileInputStream(file);\n            List<Message> processedMessages = readAndProcessMessages(pipeline, msgCat, inputStream);\n            OutputStream outputStream = new FileOutputStream(new File(outFileName));\n            writeMessages(msgCat, processedMessages, outputStream);\n        }\n    }\n", "label": 1, "substitutes": {"copyFile": [" cpfile", " CopyResource", "copyFiles", "CopFiles", "copyResource", "Copfile", "CopResource", "CopFile", " cpResource", " cpFile", " cpFiles", "copyfile", " Copyfile", " CopyFiles", " CopyFile"], "src": ["ser", "rc", "txt", "via", "usr", "sb", "rt", "ins", "sit", "dest", "js", "sys", "bs", "urus", "init", "in", "urg", "sq", "sl", "ctr", "cur", "sr", "usc", "Source", "sec", "req", "sv", "rs", "sf", "rl", "sel", "input", "upload", "rx", "sc", "st", "syn", "start", "source", "ipl", "inst"], "dst": ["hst", "hdest", "dnd", "Ddest", "pnd", "dest", "ddest", " dost", "pdest", "Dnd", " ddest", " dnd", "Dst", "pest", "hnd", "Dost", "dost", "sdest", "snd", "pst", "sest", "Dest", "sst", "host"], "inChannel": ["cinChannel", " inListener", "InConnection", "orChan", "INChan", "vinConnection", "inChan", "intChannel", "INConnection", "orChannel", "inListener", "vinButton", "inChain", "netPanel", " inButton", " inByte", "outCommand", "outConnection", "intByte", "orCommand", "inByte", "cinPanel", "InChannel", "netConnection", "netChannel", "inCommand", "InStream", "cinButton", "INPanel", "innerChan", " inPanel", "vinPanel", "innerPanel", " inConnection", " inchannel", "innerChannel", "intListener", "innerConnection", "orStream", "itListener", " inStream", "cinConnection", "itChain", "vinChannel", "intChain", "inPanel", "outStream", " inChan", "inConnection", "inchannel", "itChannel", "outChan", " inChain", "netChan", "itByte", " inCommand", "outchannel", "Inchannel", "INChannel", "inButton", "inStream"], "outChannel": ["Outchannel", "conChannel", "kButton", "atConsole", "OutClient", "kConsole", "atChannel", "inChan", "atChan", "OUTMachine", "conSection", "OUTChan", "OUTSection", "atButton", "outputchannel", "OutChannel", " outCh", " outChan", "OutChan", "outButton", " outButton", "conMachine", "outSection", "outConsole", "kChan", " outConsole", "outMachine", " outClient", "OUTChannel", " outchannel", "outChan", "outputChannel", "outputCh", "conChan", "outputClient", "outchannel", "outClient", "inSection", "inMachine", "kChannel", "OutCh", "outCh", "outputChan"]}}
{"id1": "6421904", "id2": "20920051", "code1": "    public DataRecord addRecord(InputStream input) throws DataStoreException {\n        File temporary = null;\n        try {\n            temporary = newTemporaryFile();\n            DataIdentifier tempId = new DataIdentifier(temporary.getName());\n            usesIdentifier(tempId);\n            long length = 0;\n            MessageDigest digest = MessageDigest.getInstance(DIGEST);\n            OutputStream output = new DigestOutputStream(new FileOutputStream(temporary), digest);\n            try {\n                length = IOUtils.copyLarge(input, output);\n            } finally {\n                output.close();\n            }\n            DataIdentifier identifier = new DataIdentifier(digest.digest());\n            File file;\n            synchronized (this) {\n                usesIdentifier(identifier);\n                file = getFile(identifier);\n                if (!file.exists()) {\n                    File parent = file.getParentFile();\n                    parent.mkdirs();\n                    if (temporary.renameTo(file)) {\n                        temporary = null;\n                    } else {\n                        throw new IOException(\"Can not rename \" + temporary.getAbsolutePath() + \" to \" + file.getAbsolutePath() + \" (media read only?)\");\n                    }\n                } else {\n                    long now = System.currentTimeMillis();\n                    if (getLastModified(file) < now + ACCESS_TIME_RESOLUTION) {\n                        setLastModified(file, now + ACCESS_TIME_RESOLUTION);\n                    }\n                }\n                if (file.length() != length) {\n                    if (!file.isFile()) {\n                        throw new IOException(\"Not a file: \" + file);\n                    }\n                    throw new IOException(DIGEST + \" collision: \" + file);\n                }\n            }\n            inUse.remove(tempId);\n            return new FileDataRecord(identifier, file);\n        } catch (NoSuchAlgorithmException e) {\n            throw new DataStoreException(DIGEST + \" not available\", e);\n        } catch (IOException e) {\n            throw new DataStoreException(\"Could not add record\", e);\n        } finally {\n            if (temporary != null) {\n                temporary.delete();\n            }\n        }\n    }\n", "code2": "    public static void copyTo(File source, File dest) {\n        if (source.isHidden()) ; else if (source.isDirectory()) {\n            File temp = new File(dest.getPath() + \"/\" + source.getName());\n            temp.mkdir();\n            for (File sel : source.listFiles()) copyTo(sel, temp);\n        } else {\n            try {\n                File tempDest = new File(dest.getPath() + \"/\" + source.getName());\n                tempDest.createNewFile();\n                FileChannel sourceCh = new FileInputStream(source).getChannel();\n                FileChannel destCh = new FileOutputStream(tempDest).getChannel();\n                sourceCh.transferTo(0, sourceCh.size(), destCh);\n                sourceCh.close();\n                destCh.close();\n            } catch (IOException ex) {\n                Logger.getLogger(EditorUtil.class.getName()).log(Level.SEVERE, null, ex);\n            }\n        }\n    }\n", "label": 1, "substitutes": {"addRecord": ["Addrecord", "writerecord", "AddFile", "newrecord", "addFile", "writeRecord", "addDocument", "addrecord", "newRecord", "writeFile", "newDocument", "AddRecord", "newFile", "AddDocument", "writeDocument"], "input": ["image", "address", "request", "reader", "m", "stream", "table", "context", "in", "base", "q", "open", "Input", "current", "up", "content", "format", "media", "get", "error", "out", "upload", "initial", "it", "this", "add", "config", "io", "start", "is", "source", "p", "from", "data", "w"], "temporary": ["tmporary", "semporal", "tytemp", "timmanent", "theporary", "tememp", "tmutable", "sememp", "tenporal", "tempient", "typoral", "transmanent", "tymediate", "tempperature", "temmanent", " tempty", "timutable", "temppor", "theporal", "stperature", "comarily", "tenperature", " temcreated", "temppty", "temperature", "timporal", "temputable", "tmient", "tyutable", "timarily", "temmediate", "temptemp", "tmperature", "transporal", "memperature", "typerature", "timtemp", "Temporary", "typor", "stemp", "remporal", "tenarily", "semporary", "tempporal", "memporal", "transperature", "Temperature", "tempty", "temcreated", "Temporal", "semperature", "tempporary", "typorary", "remporary", "tyient", "remcreated", "transporary", "comperature", "temtemp", "tenporary", "memutable", "temporal", "theperature", "stemperature", "temient", "rempty", "timperature", "tmemp", "timporary", " temporal", "stemmanent", "comporary", "stporal", "tmpor", "stporary", "stemporary", "tempor", "stemporal", "timmediate", "temutable", "comporal", "temarily", "tmporal", "Temutable", "themediate", "tempcreated", "memporary"], "tempId": ["tempID", "templateId", "poraryRef", "tempIs", "uniqueK", "TempUrl", "uniqueUrl", "templateUrl", "poraryPart", "poraryId", "fakePart", "uniqueId", "tempPart", "templateK", "tempK", "currentK", "currentId", "poraryUrl", "fakeId", "templateIs", "fakeRef", "tempRef", "stemId", "stemID", "TempID", "TempId", "templateRef", "templateID", "poraryID", "currentIs", "stemUrl", "uniqueIs", "currentUrl", "tempUrl", "fakeID", "templatePart"], "length": ["type", "all", "json", "value", "text", "default", "ENGTH", "time", "Length", "capacity", "description", "sequence", "limit", "code", "buffer", "load", "shape", "message", "end", "maximum", "readable", "available", "filename", "supported", "number", "read", "content", "name", "position", "total", "l", "SIZE", "loaded", "offset", "len", "data", "path", "height", "present", "ength", "amount", "full", "padding", "count", "n", "volume", "string", "L", "location", "width", "size", "version", "bytes", "duration"], "digest": ["mdester", "fingerest", "mdig", "moder", "Digig", "digist", "diger", "identig", "Diger", "modEST", "signested", "modest", "Digester", "fingerester", "fingerEST", "signist", "digEST", "mdest", " digist", "identest", "digig", "Digist", "signester", " digester", "Digested", "mdested", "modested", " digEST", "digested", "fingerested", "identester", " diger", "identested", "digester", "signest", "DigEST", " digested", "Digest"], "output": ["generation", "response", "image", "ilo", "that", "put", "next", "console", "application", "other", "client", "stream", "web", "page", "Output", "connection", "four", "net", "write", "open", "buffer", "to", "current", "you", "result", "message", "none", "see", "unsigned", "hidden", "out", "outer", "exit", "object", "ou", "network", "o", "auto", "cut", "channel", "io", "no", "icon", "source", "body", "data", "display"], "file": ["rule", "value", "File", "FILE", "h", "single", "page", "port", "base", "work", "to", "db", "filename", "real", "child", "get", " File", "out", "stat", "form", "record", "relation", "channel", "info", "io", "files", "type", "f", "handle", "resource", "al", "link", "log", "buffer", "document", "ile", "name", "target", "upload", "tree", "binary", "line", "local", "http", "temp", "id", "report", "same", "block", "entry", "comment", "create", "table", "run", "library", "module", "in", "chain", "e", "url", "le", "error", "path", "dir", "body", "user", "data", "image", "word", "fp", "action", "old", "message", "result", "format", "entity", "valid", "common", "this", "null", "full", "place", "remote", "source", "il", "class", "print"], "parent": ["parents", "rule", "block", "sp", "part", "op", "m", "tmp", "port", "base", "man", "to", "master", "shape", "holder", "owner", "child", "name", "global", "out", "per", "this", "tree", "path", "mother", "null", "dir", "g", "line", "ip", "relation", "ma", "ger", "pool", "folder", "Parent", "root", "source", "wrapper", "p", "from"], "now": ["exp", "onew", "ord", "cmp", "time", "draw", "ow", "then", "wait", "yes", "set", "sum", "here", "before", "day", "done", "date", "omp", "current", "system", "post", "always", "aj", "amp", "ct", "off", "when", "Now", "after", "since", "fx", "dd", "sw", "st", "present", "aw", "null", "gov", "mb", "tim", "full", "mm", "recent", "ready", "NOW", "size", "diff", "loc", "zero", "from"]}}
{"id1": "838844", "id2": "17996547", "code1": "    public void convert(File src, File dest) throws IOException {\n        InputStream in = new BufferedInputStream(new FileInputStream(src));\n        DcmParser p = pfact.newDcmParser(in);\n        Dataset ds = fact.newDataset();\n        p.setDcmHandler(ds.getDcmHandler());\n        try {\n            FileFormat format = p.detectFileFormat();\n            if (format != FileFormat.ACRNEMA_STREAM) {\n                System.out.println(\"\\n\" + src + \": not an ACRNEMA stream!\");\n                return;\n            }\n            p.parseDcmFile(format, Tags.PixelData);\n            if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) {\n                System.out.println(\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n                return;\n            }\n            boolean hasPixelData = p.getReadTag() == Tags.PixelData;\n            boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12;\n            int pxlen = p.getReadLength();\n            if (hasPixelData) {\n                if (inflate) {\n                    ds.putUS(Tags.BitsAllocated, 16);\n                    pxlen = pxlen * 4 / 3;\n                }\n                if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) {\n                    System.out.println(\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                    return;\n                }\n            }\n            ds.putUI(Tags.StudyInstanceUID, uid(studyUID));\n            ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID));\n            ds.putUI(Tags.SOPInstanceUID, uid(instUID));\n            ds.putUI(Tags.SOPClassUID, classUID);\n            if (!ds.contains(Tags.NumberOfSamples)) {\n                ds.putUS(Tags.NumberOfSamples, 1);\n            }\n            if (!ds.contains(Tags.PhotometricInterpretation)) {\n                ds.putCS(Tags.PhotometricInterpretation, \"MONOCHROME2\");\n            }\n            if (fmi) {\n                ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian));\n            }\n            OutputStream out = new BufferedOutputStream(new FileOutputStream(dest));\n            try {\n            } finally {\n                ds.writeFile(out, encodeParam());\n                if (hasPixelData) {\n                    if (!skipGroupLen) {\n                        out.write(PXDATA_GROUPLEN);\n                        int grlen = pxlen + 8;\n                        out.write((byte) grlen);\n                        out.write((byte) (grlen >> 8));\n                        out.write((byte) (grlen >> 16));\n                        out.write((byte) (grlen >> 24));\n                    }\n                    out.write(PXDATA_TAG);\n                    out.write((byte) pxlen);\n                    out.write((byte) (pxlen >> 8));\n                    out.write((byte) (pxlen >> 16));\n                    out.write((byte) (pxlen >> 24));\n                }\n                if (inflate) {\n                    int b2, b3;\n                    for (; pxlen > 0; pxlen -= 3) {\n                        out.write(in.read());\n                        b2 = in.read();\n                        b3 = in.read();\n                        out.write(b2 & 0x0f);\n                        out.write(b2 >> 4 | ((b3 & 0x0f) << 4));\n                        out.write(b3 >> 4);\n                    }\n                } else {\n                    for (; pxlen > 0; --pxlen) {\n                        out.write(in.read());\n                    }\n                }\n                out.close();\n            }\n            System.out.print('.');\n        } finally {\n            in.close();\n        }\n    }\n", "code2": "    public static File copyFile(File fileToCopy, File copiedFile) {\n        BufferedInputStream in = null;\n        BufferedOutputStream outWriter = null;\n        if (!copiedFile.exists()) {\n            try {\n                copiedFile.createNewFile();\n            } catch (IOException e1) {\n                e1.printStackTrace();\n                return null;\n            }\n        }\n        try {\n            in = new BufferedInputStream(new FileInputStream(fileToCopy), 4096);\n            outWriter = new BufferedOutputStream(new FileOutputStream(copiedFile), 4096);\n            int c;\n            while ((c = in.read()) != -1) outWriter.write(c);\n            in.close();\n            outWriter.close();\n        } catch (FileNotFoundException e) {\n            e.printStackTrace();\n            return null;\n        } catch (IOException e) {\n            e.printStackTrace();\n            return null;\n        }\n        return copiedFile;\n    }\n", "label": 1, "substitutes": {"convert": ["Converting", "compvert", "converts", "unverted", "consvert", "Conprocess", "CONversion", "converted", "Conversion", "unprocess", "confer", "unfer", "Confer", "unvert", "unverts", "compverts", "ConVERT", "Converted", "CONvert", "conversion", "conprocess", "CONfer", "Convert", "CONverted", "unversion", "compversion", "compprocess", "consversion", "converting", "CONverting", "consVERT", "consverting", "conVERT", "CONVERT", "Converts"], "src": ["ser", "buster", "rc", "txt", "hl", "scan", "usr", "attr", "img", "orig", "func", "ins", "sit", "cont", "sys", "stream", "SourceFile", "sq", "addr", "rest", "pkg", "cur", "sr", "rel", "filename", "ur", "Source", "its", "req", "url", "uri", "RC", "rs", "str", "SOURCE", "inst", "input", "upload", "sin", "rx", "sc", "st", "path", "ource", "s", "iv", "scene", "href", "http", "config", "dist", "start", "file", "source", "loc", "ipl", "ebin", "from", "host", "cc"], "dest": ["txt", "img", " destinations", "gin", "orig", "test", "disk", "est", "table", "port", "rest", "write", " Dest", "result", " dst", "mat", "target", "foreign", " orig", " destination", "dir", "dat", "Dest", "dist", "temp", " Destination", "source", "tif"], "in": ["en", "rin", "inn", "res", "IN", "ins", "d", "ar", "reader", "m", "stream", "In", "inner", "b", "up", "i", "bin", "serv", "l", "input", "sql", "st", "ind", "r", "el", "ad", "io", "din", "inf", "is", "isin", "source", "as", "file", "cin", "from"], "p": ["f", "php", "pa", "pb", "dp", "j", "pd", "tp", "rep", "vp", "sp", "d", "py", "parser", "part", "h", "op", "pp", "m", "fp", "t", "pl", "c", "pkg", "b", "pg", "ps", "ping", "post", "pro", "i", "cp", "ph", "pc", "pt", "pi", "l", "it", "per", "parse", "P", "pers", "at", "lp", "pre", "g", "r", "jp", "pm", "er", "wp", "prot", "pe", "ap"], "ds": ["dates", "dp", "di", " ads", "scripts", "loads", "yes", "qs", "tests", "ns", "ps", "drivers", "db", "dds", "sd", "ats", "dt", " DS", "ports", "ras", "terms", "ss", "DS", "ws", "bs", "docs", "hs", "workers", "iffs", "lists", "os", "edes", "gs", " dd", "hd", "vs", " d", "uds", "ils", "eds", "xs", "tags", "Ds", "dl", "els", "sets", "gd", "ls", "ts", "ags", "rs", " des", "obs", "s", "outs", "ods", "sts", "posts", "ands", "tes", "cs", "amps", "dos", "ads", "pd", "tp", "mys", "d", "cks", "js", " os", "its", "aws", "ys", "des", "eps", "dd", "ks", "points", "df", "nas", "dh"], "format": ["type", "f", "style", "layout", "settings", "output", "policy", "MAT", "feature", "mt", "fm", "set", "status", "table", "tag", "t", "feat", " Format", "module", "template", "sche", "spec", "fc", "shape", "mode", "Format", "ct", "act", "mat", "name", "ats", "pi", "top", "l", "it", "parse", "form", "path", "at", "filter", "lat", "pattern", "id", "cf", "file", "source", "size", "unit", "version", "pretty", "title"], "hasPixelData": ["HaspixelDATA", "hasixelData", "hasPixelDATA", "Haspixeldata", "hasPixeldata", "HasPixelDATA", "HaspixelData", "hasFrameData", "hasFrameDATA", "haspixelDATA", "hasFramedata", "HasPixeldata", "haspixeldata", " hasPixelDATA", " hasPixeldata", "hasixeldata", "hasixelDATA", "HasPixelData", "haspixelData"], "inflate": ["inFLated", "Inflate", "invalidATE", "inFLat", "inFLocate", "incelate", " invalidicate", "infolat", "Inflat", "invalidate", "inFlicate", "inflATE", "inflated", "incelicate", " inflocate", "incelocate", "Informocate", "Informated", "incelATE", "inFlATE", " inflicate", "inFlate", " invalidate", "informat", "infolated", "Inflocate", "inflicate", "inFlocate", "infolocate", "informocate", "informate", "Informat", "invalidicate", "Inflated", " inflATE", "inflocate", "informated", "Informate", "inFLate", "invalidocate", " invalidATE", "inflat", " invalidocate", "infolate"], "pxlen": ["pxln", "mmlin", "packlen", "pxlength", "cpln", "xplength", "cplength", "phpln", "pixellength", "pxlin", "cpden", "mxlength", "cplen", "packlength", "pexlength", "xylen", "mmlen", "pxdec", "tmpln", "packdec", "phplength", "pexln", "mxdec", "packfun", "pexls", "mxlen", "pxls", "pxfun", "xylin", "xyln", "tmplin", "xpden", "mxln", "tmplen", "pexlen", "pxden", "phplen", "pexfun", "mmlength", "pixelfun", "packls", "xpln", "phpdec", "pixells", "pexden", "tmplength", "xplen", "packln", "mmln", "pixellen", "xylength"], "out": ["output", "res", "obj", "ln", "client", "sys", "sum", "inter", "init", "net", "log", "print", "err", "list", "up", "crit", "name", "writer", "outer", "cmd", "conn", "gov", "ou", "group", "aos", "outs", "dir", "cfg", "inv", "screen", "gr", "io", "msg", "temp", "Out", "OUT", "user", "store", "pretty", "prefix", "ex"]}}
{"id1": "15745420", "id2": "12171364", "code1": "    private void download(String address, String localFileName) throws UrlNotFoundException, Exception {\n        String ext = G_File.getExtensao(address);\n        if (ext.equals(\"jsp\")) {\n            throw new Exception(\"Erro ao baixar pagina JSP, tipo negado.\" + address);\n        }\n        File temp = new File(localFileName + \".tmp\");\n        if (temp.exists()) temp.delete();\n        OutputStream out = null;\n        URLConnection conn = null;\n        InputStream in = null;\n        try {\n            try {\n                URL url = new URL(address);\n                conn = url.openConnection();\n                in = conn.getInputStream();\n            } catch (FileNotFoundException e2) {\n                throw new UrlNotFoundException();\n            }\n            out = new BufferedOutputStream(new FileOutputStream(temp));\n            byte[] buffer = new byte[1024];\n            int numRead;\n            long numWritten = 0;\n            while ((numRead = in.read(buffer)) != -1) {\n                out.write(buffer, 0, numRead);\n                numWritten += numRead;\n            }\n        } catch (UrlNotFoundException exception) {\n            throw exception;\n        } catch (Exception exception) {\n            throw exception;\n        } finally {\n            try {\n                if (in != null) {\n                    in.close();\n                }\n                if (out != null) {\n                    out.close();\n                }\n            } catch (IOException ioe) {\n            }\n        }\n        File oldArq = new File(localFileName);\n        if (oldArq.exists()) {\n            oldArq.delete();\n        }\n        oldArq = null;\n        File nomeFinal = new File(localFileName);\n        temp.renameTo(nomeFinal);\n    }\n", "code2": "    private static FrameworkFactory getFrameworkFactory() throws Exception {\n        URL url = Main.class.getClassLoader().getResource(\"META-INF/services/org.osgi.framework.launch.FrameworkFactory\");\n        if (url != null) {\n            BufferedReader br = new BufferedReader(new InputStreamReader(url.openStream()));\n            try {\n                for (String s = br.readLine(); s != null; s = br.readLine()) {\n                    s = s.trim();\n                    if ((s.length() > 0) && (s.charAt(0) != '#')) {\n                        return (FrameworkFactory) Class.forName(s).newInstance();\n                    }\n                }\n            } finally {\n                if (br != null) br.close();\n            }\n        }\n        throw new Exception(\"Could not find framework factory.\");\n    }\n", "label": 0, "substitutes": {"download": ["Download", "dial", " Download", "dl", "request", "view", " downloads", "link", "del", "transfer", "copy", "archive", "upload", "login", "pull", "dump", "GET", "split", "zip", "remote", "save", "submit", "install", "file", "update", "data", "move"], "address": ["type", "report", "street", "reference", "alias", "email", "contact", "service", "comment", "Address", "description", "resource", "page", "site", "context", "base", "directory", "connection", "link", "addr", "attribute", "command", "absolute", "shape", "message", "route", "uri", "name", "ace", "order", "search", "path", "network", "ip", "add", "express", "domain", "adr", "place", "remote", "location", "key", "relative", "server", "password", "index", "host", "prefix"], "localFileName": ["localFilenamePath", "localDirName", "remoteFilenameSize", "localFullFilename", "localDirFilename", "remoteFileType", "localFileType", " localFilenameName", " localFilenamePath", "localfileName", " localFilenameFilename", "LocalFileName", "localfilename", "localTableName", "localTableType", "localPageSize", "localfilePath", "LocalFilenameNames", "localFilenameNames", "localTablePath", "localPageNames", "localModelPath", "localPagename", "localFilenamename", "localDirname", "LocalFilenamePath", "localFilenameType", "localFilenameSize", "remoteFilename", "localFilenameName", "localFileFilename", "localDirPath", "remoteFilenamePath", "LocalFilePath", "remoteFilenameName", "localFilename", "localPageNum", "localPagePath", "remoteFileName", "localfileSize", "localFilenameNum", "LocalFileNum", "localFileNames", " localFilename", " localFilenamename", "localFileSize", "localPageName", "remoteFilenamename", "LocalFileNames", "localModelNames", "localModelNum", " localFileFilename", "localFileNum", "localModelName", "remoteFileSize", "localCodeType", "localCodeName", "LocalFilenameName", "localFullPath", "localFullname", " localFilePath", "localFullName", "remoteFilenameType", "localFilenameFilename", "localCodePath", "LocalFilenameNum", "remoteFilePath", "localFilePath"], "ext": ["type", "exp", "txt", "text", "sp", "cont", "word", "obj", "not", "t", "x", "code", "addr", "content", "Ext", "xt", "format", "dim", "name", "off", "str", "def", "alg", "sect", "cmd", "path", "dir", "EXT", "tim", "pattern", "ret", "typ", "desc", "fab", "zip", "config", "eng", "dist", "prot", "pat", "file", "except", "end"], "temp": ["empty", "txt", "tr", "output", "orig", "test", "dest", "part", "mt", "tar", "Temp", "tmp", "table", "t", "mem", "mod", "box", "template", "base", "mp", "fake", "perm", "current", "none", "cache", "cp", "copy", "pt", "partial", "tab", "pdf", "path", "null", "dat", "dir", "tc", "created", "pre", "porary", "tem", "por", "zip", "emp", "local", "mk", "relative", "file", "EMP", "memory", "tif", "p", "tm", "prefix", "w"], "out": ["co", "con", "output", "cos", "oe", "oss", "ao", "cn", "bo", "op", "obj", "ln", "client", "on", "sys", "w", "yes", "tmp", "conv", "t", "inner", "ns", "one", "net", "write", "b", "to", "go", "end", "print", "i", "e", "writer", "os", "outer", "pos", "or", "it", "OU", "null", "ou", "at", "outs", "aos", "o", "boot", "inv", "n", "io", "no", "Out", "file", "body", "OUT", "p", "can", "ne", "ot"], "conn": ["canon", " con", "co", "nt", "ctx", "con", "res", "comm", "cn", "cb", "enc", "yn", "obj", "client", "gate", "conv", "connection", "ca", "c", "cs", "open", "resp", "cert", "addr", "rel", "conf", "com", "ct", "cp", "Conn", "serv", "cm", "Connection", "ch", "cmd", "ctrl", "syn", "connect", "ssl", "nc", "jp", "n", "socket", "cc"], "in": ["all", "rin", "en", "image", "inn", "ini", "irm", "gin", "con", "IN", "internal", "ins", "ln", "on", "oin", "can", "client", "raw", "stream", "In", "t", "inner", "init", "inside", "net", "ic", "asin", "up", "conf", "i", "bin", "str", "inc", "l", "input", "or", "iter", "it", "ain", "ind", "nin", "inv", "n", "din", "inf", "er", "is", "no", "isin", "file", "source", "cin", "user", "from"], "url": ["browser", "f", "hl", "gl", "google", "dl", "con", "www", "client", "bel", "web", "ls", "ll", "connection", "link", "pl", "net", "sl", "open", "build", "cert", "lr", "rel", "ur", "cp", "URL", "str", "l", "cmd", "nl", "ul", "mail", "mb", "r", "ssl", "http", "il", "Url"], "buffer": ["phrase", "buf", "window", "block", "value", "buff", "sample", "column", "frame", "word", "comment", "view", "sequence", "raw", "append", "table", "stroke", "mem", "base", "template", "command", "document", "message", "shape", "stack", "cell", "number", "read", "cache", "variable", "Buffer", "initial", "history", "length", "queue", "paste", "binary", "batch", "filter", "database", "bar", "padding", "row", "button", "source", "password", "memory"], "numRead": ["numWrite", "umerSend", "NUMLength", "numPrint", "umerReader", "numberWrite", "numberRead", " numWrite", "sumWrite", "sumRead", "numPush", " numSend", "newRead", "NUMLoad", "numberREAD", "numREAD", "NUMRead", " numReader", "numberReader", "numLoad", "numReader", "newReader", " numPush", " numLoad", " numLength", "newPush", "newSend", " numREAD", "sumReader", "umerRead", "umLoad", " numPrint", "umRead", "numLength", "numberLength", "numberPrint", "numSend", "umerPush", "NUMREAD", "numberLoad", "umPrint"], "numWritten": ["umWrite", "numWrite", " numWriter", "NumWriter", "numberWrite", " numWrite", "monWriter", "numWrit", "numberWritten", "numWriter", "umWritten", "monWrite", "NumWrit", "numberWriter", "monWritten", "umWriter", " numWrit", "NumWritten", "NumWrite", "monWrit"], "oldArq": [" oldTarQ", " oldAriq", "oldAriq", "oldLaQ", "oldLaqs", "lastARqu", "oldDarqu", "oldTarq", "oldArQ", " oldTariq", "oldDarck", "oldARck", "oldArqs", " oldArQ", "oldTarch", "lastARck", "oldARch", "lastARch", "lastArck", "oldariq", " oldArqs", "oldAq", "oldAqs", "oldAQ", "lastArq", "oldTarQ", " oldArch", "oldUrq", "lastArch", " oldTarq", "oldArch", "oldArck", " oldAch", "oldLaiq", " oldAqs", "oldARqu", "oldDarq", " oldTarqs", "lastArqu", "oldAch", "oldarqs", "oldarQ", " oldTarch", "oldarq", "oldDarch", "oldARq", "oldUrch", "oldUrqu", "oldTariq", " oldAQ", "oldTarqs", "oldUrck", " oldAq", "oldLaq", "oldArqu", "lastARq"], "nomeFinal": ["NomeGlobal", "noursefinal", "nadeFinal", "nomesFin", "NomeFinal", " nomefinal", "nameWall", "nomeFin", "nomeGlobal", "nomesFinal", "nomesfinal", "nadeFin", "nomFinal", "NadeFinal", "nameGlobal", "NomeWall", "nourseWall", "nomefinal", "NadeGlobal", "nourseGlobal", "Nadefinal", " nomFin", "NadeWall", "nameFinal", "nadeWall", "Nomefinal", " nomfinal", " nomFinal", "nomeWall", "nomfinal", " nomeFin", "nadeGlobal", "namefinal", "nomFin", "nourseFinal", "nadefinal"]}}
{"id1": "8515891", "id2": "20519261", "code1": "    protected String readUrl(String svnUrl) throws IOException {\n        URL url = new URL(svnUrl);\n        URLConnection uc = url.openConnection();\n        if (url.getProtocol().equals(\"https\")) {\n            String userPassword = user + \":\" + password;\n            String encoding = new sun.misc.BASE64Encoder().encode(userPassword.getBytes());\n            uc.setRequestProperty(\"Authorization\", \"Basic \" + encoding);\n        }\n        InputStream is = null;\n        String in = null;\n        try {\n            is = uc.getInputStream();\n            in = read(is);\n        } finally {\n            try {\n                is.close();\n            } catch (Exception e) {\n            }\n        }\n        return in;\n    }\n", "code2": "    public String readReferenceText(final String ident) throws NoContentException {\n        try {\n            String name = getFilename(ident);\n            URL url = new URL(FreqAnalysisPlugin.getDefault().getBundle().getEntry(\"/\"), name);\n            InputStream in = url.openStream();\n            InputStreamReader isr = new InputStreamReader(in, \"UTF-8\");\n            BufferedReader br = new BufferedReader(isr);\n            StringBuffer buffer = new StringBuffer();\n            String line = br.readLine();\n            while (null != line) {\n                buffer.append(line + \"\\n\");\n                line = br.readLine();\n            }\n            return buffer.toString();\n        } catch (MalformedURLException muEx) {\n            logError(muEx);\n        } catch (UnsupportedEncodingException ueEx) {\n            logError(ueEx);\n        } catch (IOException ioEx) {\n            logError(ioEx);\n        }\n        throw new NoContentException(\"Unable to find or read reference text.\");\n    }\n", "label": 0, "substitutes": {"readUrl": ["getURL", "loadurl", "readurl", "geturl", "getUrl", "loadUr", "getUr", "READurl", "loadURL", "READUrl", "READURL", "readUr", "readURL", "READUr", "loadUrl"], "svnUrl": ["svNUrl", "servicensUrl", "svnServer", "svnsUrl", " svnServer", "svnStr", " svnStr", "svneStr", "servicenurl", "svnurl", "svnURL", "svnsStr", "servicenUr", "svcurl", " svnUr", "svgurl", "servicensurl", "servicensURL", "svcUrl", "svneUr", "svcUr", "servicensUr", " svNServer", " svNStr", "servicenUrl", "svnsUr", "svneServer", "svNServer", "svnsurl", "svNStr", "svneUrl", " svNUr", "svcURL", "svgURL", " svNUrl", "svnsURL", "svNUr", "svgUr", "svnsServer", "servicenURL", "svnUr", "svgUrl"], "url": ["browser", "hl", "gl", "ref", "google", "dl", "lb", "https", "bel", "raw", "ls", "ll", "base", "char", "link", "pl", "build", "sl", "impl", "call", "lr", "ur", "mount", "org", "uri", "URL", "cl", "str", "uf", "l", "uu", "nl", "ul", "mail", "conn", "github", "r", "ssl", "http", "location", "html", "ld", "loc", "acl", "Url", "ml", "host", "abs"], "uc": ["co", "rc", "u", "us", "con", "cr", "ux", "oc", "auc", "cus", "bc", "unic", "ud", "c", "fc", "soc", "cu", "ci", "usc", "anc", "cur", "ui", "lu", "uci", "ac", "uf", "roc", "ec", "ub", "uu", "sc", "ul", "orc", "conn", "lc", "tc", "unc", "mc", "nc", "ucc", "uh", "nic", "loc", "eu", "UC", "userc", "dc", "cc", "cl"], "userPassword": [" userAuth", "Userpassword", "userPass", "managerAuth", "UserGrant", "browserPassword", "UserData", "userGrant", "userpassword", "browserpassword", " userGrant", "browserPass", "userAuth", " userpassword", "browserData", "managerGrant", "managerPassword", "UserPassword", " userData", "UserAuth", "managerPass", "UserPass", "userData", " userPass"], "encoding": ["ecoding", "enoding", "coding", "ecasing", "caling", "enryption", "ecoder", "Encoder", "enoder", "ecaling", "Encaling", "ecryption", "coder", "encryption", "Encasing", "cryption", "Encryption", "encaling", "enasing", "Encoding", "encoder", "encasing"], "is": ["mis", "mi", "ows", "ois", "ms", "us", "iris", "imp", "oss", "ins", "im", "Is", "ri", "fs", "isa", "ais", "abs", "ism", "tis", "vis", "ic", "i", "its", "ris", "os", "IS", "ys", "it", "isc", "ir", "ims", "si", "lis", "isl", "obs", "s", "bis", "ip", "isf", "ists", "isi", "iso", "isin", "ios", "\u00eds", "iss", "as", "es", "sis"], "in": ["f", "report", "rin", "en", "inn", "text", "gin", "con", "IN", "vin", "ins", "pin", "m", "on", "oin", "ln", "sum", "In", "t", "inner", "k", "edIn", "lit", "kin", "v", "i", "e", "read", "bin", "str", "inc", "l", "out", "input", "login", "it", "nin", "r", "n", "din", "isin", "file", "password", "cin", "print"]}}
{"id1": "19810820", "id2": "9033639", "code1": "    public static void copyFileChannel(File src, File dst, boolean preserveModificationTime) throws IOException {\n        FileChannel inputChannel = null;\n        FileChannel outputChannel = null;\n        long length = 0;\n        try {\n            inputChannel = new FileInputStream(src).getChannel();\n            length = inputChannel.size();\n            outputChannel = new FileOutputStream(dst).getChannel();\n            long total = 0;\n            while (total < length) {\n                total += inputChannel.transferTo(0, length, outputChannel);\n            }\n            if (preserveModificationTime) {\n                dst.setLastModified(src.lastModified());\n            }\n        } finally {\n            if (inputChannel != null) {\n                inputChannel.close();\n            }\n            if (outputChannel != null) {\n                outputChannel.close();\n            }\n        }\n    }\n", "code2": "    public void testHttpsConnection() throws Throwable {\n        setUpStoreProperties();\n        try {\n            SSLContext ctx = getContext();\n            ServerSocket ss = ctx.getServerSocketFactory().createServerSocket(0);\n            TestHostnameVerifier hnv = new TestHostnameVerifier();\n            HttpsURLConnection.setDefaultHostnameVerifier(hnv);\n            URL url = new URL(\"https://localhost:\" + ss.getLocalPort());\n            HttpsURLConnection connection = (HttpsURLConnection) url.openConnection();\n            SSLSocket peerSocket = (SSLSocket) doInteraction(connection, ss);\n            checkConnectionStateParameters(connection, peerSocket);\n            connection.connect();\n        } finally {\n            tearDownStoreProperties();\n        }\n    }\n", "label": 0, "substitutes": {"copyFileChannel": [" copyByteChannel", " copyStreamchannel", " copyStreamChannel", "copyByteStream", " copyFilechannel", " copyFileFile", " copyByteStream", " copyFilesFile", " copyStreamFile", "copyBytechannel", "copyFileStream", " copyFilesChannel", "copyByteFile", " copyStreamStream", "copyByteChannel", " copyFileschannel", " copyBytechannel", "copyFileFile", " copyByteFile", " copyFileStream", " copyFilesStream", "copyFilechannel"], "src": ["ser", "rc", "txt", "usr", "sb", "img", "rt", "sync", "ins", "dest", "cont", "js", "sys", "bs", "ls", "tmp", "init", "in", "SourceFile", "sq", "sl", "ctr", "cur", "sr", "usc", "rel", "filename", "sec", "req", "Source", "RC", "rs", "sf", "rl", "SOURCE", "input", "sc", "rx", "st", "obs", "s", "syn", "start", "source", "loc", "inst", "from"], "dst": ["dnd", "Ddest", "Dist", "dest", "ddest", "jdest", "Dut", "jest", "bst", "dut", "Dnd", " ddest", " dnd", "Dst", "jst", " dist", "best", "jut", "sdest", "snd", " dest", "sest", "sut", "Dest", "dist", " dth", "dth", "bist", "sst", "Dth", "bdest", "sth"], "preserveModificationTime": ["preserveModifiedTimes", "preserveSpecificationTim", "preserveModifyPoint", "preserveQualificationsTime", "preserveModificationTim", "preserveQualificationsTimes", "preserveModificationPoint", "preserveModificationsTime", "preserveModifyingPoint", "preserveModifiedTime", "preserveSpecificationsTim", "preserveModifyTime", "preserveModificationsLength", "preserveModificationLength", "preserveModifiedTim", "preserveModifierTim", "preserveQualificationsPoint", "preserveModifyLength", "preserveSpecificationTime", "preserveSpecificationsTimes", "preserveQualificationsLength", "preserveModificationsPoint", "preserveQualificationTimes", "preserveModifyingTimes", "preserveModificationTimes", "preserveModifyTimes", "preserveModificationsTimes", "preserveModificationsTim", "preserveSpecificationTimes", "preserveModifyingLength", "preserveQualificationTime", "preserveQualificationLength", "preserveModifierTime", "preserveModifierTimes", "preserveModifyingTime", "preserveSpecificationsTime", "preserveQualificationPoint"], "inputChannel": ["clientChannel", "InputChannel", "interfaceCategory", "interfaceListener", "InputStream", "inputStream", " inputChuck", "infoChannel", "openChannel", "openGray", "inputGray", "outputChuck", "innerStream", "outputchannel", " inputListener", " inputStream", "inputchannel", "openChan", "innerChan", "inputListener", "clientConnection", "outputStream", "infoChuck", "hiddenListener", "InputBuffer", "innerChannel", "entityChannel", "inputBuffer", "infochannel", "hiddenChannel", "inputConnection", "hiddenCategory", " inputchannel", "inputChan", "entityChan", " inputChan", " inputConnection", "inputCategory", "inputChuck", " inputGray", "innerchannel", "evalChan", "InputChan", "clientChan", "interfaceChannel", " inputCategory", "infoChan", "openConnection", "outputBuffer", "evalChannel", "Inputchannel", "clientGray", " inputBuffer", "outputChan"], "outputChannel": ["webchannel", "inputInstance", "outputConnection", " outputChan", " outputManager", " outputStream", "doubleField", "writeChannel", "doubleChan", "writeChan", "coinChannel", "coinField", "displayChannel", "coinInstance", "outputchannel", "webChannel", "OutputStream", " outputchannel", "putButton", "inputManager", "Outputchannel", "putChannel", "putChan", "outputStream", "coinChan", "writeStream", "doubleChannel", "doubleInstance", "putchannel", "webManager", "writeManager", "inputField", "OutputChan", "writechannel", " outputConnection", " outputButton", "inputConnection", "outputInstance", "outputButton", "outputManager", "inputChan", "OutputManager", "displayButton", "OutputConnection", "displayChan", "outputField", "OutputChannel", "displaychannel", "outputChan"], "length": ["type", "all", "expected", "json", "value", "text", "ENGTH", "time", "Length", "capacity", "left", "details", "then", "sequence", "library", "base", "limit", "HH", "buffer", "load", "to", "shape", "max", "available", "family", "join", "list", "end", "required", "number", "position", "partial", "l", "data", "len", "history", "offset", "component", "term", "height", "ength", "amount", "present", "full", "padding", "count", "volume", "width", "start", "size", "loop", "needed", "bytes", "duration"], "total": ["all", "translation", "good", "unique", "active", "free", "quant", "unknown", "description", "summary", "sequence", "sum", "raw", "title", "t", "base", "done", "stable", "human", "to", "used", "current", "max", "available", "number", "less", "ta", "required", "successful", "complete", "valid", "meta", "last", "note", "this", "offset", "amount", "otal", "checked", "created", "num", "bar", "full", "local", "info", "count", "scale", "Total", "no", "size", "zero", "index", "eta", "equal", " Total"]}}
{"id1": "8062076", "id2": "12306305", "code1": "    public void updateUser(User portalUserBean, AuthSession authSession) {\n        DatabaseAdapter dbDyn = null;\n        PreparedStatement ps = null;\n        try {\n            dbDyn = DatabaseAdapter.getInstance();\n            String sql = \"update WM_LIST_USER \" + \"set    FIRST_NAME=?,MIDDLE_NAME=?,LAST_NAME=?, \" + \"       ADDRESS=?,TELEPHONE=?,EMAIL=? \" + \"where  ID_USER=? and is_deleted=0 and  ID_FIRM in \";\n            switch(dbDyn.getFamaly()) {\n                case DatabaseManager.MYSQL_FAMALY:\n                    String idList = authSession.getGrantedCompanyId();\n                    sql += \" (\" + idList + \") \";\n                    break;\n                default:\n                    sql += \"(select z1.ID_FIRM from v$_read_list_firm z1 where z1.user_login = ?)\";\n                    break;\n            }\n            ps = dbDyn.prepareStatement(sql);\n            int num = 1;\n            ps.setString(num++, portalUserBean.getFirstName());\n            ps.setString(num++, portalUserBean.getMiddleName());\n            ps.setString(num++, portalUserBean.getLastName());\n            ps.setString(num++, portalUserBean.getAddress());\n            ps.setString(num++, portalUserBean.getPhone());\n            ps.setString(num++, portalUserBean.getEmail());\n            ps.setLong(num++, portalUserBean.getUserId());\n            switch(dbDyn.getFamaly()) {\n                case DatabaseManager.MYSQL_FAMALY:\n                    break;\n                default:\n                    ps.setString(num++, authSession.getUserLogin());\n                    break;\n            }\n            int i1 = ps.executeUpdate();\n            if (log.isDebugEnabled()) log.debug(\"Count of updated record - \" + i1);\n            dbDyn.commit();\n        } catch (Exception e) {\n            try {\n                if (dbDyn != null) {\n                    dbDyn.rollback();\n                }\n            } catch (Exception e001) {\n            }\n            String es = \"Error update of portal user\";\n            log.error(es, e);\n            throw new IllegalStateException(es, e);\n        } finally {\n            DatabaseManager.close(dbDyn, ps);\n            dbDyn = null;\n            ps = null;\n        }\n    }\n", "code2": "    private static void doCopyFile(File srcFile, File destFile, boolean preserveFileDate) throws IOException {\n        if (destFile.exists() && destFile.isDirectory()) {\n            throw new IOException(\"Destination '\" + destFile + \"' exists but is a directory\");\n        }\n        FileChannel input = new FileInputStream(srcFile).getChannel();\n        try {\n            FileChannel output = new FileOutputStream(destFile).getChannel();\n            try {\n                output.transferFrom(input, 0, input.size());\n            } finally {\n                IOUtil.closeQuietly(output);\n            }\n        } finally {\n            IOUtil.closeQuietly(input);\n        }\n        if (srcFile.length() != destFile.length()) {\n            throw new IOException(\"Failed to copy full contents from '\" + srcFile + \"' to '\" + destFile + \"'\");\n        }\n        if (preserveFileDate) {\n            destFile.setLastModified(srcFile.lastModified());\n        }\n    }\n", "label": 0, "substitutes": {"updateUser": ["UpdateAccount", " updateAccount", " updateUsers", "UPDATEUser", "UpdateUser", "UPDATEPerson", "updatePerson", "UpdatePerson", "UpdateUsers", "updateUsers", "updateAccount", "UPDATEAccount", "UPDATEUsers", " updatePerson"], "portalUserBean": ["portalOwnerBelann", "portalUserDean", "portalUserObjectan", "portaluserPebean", "portalClientBeon", "portalUserPebean", "portalUserBroin", "portalUserBroan", "portalPersonProAN", "portalUserBrooon", "portalUserProbean", "portalPersonBeale", "portalUserBelane", "portalUserSoann", "portalUserSoan", "portalUserPeAN", "portalPersonBeann", "portalUserbeann", "portalClientBbean", "portalUserBEAN", "portalPersonPeann", "portalUserBoan", "portalUserPeann", "portalClientBeAN", "portalUserPein", "portalUserRobean", "portalUserBEon", "portalClientBAN", "portalUserbean", "portalUserObjectAN", "portalPersonPeAN", "portalUserRoann", "portalUserBelun", "portalClientRoon", "portalUserBeon", "portalPersonPein", "portalUserPean", "portalPersonBeoon", "portalOwnerBeann", "portalUserProan", "portaluserPeAN", "portaluserPean", "portalUserBeann", "portalUserBEann", "portalFileBeann", "portalUserPeoon", "portalUserBEin", "portalUserBAN", "portalFileBean", "portalUserRoans", "portalFileBelane", "portalUserBEan", "portalPersonProen", "portalUserPeen", "portalUserBeale", "portalOwnerBelan", "portalUserBeun", "portalUserBun", "portalUserBEans", "portalPersonBean", "portalPersonProan", "portalUserProen", "portalUserBann", "portalClientBann", "portalUserSoun", "portalPersonPeale", "portalUserBEoon", "portalUserRoan", "portalFileBelann", "portalUserBein", "portalUserDebean", "portalClientBebean", "portalClientRoAN", "portalPersonBein", "portalClientBeann", "portalUserPeale", "portalUserBbean", "portaluserBebean", "portalClientBean", "portalFileBebean", "portaluserBeAN", "portalPersonProann", "portalUserBoen", "portalPersonPeoon", "portalClientBan", "portalUserBeen", "portalClientRoan", "portalUserBelann", "portalUserBebean", "portaluserBean", "portalFileBelan", "portalPersonPean", "portalUserbebean", "portalOwnerBelun", "portalUserDeann", "portalUserRoane", "portalPersonBeAN", "portalUserProale", "portalUserBoann", "portalUserBans", "portalUserBelan", "portalUserDeAN", "portalUserbeane", "portalPersonBeen", "portalOwnerBean", "portalOwnerBeun", "portalFileBeane", "portalUserBon", "portalUserBeoon", "portalUserBan", "portalUserRoAN", "portalUserBeane", "portalUserBeAN", "portalUserObjectale", "portalFileBelbean", "portalUserRoon", "portalUserBelbean", "portalUserBeans", "portalUserBoAN", "portalUserProann", "portalUserBroann", "portalUserProAN", "portalClientRoans", "portalClientBeans"], "authSession": ["authUser", "aptState", "aptSite", "uthUser", "authsession", "AuthSession", "selectClient", "Authsession", "uthSession", "authClient", "authorClient", "aptSession", "AuthUser", "authorState", "selectSite", "uthsession", "authSite", "authState", " authUser", "authorSite", "aptClient", "authorSession", " authsession", "selectState", "selectSession"], "dbDyn": ["datCYN", "dbDoynam", "dbSys", " dbDync", "dbDoys", "dbDyl", "dbDbyp", "dbDoily", "dbCreateyn", "dbCreateily", "dbFyp", "dbNync", "webDsyn", " dbDyp", "DbDoy", "dbFYN", " dbDoont", "dbDys", "dbFyd", "dbDoy", "dlCreateily", " dbDoyn", "dbBindyn", "dbDuYN", "datCyp", "datDys", "dbCont", "dbDuyn", "dbDoyn", "dbCreateynam", "datDYN", "dbdync", "dbFys", "dbDont", "dbDeyn", "dbSynam", "dbDoyd", "dbFyn", "dbDsys", "dbCYN", "dbDbys", "dbDyd", "dlDily", "datCys", "dbSyn", "dbdyn", "dbBindily", "dbSYN", "dlDyn", "dbDoYN", "dbFy", "DbDoyn", "dbDesyn", "dbCys", "datCyn", "dlDynam", "webDys", "dbSsyn", " dbDsyn", " dbDont", "webDyl", "dbGYN", "dbNyn", "webDsys", "dbDuys", "datDyp", "dbSyd", "dbGyn", "webDsynam", "dbDync", "dbDbYN", " dbDYN", "dbGyp", "dbGys", "dbNy", "webDyn", "dbCyp", "webDynam", " dbDoys", "DbDoYN", "DbDyd", "dbDyp", "DbDyn", "dbSyl", "dbDYN", "DbDYN", "datDyn", "dbDsyn", " dbDy", "dbDily", "dbdys", "dbSy", " dbDoYN", "DbDy", "dbDuont", "dlCreateynam", "dbNys", "webDsyl", "dbDsynam", "dlCreateyn", "dbCyn", "dbDeYN", "dbDynam", "dbdy", "dbDbyn", "dbDsyl", "DbDoyd", "dbDoyl", "dbBindynam", " dbDys", "dbDoont", "dbDoyp", "dbDy"], "ps": ["amps", "pa", "ups", "pd", "PS", "tp", "ress", "gres", "res", "ples", "sp", "params", "pse", "js", "Ps", "op", "pp", "ws", "fs", "itions", "fp", "bs", "qs", "pl", "stats", "mp", "pes", "ts", "aps", "its", "ptr", "ips", "fps", "ats", "pt", "rs", "pps", "pos", "ys", "eps", "ops", "ds", "points", "sol", "gs", "pres", "pers", "css", "s", "ims", "ports", "ip", "als", "jp", "vs", "sts", "wp", "posts", "ils", "ks", "pr", "p", "pe", "ies", "cs"], "sql": ["csv", "series", "ss", "sb", "dl", "sp", "serial", "wal", "js", "details", "sal", "ln", "ws", "sys", "qs", "status", "ls", "ll", "sq", "template", "spec", "log", "sl", "stats", "join", "rel", "xml", "sv", "url", "statement", "ql", "eps", "query", "SQL", "nl", "sol", "seed", "s", "sn", "inv", "ssl", "pel", "string", "socket", "spr", "repl", "fn", "scl", "shell", "plan", "pr", "print", "prefix", "expression"], "idList": [" idLIST", "idL", "idLIST", "idsLIST", "idlist", "infoList", " idL", "idslist", "uidLIST", "uidList", "infoL", "infoLIST", "IdList", "IdLIST", "idsL", " idlist", "infolist", "uidlist", "Idlist", "idsList"], "num": ["coord", "nm", "dec", "um", "con", "orig", "prim", "draw", "nn", "nam", "sum", "conv", "fac", "mem", "gre", "done", "tu", "mon", "multi", "cu", "hum", "un", "number", "NUM", "dim", "nb", "mat", "node", "non", "nu", "hom", "alph", "proc", "snap", "note", "cal", "np", "mult", "dat", "nom", "den", "tim", "mn", "desc", "eng", "ret", "begin", "umber", "no", "zero", "index", "unit", "Num"], "i1": [" i0", "I61", "li1", "pi1", "i61", "i0", "I0", "li2", " i2", "li61", "i2", "pi61", "pi2", "I2", "pi0", "li0", " i61", "I1"]}}
{"id1": "8216539", "id2": "21827619", "code1": "    protected String getFileContentAsString(String filePath, String encoding) throws IOException {\n        URL testURL = Thread.currentThread().getContextClassLoader().getResource(filePath);\n        InputStream input = null;\n        StringWriter sw = new StringWriter();\n        try {\n            if (testURL != null) {\n                input = testURL.openStream();\n            } else {\n                input = new FileInputStream(filePath);\n            }\n            IOUtils.copy(input, sw, encoding);\n        } finally {\n            if (input != null) {\n                input.close();\n            }\n        }\n        return sw.toString();\n    }\n", "code2": "    public static String SHA1(String text) throws NoSuchAlgorithmException, UnsupportedEncodingException {\n        MessageDigest md;\n        md = MessageDigest.getInstance(\"SHA-1\");\n        byte[] sha1hash = new byte[40];\n        md.update(text.getBytes(\"iso-8859-1\"), 0, text.length());\n        sha1hash = md.digest();\n        return convertToHex(sha1hash);\n    }\n", "label": 0, "substitutes": {"getFileContentAsString": ["getFileContentasString", "getFileTextAsStr", "getFileContentAsStr", "getFileContentAsText", "getFileTextAsString", "getFileContentasText", "getFileTextAsText", "getFileContentasStr"], "filePath": ["ilePath", "entryPath", "ileDef", "fileInfo", "FileName", "baseName", "FILEName", "Filepath", "FileString", " fileString", " fileName", "FilePATH", "fileDef", " fileDef", "entrypath", "filePATH", "FILEpath", "entryPATH", "entryName", "FILEPATH", "basepath", "baseString", "FileDef", "FileInfo", "fileName", "ileName", "filepath", "FilePath", "basePath", "FILEPath", "ileInfo", " fileInfo", "fileString", " filepath"], "encoding": ["enoding", "unicuing", "ENCordering", "Encuing", "unicoding", "encode", "Encordering", "characterordering", "unicaching", "enaching", "Encaching", "ENCoding", "Encging", "enode", "encuing", "encordering", "Encoding", "characterging", "unicode", "Encode", "characteroding", "enuing", "characteraching", "ENCging", "encging", "encaching", "ENCaching"], "testURL": ["testingRE", "testedUR", "testingUR", "testRE", " testUrl", "testSR", "testedUrl", " testUR", "testUrl", "testingURL", "TestSR", "checkSR", "testedURL", "checkURL", "TestUrl", "TestUR", " testSR", "testedRE", "TestURL", "testUR", "testingUrl", "checkUrl", "testingSR", "checkUR", " testRE"], "input": ["active", "output", "sample", "tmp", "accept", "inner", "q", "up", "hidden", "get", "iter", "it", "form", "ip", "channel", "config", "start", "quit", "from", "address", "cont", "reader", "cur", "list", "act", "has", "upload", "batch", "lat", "exec", "file", "submit", "PUT", "quick", "hello", "comment", "view", "raw", "stream", "feed", "in", "open", "Input", "missing", "xml", "read", "url", "unsigned", "pull", "acl", "data", "empty", "image", "json", "op", "client", "context", "init", "exist", "command", "current", "audio", "focus", "eval", "add", "iterator", "source", "can", "qa"], "sw": ["wr", "ows", "sb", "sm", "su", "Sw", "sp", "sur", "ow", "enc", "ws", "wa", "wl", "sa", " Sw", "hw", "ews", "sl", "we", "iw", "sk", "sv", "sh", "wra", "fw", "sf", "igm", "was", "wn", "sc", "ew", "aw", "sn", "SW", "kw", "wo", "nw", "tw", "wh", "sem", "rew", "w"]}}
{"id1": "19738435", "id2": "23677142", "code1": "    public Resource parse(URL url, IRDFContainer target) throws RDFException, IOException {\n        parseURL = url;\n        URLConnection connection = url.openConnection();\n        if (charset == null) {\n            charset = Charset.forName(\"UTF-8\");\n        }\n        Reader reader = new InputStreamReader(connection.getInputStream(), charset);\n        return internalParse(reader, target);\n    }\n", "code2": "\tpublic static void BubbleSortShort2(short[] num) {\n\t\tint last_exchange;\n\t\tint right_border = num.length - 1;\n\t\tdo {\n\t\t\tlast_exchange = 0;\n\t\t\tfor (int j = 0; j < num.length - 1; j++) {\n\t\t\t\tif (num[j] > num[j + 1])\n\t\t\t\t{\n\t\t\t\t\tshort temp = num[j];\n\t\t\t\t\tnum[j] = num[j + 1];\n\t\t\t\t\tnum[j + 1] = temp;\n\t\t\t\t\tlast_exchange = j;\n\t\t\t\t}\n\t\t\t}\n\t\t\tright_border = last_exchange;\n\t\t} while (right_border > 0);\n\t}\n", "label": 0, "substitutes": {"parse": ["transform", "handle", "json", "process", "pair", "match", "layer", "parser", "service", "request", "resource", "se", "create", "link", "build", "replace", "shape", "document", "load", "slice", "xml", "format", "read", "arse", "proc", "construct", "file"], "url": ["browser", "gl", "address", "u", "ref", "dl", "util", "parser", "resource", "client", "https", "page", "web", "ls", "ll", "base", "char", "link", "build", "q", "sl", "open", "document", "impl", "xml", "ur", "mount", "uri", "URL", "name", "str", "localhost", "l", "input", "sql", "nl", "path", "conn", "term", "github", "el", "ssl", "http", "location", "string", "file", "loc", "Url", "id", "host", "abs"], "target": ["type", "report", "nt", "layout", "output", "resource", "other", "table", "context", "t", "template", "graph", "scope", "to", "result", "node", "owner", "Target", "name", "top", "container", "tree", "parent", "metadata", "project", "object", "path", "component", "term", "group", "record", "instance", "collection", "model", "pattern", "local", "source", "root", "arget"], "parseURL": ["buildURL", "arsePage", "buildSR", "parseUrl", "parsePage", " parsePage", "parseSR", " parseUrl", "buildUrl", " parseSR", "arseURL", "arseUrl", "buildPage", "arseSR"], "connection": ["ion", "generation", "response", "creator", "con", "connected", "entry", "character", "resource", "application", "description", "client", "context", "directory", "link", "command", "c", "open", "document", "result", "uri", "condition", "position", "writer", "Connection", "cone", "conn", "created", "network", "connect", "channel", "database", "nc", "relation", "socket", "still", "communication", "session", "established"], "charset": ["CHARSets", "cheresect", "cheresets", "CHarset", "chaset", "chactersET", "chresset", "chatsets", "chagnET", "chactersat", "chactersets", "chARSat", "chatset", "chatsset", "CHarsetter", "chagnet", "chararsheet", "chasheet", "chereset", "CHarsets", "chARSetter", "CHARSat", "chearset", "chactersect", "charasset", "chactersetter", "chresect", "chagnheet", "chearsets", "chatsect", "chacterset", "chasset", "CHarsat", "chagnset", "charsetter", "chactersheet", "chararset", "charasheet", "chresets", "charsect", "chearsect", "chactersset", "chararsset", "chasET", "charsET", "CHARSetter", "charsheet", "charsat", "chreset", "charaset", "CHARSet", "charsset", "cheresset", "charsets", "charasET", "chARSets", "chearsset", "chARSet", "chararsET"], "reader": ["runner", "event", "rar", "entry", "layer", "parser", "driver", "resource", "builder", "client", "processor", "stream", "context", "inner", "Reader", "red", "buffer", "readable", "document", "message", "read", "uri", "writer", "input", "iter", "upper", "handler", "iterator", "r", "row", "ner", "io", "file", "reading", "source", "loader", "data"]}}
{"id1": "2668853", "id2": "19096138", "code1": "    public static boolean decodeFileToFile(final String infile, final String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.DECODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            final byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (final java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (final Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (final Exception exc) {\n            }\n        }\n        return success;\n    }\n", "code2": "    public static void main(String[] args) {\n        String logFileName = args[0];\n        int extractLineEvery = new Integer(args[1]).intValue();\n        String filterToken = \"P0\";\n        if (args.length > 2) {\n            filterToken = args[2];\n        }\n        try {\n            BufferedReader br = new BufferedReader(new FileReader(logFileName));\n            BufferedWriter bw = new BufferedWriter(new FileWriter(new File(logFileName + \".trim\")));\n            String readLine;\n            int x = 0;\n            while ((readLine = br.readLine()) != null) {\n                if ((x++ % extractLineEvery == 0) && readLine.startsWith(filterToken)) {\n                    bw.write(readLine + \"\\n\");\n                }\n            }\n            bw.flush();\n            bw.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n", "label": 1, "substitutes": {"decodeFileToFile": ["decodeFileToPage", "decodeFilesToFiles", "decodeFile2Page", "decodeFile2File", "decodeFilesToFile", "decodeFilesToPage", "decodeFilesToString", "decodeFiles2String", "decodeFiles2Files", "decodeFileAsPage", "decodeFiles2Page", "decodeFileTOFiles", "decodeFile2Files", "decodeFileTOFile", "decodeFileAsFiles", "decodeFiles2File", "decodeFileTOString", "decodeFileToFiles", "decodeFileTOPage", "decodeFileAsFile", "decodeFile2String", "decodeFileAsString", "decodeFileToString"], "infile": ["inputfilename", "outbase", "inputFile", "outFile", "innwhere", "innfile", "inwhere", "inpath", " inbase", " infilename", "inbase", "InFile", "innbase", "infilename", "inputbase", "inFile", " inwhere", "innfilename", "inputfile", "Inbase", "inputpath", "inputwhere", "Inpath", "outpath", "Infile"], "outfile": ["outfp", "Outfilename", "outFile", "tofilename", "listfilename", "inpath", "outfilename", "listfile", " outfilename", "Outfile", "OutFile", "tofp", "infilename", "listFile", "inFile", "infp", " outpath", "toFile", " outFile", "listfp", "tofile", "outpath", "Outpath"], "in": ["rin", "en", "image", "inn", "ini", "by", "gin", "con", "IN", "ins", "pin", "im", "on", "oin", "ro", "al", "In", "init", "inner", "inside", "ai", "re", "i", "bin", "get", "inc", "input", "amin", "iter", "it", "per", " din", "form", "conn", "ain", "ind", "o", "nin", "info", "n", "io", "din", "inf", "is", "isin", "source", "cin", "user", "from"], "out": ["ion", "co", "en", "nt", "flush", "con", "output", "res", "oss", "cn", "ln", "on", "sys", "w", "t", "inner", "net", "write", "print", "b", "to", "end", "opt", "writer", "os", "outer", "ent", "it", "OU", "gt", "ou", "at", "aos", "g", "o", "outs", "ex", "n", "io", "Out", "file", "fn", "OUT", "can", "ne", "ot"], "buffer": ["phrase", "buf", "window", "bone", "block", "buff", "sample", "column", "frame", "comment", "view", "sequence", "append", "table", "pad", "mem", "base", "template", "command", "attribute", "document", "message", "available", "stack", "number", "cache", "Buffer", "variable", "black", "total", "initial", "tree", "note", "history", "paste", "queue", "length", "binary", "batch", "bar", "padding", "info", "row", "display", "temp", "password", "memory", "zero", "header"], "read": ["first", "each", "text", "find", "select", "shift", "reader", "wait", "raw", "stream", "set", "run", "before", "range", "q", "write", "open", "push", "readable", "load", "end", "print", "reads", "hold", "seek", "close", "i", "skip", "get", " Read", "give", "need", "input", "iter", "through", "query", "len", "length", "Read", "add", "connect", "count", "ready", "start", "size", "reading", "send", "check", "index", "READ", "data", "pe", "ok"], "success": ["first", "same", "good", "response", " succeed", "ceed", " succ", "cess", "city", "release", "cont", "green", " successful", "summary", "please", "status", " Success", "accept", "Success", "danger", "exist", "ratulations", "done", "ccess", "growth", "warning", "master", "primary", "result", " successfully", "close", "safe", " okay", "second", "unity", "crit", "successful", " failure", "sufficient", "error", "complete", "valid", "top", " succeeds", "snap", "democracy", "commit", "security", "continue", " convergence", "photo", "surv", "successfully", "town", "submit", " succeeded", "support", " successes", "setup", "ok"]}}
{"id1": "5237257", "id2": "20100809", "code1": "    private void download(String fileName) {\n        String filePath = Activator.showSaveDialog(fileName, new String[] { \".xls\" });\n        if (filePath != null) {\n            InputStream in = null;\n            OutputStream out = null;\n            try {\n                in = this.getClass().getResourceAsStream(\"/\" + fileName);\n                out = new FileOutputStream(filePath);\n                IOUtils.copy(in, out);\n            } catch (IOException ioe) {\n                Activator.showExceptionDialog(ioe);\n            } finally {\n                if (in != null) {\n                    try {\n                        in.close();\n                    } catch (IOException e1) {\n                        Activator.showExceptionDialog(e1);\n                    }\n                }\n                if (out != null) {\n                    try {\n                        out.close();\n                    } catch (IOException e1) {\n                        Activator.showExceptionDialog(e1);\n                    }\n                }\n            }\n        }\n    }\n", "code2": "    public static void copy(File srcPath, File dstPath) throws IOException {\n        if (srcPath.isDirectory()) {\n            if (!dstPath.exists()) {\n                boolean result = dstPath.mkdir();\n                if (!result) throw new IOException(\"Unable to create directoy: \" + dstPath);\n            }\n            String[] files = srcPath.list();\n            for (String file : files) {\n                copy(new File(srcPath, file), new File(dstPath, file));\n            }\n        } else {\n            if (srcPath.exists()) {\n                FileChannel in = null;\n                FileChannel out = null;\n                try {\n                    in = new FileInputStream(srcPath).getChannel();\n                    out = new FileOutputStream(dstPath).getChannel();\n                    long size = in.size();\n                    MappedByteBuffer buf = in.map(FileChannel.MapMode.READ_ONLY, 0, size);\n                    out.write(buf);\n                } finally {\n                    if (in != null) in.close();\n                    if (out != null) out.close();\n                }\n            }\n        }\n    }\n", "label": 1, "substitutes": {"download": ["Download", "export", " dump", " Download", " retrieve", " recover", " downloading", " browse", " downloads", "init", "write", "open", " restore", "load", " downloaded", " seek", " upload", " checkpoint", "copy", "get", "upload", " zip", "dump", "paste", "save", " drop", "file", "delete"], "fileName": [" filename", "FILEFilename", "FileType", "FileName", " fileFilename", "projectPath", "FILEName", "projectname", "imageName", "fileType", "fileFilename", " fileTime", "filename", "resourceTime", "FileTime", "fileTime", "FILEname", "resourceName", "resourceType", "FilePath", "projectFilename", "FILEPath", "projectName", " fileType", "resourcePath", "imagePath"], "filePath": ["ilePath", "resourceUrl", " fileId", "FILEUrl", "FileName", "FILEStart", " fileUrl", "fileUrl", "FILEName", "ileP", "ileStart", "resourcepath", "FileP", "languageName", "FILEpath", "languagePath", "languageId", "fileId", "FileStart", "resourceName", "fileStart", "FileId", "ileName", "filepath", "FilePath", "FILEPath", "FILEP", "resourcePath", " filepath", "fileP"], "in": ["f", "mi", "co", "rin", "en", "win", "inn", "ini", "gin", "con", "ie", "IN", "ins", "im", "ar", "m", "on", "ln", "al", "In", "init", "inner", "inside", "one", "net", "ai", "re", "up", "i", "read", "bin", "pi", "inc", "l", "input", "or", "sin", "iter", "it", "login", "st", "ain", "ind", "o", "nin", "r", "el", "local", "n", "io", "din", "inf", "is", "isin", "cin", "id", "from"], "out": ["ion", "co", "na", "nt", "con", "output", "cos", "oss", "cn", "op", "obj", "client", "on", "sys", "w", "conv", "t", "ns", "po", "not", "inner", "net", "we", "write", "to", "end", "up", "v", "i", "name", "os", "outer", "or", "ent", "it", "ch", "OU", "gt", "note", "conn", "null", "ou", "at", "aos", "outs", "o", "nin", "boot", "n", "io", "no", "Out", "file", "OUT", "user", "p", "can", "ne", "ex"]}}
{"id1": "15896098", "id2": "22479286", "code1": "    public String getSHA256Checksum(String source) {\n        String checksum = \"\";\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"SHA-256\");\n            md.update(source.getBytes());\n            byte[] byteData = md.digest();\n            StringBuffer sb = new StringBuffer();\n            for (int i = 0; i < byteData.length; i++) {\n                sb.append(Integer.toString((byteData[i] & 0xff) + 0x100, 16).substring(1));\n            }\n            System.out.println(\"Hex format : \" + sb.toString());\n            StringBuffer hexString = new StringBuffer();\n            for (int i = 0; i < byteData.length; i++) {\n                String hex = Integer.toHexString(0xff & byteData[i]);\n                if (hex.length() == 1) {\n                    hexString.append('0');\n                }\n                hexString.append(hex);\n            }\n            checksum = hexString.toString();\n        } catch (NoSuchAlgorithmException ex) {\n            Logger.getLogger(CMessageDigestFile.class.getName()).log(Level.SEVERE, null, ex);\n        }\n        return checksum;\n    }\n", "code2": "    public String md5(String plainText) throws NoSuchAlgorithmException {\n        MessageDigest md = MessageDigest.getInstance(\"MD5\");\n        md.update(plainText.getBytes());\n        byte[] digest = md.digest();\n        StringBuffer hexString = new StringBuffer();\n        for (int i = 0; i < digest.length; i++) {\n            plainText = Integer.toHexString(0xFF & digest[i]);\n            if (plainText.length() < 2) {\n                plainText = \"0\" + plainText;\n            }\n            hexString.append(plainText);\n        }\n        return hexString.toString();\n    }\n", "label": 1, "substitutes": {"getSHA256Checksum": ["getSHA256Checkchecksums", "getSHA256Checksums", "getSHA256Checkchecksume", "getSHA256Checkam", "getSHA256Checkume", "getSHA256Checkchecksum", "getSHA256Checkum", "getSHA256Checsums", "getSHA256Chechecksume", "getSHA256Checkcksum", "getSHA256Checksam", "getSHA256Checsum", "getSHA256Checsume", "getSHA256Chechecksum", "getSHA256Checkums", "getSHA256Chechecksam", "getSHA256Checkcksume", "getSHA256Checkcksam", "getSHA256Checkcksums", "getSHA256Checksume", "getSHA256Chechecksums", "getSHA256Checkchecksam", "getSHA256Checsam"], "source": ["style", "image", "value", "text", "subject", "output", "sample", "sequence", "secret", "raw", "status", "reason", "context", "in", "base", "template", "buffer", "message", "src", "filename", "content", "Source", "format", "url", "name", "target", "SOURCE", "input", "out", "this", "seed", "ource", "path", "s", "string", "file", "body", "from", "data"], "checksum": ["csum", " checksume", " checksums", " checkssum", " checksim", "checkssum", "cksumb", "cksume", "checkums", "ckssum", "checkim", "csim", "checksume", "checksim", "checkume", "cksum", "checkum", "cssum", " checksumb", "checksums", "cksim", "checksumb", "cksums", "checkumb", "csume"], "md": [" Md", " MD", "nt", "sm", "pd", "ms", "od", "di", "d", "Cmd", "der", "mt", "m", "mo", "mod", "mg", "red", "mp", "dr", "wd", "det", "dm", "sd", "def", "down", "dd", "cmd", "mand", "cd", "mb", "hd", "MD", "ind", "ad", "grad", "mn", "mc", "mm", "pm", "mk", "ld", "pdf", "bd", "df", "dh"], "byteData": ["bytesData", "bytesArray", "phraseData", "byteDat", " byteDat", "reverseCount", "ByteBytes", "sliceData", "byteArray", "channelData", "bleRel", "ioDATA", "byteBytes", "ByteParts", "phraseDATA", "phraseBytes", " byteDATA", "bledata", " byteRel", "routeData", "byteList", "ByteData", "ioDat", "bytesDATA", "bleParts", "ByteDATA", "byteDATA", "reverseData", "bytesBytes", "sliceList", "channeldata", "routeDat", "bytedata", "wordBytes", "ioList", "wordData", "bleData", "channelRel", " byteCount", " byteArray", "byteCount", "byteRel", " byteList", "wordDATA", "routeDATA", "channelParts", "reverseDat", "reverseDATA", " byteParts", "phraseParts", " byteBytes", "byteParts", "sliceDat", " bytedata", "sliceDATA", "wordArray", "ioData", "routeCount"], "sb": ["bt", "pb", "sm", "bf", "bg", "sp", "cb", "ob", "zb", "lb", "obb", "bh", "bps", "bs", "sbm", "bsp", "wb", "sa", "sq", "sg", "b", "bb", "db", "bj", "SB", "nb", "sv", "kb", "sh", "rb", "sf", "ub", "bash", "eb", "sw", "SF", "si", "lp", "mb", "bis", "ssl", "erb", "sam", "xb", "shell", "gb", "ib"], "i": ["y", "I", "di", "ri", "ei", "ti", "me", "q", "err", "ic", "to", "sim", "gi", "pi", "it", "\u0438", "ims", "ip", "info", "io", "er", "oi", "loop", "series", "iy", "ini", "iq", "hi", "cli", "ci", "list", "uri", "xi", "history", "si", "g", "ind", "ity", "id", "ix", "gu", "ion", "major", "u", "j", "im", "iu", "chain", "bi", "multi", "ui", "life", "my", "point", "o", "phi", "ime", "mi", "json", "ms", "ski", "ie", "qi", "m", "ki", "client", "set", "init", "ai", "ij", "l", "ji", "this", "li", "any", "remote", "ii", "print"], "hexString": ["shortBuffer", " hexBuffer", "fullString", "hexStore", "htmlBuffer", "shortArray", "exStore", " HexString", "exstring", "hexBuffer", "fullBuffer", " Hexstring", "fullStore", "hashArray", "htmlstring", " hexstring", "htmlString", "shortResource", "exBuffer", "hashString", " hexArray", " HexResource", "exArray", "hashBuffer", "hexArray", "fullstring", " HexBuffer", "shortString", "exString", " hexStore", "hexstring", "hashstring", "shortstring", " hexResource", "hexResource", "htmlArray"], "hex": ["exp", "pex", "php", "hl", "oct", "solid", "json", "prop", " Hex", "cat", "tx", "alias", "hello", "h", "cont", "raw", "x", "flash", "sex", "zh", " ex", "lit", "tex", "ph", "com", "ext", "none", "sh", "def", "des", "alph", "dump", "comp", "form", "term", "mix", "rendered", " sex", "rex", "full", "html", "temp", "rh", "he", "ex"]}}
{"id1": "22264586", "id2": "16719805", "code1": "    private static void copyFiles(String strPath, String dstPath) throws Exception {\n        File src = new File(strPath);\n        File dest = new File(dstPath);\n        if (src.isDirectory()) {\n            dest.mkdirs();\n            String list[] = src.list();\n            for (int i = 0; i < list.length; i++) {\n                String dest1 = dest.getAbsolutePath() + \"\\\\\" + list[i];\n                String src1 = src.getAbsolutePath() + \"\\\\\" + list[i];\n                copyFiles(src1, dest1);\n            }\n        } else {\n            FileChannel sourceChannel = new FileInputStream(src).getChannel();\n            FileChannel targetChannel = new FileOutputStream(dest).getChannel();\n            sourceChannel.transferTo(0, sourceChannel.size(), targetChannel);\n            sourceChannel.close();\n            targetChannel.close();\n        }\n    }\n", "code2": "    public static void copyFile(File from, File to) throws IOException {\n        if (from.isDirectory()) {\n            if (!to.exists()) {\n                to.mkdir();\n            }\n            File[] children = from.listFiles();\n            for (int i = 0; i < children.length; i++) {\n                if (children[i].getName().equals(\".\") || children[i].getName().equals(\"..\")) {\n                    continue;\n                }\n                if (children[i].isDirectory()) {\n                    File f = new File(to, children[i].getName());\n                    copyFile(children[i], f);\n                } else {\n                    copyFile(children[i], to);\n                }\n            }\n        } else if (from.isFile() && (to.isDirectory() || to.isFile())) {\n            if (to.isDirectory()) {\n                to = new File(to, from.getName());\n            }\n            FileInputStream in = new FileInputStream(from);\n            FileOutputStream out = new FileOutputStream(to);\n            byte[] buf = new byte[32678];\n            int read;\n            while ((read = in.read(buf)) > -1) {\n                out.write(buf, 0, read);\n            }\n            closeStream(in);\n            closeStream(out);\n        }\n    }\n", "label": 1, "substitutes": {"copyFiles": ["copyBlocks", "transferfiles", " copyChildren", "copyItems", "cpFiles", "CopyBlocks", "CopyFile", "transferFiles", " copyfiles", " copyItems", "transferItems", "copyfiles", "cpBlocks", "Copyfiles", "copItems", "cpFile", "copChildren", "CopyFiles", "copyFile", " copyBlocks", "cpfiles", "copfiles", "copFiles", "copyChildren", " copyFile", "transferChildren"], "strPath": ["StrPort", "brPort", " strCh", "StrName", "srcPath", "STRFile", "strPort", "strWhere", "StrWhere", "srcPort", "STRWhere", "strpath", "STRPath", "srcpath", "brName", "StrCh", "strName", "strFile", " strFile", "StrFile", "brpath", "strCh", "StrPath", " strWhere", "srcName", "STRCh", "brPath", "Strpath"], "dstPath": ["dstFile", " dstDirectory", "dptName", "ddestpath", " dndDir", "sdstPath", "ddestPath", "dndFile", "dstpath", "ddestName", "dndpath", "dptpath", "ddestDirectory", "sdstpath", "dstDirectory", " dstDir", " dndDirectory", "sddestName", "dckFile", "dndDirectory", "dstName", "sdstUrl", "dstDir", "dptUrl", "sddestpath", "dckDirectory", "ddestFile", "sdstName", " dndFile", "sddestUrl", "dndUrl", "dndName", "dndDir", " dndPath", " dstFile", "dckDir", "ddestUrl", "dptPath", "sddestPath", "dckPath", "ddestDir", "dstUrl", "dndPath"], "src": ["ser", "attr", "rc", "via", "txt", "usr", "sb", "stock", "img", "rt", "func", "sit", "sp", "ins", "cont", "se", "sys", "raw", "conv", "sq", "rest", "sl", "pkg", "ctr", "cur", "sr", "rel", "Source", "req", "sec", "rs", "sf", "str", "sel", "input", "SOURCE", "sin", "rl", "rb", "comp", "sc", "rx", "st", "ctrl", "sn", "iv", "ind", "syn", "ssl", "desc", "http", "sub", "start", "source", "loc", "ipl", "inst", "sing", "abs"], "dest": ["origin", "decl", "txt", "good", "usr", "comb", "that", "cat", "pub", "vol", "output", "pas", "them", "orig", "func", "d", "mt", "tom", "obj", "trans", "doc", "https", "est", "tmp", "port", "rest", "del", "pl", "to", "master", "result", "opt", " dst", "def", "sup", "target", "out", "des", "st", "priv", "dat", "dir", "desc", "self", "Dest", "dist", "temp", "mk", "source", "loc", "deg", "dc", "end"], "list": ["all", "LIST", "block", "ist", "dl", "test", "part", "word", "remove", "sequence", "set", "stream", "ls", "table", "status", "tag", "names", "feat", "flat", "directory", "level", "spec", "range", "chain", "label", "load", "listed", "array", "v", "detail", "number", "format", "def", "name", "lists", "copy", "get", "str", "top", "l", "stat", "tree", "li", "form", "show", "path", "dir", "pre", "batch", "filter", "add", "info", "n", "count", "string", "key", "id", "html", "source", "diff", "index", "sort", "arr", "print", "delete", "alist"], "i": ["exp", "mi", "major", "span", "json", "u", "j", "ms", "us", "y", "ski", "I", "ie", "qi", "di", "im", "ri", "ei", "m", "set", "conv", "init", "x", "in", "hi", "me", "ti", "inner", "c", "bi", "ic", "multi", "ci", "ai", "sim", "gi", "ui", "v", "uri", "pi", "ix", "ji", "it", "li", "my", "ims", "point", "si", "xi", "batch", "ind", "ip", "info", "key", "io", "gu", "is", "ii", "some", "index", "id", "a", "phi", "ex"], "dest1": ["dest01", " dst3", " dest2", "port01", "srctab", " dest3", "port1", "desttab", "port0", "Dest1", "port2", "Dest2", "src3", "Dest0", "dest2", " dst1", " dest0", " desttab", " dst2", "Dest01", "src2", " dest01", "dest0", "dest3", " dsttab"], "src1": ["rc0", "source0", "rc3", " src0", "source1", "src3", "rc2", "src2", "src0", "rc1", "source3", " src2", " src3", "source2"], "sourceChannel": [" sourceClient", "sourceGate", "srcChan", "fromChan", "sourceCommand", "fromGate", "sourceClient", "sourceConnection", "ourceChannel", "parentButton", "srcConnection", "resourceChannel", "resourceButton", "sourcechannel", "ourceStream", "servicePanel", " sourcechannel", "resourceChan", "ourceChan", "sourceButton", "sourcePanel", "targetchannel", "srcChannel", "ourcechannel", "serviceChannel", "parentPanel", "targetGate", "targetChan", "srcCommand", "fromChannel", "parentChannel", "fromConnection", " sourceStream", "srcClient", "targetStream", "ourceClient", "sourceChan", "ourceCommand", "parentChan", "sourceStream", "srcGate", "serviceChan", " sourceChan", "resourcePanel", " sourceCommand", "targetConnection", "serviceButton"], "targetChannel": ["argetChain", "Targetchannel", "resultConnection", "argetChan", " targetConnection", "TargetChannel", "sourceConnection", "destChan", "resultChan", "destChannel", " targetManager", "destManager", "argetChannel", "sourceChain", "targetChain", "destConsole", " targetchannel", "resultchannel", "targetchannel", " targetChan", " targetChain", "targetChan", "targetManager", "resultConsole", "argetConnection", " targetConsole", "sourceChan", "TargetChan", "TargetConnection", "resultChannel", "resultManager", "targetConnection", "targetConsole"]}}
{"id1": "15799935", "id2": "18489832", "code1": "    public static void saveAttachmentBody(Context context, Part part, Attachment localAttachment, long accountId) throws MessagingException, IOException {\n        if (part.getBody() != null) {\n            long attachmentId = localAttachment.mId;\n            InputStream in = part.getBody().getInputStream();\n            File saveIn = AttachmentProvider.getAttachmentDirectory(context, accountId);\n            if (!saveIn.exists()) {\n                saveIn.mkdirs();\n            }\n            File saveAs = AttachmentProvider.getAttachmentFilename(context, accountId, attachmentId);\n            saveAs.createNewFile();\n            FileOutputStream out = new FileOutputStream(saveAs);\n            long copySize = IOUtils.copy(in, out);\n            in.close();\n            out.close();\n            String contentUriString = AttachmentProvider.getAttachmentUri(accountId, attachmentId).toString();\n            localAttachment.mSize = copySize;\n            localAttachment.mContentUri = contentUriString;\n            ContentValues cv = new ContentValues();\n            cv.put(AttachmentColumns.SIZE, copySize);\n            cv.put(AttachmentColumns.CONTENT_URI, contentUriString);\n            Uri uri = ContentUris.withAppendedId(Attachment.CONTENT_URI, attachmentId);\n            context.getContentResolver().update(uri, cv, null, null);\n        }\n    }\n", "code2": "    private static URL downLoadZippedFile(URL url, File destDir) throws Exception {\n        URLConnection urlConnection = url.openConnection();\n        File tmpFile = null;\n        try {\n            tmpFile = File.createTempFile(\"remoteLib_\", null);\n            InputStream in = null;\n            FileOutputStream out = null;\n            try {\n                in = urlConnection.getInputStream();\n                out = new FileOutputStream(tmpFile);\n                IOUtils.copy(in, out);\n            } finally {\n                if (out != null) {\n                    out.close();\n                }\n                if (in != null) {\n                    in.close();\n                }\n            }\n            unzip(tmpFile, destDir);\n        } finally {\n            if (tmpFile != null) {\n                tmpFile.delete();\n            }\n        }\n        URL localURL = destDir.toURI().toURL();\n        return localURL;\n    }\n", "label": 1, "substitutes": {"saveAttachmentBody": ["saveAttachedFile", "saveExtachedbody", "saveExtachedPart", "saveAttentionPart", "saveAttentionBody", "saveAttentionFile", "saveAttachedPart", "saveAttachedbody", "saveExtachedBody", "saveExtachmentPart", "saveAttachablebody", "saveExtachmentFile", "saveAttachmentbody", "saveAttachableFile", "saveAttachableBody", "saveAttachablePart", "saveExtachmentBody", "saveAttachmentPart", "saveExtachmentbody", "saveAttentionbody", "saveAttachedBody", "saveExtachedFile", "saveAttachmentFile"], "context": ["Context", "response", "subject", "ctx", "center", "tx", "contact", "service", "frame", "request", "application", "view", "client", "environment", "connection", "template", "ce", "chain", "command", "comments", "document", "message", "current", "system", "stack", "content", "background", "cache", "media", "state", "container", "parent", "history", "search", "component", "present", "null", "java", "network", "instance", "foundation", "course", "config", "cf", "support", "version", "translation", "host", "cc"], "part": ["type", "report", "reply", "zone", "pair", "block", "and", "tx", "sample", "piece", "task", "parts", "word", "sp", "se", "trans", "bound", "pod", "tmp", "thread", "work", "base", "connection", "Part", "message", "join", "post", "host", "name", "partial", "top", "PART", "art", "parent", "component", "instance", "add", "job", "temp", "start", "file", "patch", "body", "version", "p", "data", "session"], "localAttachment": ["localDetention", "localAcached", "localAttention", "localAttachention", " localAssachment", "localATTention", "localATTignment", "localAssail", " localAttachignment", "localAssachment", "localAttachail", "localATTment", " localAssached", "localAttignment", " localAttention", " localAttachachment", "localAppached", "localAttment", "localattached", " localAttment", " localAttignment", "localDetail", "localattachment", "localAcachment", " localAssail", " localAttached", " localAssention", "localAssignment", "localAttachignment", " localAttachached", "localDetachment", " localAttachention", "localAttachachment", " localAttail", " localDetached", "localAttached", "localAttail", "localAssention", "localattention", "localAppention", "localAcignment", " localDetignment", "localAssment", "localAcail", "localDetignment", " localDetail", "localAttachached", "localAssached", "localAppachment", "localAppail", "localDetached", " localDetachment", "localATTachment"], "accountId": ["accountAnd", "accountNum", "bankId", " accountNum", "AccountId", "objectName", "accountDb", "objectID", "accDb", "bankID", "amountID", " accountInt", "bankAnd", "amountInt", "accId", " accountName", " accountAnd", "accInt", "AccountName", "AccountById", " accountById", "objectById", "amountId", "containerId", "accountID", "accountInt", "objectId", " accountS", "accNum", "accS", "accID", "accountById", "AccountID", " accountID", "containerID", " accountDb", "bankS", "amountDb", "containerInt", "accountName", "containerNum", "accountS", "accAnd"], "attachmentId": ["attachmentById", "AttociationID", "attmentid", "contachmentSerial", "attionById", "attignmentid", "attachmentid", "attmentId", "AttociationById", "AttachmentId", "assachmentid", "attachmentSerial", "AttociationId", "AttachmentID", "assignmentById", "attionid", "attachmentID", "attociationId", "attacheById", "assignmentid", "assignmentID", "attacheId", "assignmentId", "attociationSerial", "attachedById", "attignmentId", "assachmentID", "attmentID", "attociationById", "assachmentId", "attacheID", "contachedSerial", "assachmentById", "attociationID", "AttachmentById", "attmentById", "Attociationid", "attachedSerial", "attachedId", "attionSerial", "contachmentId", "attionId", "contachmentById", "contachedById", "attachedID", "attignmentID", "attignmentById", "attacheid", "Attachmentid", "contachedid", "contachmentid", "contachedId", "attachedid", "attociationid"], "in": ["all", "en", "rin", "inn", "con", "gin", "IN", "vin", "ins", "m", "on", "sum", "raw", "al", "In", "init", "inner", "inside", "ai", "up", "conf", "i", "read", "bin", "act", "inc", "l", "input", "iter", "it", "ch", "per", "ind", "r", "mc", "mm", "info", "din", "inf", "is", "isin", "source", "file", "body", "as", "cin", "id", "p", "from", "ex"], "saveIn": ["sendOut", "sendIn", "sendIN", "aveIns", " saveIns", "getIN", "savAs", "secureAs", "storeIn", "storePath", "savIns", "storeOut", "sendPath", "savIn", "saveIns", "secureIns", "aveOut", "aveIN", " saveIN", " savePath", "secureIn", "getOut", "secureIN", "savIN", "saveIN", "storeIN", "getIn", " saveOut", "getIns", "savePath", "aveIn", "saveOut"], "saveAs": [" saveAS", "aveTo", "saveAS", "submitIn", "submitas", "SaveAs", "submitBy", "dumpAn", "aveAs", " saveAn", "saveAn", "dumpAs", "submitAS", "SaveBy", "SaveAS", "aveAS", "saveTo", " saveBy", "saveas", "saveBy", "aveas", "aveAn", "SaveIn", "Saveas", "dumpTo", "submitAs", " saveTo", "aveIn"], "out": ["all", "co", "con", "output", "cos", "res", "oss", "ao", "cn", "obj", "sys", "sum", "conv", "t", "inner", "one", "net", "log", "to", "up", "v", "i", "gc", "name", "serv", "copy", "os", "outer", "ent", "OU", "it", "null", "ou", "outs", "aos", "o", "inv", "auto", "n", "io", "Out", "OUT", "can", "ex"], "copySize": ["copySIZE", "likeSize", "CopySIZE", "msgPercent", "msgLength", "pushLength", "CopyLength", "copyFontSize", "CopyPercent", "copyCount", "CopyCount", "CopySize", "opySize", "likeLength", "copyLength", "pushCount", "pushFontSize", " copyLength", "msgSIZE", "copyPercent", "msgSize", " copyFontSize", "CopyFontSize", "opyLength", "likeCount", "likeFontSize", "pushSize", " copyCount", "opyPercent", "opySIZE"], "contentUriString": ["contentUnristring", "contentUnuriString", "contentUuriString", "contentUriStr", "contentIriString", "contentUuriStr", "contentIiString", "contentIiStr", "contentUniNumber", "contentUniStr", "contentUnistring", "contentIristring", "contentUnuriStr", "contentUriStatic", "contentUiString", "contentIriStr", "contentUrisStr", "contentUiStatic", "contentUnriString", "contentIriStatic", "contentUnriNumber", "contentUicStatic", "contentUicstring", "contentUuriNumber", "contentUicString", "contentUristring", "contentUrisString", "contentUnuriNumber", "contentUniString", "contentUnuristring", "contentUuriStatic", "contentUrisstring", "contentIistring", "contentIiStatic", "contentUistring", "contentUnriStr", "contentUiStr", "contentUuristring", "contentUicStr", "contentUriNumber", "contentUrisNumber"], "mSize": ["lPos", "moBytes", "nBytes", "moSize", "moPos", "nSize", "mPos", "nPos", "mBytes", "lSize", "moLength", "lLength", "nLength", "lBytes", "mLength"], "mContentUri": ["mResourceURI", "mResourceUri", "mContent_RI", "mContentURI", "mResourceIris", "mContent_ris", "mResourceUuid", "mContent_ri", "mResourceUris", "mContentPRI", "mContentIris", "mContent_uid", "mContentPris", "mContentPuid", "mContentIuid", "mResourceIRI", "mResourceIri", "mContentUris", "mContentIRI", "mContentIri", "mContentUuid", "mResourceIuid", "mContentPri"], "cv": ["csv", "buf", "rc", "pb", "um", "cmp", "vol", "uv", "vp", "cb", "cn", "cont", "vt", "av", "conv", "box", "CV", "c", "GV", "fc", "cas", "cu", "lv", "v", "ov", "xc", "cp", "sv", "gc", "act", "ct", "vc", "cm", "const", "vv", "cod", "qv", "ctrl", "mult", "lc", "tc", "ev", "nc", "desc", "qu", "vr", "cap", "cf", "vm", "nv", "dc", "cc"], "uri": ["origin", " Uri", "report", "handle", "address", "u", "subject", "picture", "qi", "ri", "URI", "resource", "directory", "q", "link", "ue", "range", "result", "uni", "ur", "ui", "i", "url", " URI", " ni", "doi", "bid", "iri", "uu", "query", "component", "term", "dir", "uid", "ip", "folder", "unit", "id", "du", "prefix", "phi"]}}
{"id1": "22801734", "id2": "5989666", "code1": "    private static void setup() throws Exception {\n        String path = Webcam.class.getProtectionDomain().getCodeSource().getLocation().getFile();\n        File jarFile = new File(URLDecoder.decode(path, \"UTF-8\") + \"/Hanasu.jar\");\n        if (!jarFile.exists()) jarFile = new File(\"/home/marc/Virtual Machine/Hanasu.jar\");\n        File f = File.createTempFile(\"tempabca\", \"bdfafad\");\n        f.delete();\n        f.mkdir();\n        String parent = f.getAbsolutePath() + \"/\";\n        byte[] buf = new byte[1024];\n        ZipInputStream zipinputstream = null;\n        ZipEntry zipentry;\n        zipinputstream = new ZipInputStream(new FileInputStream(jarFile));\n        zipentry = zipinputstream.getNextEntry();\n        while (zipentry != null) {\n            String entryName = zipentry.getName();\n            if (entryName.startsWith(\"native\")) {\n                int n;\n                FileOutputStream fileoutputstream;\n                File newFile = new File(parent + entryName);\n                if (zipentry.isDirectory()) {\n                    newFile.mkdirs();\n                    zipentry = zipinputstream.getNextEntry();\n                    continue;\n                }\n                fileoutputstream = new FileOutputStream(newFile);\n                while ((n = zipinputstream.read(buf, 0, 1024)) > -1) fileoutputstream.write(buf, 0, n);\n                fileoutputstream.close();\n                zipinputstream.closeEntry();\n            }\n            zipentry = zipinputstream.getNextEntry();\n        }\n        zipinputstream.close();\n        String arch = \"\";\n        boolean x64 = false;\n        for (String key : keys) {\n            String property = System.getProperty(key);\n            if (property != null) {\n                x64 = (property.indexOf(\"64\") >= 0);\n            }\n        }\n        if (JPTrayIcon.isUnix()) {\n            if (x64) arch = \"linux-amd64\"; else arch = \"linux-x86\";\n        }\n        if (JPTrayIcon.isWindows()) {\n            System.out.println(\"Arch: \" + System.getProperty(\"sun.arch.data.model\"));\n            if (x64 && !System.getProperty(\"sun.arch.data.model\").equals(\"32\")) arch = \"win64-amd64\"; else arch = \"win32-x86\";\n        }\n        if (JPTrayIcon.isMac()) arch = \"macosx-universal\";\n        System.out.println(\"Using native/\" + arch + \"/\");\n        addLibraryPath(parent + \"native/\" + arch + \"/\");\n    }\n", "code2": "    private String postXml(String url, String soapAction, String xml) {\n        try {\n            URLConnection conn = new URL(url).openConnection();\n            if (conn instanceof HttpURLConnection) {\n                HttpURLConnection hConn = (HttpURLConnection) conn;\n                hConn.setRequestMethod(\"POST\");\n            }\n            conn.setConnectTimeout(this.connectionTimeout);\n            conn.setReadTimeout(this.connectionTimeout);\n            conn.setRequestProperty(\"Content-Type\", \"text/xml; charset=utf-8\");\n            conn.setRequestProperty(\"Accept\", \"application/soap+xml, text/*\");\n            if (soapAction != null) {\n                conn.setRequestProperty(\"SOAPAction\", soapAction);\n            }\n            conn.setDoOutput(true);\n            OutputStreamWriter out = new OutputStreamWriter(conn.getOutputStream());\n            out.write(xml);\n            out.close();\n            BufferedReader resp = new BufferedReader(new InputStreamReader(conn.getInputStream()));\n            StringBuilder buf = new StringBuilder();\n            String str;\n            while ((str = resp.readLine()) != null) {\n                buf.append(str);\n            }\n            return buf.toString();\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        }\n    }\n", "label": 0, "substitutes": {"setup": ["reset", "sync", "test", "release", "clean", "create", "set", "Setup", "init", "build", "load", "close", "touch", "up", "mount", "upload", "sleep", "login", "construct", "seed", "boot", "connect", " Setup", "ready", "config", "save", "install", "update"], "path": ["ref", "home", "text", "address", "ath", "context", "module", "base", "directory", "template", "c", "pkg", "log", "PATH", "cert", "family", "filename", "mount", "route", "url", "name", "tree", "dir", "Path", "pattern", "full", "local", "location", "string", "relative", "file", "where", "root", "p", "host", "prefix", "title"], "jarFile": ["zipWeb", "javaFile", "jarFolder", "certPath", "certFilename", "sessionfile", "jarWeb", "jarFiles", "magicChain", "zipfile", " jarFilename", "javaPath", " jarChain", "magicfile", "JarFiles", " jarWeb", " jarE", " jarPath", "zipE", "jarPath", "jarE", "sessionResource", "JarFile", "zipFILE", "jarResource", "tarfile", "JarWeb", "magicFile", "Jarfile", "jarfile", "tarE", "sessionFile", "zipFile", "magicResource", "tarFile", "jarChain", "tarFILE", "javaFilename", " jarFILE", " jarfile", "javaFolder", " jarFolder", "certFolder", "jarFILE", "sessionChain", "certFile", " jarFiles", "jarFilename", " jarResource", "zipFiles"], "f": ["fi", "alf", "bf", "y", "d", "af", "h", "part", "fs", "fm", "fp", "fr", "fac", "t", "lf", "c", "b", "fd", "fc", "of", "v", "i", "e", "rf", "tf", "sf", "elf", "l", "out", "life", "ent", "fo", "dir", "o", "full", "fa", "F", "cf", "file", "fn", "ff", "fb", "p", "w"], "parent": ["parents", "pa", "home", "pid", "fp", "tmp", "ppa", "port", "base", "directory", "template", "pkg", "family", "filename", "owner", "name", "child", "localhost", "global", "out", "tree", "dir", "ma", "full", "location", "temp", "relative", "server", "file", "folder", "Parent", "root", "pool", "p", "host", "prefix", "title"], "buf": ["seq", "cv", "br", "buff", "img", "bl", "cb", "ob", "rw", "raw", "bed", "wb", "mem", "buffer", "pkg", "bag", "b", "printf", "result", "boxes", "db", "aka", "Buffer", "uf", "rb", "str", "tab", "blocks", "out", "fun", "data", "cmd", "paste", "obs", "norm", "queue", "mb", "batch", "Buff", "cap", "msg", "temp", "pool", "fb", "vec", "bytes"], "zipinputstream": ["zipfeedStream", "zipopenstream", "zipoutputservice", "zipuploadfield", "zipinnerStream", "zipoutputstream", " zipinputfield", "zipfeedstream", " zipinputStream", "zipuploadStream", "zipoutputrow", "zipInputform", "zipenterStream", "zipuploadreader", " zipoutputengine", "archiveoutputsign", "archiveoutputservice", "zipInputservice", "ZipInputconsole", "zipinputservice", "zipinputreader", "zipcontextreader", "zipinnerform", "zipcontextstyle", "zipoutputconsole", "zipenterconsole", " zipoutputfield", "archiveoutputStream", "zipcontextstream", "zipuploadstyle", "zipoutputsign", "zipinputloop", "zipuploadrow", "archiveinputsign", "zipinputconsole", "Zipinputstream", "zipInputstack", "archiveinputstream", "zipcontrolstream", "zipinputengine", "zipoutputstack", " zipoutputreader", "archiveoutputform", "zipopenservice", "zipoutputreader", " zipoutputStream", "zipopenStream", " zipinputreader", "archiveinputservice", "zipcontrolStream", "zipoutputengine", "ZipInputStream", "Zipinputconsole", " zipoutputstyle", "zipoutputloop", "zipInputrow", " zipoutputloop", "zipoutputform", "zipuploadstream", "zipcontrolstack", "zipinputStream", "zipInputengine", "archiveoutputconsole", "zipInputStream", "zipinputstack", "archiveoutputrow", "zipinputform", "zipoutputStream", "archiveinputform", "archiveoutputstream", "zipoutputstyle", "archiveinputStream", "zipfeedfield", "archiveinputconsole", "zipInputstream", "zipinputstyle", "zipInputsign", " zipinputstyle", "zipinnerstream", "zipoutputfield", "zipcontextloop", "zipinputsign", " zipinputloop", "zipinputfield", "zipInputconsole", "zipinputrow", "zipopensign", "zipenterstream", "archiveinputrow", " zipinputstack", "zipfeedloop", "zipuploadloop", "ZipinputStream", " zipoutputstream", " zipinputengine", "ZipInputstream", "zipcontrolengine", " zipoutputstack"], "zipentry": ["loopentry", "archiveent", "zipelement", "ZipEntry", "zipimage", "zipEntry", "zipfield", "archivecell", "zimage", "archiveconnection", "Zipfield", "zipconnection", "zent", "Zipcell", "newentry", "loopmatch", "zeEntry", " zipse", "Zipentry", "zmatch", "zipmatch", "zecell", "archivematch", "loopconnection", " zipEntry", "loopent", " ziprecord", "zipcell", "Zipapplication", "ziprecord", "zipent", "archivese", "archivesearch", "csvEntry", "zse", "zcell", "zipsearch", "zconnection", "Zipelement", "zipse", " zipcell", " zipconnection", "packcell", "Ziprecord", "csventry", "archiveentry", "csvfield", "zeentry", "zapplication", "Zipcomment", " zipfield", "packEntry", "zipcomment", " zipsearch", "packentry", "zeelement", "newapplication", "zEntry", " zipimage", "Zipimage", "zipapplication", "zentry", "zcomment", "zrecord", "zsearch", "newcomment", "packelement", "newEntry"], "entryName": ["entryKey", "archiveList", " entryname", "connectionFamily", "archiveId", "entryList", "elementId", "connectionNAME", "archivename", "channelname", "membername", "entryNAME", "memberFamily", "validName", "elementList", "memberNAME", "entryId", "elementKey", " entryTitle", "entryname", "connectionname", "entryFamily", "archiveKey", "EntryName", "elementName", "EntryList", "connectionName", "EntryKey", "validname", "channelName", "EntryId", "entryTitle", "validNAME", "memberName", "validFamily", "archiveTitle", "archiveName", "channelTitle"], "n": ["na", "_", "nt", "en", "nm", "j", "z", "N", "nan", "gn", "y", "ng", "d", "cn", "nn", "ln", "m", "ll", "t", "x", " len", "ns", "k", "c", "nor", "v", "i", "number", "none", "name", "nu", "l", "pos", "ni", "len", "np", "nl", "length", "s", "sn", "o", "num", "ren", "nr", "r", "nc", "count", "no", "fn", "an", "p", "ne"], "fileoutputstream": ["Fileinputstream", " fileoutputter", "fileOutputsystem", "fileoutputsystem", "filecutstream", "FileoutputStream", "filecolumntable", "filecontentconsole", "fileobjectstream", "fileinputtable", " fileinputstream", "fileobjectSteam", "fileconnectionStream", " filecolumnwindow", "fileoutStream", "fileconnectionsystem", "fileoutputSteam", " filecolumnstream", "filecolumnStream", "fileoutwindow", "Fileoutputtable", "fileinputview", "fileinputwindow", "fileoutputtable", " fileoutputStream", "filecutter", "fileOutputconsole", " filecolumnStream", "FileoutputSteam", " fileoutputsystem", "filecontentstream", " fileinputter", " fileconnectionsystem", "fileOutputStream", "filecutview", "fileconnectionconsole", " fileoutputwindow", "fileoutview", " fileinputStream", " fileinputview", "fileoutter", "fileoutstream", " fileoutputconsole", "fileoutputter", "filecolumnwindow", "filecontentsystem", "fileobjectStream", "Fileoutputstream", " filecolumntable", " fileconnectionconsole", "fileinputstream", " fileoutputview", "fileinputSteam", "filecutStream", " fileconnectionStream", "filecontentStream", "fileOutputstream", "FileinputStream", "fileoutputview", "filecolumnstream", "fileoutputStream", "fileinputter", "Fileinputtable", "fileoutputwindow", " fileoutputtable", "fileouttable", "fileoutputconsole", "fileobjecttable", "fileinputStream", "fileconnectionstream", "FileinputSteam", " fileconnectionstream"], "newFile": ["newDirectory", "freshfile", "NEWDir", "newFolder", "anotherField", "newfile", "NEWFILE", "anotherFolder", "freshFile", "NEWfile", "bigfile", " newfile", " newField", "freshField", "NEWField", "anotherFile", "NEWFile", "bigFILE", "newDir", "NEWFolder", "anotherfile", "newFILE", "newField", " newDir", "bigFile", "Newfile", "NewDirectory", "bigDirectory", "NewFILE", " newFolder", "NEWDirectory", "freshDir", "NewFile"], "arch": ["type", "Arch", "rar", "archs", "dll", "mask", "war", "rep", "imp", "platform", "ar", " architecture", "cpu", "ppa", "library", "deb", "app", "ARCH", "work", "build", "pkg", "dar", "arm", "system", "dr", "family", "ph", "ext", "program", "brand", "owner", "act", "archive", "os", "race", "hard", "hex", "ch", "comp", "form", "component", "egg", "craft", "ip", "rpm", "arc", "chart", "install", "mac", "version", "chip", "print", "host", "pe"], "key": ["phrase", "pair", "step", "value", "var", "item", "prop", "y", "entry", "ie", "shift", "word", "feature", "option", "air", "ico", "title", "cy", "x", "Key", "char", "code", "k", "attribute", "me", "chain", "link", "ice", "variable", "ace", "name", "child", "important", "val", "row", "index", "id", "print", "prefix", "ame", "KEY"], "property": ["Property", "translation", "event", "style", "address", "prop", "pair", "value", "displayText", "character", "feature", "frame", "resource", "description", "option", "sequence", "category", "char", "label", "attribute", "function", "pro", "properties", "variable", "owner", "state", "position", "ty", "rue", "tie", "complex", "language", "pe", "relation", "info", "string", "field", "class", "store", "print", "power", "expression", "title"], "x64": ["x65", "rx86", "x509", " x48", "xox", " x509", "px65", " x62", "x48", "mx64", "rex509", "px64", "x86", "rx864", "x864", "ox66", "ex62", "px66", "ex509", "rex62", " xox", "ex64", "rex64", " x66", "mxox", "x62", "px48", "rx64", "x32", " x864", "mx86", "rex32", " x65", "rxox", "ox48", "ox64", "ex32", "ox65", "x66", " x86", " x32", "mx864"]}}
{"id1": "2518655", "id2": "16215393", "code1": "    public static void main(String[] args) throws FileNotFoundException {\n        if (args.length < 2) throw new IllegalArgumentException();\n        String fnOut = args[args.length - 1];\n        PrintWriter writer = new PrintWriter(fnOut);\n        for (int i = 0; i < args.length - 1; i++) {\n            File fInput = new File(args[i]);\n            Scanner in = new Scanner(fInput);\n            while (in.hasNext()) {\n                writer.println(in.nextLine());\n            }\n        }\n        writer.close();\n    }\n", "code2": "    public void importSequences() {\n        names = new ArrayList<String>();\n        sequences = new ArrayList<String>();\n        try {\n            InputStream is = urls[urlComboBox.getSelectedIndex()].openStream();\n            ImportHelper helper = new ImportHelper(new InputStreamReader(is));\n            int ch = helper.read();\n            while (ch != '>') {\n                ch = helper.read();\n            }\n            do {\n                String line = helper.readLine();\n                StringTokenizer tokenizer = new StringTokenizer(line, \" \\t\");\n                String name = tokenizer.nextToken();\n                StringBuffer seq = new StringBuffer();\n                helper.readSequence(seq, \">\", Integer.MAX_VALUE, \"-\", \"?\", \"\", null);\n                ch = helper.getLastDelimiter();\n                names.add(name);\n                sequences.add(seq.toString());\n            } while (ch == '>');\n        } catch (MalformedURLException e) {\n            e.printStackTrace();\n        } catch (EOFException e) {\n        } catch (IOException e) {\n        }\n    }\n", "label": 0, "substitutes": {"fnOut": [" fnIn", "synOutput", "fnOr", " fnNet", "pdfIn", "synIn", "fnOs", " fnOutput", "dnOr", "fnNet", "pdfNet", "dnOut", "fnIn", "bfNet", " fnOs", "synOr", "synOut", "bfOut", "dnIn", "fnOutput", "pdfOs", "pdfOut", "dnOutput", "bfIn", " fnOr", "bfOs"], "writer": ["runner", "report", "window", "worker", "creator", "flush", "her", "rator", "Writer", "caster", "and", "writers", "console", "parser", "driver", "service", "comment", "reader", "builder", "client", "wright", "writing", "table", "inner", "maker", "white", "aster", "editor", "write", "buffer", "writ", "master", "journal", "println", "close", "widget", "format", "variable", "external", "operator", "outer", "written", "commit", "walker", "handler", "auto", "width", "fn", "file", "riter", "zero", "send", "loader", "wrapper", "print", "w"], "i": ["mi", "u", "ini", "j", "us", "y", "ski", "I", "ie", "ogi", "qi", "di", "im", "ri", "ei", "m", "ki", "client", "init", "x", "hi", "me", "iu", "q", "ti", "bi", "c", "chain", "ic", "multi", "ci", "ai", "sim", "gi", "ui", "v", "uri", "pi", "ij", "ix", "it", "li", "xi", "ims", "\u0438", "si", "my", "g", "ind", "batch", "ip", "ma", "key", "gu", "is", "ii", "id", "phi"], "fInput": [" fIn", " fNew", "cfNew", "sfIn", "lNew", "fIn", "linput", "cfOutput", " finput", "fileInput", "cfInput", " fOutput", "sfinput", "fileIn", "fileOutput", "finput", "fileinput", "sfInput", "cfinput", "sfOutput", "fNew", "lInput", "lOutput", "fOutput"], "in": ["all", "rin", "en", "inn", "ini", "gin", "con", "IN", "vin", "ins", "pin", "ln", "client", "al", "In", "conv", "t", "inside", "inner", "thin", "re", "kin", "conf", "bin", "serv", "inc", "out", "input", "sin", "or", "it", " din", "again", "ind", "r", "ma", "info", "n", "din", "inf", "is", "isin", "cin", "check"]}}
{"id1": "1421557", "id2": "5414088", "code1": "    public static boolean encodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.ENCODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "code2": "    public static void saveFileData(File file, File destination, java.io.File newDataFile) throws Exception {\n        String fileName = file.getFileName();\n        String assetsPath = FileFactory.getRealAssetsRootPath();\n        new java.io.File(assetsPath).mkdir();\n        java.io.File workingFile = getAssetIOFile(file);\n        DotResourceCache vc = CacheLocator.getVeloctyResourceCache();\n        vc.remove(ResourceManager.RESOURCE_TEMPLATE + workingFile.getPath());\n        if (destination != null && destination.getInode() > 0) {\n            FileInputStream is = new FileInputStream(workingFile);\n            FileChannel channelFrom = is.getChannel();\n            java.io.File newVersionFile = getAssetIOFile(destination);\n            FileChannel channelTo = new FileOutputStream(newVersionFile).getChannel();\n            channelFrom.transferTo(0, channelFrom.size(), channelTo);\n            channelTo.force(false);\n            channelTo.close();\n            channelFrom.close();\n        }\n        if (newDataFile != null) {\n            FileChannel writeCurrentChannel = new FileOutputStream(workingFile).getChannel();\n            writeCurrentChannel.truncate(0);\n            FileChannel fromChannel = new FileInputStream(newDataFile).getChannel();\n            fromChannel.transferTo(0, fromChannel.size(), writeCurrentChannel);\n            writeCurrentChannel.force(false);\n            writeCurrentChannel.close();\n            fromChannel.close();\n            if (UtilMethods.isImage(fileName)) {\n                BufferedImage img = javax.imageio.ImageIO.read(workingFile);\n                int height = img.getHeight();\n                file.setHeight(height);\n                int width = img.getWidth();\n                file.setWidth(width);\n            }\n            String folderPath = workingFile.getParentFile().getAbsolutePath();\n            Identifier identifier = IdentifierCache.getIdentifierFromIdentifierCache(file);\n            java.io.File directory = new java.io.File(folderPath);\n            java.io.File[] files = directory.listFiles((new FileFactory()).new ThumbnailsFileNamesFilter(identifier));\n            for (java.io.File iofile : files) {\n                try {\n                    iofile.delete();\n                } catch (SecurityException e) {\n                    Logger.error(FileFactory.class, \"EditFileAction._saveWorkingFileData(): \" + iofile.getName() + \" cannot be erased. Please check the file permissions.\");\n                } catch (Exception e) {\n                    Logger.error(FileFactory.class, \"EditFileAction._saveWorkingFileData(): \" + e.getMessage());\n                }\n            }\n        }\n    }\n", "label": 1, "substitutes": {"encodeFileToFile": ["encodeStringAsFile", "encodeFileToFiles", "encodeFileToDisk", "encodeFileAsFile", "encodeStringToFile", "encodeFileToStream", "encodeFileFromFiles", "encodeStringAsDisk", "encodeStringAsStream", "encodeFiletoFile", "encodeFileAsStream", "encodeStringToDisk", "encodeFileAsDisk", "encodeFiletoDisk", "encodeFiletoFiles", "encodeStringToFiles", "encodeFileFromStream", "encodeFileAsFiles", "encodeFileFromDisk", "encodeStringAsFiles", "encodeFiletoStream", "encodeFileFromFile", "encodeStringToStream"], "infile": ["inputfilename", "inputFile", "outbase", "outFile", " inFile", "inpath", " inbase", " infilename", "outfilename", "inbase", "InFile", "infilename", "inFile", "inputfile", "Inbase", "inputpath", " inpath", "Inpath", "outpath", "Infile"], "outfile": ["outfp", "newFile", "outname", "newfile", "indir", " outname", "outFile", "outdir", "fromfile", "outfilename", "inname", "newname", " outfilename", "tofp", "infilename", "todir", "inFile", "infp", "toFile", "newfilename", "fromfp", " outFile", "fromdir", "tofile", "fromFile"], "in": ["rin", "en", "image", "inn", "ini", "by", "gin", "con", "IN", "ins", "pin", "im", "ar", "on", "oin", "ro", "al", "In", "t", "inner", "inside", "init", "re", "up", "i", "bin", "get", "inc", "input", "amin", "or", "iter", "it", "per", " din", "form", "conn", "ain", "ind", "nin", "info", "din", "inf", "is", "isin", "source", "cin", "id", "from"], "out": ["ion", "co", "en", "nt", "flush", "con", "output", "res", "oss", "cn", "on", "sys", "t", "inner", "net", "write", "print", "b", "to", "end", "opt", "up", "writer", "os", "outer", "it", "OU", "gt", "null", "ou", "at", "outs", "g", "o", "aos", "ex", "n", "io", "Out", "file", "fn", "OUT", "can", "ne", "ot"], "buffer": ["phrase", "buf", "window", "bone", "block", "buff", "sample", "column", "frame", "comment", "view", "sequence", "append", "table", "pad", "library", "mem", "base", "template", "command", "attribute", "document", "message", "available", "stack", "number", "cache", "Buffer", "variable", "black", "total", "initial", "note", "history", "paste", "queue", "length", "binary", "batch", "bar", "padding", "info", "row", "display", "temp", "button", "password", "memory", "print", "header", "character"], "read": ["first", "each", "text", "find", "select", "reader", "wait", "allow", "raw", "stream", "set", "run", "before", "range", "write", "open", "push", "readable", "load", "print", "reads", "hold", "seek", "close", "i", "req", "skip", "get", " Read", "give", "input", "need", "iter", "through", "query", "len", "length", "Read", "ind", "add", "connect", "count", "n", "ready", "start", "size", "reading", "send", "check", "index", "READ", "end", "ok"], "success": ["first", "same", "good", "response", "value", " succ", "ceed", "cess", "positive", "fail", "city", "release", " successful", "summary", "please", "status", " Success", "ith", "accept", "Success", "danger", "done", "ratulations", "ccess", "growth", "warning", "primary", "result", "safe", " okay", "second", "unity", "crit", "condition", "successful", " failure", "sufficient", "error", "valid", "complete", "commit", "snap", "democracy", "continue", "photo", "surv", "successfully", "town", "submit", "support", " successes", "setup", "ok"]}}
{"id1": "22320592", "id2": "13891080", "code1": "    private static void loadDefaultPreferences() {\n        try {\n            URL url = ClassLoader.getSystemResource(\"OpenDarkRoom.defaults.properties\");\n            preferences.load(url.openStream());\n        } catch (FileNotFoundException e) {\n            log.error(\"Default preferences file not found\");\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n", "code2": "    public static void copyFile(File srcFile, File destFile) throws IOException {\n        logger.debug(\"copyFile(srcFile={}, destFile={}) - start\", srcFile, destFile);\n        FileChannel srcChannel = new FileInputStream(srcFile).getChannel();\n        FileChannel dstChannel = new FileOutputStream(destFile).getChannel();\n        try {\n            dstChannel.transferFrom(srcChannel, 0, srcChannel.size());\n        } finally {\n            srcChannel.close();\n            dstChannel.close();\n        }\n    }\n", "label": 0, "substitutes": {"loadDefaultPreferences": ["loaddefaultPrefs", "loaddefaultPres", "loadDefaultConfies", "loadDefaultProfSettings", "loaddefaultPreies", "loadDefaultPrefies", "loadDefaultPrefSettings", "loaddefaultPreferences", "loadDefaultPrefs", "loaddefaultPreSettings", "loadDefaultPreies", "loadDefaultProfies", "loaddefaultPrefies", "loadDefaultConferences", "loaddefaultPreerences", "loadDefaultPres", "loadDefaultProferences", "loadDefaultProfs", "loadDefaultPreSettings", "loaddefaultPrefSettings", "loadDefaultPreerences", "loadDefaultConfSettings", "loadDefaultConfs"], "url": ["f", "browser", "address", "ref", "u", "res", "service", "resource", "obj", "ls", "ll", "context", "base", "char", "abs", "link", "log", "sl", "document", "result", "re", "ur", "mount", "uri", "URL", "name", "str", "rl", "l", "resources", "nl", "ul", "path", "r", "ret", "http", "location", "config", "file", "Url", "loader", "cl"]}}
{"id1": "5436973", "id2": "20920051", "code1": "    public String httpToStringStupid(String url) throws IllegalStateException, IOException, HttpException, InterruptedException, URISyntaxException {\n        String pageDump = null;\n        getParams().setParameter(ClientPNames.COOKIE_POLICY, org.apache.http.client.params.CookiePolicy.BROWSER_COMPATIBILITY);\n        getParams().setParameter(HttpConnectionParams.SO_TIMEOUT, getPreferenceService().getSearchSocketTimeout());\n        HttpGet httpget = new HttpGet(url);\n        httpget.getParams().setParameter(HttpConnectionParams.SO_TIMEOUT, getPreferenceService().getSearchSocketTimeout());\n        HttpResponse response = execute(httpget);\n        HttpEntity entity = response.getEntity();\n        pageDump = IOUtils.toString(entity.getContent(), \"UTF-8\");\n        return pageDump;\n    }\n", "code2": "    public static void copyTo(File source, File dest) {\n        if (source.isHidden()) ; else if (source.isDirectory()) {\n            File temp = new File(dest.getPath() + \"/\" + source.getName());\n            temp.mkdir();\n            for (File sel : source.listFiles()) copyTo(sel, temp);\n        } else {\n            try {\n                File tempDest = new File(dest.getPath() + \"/\" + source.getName());\n                tempDest.createNewFile();\n                FileChannel sourceCh = new FileInputStream(source).getChannel();\n                FileChannel destCh = new FileOutputStream(tempDest).getChannel();\n                sourceCh.transferTo(0, sourceCh.size(), destCh);\n                sourceCh.close();\n                destCh.close();\n            } catch (IOException ex) {\n                Logger.getLogger(EditorUtil.class.getName()).log(Level.SEVERE, null, ex);\n            }\n        }\n    }\n", "label": 0, "substitutes": {"httpToStringStupid": ["httpToStrStuid", "httpToStrUuid", "httpToStrUamp", "httpToStringStamp", "httpToStringSnuff", "httpToStrUupid", "httpToStringUuid", "httpToStrStuff", "httpToStringSnamp", "httpToStringRestupid", "httpToStrStupid", "httpToStringUamp", "httpToStringStuid", "httpToStringRestamp", "httpToStringUuff", "httpToStringSnupid", "httpToStringRestuid", "httpToStringStuff", "httpToStrStamp", "httpToStrUuff", "httpToStringUupid", "httpToStringSnuid", "httpToStringRestuff"], "url": ["address", "ref", "u", "dl", "https", "page", "ls", "web", "ll", "base", "char", "link", "pl", "b", "result", "ur", "i", "uri", "URL", "name", "str", "l", "out", "ul", "path", "ssl", "pattern", "ret", "key", "http", "location", "string", "server", "file", "loc", "password", "Url", "id", "p", "host"], "IOException": [" IOError", "IOError", "ioException", "TimeoutException", "TimeoutError", "ioError"], "HttpException": ["HTTPException", "httpException", "httpError", "HTTPError", "HttpError", "RuntimeException", "RuntimeError"], "InterruptedException": ["InterruptEx", "InterinterruptedEx", " InterruptException", "InterruptionException", "InterruptedEx", " InterruptedError", "InterruptionEx", "InterinterruptedException", "InterinterruptedError", "InterruptException", "InterruptedError", " InterruptError", " InterruptedEx", "InterruptionError", " InterruptEx", "InterruptError"], "URISyntaxException": ["URISyntixEx", "URISyntlexEx", "URISeticntaxWarning", "URISyntaxWarning", "URISyntntaxException", "URISyntntaxEx", "URISeticntaxException", "URISeticaxWarning", "URISeticntaxEx", "URISyntixException", "URISyntlexWarning", "URISyntixWarning", "URISeticaxEx", "URISeticaxException", "URISyntaxEx", "URISyntlexException", "URISyntntaxWarning"], "pageDump": ["PageDumps", "pageSumps", "pageDumper", "pageDodump", "pageDash", "PageDdump", "pageDamp", "pagedump", "pageDoumps", "pagedumps", "pageStdump", "pagePamp", "pageSump", "pagePdump", "pageDoumper", "PageDump", "pageStash", " pageDamp", "pageddump", "pageDumps", "pageStump", "pagePash", "pageSdump", "pageDoump", "pagePump", " pageDumps", "pagedumper", " pageDdump", " pageDumper", "pageSumper", "pageStamp", " pageDash", "PageDumper", "pageDdump"], "httpget": ["ttpget", "httppost", "Httpget", "HTTPcreate", "hoverget", " httpGET", "HTTPGET", "ttpfind", "ttpGet", " httpcreate", "HTTPfind", "Httpfind", "Httpcall", "hoverGET", "hovercreate", "Httppost", " httpcall", "HTTPGet", "hoverGet", "ttppost", "ttpcall", "httpGET", "HTTPget", "httpcreate", "httpGet", " httppost", "ttpcreate", " httpGet", "httpcall", "httpfind", " httpfind"], "response": ["event", "report", "reply", "json", "block", "that", "output", "entry", "res", "next", "service", "request", "frame", "application", "description", "sequence", "yes", "Response", "page", "status", "connection", "profile", "command", "attribute", "open", "resp", "document", "message", "result", "onse", "content", "successful", "pos", "respond", "object", "answer", "remote", "still", "body", "given"], "entity": ["event", "json", "image", "ITY", "address", "output", "entry", "ie", "email", "ee", "comment", "resource", "obj", "page", "environment", "ce", "me", "document", "result", "content", "e", "detail", "person", "ent", "metadata", "object", "encrypted", "security", "group", "line", "model", "inv", "el", "activity", "icon", "voice", "Entity", "ity", "body", "existent", "unit", "pe"]}}
{"id1": "19494842", "id2": "7166270", "code1": "    private void callService() {\n        try {\n            URL url = new URL(baseUrl + servicePath + attributes);\n            BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream()));\n            String inputLine;\n            StringBuffer buf = new StringBuffer();\n            while ((inputLine = in.readLine()) != null) {\n                buf.append(inputLine);\n            }\n            in.close();\n            answer = buf.toString();\n        } catch (MalformedURLException e) {\n            answer = \"Malformed Url:\" + e.getMessage();\n            return;\n        } catch (IOException e) {\n            answer = \"I/O exception: \" + e.getMessage();\n            return;\n        }\n    }\n", "code2": "    protected String issueCommandToServer(String command, ChangeCapsule changeCapsule) throws IOException {\n        URLConnection urlConn = serverURL.openConnection();\n        urlConn.setDoInput(true);\n        urlConn.setDoOutput(true);\n        urlConn.setRequestProperty(\"Content-Type\", \"application/x-www-form-urlencoded\");\n        OutputStreamWriter wr = new OutputStreamWriter(urlConn.getOutputStream());\n        String content = ApplyChangesServlet.PARAMETER_COMMAND + \"=\" + command;\n        content += \"&\" + ApplyChangesServlet.PARAMETER_CAPSULE + \"=\" + URLEncoder.encode(changeCapsule.toJSON(), \"UTF-8\");\n        wr.write(content);\n        wr.flush();\n        BufferedReader input = new BufferedReader(new InputStreamReader(urlConn.getInputStream()));\n        StringBuffer response = new StringBuffer();\n        String str;\n        while (null != ((str = input.readLine()))) {\n            response.append(str);\n        }\n        wr.close();\n        input.close();\n        return response.toString();\n    }\n", "label": 1, "substitutes": {"callService": ["callServices", "runServices", "runService", "useService", "runservice", " callservice", "callservice", "useQuery", "callQuery", "useServices", " callServices", " callQuery", "useservice", "runQuery"], "url": ["browser", "hl", "gl", "address", "sb", "google", "dl", "service", "resource", "client", "bel", "ls", "web", "ll", "base", "char", "link", "pl", "sl", "b", "ur", "uri", "URL", "get", "str", "l", "oul", "nl", "ul", "conn", "r", "ssl", "channel", "http", "file", "acl", "Url"], "in": ["all", "rin", "en", "inn", "and", "gin", "con", "IN", "ins", "ri", "reader", "on", "oin", "sum", "In", "inner", "ill", "b", "ic", "conf", "i", "read", "bin", "inc", "l", "input", "out", "iter", "it", " din", "again", "r", "el", "mn", "mc", "io", "din", "inf", "er", "is", "isin", "cin", "check", "from"], "inputLine": [" inputL", "InputRow", "inputL", " inputRow", "inputFile", "inputLINE", "contextL", "outputline", "InputLine", "responseLine", "contextRow", "inputRow", " inputFile", "outputRow", "helloLINE", "helloLine", "parseLine", "helloFile", " inputLINE", "inputline", "parseFile", " inputline", "Inputline", "parseLINE", "responseRow", "InputLINE", "parseRow", "responseline", "contextline", "outputL", "helloRow", "contextLine", "outputLine", "responseLINE"], "buf": ["cv", "nm", "block", "pb", "buff", "br", "img", "bg", "raf", "cam", "cb", "vet", "ob", "comm", "area", "bh", "bed", "conv", "mem", "buffer", "fam", "bag", "pkg", "cur", "db", "Buffer", "gor", "rb", "uf", "hung", "tab", "alph", "bu", "mu", "cmd", "queue", "nom", "inv", "bar", "aux", "Buff", "cap", "mk", "cf", "msg", "vec"], "answer": ["report", "reply", "response", "image", "value", "address", "about", "entry", "say", "poll", "argument", "option", "sequence", "answered", "accept", "offer", "ve", "command", "replace", "interpret", "message", "result", "onse", "array", "review", "cache", "archive", "ask", "exit", "search", "form", "continue", "sn", "question", "again", "Answer", "channel", "place", "install", "send", "version", "ver", "remember", "username", "print", "equ"]}}
{"id1": "339517", "id2": "1508161", "code1": "    ClassFile getClassFile(String name) throws IOException, ConstantPoolException {\n        URL url = getClass().getResource(name);\n        InputStream in = url.openStream();\n        try {\n            return ClassFile.read(in);\n        } finally {\n            in.close();\n        }\n    }\n", "code2": "    public void conMail(MailObject mail) throws NetworkException, ContentException {\n        HttpClient client = HttpConfig.newInstance();\n        String url = HttpConfig.bbsURL() + HttpConfig.BBS_MAIL_CON + mail.getId() + \"&\" + HttpConfig.BBS_MAIL_N_PARAM_NAME + \"=\" + mail.getNumber();\n        HttpGet get = new HttpGet(url);\n        try {\n            HttpResponse response = client.execute(get);\n            HttpEntity entity = response.getEntity();\n            if (HTTPUtil.isXmlContentType(response)) {\n                Document doc = XmlOperator.readDocument(entity.getContent());\n                BBSBodyParseHelper.parseMailContent(doc, mail);\n            } else {\n                String msg = BBSBodyParseHelper.parseFailMsg(entity);\n                throw new ContentException(msg);\n            }\n        } catch (ClientProtocolException e) {\n            e.printStackTrace();\n            throw new NetworkException(e);\n        } catch (IOException e) {\n            e.printStackTrace();\n            throw new NetworkException(e);\n        }\n    }\n", "label": 0, "substitutes": {"getClassFile": [" getAppFactory", "getMethodFactory", "getAppClass", " getAppClass", " getAppFile", "getPackageFile", "getMethodClass", "getClassPage", " getClassPage", "getAppFile", "getPackageClass", "getAppFactory", "getAppPage", "getPackageFactory", " getAppPage", " getClassClass", "getClassClass", "getClassFactory", "getMethodFile", "getMethodPage", "getPackagePage", " getClassFactory"], "name": ["type", "address", "value", "named", "word", "resource", "description", "names", "base", "command", "message", "missing", "filename", "uri", "str", "initial", "NAME", "search", "path", "ame", "full", "key", "n", "string", "file", "class", "password", "id", "Name", "data", "prefix", "title"], "url": ["f", "browser", "gl", "address", "ref", "dl", "service", "resource", "client", "bel", "ls", "web", "ll", "char", "q", "link", "log", "sl", "open", "b", "build", "lr", "rel", "mount", "uri", "URL", "str", "l", "ch", "nl", "ul", "mail", "path", "null", "ret", "http", "io", "file", "loc", "Url", "user", "abs"], "in": ["f", "all", "rin", "en", "inn", "and", "gin", "con", "IN", "ins", "reader", "ln", "oin", "sum", "stream", "al", "In", "inner", "lit", "asin", "i", "read", "bin", "act", "mat", "serv", "inc", "l", "input", "out", "sin", "or", "cond", "it", " din", "s", "ind", "add", "mn", "mc", "io", "din", "is", "isin", "body", "cin", "data"]}}
{"id1": "22441244", "id2": "7087108", "code1": "    public void send(org.hibernate.Session hsession, Session session, String repositoryName, int ideIdint, String to, String cc, String bcc, String subject, String body, Vector attachments, boolean isHtml, String charset, InternetHeaders headers, String priority) throws MailException {\n        try {\n            if (charset == null) {\n                charset = MimeUtility.javaCharset(Charset.defaultCharset().displayName());\n            }\n            if ((body == null) || body.trim().equals(\"\")) {\n                body = \" \";\n            }\n            Email email = null;\n            if (isHtml) {\n                email = new HtmlEmail();\n            } else {\n                email = new MultiPartEmail();\n            }\n            email.setCharset(charset);\n            Users user = getUser(hsession, repositoryName);\n            Identity identity = getIdentity(hsession, ideIdint, user);\n            InternetAddress _returnPath = new InternetAddress(identity.getIdeEmail(), identity.getIdeName());\n            InternetAddress _from = new InternetAddress(identity.getIdeEmail(), identity.getIdeName());\n            InternetAddress _replyTo = new InternetAddress(identity.getIdeReplyTo(), identity.getIdeName());\n            InternetAddress[] _to = MessageUtilities.encodeAddresses(to, null);\n            InternetAddress[] _cc = MessageUtilities.encodeAddresses(cc, null);\n            InternetAddress[] _bcc = MessageUtilities.encodeAddresses(bcc, null);\n            if (_from != null) {\n                email.setFrom(_from.getAddress(), _from.getPersonal());\n            }\n            if (_returnPath != null) {\n                email.addHeader(\"Return-Path\", _returnPath.getAddress());\n                email.addHeader(\"Errors-To\", _returnPath.getAddress());\n                email.addHeader(\"X-Errors-To\", _returnPath.getAddress());\n            }\n            if (_replyTo != null) {\n                email.addReplyTo(_replyTo.getAddress(), _replyTo.getPersonal());\n            }\n            if ((_to != null) && (_to.length > 0)) {\n                HashSet aux = new HashSet(_to.length);\n                Collections.addAll(aux, _to);\n                email.setTo(aux);\n            }\n            if ((_cc != null) && (_cc.length > 0)) {\n                HashSet aux = new HashSet(_cc.length);\n                Collections.addAll(aux, _cc);\n                email.setCc(aux);\n            }\n            if ((_bcc != null) && (_bcc.length > 0)) {\n                HashSet aux = new HashSet(_bcc.length);\n                Collections.addAll(aux, _bcc);\n                email.setBcc(aux);\n            }\n            email.setSubject(subject);\n            Date now = new Date();\n            email.setSentDate(now);\n            File dir = new File(System.getProperty(\"user.home\") + File.separator + \"tmp\");\n            if (!dir.exists()) {\n                dir.mkdir();\n            }\n            if ((attachments != null) && (attachments.size() > 0)) {\n                for (int i = 0; i < attachments.size(); i++) {\n                    ByteArrayInputStream bais = null;\n                    FileOutputStream fos = null;\n                    try {\n                        MailPartObj obj = (MailPartObj) attachments.get(i);\n                        File file = new File(dir, obj.getName());\n                        bais = new ByteArrayInputStream(obj.getAttachent());\n                        fos = new FileOutputStream(file);\n                        IOUtils.copy(bais, fos);\n                        EmailAttachment attachment = new EmailAttachment();\n                        attachment.setPath(file.getPath());\n                        attachment.setDisposition(EmailAttachment.ATTACHMENT);\n                        attachment.setDescription(\"File Attachment: \" + file.getName());\n                        attachment.setName(file.getName());\n                        if (email instanceof MultiPartEmail) {\n                            ((MultiPartEmail) email).attach(attachment);\n                        }\n                    } catch (Exception ex) {\n                    } finally {\n                        IOUtils.closeQuietly(bais);\n                        IOUtils.closeQuietly(fos);\n                    }\n                }\n            }\n            String mid = getId();\n            if (headers != null) {\n                Header xheader;\n                Enumeration xe = headers.getAllHeaders();\n                for (; xe.hasMoreElements(); ) {\n                    xheader = (Header) xe.nextElement();\n                    if (xheader.getName().equals(RFC2822Headers.IN_REPLY_TO)) {\n                        email.addHeader(xheader.getName(), xheader.getValue());\n                    } else if (xheader.getName().equals(RFC2822Headers.REFERENCES)) {\n                        email.addHeader(xheader.getName(), xheader.getValue());\n                    }\n                }\n            } else {\n                email.addHeader(RFC2822Headers.IN_REPLY_TO, \"<\" + mid + \".JavaMail.duroty@duroty\" + \">\");\n                email.addHeader(RFC2822Headers.REFERENCES, \"<\" + mid + \".JavaMail.duroty@duroty\" + \">\");\n            }\n            if (priority != null) {\n                if (priority.equals(\"high\")) {\n                    email.addHeader(\"Importance\", priority);\n                    email.addHeader(\"X-priority\", \"1\");\n                } else if (priority.equals(\"low\")) {\n                    email.addHeader(\"Importance\", priority);\n                    email.addHeader(\"X-priority\", \"5\");\n                }\n            }\n            if (email instanceof HtmlEmail) {\n                ((HtmlEmail) email).setHtmlMsg(body);\n            } else {\n                email.setMsg(body);\n            }\n            email.setMailSession(session);\n            email.buildMimeMessage();\n            MimeMessage mime = email.getMimeMessage();\n            int size = MessageUtilities.getMessageSize(mime);\n            if (!controlQuota(hsession, user, size)) {\n                throw new MailException(\"ErrorMessages.mail.quota.exceded\");\n            }\n            messageable.saveSentMessage(mid, mime, user);\n            Thread thread = new Thread(new SendMessageThread(email));\n            thread.start();\n        } catch (MailException e) {\n            throw e;\n        } catch (Exception e) {\n            throw new MailException(e);\n        } catch (java.lang.OutOfMemoryError ex) {\n            System.gc();\n            throw new MailException(ex);\n        } catch (Throwable e) {\n            throw new MailException(e);\n        } finally {\n            GeneralOperations.closeHibernateSession(hsession);\n        }\n    }\n", "code2": "    @Override\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        String path = request.getPathTranslated().substring(0, request.getPathTranslated().length() - request.getPathInfo().length()) + request.getServletPath() + request.getPathInfo();\n        File file = new File(path);\n        if (file.exists()) {\n            FileInputStream in = new FileInputStream(file);\n            IOUtils.copyLarge(in, response.getOutputStream());\n            in.close();\n        }\n    }\n", "label": 1, "substitutes": {"send": ["export", "report", "reply", "Send", "execute", "create", "set", "init", "build", "write", "transfer", "message", "post", "get", "parse", "mail", "security", "add", "sent", "msg", "save", "submit", "apply", "print", "end", "push"], "hsession": ["hettings", " HSession", "hssession", "hhettings", "HSsession", " HSpace", "rssession", "hession", "hsessions", "HSession", "hhsession", "hessions", "hsettings", "rsess", "HSessions", "hhhip", " HSsession", "hspace", "HShip", "hhip", "rspace", "HSpace", "hsess", "HSettings", "hhessions", "hhession", " HSess", "hship", "rsession", "HSess"], "session": ["event", "lock", "Session", "driver", "view", "client", "set", "context", "connection", "sid", "ess", "document", "message", "content", "cache", "state", "name", "ession", "parent", "object", "instance", "ip", "manager", "account", "job", "password", "store"], "repositoryName": ["repoitoryName", "reposositoryData", "repositableNAME", "repoitoryNAME", "repositoryTitle", "reposoryName", "reposoryNAME", "reposoryname", "repoositoryTitle", "repositorNAME", "repoitoryname", "repositoryData", "reposositoryNAME", "repositableName", "reposositoryPath", "repositionNAME", "reposositoryName", "repositorTitle", "repositorName", "repositablename", "repositoryNAME", "repoitoryPath", "repositionTitle", "repoitoryData", "repositoryname", "reposositoryTitle", "repositableData", "repositionName", "reposositoryname", "repoositoryName", "reposoryData", "repoositoryData", "repositionPath", "repositoryPath", "repositorPath", "repoitoryTitle", "repoositoryname", "repoositoryNAME", "repoositoryPath"], "ideIdint": ["ideidINT", "ideIdentline", " ideThint", "ideIDno", "ideIdentno", "ideInfoINT", "ideDst", "ideIdentind", "ideidst", "IDEIdst", "ideIdline", "ideThno", "ideIdst", "ideIdno", "ideThind", "IDEIdINT", "ideThint", "ideIDline", "ideThline", "ideIDint", " ideIdline", " ideIdno", "ideIDind", "IDEidint", "IDEIdint", "ideInfost", "ideIdind", "ideDint", "IDEidst", "ideIdentint", "ideidint", "ideIdINT", " ideIdind", " ideThline", "IDEidINT", "ideDINT", " ideThind", " ideThno", "ideInfoint"], "to": ["co", "tr", "address", "by", "tp", "To", "about", "contact", "toc", "client", "TO", "site", "t", "tt", "po", "range", "addr", "company", "pro", "route", "topic", "eto", "phone", "token", "os", "top", "target", "pos", "tel", "too", "st", "o", "auto", "ato", "no", "ta"], "cc": ["co", "rc", "cloud", "cv", "cmp", "cb", "cn", "toc", "cr", "CC", "ico", "cy", "cci", "ce", "ca", "cs", "company", "fc", "ic", "ci", "ct", "cp", "ac", "cca", "cm", "ec", "cmd", "sc", "ck", "ctrl", "cd", "tc", "mc", "cf", "control", "cin", "dc", "cl"], "bcc": ["cbcm", "vce", "rbcc", "rbck", "sbce", "bCC", " bCC", "cbcc", "rbCC", "rbce", " bck", "vcy", "vcc", "rbcy", "bcm", "cbCC", "sbcy", "bck", "cbck", "vck", " bcm", "sbck", "bce", "rbcm", "bcy", "sbcc"], "subject": ["author", "text", "comment", "description", "header", "template", "message", "filename", "content", "face", "topic", "name", "head", "uri", "Subject", "note", "metadata", "mail", "form", "security", "html", "heading", "source", "id", "host", "prefix", "title"], "body": ["Body", "back", "report", "handle", "layout", "json", "response", "text", "default", "output", "params", "parts", "part", "comment", "h", "ODY", "description", "other", "bh", "summary", "business", "base", "inner", "template", "code", "buffer", "b", "message", "post", "content", "background", "url", "name", "head", "top", "bytes", "hex", "query", "note", "mail", "object", "null", "binary", "news", "ody", "line", "any", "zip", "padding", "bill", "html", "files", "no", "inline", "source", "shell", "data", "title"], "attachments": ["Attachresses", "achmentresses", "Attachachment", "achmentments", "achmenttypes", "attachachment", "attachtypes", "attresses", "attachresses", "Attachtypes", "attments", "atttypes", "Attachments", "achmentachment"], "isHtml": ["ishhtml", "isVhtml", "isJhtml", "isHap", " isHHTML", "isJtml", "isHhtml", "isChip", " isWhtml", "isWhhtml", "isHip", "isChtml", "isJttp", " isWhip", "IsHttp", "isVHTML", "isHttp", "isChhtml", "isWhtml", "isWhip", "IsHtml", "ishtml", "isJap", "isWhHTML", "IsHhtml", "isVtml", "IsHap", " isHhtml", " isWhhtml", "ishap", "isHHTML", " isWhHTML", "ishttp", " isHip", "isChHTML", "isVip"], "charset": ["chARSetic", "chatset", "Charsetic", "CHippets", "channelsET", "clerset", "chippET", "charpetter", "chacterset", "clarspace", "charpetic", "ChARSet", "quarset", "chersetter", "clarsets", "clarset", "charpett", "chippec", "chablesale", "quatset", "chatsetter", "quarsec", "chatsec", "chablesec", "cherspace", "channelsetic", "chippets", "clersetter", "charsetter", "channelsetter", "chippale", "charsET", "CHippET", "charsets", "CHarsET", "quarsetter", "clarsetter", "charsetic", "charpets", "chableset", "ChARSetter", "quatsale", "chatsale", "chARSetter", "chablesetter", "charspace", "quarsale", "chippetter", "cherset", "quatsetter", "charsett", "CharsET", "charsec", "quatsec", "CHarset", "Charsetter", "chactersets", "charpET", "CHarsets", "Charset", "chacterspace", "CHarsett", "chactersetter", "chARSpace", "chippet", "ChARSetic", "channelset", "chARSET", "clerspace", "chersets", "clersets", "charpet", "CHippet", "charsale", "CHippett", "chARSets", "ChARSET", "chippett", "chARSet"], "headers": ["ilers", "params", "users", "keys", "limits", "details", "types", "lines", "ters", "ppers", "names", "comments", "dr", "head", "fields", "heads", "members", "metadata", " trailers", "ers", "authors", "ors", "files", "relations", "codes", " heads", "header"], "priority": ["origin", " severity", "flags", "policy", "serial", "description", "status", "context", "level", "profile", "comments", "company", "primary", "properties", "state", "phone", "position", " urgency", "pos", "grade", "order", "security", "due", "password", "id", "prefix", "title"], "email": ["echo", "event", "all", "report", "response", "address", "gmail", "ilo", "element", "output", "entry", "oe", "sample", "console", "ee", "contact", "et", "comment", "test", "office", "description", "view", "die", "template", "ell", "link", "em", "ome", "company", "log", "fax", "label", "document", "message", "call", "result", "delete", "xml", "detail", "e", "url", "example", "liner", "external", "initial", "Email", "note", "object", "mail", "search", "enter", "instance", "line", "model", "database", "el", "ssl", "domain", "http", "html", "er", "msg", "voice", "server", "password", "shell", "il", "print", "ne", "license", "reset"], "user": ["browser", "admin", "author", "usr", "actor", "creator", "by", "match", "output", "util", "users", "client", "usa", "connection", "profile", "me", "USER", "human", "used", "result", "system", "owner", "name", "person", "entity", "login", "auth", "uid", "ident", "ip", "use", "manager", "account", "usage", "id", "User", "student", "username", "from"], "identity": ["idiciary", "personicate", "identifier", "solidality", "idity", "ententity", "recognity", "IDENTificate", "IDENTitate", "solidity", "identality", "presentitate", "instifier", "identalty", "entifier", "presententity", "IDENTator", "equity", "solidentity", "ethnicularity", "ethnicity", "IDENTity", "primance", "recognicate", "recognance", "identiciary", "instator", "identator", "solidularity", "IDENTicate", "ethnicentity", "instalty", "identITY", "equalty", "IDENTalty", "idality", "primicate", "equentity", "identificate", "presentity", "entularity", "IDENTularity", "IDENTality", "equator", "entity", "personentity", "recognentity", "IDENTifier", "instentity", "primity", "IDENTentity", "personificate", "personiciary", "identitate", "identicate", "IDENTiciary", "idITY", "personity", "personITY", "instularity", "idularity", "instity", "IDENTance", "IDENTITY", "presentularity", "idententity", "identance", "primificate", "primentity", "ethnicitate", "identularity"], "_returnPath": ["_requestPoint", " _errorAddress", "_retLocation", "_requestName", "_errorPoint", "setreturnTo", "_returnLocation", " _errorName", "_ReturnName", "setsavePath", "_savepath", "_deletepath", "_errorLocation", "_getPath", "_errorpath", "_retUrl", "setreturnUrl", "setsaveUrl", "_deletePoint", " _returnAddress", "_errorName", "_resultLocation", "_ReturnAddress", "_saveTo", "_returnpath", "_returnPoint", "_returnDir", " _returnName", "_retTo", "_retPoint", "_replyCode", "_retPath", "_requestPath", "setsaveTo", "_errorAddress", " _returnPoint", "_getDir", "_getCode", "_errorPath", "_deletePath", "_returnName", "_ReturnPath", "_requestAddress", "_retCode", "_ReturnPoint", "_replyPath", "_returnTo", "_savePath", "_errorUrl", "setsavepath", "_resultPoint", "_retDir", "_errorTo", " _errorPath", "_returnAddress", "_getTo", "_replyDir", "setreturnpath", "_returnUrl", "_saveUrl", "_retpath", "setreturnPath", "_resultPath", "_returnCode", " _errorPoint", "_resultTo", "_deleteTo"], "_from": ["letto", " _actor", " _author", "_reset", "_author", "remlocal", " _about", "longreset", "_form", "_about", "_source", "longfrom", "_addr", " _reset", "_local", "longsource", "letsource", "letabout", "remowner", "\tfrom", "letfrom", "remaddr", " _form", " _source", "_actor", "\tactor", "longto", "remfrom", "\tform", "\tauthor", "_owner"], "_replyTo": ["_responsePath", "_backTo", "_respondTO", "_ReplyTO", "_replyPath", "_backFrom", "_replyTO", "_responseTo", "_closeTO", "_backPath", "_returnFrom", "_respondFrom", "_returnOnly", "_respondOnly", "_returnTo", "_commentTo", "_ReplyFrom", "_replyFrom", "_ReplyOnly", "_ReplyTo", "_closeLine", "_responseOf", "_closeOf", "_replyOnly", "_commentTO", "_replyOf", "_commentOf", "_returnTO", "_ReplyPath", "_backTO", "_responseLine", "_commentLine", "_closeTo", "_responseTO", "_responseFrom", "_respondTo", "_replyLine"], "_to": ["prita", "successta", "successtopic", "_site", "successsite", "pritopic", "_ta", "successto", "prito", "_topic", "prisite"], "_cc": ["_subject", " _cs", "_cs", "_cca", " _subject", " _cca"], "_bcc": ["_rbcc", "_bck", "_wacc", "_wck", "_wcc", "_wca", "_rcc", "_rbck", "_rca", "_racc", "_rbacc", "_bacc", "_bca", "_rbca", "_rck"]}}
{"id1": "20735941", "id2": "14450108", "code1": "    protected File getFile() throws IOException {\n        File home = new File(System.getProperty(\"user.dir\"));\n        String fileName = String.format(\"%s.txt\", getFilePrefix());\n        File file = new File(home, fileName);\n        if (file.exists()) {\n            return file;\n        } else {\n            URL url = LocalNameGenerator.class.getResource(\"/\" + fileName);\n            if (url == null) {\n                throw new IllegalStateException(String.format(\"Cannot find resource at %s\", fileName));\n            } else {\n                InputStream in = url.openStream();\n                try {\n                    BufferedOutputStream out = new BufferedOutputStream(new FileOutputStream(file));\n                    try {\n                        IOUtils.copy(in, out);\n                    } finally {\n                        out.close();\n                    }\n                } finally {\n                    in.close();\n                }\n                return file;\n            }\n        }\n    }\n", "code2": "    public FTPFile[] connect() {\n        if (ftpe == null) {\n            ftpe = new FTPEvent(this);\n        }\n        if (ftp == null) {\n            ftp = new FTPClient();\n        } else if (ftp.isConnected()) {\n            path = \"\";\n            try {\n                ftp.disconnect();\n            } catch (IOException e1) {\n                log.error(\"could not disconnect -\" + e1.getMessage());\n            }\n        }\n        currentDir = new FTPFile[0];\n        log.debug(\"try to connect\");\n        try {\n            int reply;\n            ftp.connect(ftpsite);\n            reply = ftp.getReplyCode();\n            if (!FTPReply.isPositiveCompletion(reply)) {\n                ftp.disconnect();\n                log.error(\"FTP server refused connection.\");\n            }\n        } catch (IOException e) {\n            log.error(\"FTPConnection error: \" + e.getMessage());\n            if (ftp.isConnected()) {\n                try {\n                    ftp.disconnect();\n                } catch (IOException f) {\n                }\n            }\n        }\n        try {\n            if (!ftp.login(user, password)) {\n                log.error(\"could not login with: \" + user);\n                ftp.logout();\n            }\n            log.debug(\"Remote system is \" + ftp.getSystemName());\n            ftp.enterLocalPassiveMode();\n            currentDir = ftp.listFiles();\n        } catch (FTPConnectionClosedException e) {\n            log.error(\"FTPConnectionClosedException: \" + e.getMessage());\n        } catch (IOException e) {\n            log.error(\"IOException: \" + e.getMessage());\n        }\n        ftpe.setType(FTPEvent.CONNECT);\n        fireFTPEvent(ftpe);\n        return currentDir;\n    }\n", "label": 0, "substitutes": {"getFile": ["readFile", "newFilename", "getfile", "newSourceFile", "getSourceFile", "openFilename", "getFilename", "newFile", "openfile", "newfile", "openFile", "openSourceFile", "readFilename", "readfile", "readSourceFile"], "home": ["shared", "ghost", "default", "h", "share", "www", "omes", "mem", "base", "directory", "profile", "ome", "Home", "room", "join", " HOME", "wd", "up", "owner", "name", "localhost", "parent", "Dir", "project", "path", "mail", "housing", "dir", "history", "Root", "hub", "book", "auto", "self", "http", "html", "server", "root", "HOME", "user", "index", "host"], "fileName": ["resourceFilename", " filename", "fileFile", "filenamename", "fileNAME", "FileName", " filePath", " fileFilename", "viewFile", "FileNames", "resourcePath", "baseName", "FILEName", "tileFilename", "projectname", "FileString", " fileString", "tileName", "fileFilename", "baseDefault", "filenameFilename", "filename", "FILEString", "FILENames", "projectNAME", "baseNAME", "basename", "resourceName", " fileNAME", "viewName", "tileNAME", "filenamePath", "filePath", "fileDefault", "fileNames", " fileFile", "projectDefault", "tileFile", " fileDefault", "FilePath", " fileNames", "FILEPath", "projectName", "viewFilename", "viewNAME", "resourcename", "fileString", "filenameName"], "file": ["type", "f", "report", "handle", "fe", "image", "output", "File", "FILE", "bo", "resource", "view", "foo", "fp", "al", "page", "table", "run", "library", "port", "base", "work", "po", "be", "link", "buffer", "log", "write", "function", "to", "document", "used", "load", "result", "db", "current", "from", "filename", "ile", "format", "node", "name", "le", "or", "tree", "object", "path", "null", "dir", "model", "use", "channel", "full", "local", "info", "place", "pool", "user", "print"], "url": ["browser", "f", "gl", "address", "ref", "dl", "util", "resource", "client", "https", "bel", "ls", "web", "ll", "base", "char", "link", "sl", "cert", "impl", "lr", "rel", "ur", "org", "uri", "URL", "name", "str", "rl", "l", "nl", "ul", "mail", "path", "null", "norm", "mb", "github", "r", "ssl", "ret", "key", "http", "html", "loc", "Url", "user", "host", "abs"], "in": ["f", "rin", "en", "inn", "ini", "and", "gin", "con", "IN", "ins", "im", "on", "al", "In", "init", "inner", "inside", "ic", "ai", "up", "i", "read", "bin", "inc", "l", "input", "iter", "it", " din", "s", "ind", "o", "r", "el", "mc", "n", "io", "din", "inf", "is", "isin", "source", "body", "cin", "from"], "out": ["ion", "co", "en", "nt", "flush", "con", "output", "cos", "oss", "cn", "obj", "ln", "on", "client", "sys", "conv", "inner", "one", "net", "write", "log", "to", "v", "writer", "os", "outer", "OU", "it", "null", "ou", "aos", "outs", "o", "batch", "gr", "n", "io", "msg", "Out", "OUT", "check", "can", "ne", "ot"]}}
{"id1": "886783", "id2": "12171364", "code1": "    private static void doGet(LNISoapServlet lni, String itemHandle, String packager, String output, String endpoint) throws java.rmi.RemoteException, ProtocolException, IOException, FileNotFoundException {\n        String itemURI = doLookup(lni, itemHandle, null);\n        URL url = LNIClientUtils.makeDAVURL(endpoint, itemURI, packager);\n        System.err.println(\"DEBUG: GET from URL: \" + url.toString());\n        HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n        conn.setRequestMethod(\"GET\");\n        conn.setDoInput(true);\n        fixBasicAuth(url, conn);\n        conn.connect();\n        int status = conn.getResponseCode();\n        if (status < 200 || status >= 300) {\n            die(status, \"HTTP error, status=\" + String.valueOf(status) + \", message=\" + conn.getResponseMessage());\n        }\n        InputStream in = conn.getInputStream();\n        OutputStream out = new FileOutputStream(output);\n        copyStream(in, out);\n        in.close();\n        out.close();\n        System.err.println(\"DEBUG: Created local file \" + output);\n        System.err.println(\"RESULT: Status=\" + String.valueOf(conn.getResponseCode()) + \" \" + conn.getResponseMessage());\n    }\n", "code2": "    private static FrameworkFactory getFrameworkFactory() throws Exception {\n        URL url = Main.class.getClassLoader().getResource(\"META-INF/services/org.osgi.framework.launch.FrameworkFactory\");\n        if (url != null) {\n            BufferedReader br = new BufferedReader(new InputStreamReader(url.openStream()));\n            try {\n                for (String s = br.readLine(); s != null; s = br.readLine()) {\n                    s = s.trim();\n                    if ((s.length() > 0) && (s.charAt(0) != '#')) {\n                        return (FrameworkFactory) Class.forName(s).newInstance();\n                    }\n                }\n            } finally {\n                if (br != null) br.close();\n            }\n        }\n        throw new Exception(\"Could not find framework factory.\");\n    }\n", "label": 0, "substitutes": {"doGet": ["DoPut", "doGET", " doPut", " doGET", "handlePut", "Doget", "handleGET", "doget", " doget", "doPut", "handleget", "handleGet", "DoGET", "DoGet"], "lni": ["slti", "Lti", "rne", "lini", " lti", "slini", "Lnis", " lnis", "lti", "rti", "Lne", " lne", "Lini", "slni", "slne", "rnis", "lne", " lini", "rni", "Lni", "lnis"], "itemHandle": ["itemID", "itemhandle", "itHandle", "itID", "ithandle", "Itemhandle", "itemH", " itemID", "issueID", "ItemHandle", "ItemID", "ItemH", " itemH", "itemHand", " itemHand", "issuehandle", "issueHandle", " itemhandle", "itHand", "ItemHand", "issueH"], "packager": ["packageagger", "packageagers", "packagers", "packsagger", " packagger", "packsaler", "packagger", "packsagers", " packaler", " packenger", "packsenger", "facenger", " packagers", "facager", "packageaging", "packsager", "packenger", "facaler", "packaging", " packaging", "facagger", "packaler", "packageager", "packsaging"], "output": ["handle", "response", "value", "text", "ilo", "put", "column", "resource", "client", "page", "port", "Output", "directory", "connection", "label", "generated", "print", "write", "buffer", "log", "absolute", "message", "current", "xml", "filename", "format", "name", "hidden", "error", "target", "input", "outer", "written", "OU", "region", "path", "ou", "o", "key", "string", "location", "temp", "file", "source", "unit", "username", "PUT", "data", "prefix", "display"], "endpoint": ["beginPoint", "endspoints", "ndpoints", "endpoints", "beginpoints", "Endpoint", "endspt", "beginpoint", "Endpt", "ndpoint", "endpt", "endPoint", "EndPoint", "beginpt", "endsPoint", "ndpt", "endspoint", "Endpoints", "ndPoint"], "IOException": ["RuntimeGroup", "NetworkException", " IOOver", "NetworkGroup", "IOGroup", " IOGroup", "NetworkOver", "RuntimeException", "RuntimeOver", "IOOver"], "FileNotFoundException": ["FileNotPresentWarning", "FileAlreadyFoundException", "FileNotFoundWarning", "FileAlreadyPresentWarning", "FileAlreadyPresentError", "FileNotPresent ", "FileNotFound ", "FileNotPresentError", "FileAlreadyPresentException", "FileAlreadyFound ", "FileNotFoundError", "FileNotPresentException", "FileAlreadyFoundWarning", "FileAlreadyFoundError", "FileAlreadyPresent "], "itemURI": ["itemID", "itemuri", "resourceID", " itemURL", "storeuri", "storeURL", "resourceURI", "storeURI", " itemID", " itemRI", "ItemRI", "ItemURL", "ItemID", "storeRI", "resourceURL", "itemURL", "Itemuri", "resourceuri", " itemuri", "ItemURI", "itemRI"], "url": ["f", "browser", "handle", "sb", "ref", "dl", "con", "res", "parser", "client", "bel", "ls", "web", "ll", "base", "char", "q", "build", "pl", "sl", "log", "impl", "re", "xml", "ur", "mount", "org", "gc", "un", "uri", "URL", "name", "str", "rl", "get", "l", "kl", "cmd", "nl", "this", "ul", "path", "null", "sql", "term", "r", "ssl", "el", "domain", "key", "http", "location", "html", "server", "loc", "il", "Url", "host", "fl", "abs"], "conn": ["canon", "en", "nt", "subject", "that", "ctx", "con", "res", "sync", "pas", "cb", "cn", "comm", "cont", "enc", "obj", "yn", "cell", "client", "ws", "sys", "conv", "init", "ann", "connection", "ns", "addr", "net", "c", "open", "resp", "cert", "err", "cur", "call", "pg", "close", "db", "iw", "conf", "org", "req", "cp", "ct", "act", "Conn", "ch", "stat", "cmd", "auth", "ctrl", "cfg", "syn", "connect", "ssl", "nc", "desc", "jp", "typ", "socket", "msg", "wp", "att", "exec", "fin", "compl", "gen"], "status": ["STAT", "ser", "access", "response", "json", "z", "res", " Status", "d", "service", "score", "uses", "wait", "fs", "atus", "wa", "x", "compliance", "code", "sex", "spec", "US", "stats", "cgi", "resp", "current", "result", "re", "xml", "number", "e", "format", "progress", "Status", "state", "name", "str", "success", "esp", "login", "stat", "sc", "sw", "st", "pres", "s", "magic", "use", "ssl", "ret", "http", "html", "msg", "is", "iso", "compl", "source", "size", "version", "index", "id", "sem", "es", "server", "prefix", "ex"], "in": ["rin", "en", "inn", "ini", "irm", "gin", "min", "IN", "ins", "im", "cont", "ln", "on", "In", "init", "inner", "inside", "old", "ai", "dr", "re", "xml", "up", "i", "read", "bin", "str", "inc", "input", "sin", "iter", "it", " din", "st", "ind", "r", "mn", "mm", "din", "inf", "is", "isin", "source", "body", "cin", "id", "from"], "out": ["all", "co", "good", "nt", "en", "vol", "res", "cos", "oss", "cn", "cont", "sys", "sum", "set", "conv", "t", "inner", "net", "err", "to", "list", "v", "writer", "os", "outer", "ent", "OU", "ch", "it", "cmd", "gt", "null", "ou", "at", "g", "o", "outs", "aos", "inv", "n", "io", "Out", "OUT", "check", "ne", "ex"]}}
{"id1": "21125261", "id2": "6188784", "code1": "    @Test\n    public void test() throws Exception {\n        InputStream is = this.getClass().getResourceAsStream(\"originAndDestination.xml\");\n        ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();\n        IOUtils.copy(is, byteArrayOutputStream);\n        TrafficModelDefinition def = MDFReader.read(byteArrayOutputStream.toByteArray());\n        TrafficSimulationEngine se = new TrafficSimulationEngine();\n        se.init(def);\n        int linkId = 2;\n        int segmentId = 0;\n        Map<Integer, Set<Integer>> linkSegments = new HashMap<Integer, Set<Integer>>();\n        Set<Integer> segments = new HashSet<Integer>();\n        segments.add(segmentId);\n        linkSegments.put(linkId, segments);\n        FrameProperties frameProperties = new FrameProperties(linkSegments, new HashSet<Integer>());\n        se.setFrameProperties(frameProperties);\n        for (float time = 0; time < 60 * 10; time += 0.1f) {\n            se.step(0.1f);\n            for (RoadObject vehicle : se.getDynamicObjects()) {\n                System.out.println(time + \": X=\" + vehicle.getPosition() + \"\\tV=\" + vehicle.getSpeed());\n            }\n        }\n    }\n", "code2": "    public static void copy(File source, File dest) throws IOException {\n        FileChannel in = null, out = null;\n        try {\n            in = new FileInputStream(source).getChannel();\n            out = new FileOutputStream(dest).getChannel();\n            long size = in.size();\n            MappedByteBuffer buf = in.map(FileChannel.MapMode.READ_ONLY, 0, size);\n            out.write(buf);\n        } finally {\n            if (in != null) in.close();\n            if (out != null) out.close();\n        }\n    }\n", "label": 1, "substitutes": {"test": ["Test", "sample", "hello", "feature", "execute", " tests", "tests", "launch", "run", "t", "debug", "train", "load", "testing", "read", "example", "fit", " evaluate", "show", "volt", " sample", "evaluate", "T", " testing", "unit", "server"], "is": ["mis", "xs", "does", "ms", "us", "sit", "Is", "ri", "ws", "fs", "sys", "bs", "stream", "ls", "isa", "ais", "in", "tis", "ps", "ai", "xml", "i", "its", "serv", "rs", "ris", "IS", "os", "input", "out", "has", "are", "isc", "lis", "s", "isi", "iso", "as", "ios", "es", "sis"], "byteArrayOutputStream": ["byteArrayOutputView", "byteArray4Stream", "byteArrayOutputForm", "byteStringOutputSteam", "byteArrayApplicationStream", "byteArrayOutputString", "byteStringoutputSteam", "byteArray4View", "byteArrayoutputStream", "byteArrayOutputStyle", "byteArrayInputString", "byteStreamInputStream", "byteArray4Steam", "byteStringInputStream", "byteArray4String", "byteStreamInputSteam", "byteStreamOutputStyle", "byteStringOutputString", "byteArrayByteView", "byteArrayoutputString", "byteStringOutputForm", "byteStreamOutputForm", "byteArrayApplicationStyle", "byteArrayoutputSteam", "byteStreamOutputSteam", "byteStringInputView", "byteArrayByteStyle", "byteStringOutputStream", "byteArrayInputStyle", "byteArrayoutputForm", "byteArrayByteForm", "byteArrayInputStream", "byteArrayOutputSteam", "byteArrayByteStream", "byteArrayByteString", "byteArrayApplicationForm", "byteArrayInputSteam", "byteStreamInputStyle", "byteArrayByteSteam", "byteStringoutputForm", "byteArrayInputForm", "byteStreamInputForm", "byteStringInputSteam", "byteStringoutputStream", "byteStringInputString", "byteArrayApplicationSteam", "byteStringoutputString", "byteStreamOutputStream", "byteStringOutputView", "byteArrayInputView"], "def": ["dem", "defined", "decl", "dec", "json", "dl", "default", "d", "Def", "dict", "Definition", "sche", "del", "md", "ef", "db", "pro", "det", "conf", "ded", "sd", "crit", "definition", "dal", "des", "ds", "da", "cd", "define", "hd", "DE", "desc", "DEF", "de", "dev", "df"], "se": ["ze", "ode", "ser", "ses", "su", "SE", "ie", "ine", "sed", "sp", "ee", "engine", "pse", "es", "ide", "ene", "set", "est", "sa", "ae", "sche", "me", "ve", "ce", "we", "sl", "be", "ade", "ense", "Se", "e", "sd", "sec", "see", "ste", "le", "sel", "ase", "parse", "spe", "ge", "ese", "she", "te", "de", "sea", "ane", "so", "sem", "he", "ke", "ne", "pe"], "linkId": ["lineName", "Linkid", " linkID", "connectionID", "linkID", " linkid", "linkid", "linkedId", "chainId", "lineID", "lineId", "LinkId", "linkedID", "LinkName", "connectionIdent", "LinkID", "linkedIdent", "chainID", "linkName", " linkName", "lineid", "connectionId", "linkIdent", "chainIdent"], "segmentId": ["segmentById", "idegementRef", "begmentName", "semissionid", "begroupName", "begroupId", "idegmentId", "segementid", "semissionRef", "idegmentRef", "segroupId", "begroupID", "segmentRef", "segementId", "sementID", "segroupName", "segroupById", "segementName", "segementID", "idegementName", "idegementid", "sementRef", "begmentID", "segementRef", "sementById", "idegmentid", "segmentName", "idegementId", "idegmentName", "semissionName", "segmentID", "segementById", "begmentById", "segmentid", "begroupById", "sementId", "segroupID", "sementName", "semissionId", "begmentId", "sementid"], "linkSegments": ["linkGroups", "linkBuildets", " linkBuildets", " linkGments", "linkSeggments", "linkFragroups", " linkThreadroups", "linkGment", " linkSeggments", "linkSegroups", "linkConnectets", "linkThreadroups", " linkSeglements", " linkThreadments", "linkParlements", " linkSegroups", " linkBuildables", "linkParments", "linkFraggments", " linkGgments", " linkBuildgments", "linkFragment", " linkSegets", "linkBuildroups", " linkBuildments", "linkSegables", "linkConnectments", "linkGgments", "linkConnectables", "linkSeglements", "linkThreadgments", " linkThreadlements", "linkBuildables", "linkSements", " linkThreadgments", "linkBuildgments", "linkThreadlements", "linkGments", "linkConnectlements", "linkSegets", "linkBuildments", "linkThreadments", " linkSegables", "linkSeables", "linkParroups", " linkGment", "linkSeets", "linkSegment", "linkConnectgments", "linkPargments", "linkConnectroups", " linkGroups", "linkBuildment", " linkSegment", "linkFragments"], "segments": ["sements", "megs", "megments", " segs", "velements", "sevals", " Segments", "segins", " sevals", "bevals", "seges", " Sements", "usements", "parsements", "segs", "vectors", "parsegments", " sements", " seges", "usegments", "selements", "parsectors", "usegins", "parselements", " Seges", " Sevals", "beges", "vements", "begments", "bements", " segins", " sectors", "usegs", "vegments", "mements", "megins", "sectors", " selements"], "frameProperties": ["framePrperties", "frameProfilities", "frameByperties", "framePrps", "framePrptions", "frameProilities", " frameProps", " frameProptions", "frameParrics", "frameProps", " frameProilities", "frameByptions", "frameComperties", "frameProfperties", "frameProrics", "framePropilities", "frameParptions", "frameByilities", " framePrperties", " framePrptions", "framePropps", "framePropptions", "frameProfps", " frameByptions", "frameProptions", " framePrrics", "frameParps", "frameComps", "framePropperties", " frameByperties", " framePrps", "framePrrics", " frameByps", "frameByps", "frameComrics", "frameProfptions", " frameProrics", "frameComptions", " frameByilities", "frameParperties"], "time": ["event", "times", "ime", "window", "transform", "year", "step", "value", "each", "money", "tx", "task", "speed", "runtime", "distance", "Time", "depth", "sequence", "set", "context", "t", "TIME", "x", "tt", "frequency", "before", "trace", "date", "message", "timer", "system", "ts", "second", "counter", "now", "trust", "total", "etime", "delay", "rate", "think", "point", "length", "slow", "estamp", "clock", "tim", "count", "start", "size", "timeout", "version", "check", "duration"], "vehicle": ["survendor", "vehocity", "survogram", "vehogram", "yardicle", "survocity", "vehICLE", "verogram", "venticle", "VehICLE", "vertic", "vertocity", "vehicles", "venticles", "heroocity", " vehicles", "verticle", "Vehic", "heroicles", "vericle", "yardocity", "survicle", "yardendor", "heroICLE", "Vehicles", "verendor", "vehic", "vehendor", "yardogram", " vehocity", "verocity", "verticles", "Vehocity", " vehICLE", "ventocity", "Vehicle", "ventic", "heroicle"]}}
{"id1": "1357662", "id2": "4798332", "code1": "    private void copyFileTo(File destination) throws IOException {\n        logger.fine(\"Copying from \" + destination + \"...\");\n        FileChannel srcChannel = new FileInputStream(getAbsolutePath()).getChannel();\n        logger.fine(\"...got source channel \" + srcChannel + \"...\");\n        FileChannel destChannel = new FileOutputStream(new File(destination.getAbsolutePath())).getChannel();\n        logger.fine(\"...got destination channel \" + destChannel + \"...\");\n        logger.fine(\"...Got channels...\");\n        destChannel.transferFrom(srcChannel, 0, srcChannel.size());\n        logger.fine(\"...transferred.\");\n        srcChannel.close();\n        destChannel.close();\n    }\n", "code2": "    public static String SHA(String source) {\n        logger.info(source);\n        String result = null;\n        try {\n            MessageDigest digest = MessageDigest.getInstance(\"SHA\");\n            digest.update(source.getBytes());\n            byte[] bytes = digest.digest();\n            result = EncodeUtils.hexEncode(bytes);\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        }\n        logger.info(result);\n        return result;\n    }\n", "label": 0, "substitutes": {"copyFileTo": ["CopDirectoryTo", "copyFileTO", "copyToTO", "copyDirectoryTo", "copyToTo", "copyDirectoryTO", "CopFileTO", "copyfileFile", "copyfileFrom", "CopFileFile", "CopDirectoryTO", "CopDirectoryFile", "copyDirectoryFrom", "CopDirectoryFrom", "copyFileFrom", "copyToFrom", "copyfileTo", "copyFileFile", "CopFileFrom", "copyToFile", "copyDirectoryFile", "copyfileTO", "CopFileTo"], "destination": ["Destinate", " destinations", " destification", "distinate", "deluration", "descification", "desturation", "delification", "catination", "restification", "dominations", "distification", "destinate", "estination", "catinate", "estinator", "catification", "descinate", " destinate", "estinations", "estinated", "restinate", "domination", "Destinated", " destinator", "descination", "descinated", "distination", " desturation", "dominator", "catinated", " destinity", "destinity", " destinated", "distinated", "destinations", "destification", "delinity", "Destification", "destinated", "distinity", "disturation", "dominated", "Destination", "destinator", "delination", "restination", "restinated"], "srcChannel": ["sysChan", "srChain", "rcConnection", "srcChan", "srcCh", "srChan", "sourceChannel", "sourceConnection", "sysStream", "srcConnection", "srcchannel", "insChain", "sysConnection", "srcStream", "sinChan", "rcChannel", "sourcechannel", "sysChannel", "rcchannel", "srcChain", " srcStream", " srcCh", "rcChan", "insChannel", "sinChain", "srChannel", "srCase", " srcChain", "srcCase", "sourceCh", " srcchannel", " srcChan", "insCh", " srcConnection", "rcCh", "sourceChan", "sinCase", "sinChannel", " srcCase", "rcStream", "insChan", "rcChain"], "destChannel": ["destCh", " destCan", " destCh", "srcChan", " destConnection", "homeChan", "certCh", "homeChannel", "DestChannel", "etcConnection", "destCan", "destChan", "homeCategory", "srcConnection", "DestCan", "srcchannel", "etcC", "etcChan", " destChan", "DestConnection", "certCan", "destC", " destCategory", "homechannel", "destConnection", "destchannel", "srcC", "Destchannel", "DestChan", "certConnection", "DestCategory", " destchannel", " destC", "destCategory", "DestCh", "etcChannel", "certChannel"]}}
{"id1": "1769771", "id2": "14047629", "code1": "    private void copyFile(File in, File out) throws IOException {\n        FileChannel inChannel = new FileInputStream(in).getChannel();\n        FileChannel outChannel = new FileOutputStream(out).getChannel();\n        try {\n            inChannel.transferTo(0, inChannel.size(), outChannel);\n        } catch (IOException e) {\n            throw e;\n        } finally {\n            if (inChannel != null) inChannel.close();\n            if (outChannel != null) outChannel.close();\n        }\n    }\n", "code2": "    protected ExternalDecoder(InputStream source, Process process) {\n        super(source);\n        this.process = process;\n        this.processStdOut = process.getInputStream();\n        this.processStdIn = process.getOutputStream();\n        new Thread() {\n\n            @Override\n            public void run() {\n                try {\n                    IOUtils.copy(getSource(), processStdIn);\n                    System.err.println(\"Copy done.\");\n                    close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                    IOUtils.closeQuietly(ExternalDecoder.this);\n                }\n            }\n        }.start();\n    }\n", "label": 1, "substitutes": {"copyFile": ["CopyFiles", "copyLine", "copyFiles", " copyLine", "CopyStream", " copyStream", "CopyLine", " CopyLine", " CopyStream", "copyStream", " CopyFiles", " copyFiles", "CopyFile", " CopyFile"], "in": ["rin", "en", "inn", "ini", "gin", "IN", "ins", "on", "In", "init", "inner", "old", "b", "ic", "up", "i", "bin", "inc", "l", "input", " input", "ind", "r", "el", "mm", "io", "din", "inf", "is", "isin", "source", "cin", "from"], "out": ["nt", "output", "res", "op", "help", "t", "po", "log", "net", "err", "b", "to", "c", "ot", "up", "v", "serv", "os", "l", "it", "gt", "at", "ou", "outs", "s", "o", "n", "io", "msg", "Out", "file", "OUT", "p", "update", "ex", "w"], "inChannel": ["cinChannel", "ainClient", "ainScope", "cinCommand", "insideClient", "ainChannel", "InChan", "inChan", "intChannel", "insideScope", "insideChannel", "dinchannel", "dinChan", " inCase", " inButton", "sinRoom", "outConnection", " inRoom", "inCase", "intCommand", " inClient", "InChannel", "sinCommand", "innChannel", "inCommand", "dinConnection", "dinChannel", " inConnection", " inScope", "intChan", " inchannel", "inScope", " inCategory", "innButton", "inCategory", "cinRoom", "inRoom", "ainCategory", " inChan", "innClient", "inConnection", "inchannel", "InCommand", "sinCase", "sinChannel", "outChan", "intchannel", "insideCategory", "innCase", "sinClient", " inCommand", "sinButton", "Inchannel", "inClient", "outchannel", "inButton"], "outChannel": ["parentMany", " outMany", "outMany", "inChan", "blockMany", "neMember", "blockChannel", "outputchannel", "outGate", "cnChannel", " outCh", " outGate", "neChannel", " outChan", "neSection", "blockChan", "blockGate", "inCh", "outSection", "cnChan", " outManager", "cnManager", "aosChan", "aosChannel", "inMember", "neChan", "aosSection", "outputManager", "parentChannel", "outMember", " outchannel", "inchannel", "outChan", "parentChan", "outputChannel", "outputCh", "outManager", "parentGate", "outchannel", "inSection", "aosMember", "outCh", "outputChan"]}}
{"id1": "14877116", "id2": "20100809", "code1": "    public void cpFile(File source, File target, boolean replace, int bufferSize) throws IOException {\n        if (!source.exists()) throw new IOException(\"source file not exists\");\n        if (!source.isFile()) throw new IOException(\"source file not exists(is a directory)\");\n        InputStream src = new FileInputStream(source);\n        File tarn = target;\n        if (target.isDirectory() || !(!(target.exists()) || replace)) {\n            String tardir = target.isDirectory() ? target.getPath() : target.getParent();\n            tarn = new File(tardir + File.separator + source.getName());\n            int n = 1;\n            while (!(!tarn.exists() || replace)) {\n                tarn = new File(tardir + File.separator + String.valueOf(n) + \" copy of \" + source.getName());\n                n++;\n            }\n        }\n        if (source.getPath().equals(tarn.getPath()) && replace) return;\n        OutputStream tar = new FileOutputStream(tarn);\n        byte[] bytes = new byte[bufferSize];\n        int readn = -1;\n        while ((readn = src.read(bytes)) > 0) {\n            tar.write(bytes, 0, readn);\n        }\n        tar.flush();\n        tar.close();\n        src.close();\n    }\n", "code2": "    public static void copy(File srcPath, File dstPath) throws IOException {\n        if (srcPath.isDirectory()) {\n            if (!dstPath.exists()) {\n                boolean result = dstPath.mkdir();\n                if (!result) throw new IOException(\"Unable to create directoy: \" + dstPath);\n            }\n            String[] files = srcPath.list();\n            for (String file : files) {\n                copy(new File(srcPath, file), new File(dstPath, file));\n            }\n        } else {\n            if (srcPath.exists()) {\n                FileChannel in = null;\n                FileChannel out = null;\n                try {\n                    in = new FileInputStream(srcPath).getChannel();\n                    out = new FileOutputStream(dstPath).getChannel();\n                    long size = in.size();\n                    MappedByteBuffer buf = in.map(FileChannel.MapMode.READ_ONLY, 0, size);\n                    out.write(buf);\n                } finally {\n                    if (in != null) in.close();\n                    if (out != null) out.close();\n                }\n            }\n        }\n    }\n", "label": 1, "substitutes": {"cpFile": [" copFile", " copSingle", " cpSingle", " dupFile", " copStream", "pasteSingle", "pasteBuffer", " dupSingle", " dupStream", "pasteStream", " copBuffer", " cpBuffer", "pasteFile", " dupBuffer", " cpStream"], "source": ["origin", "sample", "original", "base", "up", "get", "SOURCE", "comp", "sql", "form", "config", "start", "from", "series", "scan", "subject", "select", "dest", "service", "resource", "se", "site", "before", "ce", "template", "char", "secure", "Source", "name", "local", "file", "shell", "store", "sp", "create", "stream", "in", "scope", "none", "input", "query", "parent", "path", "ource", "component", "unit", "peer", "style", "image", "find", "ie", "status", "init", "spec", "attribute", "old", "current", "format", "ace", "copy", "this", "search", "null", "scene", "use", "self", "remote", "string"], "target": ["origin", "window", "theme", "output", "test", "next", "internal", "ARGET", "tmp", "t", "port", "base", "range", "build", "to", "primary", "mount", "top", "localhost", "it", "gt", "normal", "bolt", "arget", "tif", "update", "arg", "type", "handle", "that", "alias", "dest", "resource", "force", "site", "tor", "tool", " Target", "template", "link", "buffer", " dst", "Target", "global", "tree", "local", "file", " targ", "goal", "table", "scope", "master", "join", "parent", "secondary", "point", "path", "root", "dev", "host", "peer", "transform", "style", "default", "set", "current", "format", "this", "project", "null", "remote", "print"], "replace": ["first", "report", "include", "insert", "find", "match", "enable", "fill", "remove", "share", "force", "fix", "append", " Replace", "link", "write", "only", "hide", "places", "load", "join", "close", "placed", "rm", "format", "copy", "ignore", "compatible", "change", "search", "null", "record", "add", "use", "register", "place", "remote", "repeat", "save", "repl", "inline", "apply", "keep", "store", "repair", "update", "delete", "prefix", "display"], "bufferSize": [" bufferStyle", "BufferSize", " bufferCount", "blockSize", " bufferName", "blockStyle", "BufferName", "BufferSIZE", "BufferCount", "bufferName", "windowSize", "blockSIZE", "windowCount", "blockCount", "bufferCount", "windowName", "bufferStyle", "BufferStyle", " bufferSIZE", "windowSIZE", "bufferSIZE"], "src": ["ser", "rc", "txt", "usr", "sb", "img", "rt", "sync", "supp", "sp", "dest", "ins", "obj", "sys", "tmp", "stream", "conv", "init", "in", "sq", "sl", "secure", "fc", "ctr", "cur", "sr", "Source", "sec", "req", "read", "bin", "RC", "copy", "rs", "sf", "SOURCE", "rb", "input", "out", "sin", "rl", "iter", "proc", "std", "str", "sc", "rx", "st", "syn", "http", "sub", "inst"], "tarn": ["wtarn", "vtann", "storn", "starl", "Tarm", "tarp", "Tarn", "pann", "yarm", "Torn", "Tinn", "starn", "stourn", " tara", "utard", " tarm", "vtarn", "porn", " tinn", "tarl", "thourn", " tourn", "tara", "utorn", "Tara", "tarm", "tann", "thorn", "vtarm", "wtinn", "Tourn", " tann", "tourn", "wtara", " tarl", "parm", "tharl", " torn", "yourn", "utann", "tard", "Tard", "torn", "wtann", " tard", "tharn", "yarp", "starp", "utarn", "Tann", "yarn", "starm", "tinn", " tarp", "vtorn", "parn", "pourn"], "tardir": ["tardore", "tarnore", " tardar", "taredir", "tradr", "taddir", " tardint", " tarnr", "tartart", " tardore", "tarnir", " tarndir", "tadint", "tradir", "tardart", "tardar", "tadr", "tartore", "tadar", " tarnint", "tareddir", "tradore", " tartart", "tarnr", " tardart", " tarddir", "tadir", "tartr", "taredar", "tartir", "tartar", " tartir", "tarnar", "tarnart", " tartore", "tarnint", " tardr", " tarnar", "tarndir", "tarddir", "tartdir", " tarnir", " tartr", "tardint", "taredint", "tardr", "tradart"], "n": ["na", "en", "nt", "nm", "j", "z", "N", "nan", "con", "y", "next", "d", "cn", "nn", "m", "ln", "on", "t", "x", "ns", "k", "c", "max", "un", "i", "number", "nb", "nu", "l", "nl", "norm", "sn", "g", "ind", "num", "nr", "mn", "nc", "count", "index", "w"], "tar": ["drop", "csv", "cube", "rar", "txt", "tr", "mask", "tg", "cro", "gz", "cat", "war", "par", "tan", "vol", "cast", "mar", "ar", "part", "sum", "tor", "gre", "box", "dra", "stable", "buffer", "ctr", "nut", "dr", "tif", "Tar", "tap", "sv", "copy", "tf", "archive", "car", "or", "pack", "parse", "cot", "qa", "add", "star", "zip", "te", "sea", "trap", "bolt", "gob", "store", "bare", "roo"], "bytes": ["series", "services", "vals", "frames", "reports", "Bytes", "versions", "rows", "strings", "parts", "cells", "users", "bps", "seconds", "lines", "qs", "les", "unks", "bs", "ls", "classes", "ings", "bits", "pins", "pieces", "bles", "boxes", "steps", "words", "its", "ips", "elines", "blocks", "resources", "ones", "gs", "outs", "bags", "groups", "pages", "files", "gets", "values", "some", "tes", "es", "cs"], "readn": ["writen", "loadl", "readnn", "readl", "writeN", "writenn", " Readl", "readN", " Readn", " Readnl", "writele", "Readl", "printns", "writel", "loadN", "printn", " readnl", "writens", "ReadN", "Readnl", "printle", "rolll", "loadn", "rollns", "Readnn", "rolln", "printl", "loadnn", "readle", "readns", "Readn", "rollle", "readnl", " readl"]}}
{"id1": "5998352", "id2": "755203", "code1": "    @Test\n    public void testStandardTee() throws Exception {\n        final String reference = \"test\";\n        final Reader source = new StringReader(reference);\n        final StringWriter destination1 = new StringWriter();\n        final StringWriter destination2 = new StringWriter();\n        final TeeWriter tee = new TeeWriter(destination1, destination2);\n        org.apache.commons.io.IOUtils.copy(source, tee);\n        tee.close();\n        assertEquals(\"the two string are equals\", reference, destination1.toString());\n        assertEquals(\"the two string are equals\", reference, destination2.toString());\n        assertEquals(\"byte count\", reference.length(), tee.getSize());\n    }\n", "code2": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "label": 1, "substitutes": {"testStandardTee": [" teststandardMette", " teststandardTee", " testStandardNee", " testStandardTe", " testStandardMees", " teststandardMees", " testStandardTees", " testStandardMee", " teststandardTees", " testStandardNette", " testStandardNees", " testStandardNe", " testStandardEees", " teststandardMe", " testStandardMette", " testStandardMe", " testStandardEee", " teststandardTette", " testStandardTette", " testStandardEette", " teststandardMee", " testStandardEe", " teststandardTe"], "reference": ["type", "back", "report", "ref", "value", "address", "operation", "sample", "pointer", "test", "hello", "internal", "alias", "service", "request", "argument", "description", "word", "sequence", "using", "reverse", "library", "directory", "template", "link", "attribute", "associated", "function", "document", "message", "re", "filename", "Reference", "information", "example", "see", "condition", "position", "name", "external", "definition", "resolution", "section", "approximately", "note", "search", "collection", "relation", "register", "pattern", "use", "key", "remote", "string", "relative", "memory", "specified", "print", "prefix", "expression", "title"], "source": ["ser", "style", "select", "sample", "console", "service", "resource", "reader", "sequence", "force", "stream", "context", "inner", "base", "template", "spec", "store", "buffer", "from", "src", "Source", "format", "copy", "get", "target", "SOURCE", "operator", "input", "sql", "seed", "ource", "instance", "iterator", "core", "file", "shell", "unit", "username", "loader"], "destination1": ["DestinationName", "destification1", "desturationOne", "destation1", "destificate1", "destinations1", "destinatorName", "destensionOne", "desturation1", "destificateOne", "destregationOne", "DestinatorName", "destregationone", "stination2", "destificate01", "stination1", "Destinatorone", "destensionFirst", "stensionFirst", "Destinator01", "destinationName", "Destinationone", "destinatorOne", "destinator1", "Destinator1", "destinationsOne", "stinationFirst", "desturationFirst", "Destination1", "DestinationOne", "destregation1", "destinationOne", "Destination01", "DestinatorOne", "destationOne", "destificationOne", "destinationsFirst", "destination01", "destinatorone", "stension1", "stensionOne", "destificationName", "destinator01", "destation01", "destension1", "stension2", "destinationFirst", "destinations2", "destension2", "desturation2", "destregationName", "stinationOne", "destinationone", "destificationone"], "destination2": ["destendanttwo", " destinationB", "destinate2", "destinition2", "desturationB", "destinationTwo", "destination4", "destendant4", " desturationB", " desturationtwo", "destination3", "destinition3", "destensiontwo", "destociation1", "destociation2", "Destination2", "destinationB", "destinator2", "Destension2", "destendantB", " desturation2", "destinated2", "desturation4", "destinated52", "Destination1", "destinationtwo", " desturation4", "destinition52", "Destension1", "estination3", "destendant2", " destinationtwo", "estinition52", "DestinationTwo", "destensionB", "estination52", " destination4", "destination52", "estinition3", "destinateTwo", "desturationtwo", "destensionTwo", "destinate1", "DestensionTwo", "estination2", "estinition2", "destension1", "destension4", "destinated3", "destinator52", "destension2", "destinator3", "destociationTwo", "desturation2"], "tee": ["tees", "ceee", "seE", "cee", " teee", "chee", "teer", " tees", "ceoe", "cheea", "cheee", "teea", "tete", " teE", "ieee", "see", " teoe", "pees", "teee", "iee", "ieea", "teoe", "chete", "cees", " tete", "peer", "teE", "ceE", "iete", " teea", "seee", "pee", "peee", " teer", "seoe", "ceer", "peoe", "peE"]}}
{"id1": "7981642", "id2": "10385815", "code1": "    @Override\n    public void update(String mail, String email, String pwd, String firstname, String lastname) throws NamingException, NoSuchAlgorithmException, UnsupportedEncodingException {\n        jndiManagerConnection connection = new jndiManagerConnection();\n        Attributes attrs = new BasicAttributes();\n        attrs.put(\"sn\", lastname);\n        attrs.put(\"givenName\", firstname);\n        attrs.put(\"cn\", firstname + \" \" + lastname);\n        if (!pwd.isEmpty()) {\n            MessageDigest sha = MessageDigest.getInstance(\"md5\");\n            sha.reset();\n            sha.update(pwd.getBytes(\"utf-8\"));\n            byte[] digest = sha.digest();\n            String hash = Base64.encodeBase64String(digest);\n            attrs.put(\"userPassword\", \"{MD5}\" + hash);\n        }\n        DirContext ctx = connection.getLDAPDirContext();\n        ctx.modifyAttributes(\"mail=\" + mail + \",\" + dn, DirContext.REPLACE_ATTRIBUTE, attrs);\n        if (!mail.equals(email)) {\n            String newName = \"mail=\" + email + \",\" + dn;\n            String oldName = \"mail=\" + mail + \",\" + dn;\n            ctx.rename(oldName, newName);\n        }\n    }\n", "code2": "    public static void copy(String fileFrom, String fileTo) throws IOException {\n        FileInputStream inputStream = null;\n        FileOutputStream outputStream = null;\n        FileChannel inputChannel = null;\n        FileChannel outputChannel = null;\n        try {\n            inputStream = new FileInputStream(fileFrom);\n            outputStream = new FileOutputStream(fileTo);\n            inputChannel = inputStream.getChannel();\n            outputChannel = outputStream.getChannel();\n            inputChannel.transferTo(0, inputChannel.size(), outputChannel);\n        } finally {\n            try {\n                inputChannel.close();\n            } finally {\n                try {\n                    outputChannel.close();\n                } finally {\n                    try {\n                        inputStream.close();\n                    } finally {\n                        outputStream.close();\n                    }\n                }\n            }\n        }\n    }\n", "label": 0, "substitutes": {"update": ["edit", "handle", "reply", "text", "insert", "sample", "put", "test", "updated", "remove", "UPDATE", "create", "set", "append", "mod", "feed", "init", "write", "replace", "load", "printf", "touch", "post", "up", "read", "input", "upload", "login", "commit", "data", "pack", "auth", "change", "add", "register", "alter", "place", "config", "save", "apply", "Update", "check", "store", "username", "delete", "move", "escape"], "mail": ["Mail", "address", "gmail", "virtual", "tp", "dl", "dial", "imp", "test", "link", "im", "m", "ln", "grid", "dn", "eth", "mun", "port", "mem", "label", "addr", "md", "del", "pkg", "old", "net", "pl", "log", "cert", "message", "mobile", "hold", "mount", "dm", "com", "url", "alt", "name", "Email", "iter", "cmd", "enter", "dir", "ip", "mails", "el", "zip", "domain", "mm", "n", "local", "http", "id", "msg", "server", "file", "mill", "username", "print", "host"], "email": ["echo", "nm", "address", "image", "text", "ilo", "virtual", "sample", "test", "cn", "cdn", "et", "ln", "m", "dn", "ns", "IL", "template", "date", "link", "addr", "del", "label", "log", "atom", "message", "xml", "detail", "number", "e", "url", "uri", "name", "phone", "example", "external", "entity", "Email", "note", "nl", "sql", "object", "enter", "ip", "line", "el", "zip", "domain", "n", "html", "server", "file", "password", "il", "username", "host"], "pwd": ["Ppriv", "pw", "presspriv", " pfx", "psfx", " pws", "Pfx", "pswd", "Pwd", "Pgen", "Pws", "Pword", "Pw", " pword", "dpword", "pgen", "pws", "ppriv", " pw", "psw", "pressw", "pressws", "pow", " pgen", "dpgen", "psow", "dpw", "presswd", "pfx", " pow", "Pow", "pword", "dpwd", " ppriv"], "firstname": ["Firstparent", "firstName", "lastName", "firstparent", "smallNAME", "FirstNAME", "smallname", "smallName", "firstnames", " firstNAME", " firstnames", "lastparent", "firstrun", "lastrun", "lastnames", "Firstnames", "FirstName", "lastNAME", " firstrun", " firstName", "smallrun", "firstNAME", " firstparent", "Firstname"], "lastname": ["firstName", " lastame", "lastName", "givenName", "firsttype", "longName", " lastnum", "firstame", "firstnum", "longnum", "givennum", "fullName", " lasttype", "lastnum", "giventype", "lasttype", "givenname", "fullname", "longname", " lastName", "fullame", "longame", "lastame"], "connection": ["event", "ion", "response", "creator", "con", "connected", "entry", "city", "engine", "resource", "application", "description", "client", "onet", "context", "directory", "link", "command", "c", "management", "document", "system", "condition", "Connection", "cone", "handler", "conn", "network", "collection", "database", "connect", "relation", "nc", "communication", "pool", "session"], "attrs": ["adrs", "adributes", "latrs", "atrics", "actters", "addrs", "adras", "attsrs", "addributes", "latributes", "attds", "attachras", " attries", "addrd", "attns", "attsributes", "atrs", "attters", "avrs", "attsrics", "avributes", "attsds", "atras", "attrys", "avrics", "attachrs", "atrd", "attachributes", " attributes", "attachRs", "atns", "atries", "attrics", "attsps", "attps", "avras", "attsries", "actrys", "atds", "attsras", "atrys", "atributes", "actributes", "atRs", "addras", "atters", " attras", "atps", " attrd", "attras", "attRs", " attRs", "adns", " attns", "latrys", "latters", " attds", "attries", "addRs", "attributes", "attrd", "actrs", " attps"], "sha": ["shared", "pa", "lambda", "sm", "git", "alpha", "ha", "cos", "func", "asha", "ksh", "h", "tar", "SHA", "sum", "wa", "ya", "ppa", "sa", "mem", "hi", "sche", "sq", "ca", "md", "go", "sh", "has", "total", "comp", "HA", "da", "mb", "ka", "shi", "ma", "auto", "no", "iso", "mac", "ssh", "shell", "acl", "sam", "a", " SHA"], "digest": ["dested", "redge", "redested", "divEST", "dest", "digests", "digse", "dighest", "digge", "Digests", " digests", "mdEST", "digEST", "Digse", "mdest", "dests", "dge", "Digge", "redest", "Dighest", "Digested", "divhest", "mdse", "mdested", "mdhest", " digEST", "digested", "divest", "DigEST", "mdests", "divse", " digested", "redests", "Digest"], "hash": ["ashes", "handle", "each", "ash", "Hash", "ha", "h", "score", "bh", "sum", "tag", "flash", "base", "shadow", "md", "ASH", "message", "result", "format", "cache", "sh", "has", "input", "total", "trust", "dump", "hex", "auth", "search", "dig", "filter", "proof", "key", "html", "rh", "password", "mac", "check", "print"], "ctx": ["Context", "co", "txt", "nt", "tz", "cv", " context", "rc", "cmp", "con", "tx", "cb", "tk", "obj", "tmp", "bc", "context", "conv", "x", "sq", "wx", "ca", "pkg", "ctr", "pg", "cu", "ct", "xc", "gc", "cp", "Conn", "cm", " cx", "gm", "kl", "sc", "ck", "np", "conn", "ctrl", "lc", "tc", "mc", "nc", "kw", "jp", "mk", "cf", "loc", "dc"], "newName": ["currentName", "finalname", "oldname", "NewNAME", "currentNAME", "finalName", "NewKey", "newKey", "newHome", "newname", "oldHome", " newNames", "Newname", "finalHome", " newHome", " newname", "oldNames", "NewName", "newNames", "newNAME", " newKey", "currentKey", "currentname", "finalNames", " newNAME"], "oldName": ["recentname", "oldname", "olderPref", "smallOr", " oldPref", "smallname", "oldOr", "smallName", "recentName", "smallAnd", "newname", "oldPref", " oldname", "recentAnd", "prevName", "oldKey", "recentOr", "oldername", "prevKey", "newOr", " oldKey", "olderName", "olderKey", "oldAnd", "prevPref", "newAnd", "prevname"]}}
{"id1": "3375724", "id2": "22552318", "code1": "    public void importarEmissoresDosTitulosFinanceiros(File pArquivoTXT, Andamento pAndamento) throws FileNotFoundException, SQLException {\n        int numeroDoRegistro = -1;\n        Scanner in = null;\n        Statement stmtLimpezaInicialDestino = conDestino.createStatement();\n        String sql = \"TRUNCATE TABLE TMP_TB_EMISSOR_TITULO\";\n        stmtLimpezaInicialDestino.executeUpdate(sql);\n        sql = \"INSERT INTO TMP_TB_EMISSOR_TITULO(SIGLA, NOME, CNPJ, DATA_CRIACAO) VALUES(:SIGLA, :NOME, :CNPJ, :DATA_CRIACAO)\";\n        OraclePreparedStatement stmtDestino = (OraclePreparedStatement) conDestino.prepareStatement(sql);\n        stmtDestino.setExecuteBatch(COMANDOS_POR_LOTE);\n        final int TAMANHO_DO_CABECALHO_DO_ARQUIVO = 0;\n        final int TAMANHO_DO_RODAPE_DO_ARQUIVO = 0;\n        final int TAMANHO_DOS_METADADOS_DO_ARQUIVO = TAMANHO_DO_CABECALHO_DO_ARQUIVO + TAMANHO_DO_RODAPE_DO_ARQUIVO;\n        final int TAMANHO_MEDIO_POR_REGISTRO = 81;\n        long tamanhoDosArquivos = pArquivoTXT.length();\n        int quantidadeDeRegistrosEstimada = (int) (tamanhoDosArquivos - TAMANHO_DOS_METADADOS_DO_ARQUIVO) / TAMANHO_MEDIO_POR_REGISTRO;\n        String registro;\n        String[] campos;\n        try {\n            in = new Scanner(new FileInputStream(pArquivoTXT), Constantes.CONJUNTO_DE_CARACTERES_DOS_ARQUIVOS_TEXTO_DA_BOVESPA.name());\n            int quantidadeDeRegistrosImportada = 0;\n            numeroDoRegistro = 0;\n            String vSIGLA, vNOME;\n            BigDecimal vCNPJ;\n            java.sql.Date vDATA_CRIACAO;\n            final int QTDE_CAMPOS = CampoDoArquivoDosEmissoresDeTitulosFinanceiros.values().length;\n            final String SEPARADOR_DE_CAMPOS_DO_REGISTRO = \",\";\n            final String DELIMITADOR_DE_CAMPOS_DO_REGISTRO = \"\\\"\";\n            while (in.hasNextLine()) {\n                ++numeroDoRegistro;\n                registro = in.nextLine();\n                stmtDestino.clearParameters();\n                registro = registro.substring(1, registro.length() - 1);\n                if (registro.endsWith(DELIMITADOR_DE_CAMPOS_DO_REGISTRO)) {\n                    registro = registro + \" \";\n                }\n                campos = registro.split(DELIMITADOR_DE_CAMPOS_DO_REGISTRO + SEPARADOR_DE_CAMPOS_DO_REGISTRO + DELIMITADOR_DE_CAMPOS_DO_REGISTRO);\n                int quantidadeDeCamposEncontradosIncluindoOsVazios = campos.length;\n                if (quantidadeDeCamposEncontradosIncluindoOsVazios != QTDE_CAMPOS) {\n                    throw new CampoMalDelimitadoEmRegistroDoArquivoImportado(registro);\n                }\n                vSIGLA = campos[CampoDoArquivoDosEmissoresDeTitulosFinanceiros.SIGLA.ordinal()];\n                vNOME = campos[CampoDoArquivoDosEmissoresDeTitulosFinanceiros.NOME.ordinal()];\n                String cnpjTmp = campos[CampoDoArquivoDosEmissoresDeTitulosFinanceiros.CNPJ.ordinal()];\n                if (cnpjTmp != null && cnpjTmp.trim().length() > 0) {\n                    vCNPJ = new BigDecimal(cnpjTmp);\n                } else {\n                    vCNPJ = null;\n                }\n                String dataDaCriacaoTmp = campos[CampoDoArquivoDosEmissoresDeTitulosFinanceiros.DATA_CRIACAO.ordinal()];\n                if (dataDaCriacaoTmp != null && dataDaCriacaoTmp.trim().length() > 0) {\n                    int dia = Integer.parseInt(dataDaCriacaoTmp.substring(6, 8)), mes = Integer.parseInt(dataDaCriacaoTmp.substring(4, 6)) - 1, ano = Integer.parseInt(dataDaCriacaoTmp.substring(0, 4));\n                    Calendar calendario = Calendar.getInstance();\n                    calendario.clear();\n                    calendario.set(ano, mes, dia);\n                    vDATA_CRIACAO = new java.sql.Date(calendario.getTimeInMillis());\n                } else {\n                    vDATA_CRIACAO = null;\n                }\n                stmtDestino.setStringAtName(\"SIGLA\", vSIGLA);\n                stmtDestino.setStringAtName(\"NOME\", vNOME);\n                stmtDestino.setBigDecimalAtName(\"CNPJ\", vCNPJ);\n                stmtDestino.setDateAtName(\"DATA_CRIACAO\", vDATA_CRIACAO);\n                int contagemDasInsercoes = stmtDestino.executeUpdate();\n                quantidadeDeRegistrosImportada++;\n                double percentualCompleto = (double) quantidadeDeRegistrosImportada / quantidadeDeRegistrosEstimada * 100;\n                pAndamento.setPercentualCompleto((int) percentualCompleto);\n            }\n            conDestino.commit();\n        } catch (Exception ex) {\n            conDestino.rollback();\n            ProblemaNaImportacaoDeArquivo problemaDetalhado = new ProblemaNaImportacaoDeArquivo();\n            problemaDetalhado.nomeDoArquivo = pArquivoTXT.getName();\n            problemaDetalhado.linhaProblematicaDoArquivo = numeroDoRegistro;\n            problemaDetalhado.detalhesSobreOProblema = ex;\n            throw problemaDetalhado;\n        } finally {\n            pAndamento.setPercentualCompleto(100);\n            in.close();\n            if (stmtLimpezaInicialDestino != null && (!stmtLimpezaInicialDestino.isClosed())) {\n                stmtLimpezaInicialDestino.close();\n            }\n            if (stmtDestino != null && (!stmtDestino.isClosed())) {\n                stmtDestino.close();\n            }\n        }\n    }\n", "code2": "    private synchronized void loadDDL() throws IOException {\n        try {\n            conn.createStatement().executeQuery(\"SELECT * FROM non_generic_favs\").close();\n        } catch (SQLException e) {\n            Statement stmt = null;\n            if (!e.getMessage().matches(ERR_MISSING_TABLE)) {\n                e.printStackTrace(System.out);\n                throw new IOException(\"Error on initial data store read\");\n            }\n            String[] qry = { \"CREATE TABLE non_generic_favs (id INT NOT NULL PRIMARY KEY)\", \"CREATE TABLE ignore_chan_favs (id INT NOT NULL PRIMARY KEY, chanlist LONG VARCHAR)\", \"CREATE TABLE settings (var VARCHAR(32) NOT NULL, val VARCHAR(255) NOT NULL, PRIMARY KEY(var))\", \"INSERT INTO settings (var, val) VALUES ('schema', '1')\" };\n            try {\n                conn.setAutoCommit(false);\n                stmt = conn.createStatement();\n                for (String q : qry) stmt.executeUpdate(q);\n                conn.commit();\n            } catch (SQLException e2) {\n                try {\n                    conn.rollback();\n                } catch (SQLException e3) {\n                    e3.printStackTrace(System.out);\n                }\n                e2.printStackTrace(new PrintWriter(System.out));\n                throw new IOException(\"Error initializing data store\");\n            } finally {\n                if (stmt != null) {\n                    try {\n                        stmt.close();\n                    } catch (SQLException e4) {\n                        e4.printStackTrace(System.out);\n                        throw new IOException(\"Unable to cleanup data store resources\");\n                    }\n                }\n                try {\n                    conn.setAutoCommit(true);\n                } catch (SQLException e3) {\n                    e3.printStackTrace(System.out);\n                    throw new IOException(\"Unable to reset data store auto commit\");\n                }\n            }\n        }\n        return;\n    }\n", "label": 1, "substitutes": {"importarEmissoresDosTitulosFinanceiros": [" insertarEmissoresDosTitULoC", " insertarEmissoresDosTituloFe", " insertarEmissoresDosTitULosFe", " insertarEmissoresDosTitULoT", " insertarEmissoresDosTitulOsC", " insertarEmissoresDosTitulosFe", " insertarEmissoresDosTitulOsF", " insertarEmissoresDosTitulasT", " insertarEmissoresDosTitulosT", " insertarEmissoresDosTitulasFe", " insertarEmissoresDosTitULosC", " insertarEmissoresDosTituloT", " insertarEmissoresDosTitulosC", " insertarEmissoresDosTitulosF", " insertarEmissoresDosTitULosF", " insertarEmissoresDosTitulOsFe", " insertarEmissoresDosTitulasC", " insertarEmissoresDosTituloC", " insertarEmissoresDosTitULoF", " insertarEmissoresDosTitulasF", " insertarEmissoresDosTitULosT", " insertarEmissoresDosTituloF", " insertarEmissoresDosTitULoFe", " insertarEmissoresDosTitulOsT"], "pArquivoTXT": ["pArquivotxt", "pArquivoXTXT", "pArquivTEX", "pArquivoBXT", "pArquiveTXT", "pArquivoTEX", "pArquivoBBT", "pArquivNEX", "pArquivoNXT", "pArquivNRL", "pArquivoRxt", "pArquivRXT", "pArquivoRIN", "pArquiveNBT", "pArquivoFEX", "pArquivTRL", "pArquivotIN", "pArquivRIN", "pArquivoBEX", "pArquivoFxt", "pArquivTOX", "pArquivoBxt", "pArquivoROX", "pArquivoDEX", "pArquivoFBT", "pArquivoDXT", "pArquivoNxt", "pArquivoXTxt", "pArquivoFRL", "pArquiveNxt", "pArquivNXT", "pArquivoDxt", "pArquivoDRL", "pArquivROX", "pArquivNxt", "pArquivoTBT", "pArquivoTIN", "pArquiveNXT", "pArquiveTEX", "pArquivoNRL", "pArquivoXTOX", "pArquiveNEX", "pArquivotOX", "pArquivoNEX", "pArquiveTxt", "pArquivoNBT", "pArquivoFXT", "pArquivoTxt", "pArquivRxt", "pArquivoTOX", "pArquivoXTIN", "pArquivTIN", "pArquivoTRL", "pArquivTXT", "pArquivTxt", "pArquivotXT", "pArquiveTBT", "pArquivoRXT"], "pAndamento": ["pandamentO", "pAndamentoS", "pandamento", "pandmentoS", "pandmento", "pAndmentos", "pAndumentO", "pAndementoS", "pandmentO", "pandamentoS", "pAndmentO", "pAndamentO", "pAndumentos", "pAndementos", "pAndemento", "pAndumentoS", "pAndamentos", "pandmentos", "pAndumento", "pAndementO", "pandamentos", "pAndmento", "pAndmentoS"], "numeroDoRegistro": ["numeroDoregistulo", "numeroDoRegestro", "numeroDoRegendro", "numeroDoregistros", "numeroDoRegestr", "numeroDoRegistulo", "numeroDoRegitr", "numeroDoregestro", "numeroDoRegendros", "numeroDoRegitros", "numeroDoRegistr", "numeroDoRegendr", "numeroDoRegitulo", "numeroDoregistro", "numeroDoregistr", "numeroDoregestulo", "numeroDoRegestros", "numeroDoregestr", "numeroDoregestros", "numeroDoRegitro", "numeroDoRegistros", "numeroDoRegestulo", "numeroDoRegendulo"], "in": ["f", "scan", "rin", "inn", "gin", "con", "min", "IN", "vin", " nin", "ins", "pin", "reader", " inn", "ln", "m", "tin", "In", "inner", "inning", "thin", "edIn", "kin", "bin", "inc", "out", "input", "sin", " sin", " din", " out", "nin", "n", "ner", " ins", "din", "inf", "isin", "cin", "from"], "stmtLimpezaInicialDestino": ["stmtLimpezaInicialEstino", "stmtLimpezaInicialStino", "stmtLimpezaIniciaEstination", "stmtLimpezaInicialDestinos", "stmtLimpezaInicialStinos", "stmtLimpezaInicialEstINO", "stmtLimpezaIniciaDestino", "stmtLimpezaInicialDecinos", "stmtLimpezaInicioDestaine", "stmtLimpezaInicialDestaine", "stmtLimpezaInicialdestination", "stmtLimpezaInicialEstinos", "stmtLimpezaInicialEstination", "stmtLimpezaIniciaEstinos", "stmtLimpezaInicialdestino", "stmtLimpezaIniciaDestination", "stmtLimpezaInicialDestination", "stmtLimpezaInicialEstaine", "stmtLimpezaInicioEstinos", "stmtLimpezaInicialDestINO", "stmtLimpezaInicialdestINO", "stmtLimpezaInicialDecino", "stmtLimpezaInicialDecINO", "stmtLimpezaInicioDestino", "stmtLimpezaInicialStINO", "stmtLimpezaIniciaEstino", "stmtLimpezaInicioDestinos", "stmtLimpezaInicioEstaine", "stmtLimpezaInicialStaine", "stmtLimpezaInicialStination", "stmtLimpezaIniciaDestinos", "stmtLimpezaInicialdestinos", "stmtLimpezaIniciaDestINO", "stmtLimpezaInicioEstino", "stmtLimpezaInicioDestINO", "stmtLimpezaInicioEstINO", "stmtLimpezaIniciaEstINO", "stmtLimpezaInicialDecaine"], "sql": ["csv", "xs", "json", "dl", "select", "params", "sp", "wal", "js", "description", "details", "ln", "pp", "qs", "raw", "ls", "script", "sq", "template", "spec", "command", "q", "log", "join", "rel", "xml", "format", "sd", "sv", "url", "name", "serv", "str", "statement", "ql", "eps", "lex", "query", "SQL", "cmd", "sol", "nl", "seed", "s", "sn", "inv", "ssl", "session", "pel", "string", "socket", "msg", "html", "spr", "fn", "scl", "expression"], "stmtDestino": ["stmtInstino", "stmtdestino", "stmtStinos", "stmtDestINO", "stmmDestination", "stmtInstorno", "stMTDecino", "stmmInstino", "stmtdestinos", "stMTDestinos", "stmtInstinos", "stmtStin", "stmtDestin", "stmtDestorno", "stMTDecINO", "stmtDestinos", "stmtdestination", "stmtdestin", "stmtStorno", "stmtDecINO", "stMTDecinos", "stmtDestination", "stmmInstination", "stmtdestINO", "stmtStINO", "stmmDestinos", "stmtDecino", "stmtStination", "stMTDestino", "stmmInstorno", "stmmDestorno", "stmtDecinos", "stmmInstinos", "stmmDestino", "stmtStino", "stmtInstination", "stMTDestINO", "stMTDecin", "stmtDecin", "stmtdestorno", "stMTDestin"], "TAMANHO_DO_CABECALHO_DO_ARQUIVO": ["TAMANHO_DO_CABECILHO", "TAMANHO_DO_CABUCALLHA", "TAMANHO_DO_CABECULHI", "TAMANHO_DO_CABUCALLHI", "TAMANHO_DO_CABECALLHO", "TAMANHO_DO_CABUCALLHO", "TAMANHO_DO_CABUCALH", "TAMANHO_DO_CABECARHA", "TAMANHO_DO_CABECALLHA", "TAMANHO_DO_CABECARH", "TAMANHO_DO_CABUCALHO", "TAMANHO_DO_CABUCALHA", "TAMANHO_DO_CABECALLHI", "TAMANHO_DO_CABUCALHI", "TAMANHO_DO_CABECULH", "TAMANHO_DO_CABECALHO", "TAMANHO_DO_CABECARHI", "TAMANHO_DO_CABECARHO", "TAMANHO_DO_CABECULHO", "TAMANHO_DO_CABECILHA", "TAMANHO_DO_CABECALHA", "TAMANHO_DO_CABECILHI", "TAMANHO_DO_CABECALH", "TAMANHO_DO_CABECILH", "TAMANHO_DO_CABUCALLH", "TAMANHO_DO_CABECALHI", "TAMANHO_DO_CABECALLH"], "TAMANHO_DO_RODAPE_DO_ARQUIVO": ["TAMANHO_DO_RODAPE2Do", "TAMANHO_DO_RODAPE_Do", "TAMANHO_DO_RODAP_do", "TAMANHO_DO_RODAP_DO", "TAMANHO_DO_RODAPE_DO", "TAMANHO_DO_RODAPEJDO", "TAMANHO_DO_RODAP_FILE", "TAMANHO_DO_RODAPEJFILE", "TAMANHO_DO_RODAPE2DO", "TAMANHO_DO_RODAPEJDo", "TAMANHO_DO_RODAPE_FILE", "TAMANHO_DO_RODAP_Do", "TAMANHO_DO_RODAPE2do", "TAMANHO_DO_RODAPE_do"], "TAMANHO_DOS_METADADOS_DO_ARQUIVO": ["TAMANHO_DOS_METADADOON", "TAMANHO_DOS_METADADO_", "TAMANHO_DOS_METADABO_", "TAMANHO_DOS_METADABOSON", "TAMANHO_DOS_METADADos_", "TAMANHO_DOS_METADADOSON", "TAMANHO_DOS_METADADSON", "TAMANHO_DOS_METADADDSON", "TAMANHO_DOS_METADADS_", "TAMANHO_DOS_METADADDS_", "TAMANHO_DOS_METADADOS_", "TAMANHO_DOS_METADABOON", "TAMANHO_DOS_METADABos_", "TAMANHO_DOS_METADABOS_"], "TAMANHO_MEDIO_POR_REGISTRO": ["TAMANHO_MEDIO_POR_REMESS", "TAMANHO_MEDIO_POR_REMIN", "TAMANHO_MEDIO_POR_REGES", "TAMANHO_MEDIO_POR_RECES", "TAMANHO_MEDIO_POR_REGIS", "TAMANHO_MEDIO_POR_REGIC", "TAMANHO_MEDIO_POR_REGIN", "TAMANHO_MEDIO_POR_REMIS", "TAMANHO_MEDIO_POR_RegIC", "TAMANHO_MEDIO_POR_Regis", "TAMANHO_MEDIO_POR_REGESS", "TAMANHO_MEDIO_POR_RECIS", "TAMANHO_MEDIO_POR_RegESS", "TAMANHO_MEDIO_POR_REGis", "TAMANHO_MEDIO_POR_RegIS", "TAMANHO_MEDIO_POR_RegES", "TAMANHO_MEDIO_POR_REMES", "TAMANHO_MEDIO_POR_RECIC", "TAMANHO_MEDIO_POR_RECis", "TAMANHO_MEDIO_POR_RegIN"], "tamanhoDosArquivos": ["tamanhoDosArquiveores", "tamanhoDosArquiveoes", "tamanhoDosArquIVs", "tamanhoDosArquivores", "tamanhoDosArquiveos", "tamanhoDosArqIVos", "tamanhoDosArquivlos", "tamanhoDosArquivalos", "tamanhoDosArqivs", "tamanhoDosArquesivalos", "tamanhoDosArquivo", "tamanhoDosArquivals", "tamanhoDosArquesivaoes", "tamanhoDosArqIVores", "tamanhoDosArqivo", "tamanhoDosArqIVs", "tamanhoDosArquesivoes", "tamanhoDosArquesivao", "tamanhoDosArquesivaos", "tamanhoDosArquesivlos", "tamanhoDosArquivao", "tamanhoDosArquivaoes", "tamanhoDosArquiveo", "tamanhoDosArquivoes", "tamanhoDosArquIVos", "tamanhoDosArquesivos", "tamanhoDosArquivelos", "tamanhoDosArquIVo", "tamanhoDosArqivos", "tamanhoDosArquIVlos", "tamanhoDosArquIVoes", "tamanhoDosArqivores", "tamanhoDosArquivaos", "tamanhoDosArquivalo", "tamanhoDosArquives", "tamanhoDosArquivalores", "tamanhoDosArquIVores", "tamanhoDosArquesivo", "tamanhoDosArqIVo", "tamanhoDosArquivs"], "quantidadeDeRegistrosEstimada": ["quantidadeDeRegistrosEstipada", "quantidadeDeRegistrosEstamadas", "quantidadeDeRegistrosEstipadas", "quantidadeDeRegistrosEstamada", "quantidadeDeRegistrosEstimado", "quantidadeDeRegistrosEstimmado", "quantidadeDeRegistrosEstamado", "quantidadeDeRegistrosEstimmada", "quantidadeDeRegistrosEstamados", "quantidadeDeRegistrosEstimmados", "quantidadeDeRegistrosEstimados", "quantidadeDeRegistrosEstimmadas", "quantidadeDeRegistrosEstipado", "quantidadeDeRegistrosEstimadas", "quantidadeDeRegistrosEstipados"], "registro": ["regitros", "Regestros", "Regestro", "regestro", "regitro", "regdistro", "registr", "regdistr", "registros", "Registros", "regestrob", "registrob", "regdistros", "regestros", "regestr", "Regestrob", "Registro", "regdistrob", "regitrob", "Registrob", "regitr", "Registr", "Regestr"], "campos": ["jamOS", " campOS", " campo", "tarOS", "tarOs", "jamo", "jamOs", "taros", "campOs", "campOS", "campo", "jamos", " campOs", "taro"]}}
{"id1": "13783898", "id2": "8430178", "code1": "    public static boolean encodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.ENCODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "code2": "    public static void copyFile(String source_name, String dest_name) throws IOException {\n        source_name = Shell.getUtils().constructPath(source_name);\n        File source_file = new File(source_name);\n        dest_name = Shell.getUtils().constructPath(dest_name);\n        File destination_file = new File(dest_name);\n        FileInputStream source = null;\n        FileOutputStream destination = null;\n        byte[] buffer;\n        int bytes_read;\n        try {\n            if (!source_file.exists() || !source_file.isFile()) throw new FileCopyException(\"cp: no such source file: \" + source_name);\n            if (!source_file.canRead()) throw new FileCopyException(\"cp: source file \" + \"is unreadable: \" + source_name);\n            if (destination_file.exists()) {\n                if (destination_file.isFile()) {\n                    BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n                    String response;\n                    if (!destination_file.canWrite()) throw new FileCopyException(\"cp: destination \" + \"file is unwriteable: \" + dest_name);\n                    System.out.print(\"cp: file \" + dest_name + \" already exists. Overwrite it ? (Y/N): \");\n                    System.out.flush();\n                    response = in.readLine();\n                    if (!response.equals(\"Y\") && !response.equals(\"y\")) throw new FileCopyException(\"cp: copy cancelled.\");\n                } else throw new FileCopyException(\"cp: destination \" + \"is not a file: \" + dest_name);\n            } else {\n                File parentdir = parent(destination_file);\n                if (!parentdir.exists()) throw new FileCopyException(\"cp: destination \" + \"directory doesn't exist: \" + dest_name);\n                if (!parentdir.canWrite()) throw new FileCopyException(\"cp: destination \" + \"directory is unwriteable: \" + dest_name);\n            }\n            source = new FileInputStream(source_file);\n            destination = new FileOutputStream(destination_file);\n            buffer = new byte[1024];\n            int size = (new Long((source_file.length() / 1024) / 50)).intValue();\n            int c = 1;\n            int written = 0;\n            System.out.print(\"cp: \");\n            while (true) {\n                if (written < 50) {\n                    if ((c - 1) == size && size != 0) {\n                        System.out.print(\"#\");\n                        c = 1;\n                        written++;\n                    } else if (size == 0) {\n                        int j = 1;\n                        if (c > 1) j = (50 / c) - 50; else j = 50 / c;\n                        for (int i = 0; i < j; i++) System.out.print(\"#\");\n                        written += j;\n                    }\n                }\n                bytes_read = source.read(buffer);\n                if (bytes_read == -1) break;\n                destination.write(buffer, 0, bytes_read);\n                c++;\n            }\n            System.out.println();\n        } finally {\n            if (source != null) try {\n                source.close();\n            } catch (IOException e) {\n            }\n            if (destination != null) try {\n                destination.close();\n            } catch (IOException e) {\n            }\n        }\n    }\n", "label": 1, "substitutes": {"encodeFileToFile": ["encodeStringAsFile", "encodeFileToFiles", "encodeFileToDisk", "encodeFileAsFile", "encodeStringToFile", "encodeFileToStream", "encodeFileFromFiles", "encodeStringAsDisk", "encodeStringAsStream", "encodeFiletoFile", "encodeFileAsStream", "encodeStringToDisk", "encodeFileAsDisk", "encodeFiletoDisk", "encodeFiletoFiles", "encodeStringToFiles", "encodeFileFromStream", "encodeFileAsFiles", "encodeFileFromDisk", "encodeStringAsFiles", "encodeFiletoStream", "encodeFileFromFile", "encodeStringToStream"], "infile": ["inputfilename", "inputFile", "outbase", "outFile", " inFile", "inpath", " inbase", " infilename", "outfilename", "inbase", "InFile", "infilename", "inFile", "inputfile", "Inbase", "inputpath", " inpath", "Inpath", "outpath", "Infile"], "outfile": ["outfp", "newFile", "outname", "newfile", "indir", " outname", "outFile", "outdir", "fromfile", "outfilename", "inname", "newname", " outfilename", "tofp", "infilename", "todir", "inFile", "infp", "toFile", "newfilename", "fromfp", " outFile", "fromdir", "tofile", "fromFile"], "in": ["rin", "en", "image", "inn", "ini", "by", "gin", "con", "IN", "ins", "pin", "im", "ar", "on", "oin", "ro", "al", "In", "t", "inner", "inside", "init", "re", "up", "i", "bin", "get", "inc", "input", "amin", "or", "iter", "it", "per", " din", "form", "conn", "ain", "ind", "nin", "info", "din", "inf", "is", "isin", "source", "cin", "id", "from"], "out": ["ion", "co", "en", "nt", "flush", "con", "output", "res", "oss", "cn", "on", "sys", "t", "inner", "net", "write", "print", "b", "to", "end", "opt", "up", "writer", "os", "outer", "it", "OU", "gt", "null", "ou", "at", "outs", "g", "o", "aos", "ex", "n", "io", "Out", "file", "fn", "OUT", "can", "ne", "ot"], "buffer": ["phrase", "buf", "window", "bone", "block", "buff", "sample", "column", "frame", "comment", "view", "sequence", "append", "table", "pad", "library", "mem", "base", "template", "command", "attribute", "document", "message", "available", "stack", "number", "cache", "Buffer", "variable", "black", "total", "initial", "note", "history", "paste", "queue", "length", "binary", "batch", "bar", "padding", "info", "row", "display", "temp", "button", "password", "memory", "print", "header", "character"], "read": ["first", "each", "text", "find", "select", "reader", "wait", "allow", "raw", "stream", "set", "run", "before", "range", "write", "open", "push", "readable", "load", "print", "reads", "hold", "seek", "close", "i", "req", "skip", "get", " Read", "give", "input", "need", "iter", "through", "query", "len", "length", "Read", "ind", "add", "connect", "count", "n", "ready", "start", "size", "reading", "send", "check", "index", "READ", "end", "ok"], "success": ["first", "same", "good", "response", "value", " succ", "ceed", "cess", "positive", "fail", "city", "release", " successful", "summary", "please", "status", " Success", "ith", "accept", "Success", "danger", "done", "ratulations", "ccess", "growth", "warning", "primary", "result", "safe", " okay", "second", "unity", "crit", "condition", "successful", " failure", "sufficient", "error", "valid", "complete", "commit", "snap", "democracy", "continue", "photo", "surv", "successfully", "town", "submit", "support", " successes", "setup", "ok"]}}
{"id1": "3584508", "id2": "539195", "code1": "    private void copyResource() throws Exception {\n        URL url = getResource(source);\n        InputStream input;\n        if (url != null) {\n            input = url.openStream();\n        } else if (new File(source).exists()) {\n            input = new FileInputStream(source);\n        } else {\n            throw new Exception(\"Could not load resource: \" + source);\n        }\n        OutputStream output = new FileOutputStream(destinationFile());\n        int b;\n        while ((b = input.read()) != -1) output.write(b);\n        input.close();\n        output.close();\n    }\n", "code2": "    static void copy(String src, String dest) throws IOException {\n        File ifp = new File(src);\n        File ofp = new File(dest);\n        if (ifp.exists() == false) {\n            throw new IOException(\"file '\" + src + \"' does not exist\");\n        }\n        FileInputStream fis = new FileInputStream(ifp);\n        FileOutputStream fos = new FileOutputStream(ofp);\n        byte[] b = new byte[1024];\n        while (fis.read(b) > 0) fos.write(b);\n        fis.close();\n        fos.close();\n    }\n", "label": 1, "substitutes": {"copyResource": [" copiedResource", " copiedAddress", " copyAddress", "copyFile", "copyAddress", " copyUrl", " copiedUrl", "downloadAddress", "downloadFile", "downloadResource", "copyUrl", "downloadUrl", " copyFile", " copiedFile"], "url": ["f", "browser", "gif", "hl", "gl", "address", "ref", "dl", "util", "service", "resource", "https", "ls", "web", "ll", "base", "char", "link", "sl", "cert", "rel", "re", "ur", "mount", "uri", "URL", "str", "rl", "l", "nl", "ul", "mail", "path", "null", "mb", "github", "r", "ssl", "el", "ret", "http", "string", "html", "file", "source", "loc", "Url", "ml", "host", "fl", "cl"], "input": ["empty", "access", "active", "image", "text", "select", "cont", "request", "unknown", "reader", "op", "raw", "stream", "sum", "context", "before", "feed", "base", "in", "accept", "inner", "PUT", "inside", "init", "open", "Input", "missing", "up", "read", "act", "state", "get", "initial", "upload", "pull", "it", "iter", "parse", "audio", "form", "null", "ain", "focus", "enter", "eval", "ip", "add", "ssl", "local", "info", "http", "config", "start", "exec", "file", "source", "acl", "index", "user", "can", "qa"], "output": ["beta", "response", "image", "text", "ilo", "put", "console", "next", "other", "client", "web", "table", "Output", "connection", "four", "net", "print", "write", "secure", "current", "you", "format", "unsigned", "position", "hidden", "success", "entity", "out", "outer", "exit", "secondary", "object", "component", "null", "continue", "bool", "ou", "group", "network", "o", "auto", "remote", "icon", "file", "online", "update", "ne", "display"], "b": ["u", "f", "sb", "B", "br", "bf", "buff", "by", "j", "bit", "block", "y", "p", "z", "cb", "d", "ob", "obj", "m", "bs", "bc", "wb", "t", "base", "char", "be", "k", "bi", "bits", "c", "bb", "db", "v", "i", "bp", "nb", "ba", "rb", "l", "eb", "binary", "mb", "g", "r", "ble", "body", "fb", "gb", "ib", "ab"]}}
{"id1": "6188784", "id2": "23666867", "code1": "    public static void copy(File source, File dest) throws IOException {\n        FileChannel in = null, out = null;\n        try {\n            in = new FileInputStream(source).getChannel();\n            out = new FileOutputStream(dest).getChannel();\n            long size = in.size();\n            MappedByteBuffer buf = in.map(FileChannel.MapMode.READ_ONLY, 0, size);\n            out.write(buf);\n        } finally {\n            if (in != null) in.close();\n            if (out != null) out.close();\n        }\n    }\n", "code2": "    public static void copyFile(File in, File out) {\n        try {\n            FileChannel inChannel = null, outChannel = null;\n            try {\n                out.getParentFile().mkdirs();\n                inChannel = new FileInputStream(in).getChannel();\n                outChannel = new FileOutputStream(out).getChannel();\n                outChannel.transferFrom(inChannel, 0, inChannel.size());\n            } finally {\n                if (inChannel != null) {\n                    inChannel.close();\n                }\n                if (outChannel != null) {\n                    outChannel.close();\n                }\n            }\n        } catch (Exception e) {\n            ObjectUtils.throwAsError(e);\n        }\n    }\n", "label": 1, "substitutes": {"copy": ["cat", " replicate", "sync", "create", " Copy", "link", "transfer", "Copy", "slice", "delete", "load", "cp", "read", "gc", " copying", "upload", " move", " mirror", "paste", "download", " duplicate", "save", "clip", " clone", "clone", " dup", " cp", "move"], "source": ["origin", "style", "image", "subject", "sample", "sp", "original", "resource", "se", "view", "sys", "site", "init", "base", "ce", "template", "spec", "scope", "src", "Source", "target", "SOURCE", "sf", "input", "iter", "query", "sql", "parent", "search", "seed", "ource", "space", "s", "null", "scene", "start", "check", "from"], "dest": ["origin", "exp", "decl", "good", "usr", "that", "img", "orig", "them", "test", "d", "cont", "way", "tom", "then", "trans", "https", "est", "rest", "del", "pot", "th", "cas", "master", "lit", "result", "src", "bin", "target", "foreign", "des", "it", "this", "search", "st", "null", "dir", "nom", "nw", "Dest", "dist", "loc", "deg"], "in": ["all", "mi", "co", "rin", "en", "win", "inn", "ini", "gin", "con", "min", "IN", "vin", "ins", "ln", "on", "oin", "doc", "al", "In", "init", "inner", "inside", "one", "ca", "net", "old", "from", "ai", "up", "i", "bin", "ac", "pi", "inc", "get", "l", "input", "or", "sin", "it", "ch", " IN", "conn", "ain", "ind", "nin", "r", "ma", "mc", "mm", "n", "info", "local", "din", "inf", "is", "isin", "cin", "can", "like"], "out": ["ion", "co", "en", "nt", "na", "con", "output", "om", "oe", "cos", "oss", "res", "cn", "ln", "client", "on", "not", "t", "inner", "ns", "conv", "net", "c", "write", "to", "opt", "up", "v", "over", "ext", "cache", "ac", "writer", "os", "outer", "ent", "it", "ch", "gt", "note", "cmd", "conn", "null", "ou", "at", "outs", "aos", "o", "ex", "n", "io", "msg", "no", "server", "Out", "OUT", "user", "can", "ne", "ot"], "size": ["ze", "empty", "export", "en", "sm", "notice", "small", "sample", "fee", "sp", "city", "capacity", "speed", "score", "area", "sum", "set", "range", "buffer", "write", "shape", "max", "close", "number", "read", "see", "name", "now", "position", "get", "total", "SIZE", "len", "length", "si", "space", "height", "amount", "sn", "num", "sy", "count", "n", "scale", "gets", "Size", "is", "width", "send", "file", "body", "start", "ize", "bytes"], "buf": ["seq", "good", "cv", "nm", "br", "buff", "cat", "orig", "func", "cam", "cb", "next", "bh", "foo", "bc", "buffer", "fam", "bag", "b", "pkg", "result", "db", "aka", "bp", "Buffer", "rb", "uf", "tab", "cmd", "queue", "batch", "bar", "row", "Buff", "cap", "msg", "job", "map", "vec", "data", "gen"]}}
{"id1": "8452134", "id2": "2009072", "code1": "    public int exists(String fileToCheck) throws IOException {\n        FTPClient ftp = new FTPClient();\n        int found = 0;\n        try {\n            int reply = 0;\n            ftp.connect(this.endpointURL, this.endpointPort);\n            reply = ftp.getReplyCode();\n            if (!FTPReply.isPositiveCompletion(reply)) {\n                ftp.disconnect();\n                throw new IOException(\"Ftp exists server refused connection.\");\n            }\n            if (!ftp.login(\"anonymous\", \"\")) {\n                ftp.logout();\n                throw new IOException(\"FTP: server wrong passwd\");\n            }\n            ftp.enterLocalPassiveMode();\n            if (ftp.listNames(fileToCheck) != null) {\n                found = 1;\n            }\n            ftp.logout();\n        } catch (Exception e) {\n            throw new IOException(e.getMessage());\n        }\n        return found;\n    }\n", "code2": "    public InputStream openInput(Fragment path) throws IOException {\n        int len = path.words().size();\n        String p = Util.combine(\"/\", path.words().subList(1, len));\n        URL url = new URL(\"http\", path.words().get(0), p);\n        InputStream result = url.openStream();\n        return result;\n    }\n", "label": 0, "substitutes": {"exists": ["Exits", "exinates", "existinates", "Exists", "exits", "extists", "existits", "Exinates", "extits", "exist", " exies", "exception", "Exies", "xits", "comists", "exies", " exits", "xist", "comist", "comits", "existies", "existists", "xists", " exinates", "extist", "extception", "comception", "xception"], "fileToCheck": ["filenameTOTest", "filenameTOcheck", "fileTOCheck", "fileTOSee", "fileTOTest", "filetoTest", "pathToWatch", "pathTOSee", "fileToSee", "file2Check", "file2Test", "filetoCheck", "filetoWatch", "pathTOWatch", "filenameToCheck", "pathToTest", "filenameTocheck", "fileTocheck", "filenameToTest", "pathToCheck", "pathTOTest", "fileToWatch", "pathTOCheck", "file2check", "fileTOWatch", "filetoSee", "pathToSee", "fileTOcheck", "filenameTOCheck", "fileToTest"], "ftp": [" ftph", "aftm", "aptp", " ftchange", "ctps", "ffcache", "ftr", "aftt", "ctp", "fabph", "ftt", " ftps", " ftpl", "cttp", "fabphp", "iftp", "fttp", "aftchange", "ftc", "ffp", " fttp", "afttp", " ftt", "aftc", " ftv", "fabc", "latphp", "ffphp", "ftphp", " ftphp", "rotp", "ctcp", "lattp", "rotps", "aftr", "rotchange", "rottp", "ldp", "iftphp", "ftm", "ldphp", "fftp", "ffr", " ftr", "ftchange", "rotcp", "aftl", "aftv", "apttp", "latp", " ftm", "ftv", "aftpl", "ldc", "ftpl", "ftps", "ftph", "fft", "ftl", "aptl", "rotl", "ftcp", "aftcp", "ldph", " ftc", " ftl", " ftcp", "fabp", "ffc", "iftcache", "aftp", "rotm", "ftcache", "latcache", "aptcp", "rotpl", "ffv", "ffcp", "ifttp"], "found": ["installed", "killed", "expected", "good", "Found", "find", "built", "d", " Found", "finder", "finished", "done", "Find", "fd", "result", "identified", "started", "seen", "fixed", "printed", "successful", "enabled", "success", "out", "valid", "matched", "tested", "loaded", "search", "initialized", "checked", "created", "successfully", "ed", "full", "count", "sent", "failed", "affected", "index", "id", "needed", "elt", "results", "filled"], "reply": ["echo", "back", "report", "pop", "mi", "txt", "response", "embed", "notice", "match", "sync", "next", "py", "comment", "force", "status", "base", "code", "ply", "link", "replace", "message", "ping", "result", "close", "onse", "strip", "conf", " Reply", "post", "nb", "state", "error", "success", "vote", "len", "cor", "nl", "answer", "continue", "flag", "record", "ret", "count", "Reply", "msg", "repl", "shell", "zero", "index", "check", "print", "push"]}}
{"id1": "9272325", "id2": "335223", "code1": "    private static HttpURLConnection sendPost(String reqUrl, Map<String, String> parameters) {\n        HttpURLConnection urlConn = null;\n        try {\n            String params = generatorParamString(parameters);\n            URL url = new URL(reqUrl);\n            urlConn = (HttpURLConnection) url.openConnection();\n            urlConn.setRequestMethod(\"POST\");\n            urlConn.setConnectTimeout(5000);\n            urlConn.setReadTimeout(5000);\n            urlConn.setDoOutput(true);\n            byte[] b = params.getBytes();\n            urlConn.getOutputStream().write(b, 0, b.length);\n            urlConn.getOutputStream().flush();\n            urlConn.getOutputStream().close();\n        } catch (Exception e) {\n            throw new RuntimeException(e.getMessage(), e);\n        }\n        return urlConn;\n    }\n", "code2": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "label": 0, "substitutes": {"sendPost": ["doPost", "doGet", "sendGet", "httpPost", "executeGet", "sendPOST", "doRequest", "httpGet", "executePOST", "doPOST", "executePost", "sendRequest", "httpPOST", "executeRequest", "httpRequest"], "reqUrl": [" reqPath", "reqPath", "resStr", " reqName", "requestUrl", " reqStr", " reqLink", "seqUrl", "resUrl", "requURL", "seqURL", "requestURL", "requLink", "resPath", "requestStr", "resURL", "requestPath", "reqStr", "seqLink", " reqURL", "seqName", "reqURL", "requName", "reqLink", "requUrl", "reqName"], "parameters": ["pareters", "prometers", "parmes", "paramams", "promams", "equeters", "prommes", "paramations", "publiceter", "parammes", "paramuments", "publicams", "prometer", "paruments", "publiceters", "promuments", "publications", "promations", "aramuments", "pareter", "equations", "equams", "arameter", "equeter", "arammes", "arameters", "parameter"], "urlConn": ["objCtrl", "belCond", "sslConn", " urlCon", " urlConnect", "rowconn", "utilConnection", "sslDesc", "urlCon", "utilConnector", "sslCon", "httpConnect", "mountCtrl", "fileConn", "sslConnector", "mountLink", "urlCtrl", "relconn", "URLCon", "urlWr", "urlconn", "relConnection", "belConnection", "mountWr", "retconn", "retConnect", "fileConnection", "objConn", "utilConnect", "sslCond", "fileCon", "urlCo", "nlConn", "mountConnector", "fileconn", "sslconn", "rowCo", "urlConnector", "implConn", "belConn", "mountconn", "webConnect", "retConn", " urlConnector", "urlDesc", "nlConnect", "implDesc", "belDesc", "nlConnector", "resourceconn", "nlConnection", "mountConn", " urlCtrl", "urlLink", "rowConnection", "leftCon", "webConn", " urlLink", "relCo", "urlConnect", "resourceConn", "implConnection", "sslConnection", " urlWr", "utilConn", "objCo", "urlConnection", "rowConn", " urlConnection", " urlCo", "URLConn", "relConn", "objconn", "mountCo", "leftconn", "sslCo", "resourceWr", " urlconn", "httpConnector", "resourceLink", "URLconn", "sslConnect", "httpConn", "leftConn", "webconn", "httpConnection", "implCond", "leftConnect", "URLConnect", "relConnector", "urlCond"], "params": ["terms", "services", "tags", "json", "options", "keys", "m", "types", "names", "changes", "base", "phys", "pins", "ps", "conf", "v", "properties", "ams", "param", "rs", "pps", "bytes", "points", "Parameters", "s", "AMS", "results", "padding", "string", "config", "files", "values", "posts", "password", "p", "units", "data", "prefix"], "url": ["f", "hl", "sb", "au", "dl", "lb", "https", "bel", "ls", "web", "ll", "t", "base", "build", "log", "sl", "pkg", "ur", "mount", "uri", "URL", "name", "get", "rl", "str", "l", "out", "uu", "nl", "ul", "r", "ssl", "el", "self", "http", "location", "loc", "il", "Url", "loader", "abs"], "b": ["f", "buf", "sb", "br", "buff", "bf", "z", "block", "u", "bit", "B", "cb", "d", "ob", "obj", "m", "bs", "bc", "base", "be", "buffer", "orb", "bits", "bb", "db", "bp", "v", "i", "bin", "nb", "rb", "l", "it", "eb", "s", "binary", "mb", "batch", "bis", "r", "n", "fb", "gb", "p", "a", "bytes", "w"]}}
{"id1": "18504192", "id2": "3958807", "code1": "    static void copyFile(File in, File out) throws IOException {\n        FileChannel source = new FileInputStream(in).getChannel();\n        FileChannel destination = new FileOutputStream(out).getChannel();\n        source.transferTo(0, source.size(), destination);\n        source.close();\n        destination.close();\n    }\n", "code2": "        private void loadBinaryStream(String streamName, InputStream streamToLoad, long sz, HttpServletRequest req, HttpServletResponse resp) throws IOException {\n            resp.setContentType(getContentType(req, streamName));\n            resp.setHeader(\"Content-Disposition\", \"inline;filename=\" + streamName);\n            resp.setContentLength((int) sz);\n            OutputStream out = resp.getOutputStream();\n            BufferedOutputStream bos = new BufferedOutputStream(out, 2048);\n            try {\n                IOUtils.copy(streamToLoad, bos);\n            } finally {\n                IOUtils.closeQuietly(streamToLoad);\n                IOUtils.closeQuietly(bos);\n            }\n            getCargo().put(GWT_ENTRY_POINT_PAGE_PARAM, null);\n        }\n", "label": 1, "substitutes": {"copyFile": ["CopyFiles", " transferFile", "copyFiles", "CopyStream", " transferFiles", " CopyStream", "copyStream", "copyfile", " Copyfile", " CopyFiles", "CopyFile", " transferStream", " CopyFile", "Copyfile", " transferfile"], "in": ["rin", "en", "inn", "gin", "IN", "vin", "ins", "on", "In", "old", "b", "ic", "edIn", "up", "i", "inc", "l", "input", "or", "it", "ind", "o", "el", "mm", "n", "din", "inf", "is", "isin", "as", "cin", "id", "from"], "out": ["nt", "output", "oss", "help", "t", "po", "k", "net", "log", "err", "b", "to", "ot", "v", "i", "serv", "os", "l", "it", "gt", "ou", "at", "outs", "g", "o", "s", "ex", "n", "io", "Out", "OUT", "ne", "w"], "source": ["origin", "back", "scan", "style", "access", "subject", "match", "sample", "ie", "service", "pse", "resource", "se", "reader", "comment", "sequence", "secret", "create", "force", "before", "init", "inner", "template", "me", "store", "inside", "spec", "scope", "open", "system", "src", "Source", "copy", "position", "SOURCE", "input", "sin", "query", "parse", "search", "seed", "ource", "space", "instance", "use", "iterator", "local", "info", "volume", "ources", "start", "file", "shell", "from"], "destination": ["Destation", "restinated", " destregation", " destation", "coordregation", " destification", "comification", "restinator", "destregation", " destension", "restation", "destension", "comato", "seeinator", "coordification", "destation", "comregation", "Destinated", " destinator", "Destinator", "coordato", " destato", "coordination", " destinated", "seeination", "seeension", "destification", "destinated", "seeinated", "destato", "Destination", "Destension", "destinator", "restination", "comination"]}}
{"id1": "3731077", "id2": "7425022", "code1": "    public static void copyFile(File from, File to) throws IOException {\n        assert (from != null);\n        assert (to != null);\n        if (!to.exists()) {\n            File parentDir = to.getParentFile();\n            if (!parentDir.exists()) parentDir.mkdirs();\n            to.createNewFile();\n        }\n        FileInputStream in = null;\n        FileOutputStream out = null;\n        try {\n            in = new FileInputStream(from);\n            try {\n                out = new FileOutputStream(to);\n                FileChannel ic = in.getChannel();\n                try {\n                    FileChannel oc = out.getChannel();\n                    try {\n                        oc.transferFrom(ic, 0, from.length());\n                    } finally {\n                        if (oc != null) {\n                            oc.close();\n                        }\n                    }\n                } finally {\n                    if (ic != null) {\n                        ic.close();\n                    }\n                }\n            } finally {\n                if (out != null) {\n                    out.close();\n                }\n            }\n        } finally {\n            if (in != null) {\n                in.close();\n            }\n        }\n    }\n", "code2": "    private String transferWSDL(String wsdlURL, String userPassword) throws WiseConnectionException {\n        String filePath = null;\n        try {\n            URL endpoint = new URL(wsdlURL);\n            HttpURLConnection conn = (HttpURLConnection) endpoint.openConnection();\n            conn.setDoOutput(false);\n            conn.setDoInput(true);\n            conn.setUseCaches(false);\n            conn.setRequestMethod(\"GET\");\n            conn.setRequestProperty(\"Accept\", \"text/xml,application/xml,application/xhtml+xml,text/html;q=0.9,text/plain;q=0.8,image/png,*/*;q=0.5\");\n            conn.setRequestProperty(\"Connection\", \"close\");\n            if (userPassword != null) {\n                conn.setRequestProperty(\"Authorization\", \"Basic \" + (new BASE64Encoder()).encode(userPassword.getBytes()));\n            }\n            InputStream is = null;\n            if (conn.getResponseCode() == 200) {\n                is = conn.getInputStream();\n            } else {\n                is = conn.getErrorStream();\n                InputStreamReader isr = new InputStreamReader(is);\n                StringWriter sw = new StringWriter();\n                char[] buf = new char[200];\n                int read = 0;\n                while (read != -1) {\n                    read = isr.read(buf);\n                    sw.write(buf);\n                }\n                throw new WiseConnectionException(\"Remote server's response is an error: \" + sw.toString());\n            }\n            File outputDir = new File(wiseProperties.getProperty(\"wise.tmpDir\"));\n            if (!outputDir.exists()) {\n                outputDir.mkdir();\n                wiseProperties.setProperty(\"wise.forceImportObject\", \"true\");\n            }\n            File file = new File(wiseProperties.getProperty(\"wise.tmpDir\"), new StringBuffer(\"Wise\").append(IDGenerator.nextVal()).append(\".xml\").toString());\n            OutputStream fos = new BufferedOutputStream(new FileOutputStream(file));\n            IOUtils.copyStream(fos, is);\n            fos.close();\n            is.close();\n            filePath = file.getPath();\n        } catch (WiseConnectionException wce) {\n            throw wce;\n        } catch (Exception e) {\n            throw new WiseConnectionException(\"Wsdl download failed!\", e);\n        }\n        return filePath;\n    }\n", "label": 1, "substitutes": {"copyFile": ["CopyFiles", " cpfile", "CopyDirectory", "copyFiles", " cpFile", "downloadfile", "downloadFile", "downloadDirectory", "copyfile", " cpDirectory", " cpFiles", "CopyFile", "copyDirectory", "Copyfile", "downloadFiles"], "from": ["origin", "f", "by", "vol", "orig", "reset", "From", "original", "part", "se", "a", "view", "fr", "what", "before", "base", "range", "link", "old", "db", "un", "of", "org", "pro", "url", "name", "str", "input", "or", "without", "query", "st", "form", "rom", "term", "at", "path", "s", "ol", "bean", "add", "por", "star", "local", "info", "html", "config", "string", "with", "start", "as", "source", "file", "so", "data"], "to": ["f", "co", "nt", "that", "by", "To", "output", "two", "dest", "toc", "bo", "tom", "on", "TO", "table", "t", "tt", "base", "po", "template", "one", "tu", "th", "must", "org", "none", "name", "eto", "pt", "token", "target", "top", "total", "too", "or", "pretty", "it", "into", "parent", "this", "st", "tree", "null", "o", "oto", "etc", "auto", "full", "te", "html", "no", "temp", "size", "file", "ta", "phi"], "parentDir": ["masterDir", "masterFile", "parentDirectory", "masterFolder", "rootDir", " parentFile", " parentdir", "netDir", "parentFolder", "rootFile", "Parentdir", "netdir", "ParentDir", "netFile", "rootFolder", "parentFile", "ParentFile", "ParentFolder", "netFolder", "rootdir", " parentDirectory", "ParentDirectory", " parentFolder", "masterDirectory", "parentdir"], "in": ["all", "mi", "rin", "en", "win", "inn", "ini", "gin", "con", "min", "IN", "vin", "ins", "ri", "on", "doc", "raw", "al", "update", "In", "init", "inner", "inside", "one", "net", "print", "re", "up", "conf", "i", "irc", "xml", "bin", "get", "inc", "input", "sin", "it", " IN", "ir", "form", "ain", "ind", "o", "ma", "mc", "mm", "local", "config", "din", "inf", "is", "isin", "source", "cin", "id"], "out": ["ion", "all", "co", "na", "nt", "vol", "output", "res", "cos", "con", "oss", "cn", "op", "obj", "ln", "on", "client", "sys", "ro", "conv", "t", "ns", "one", "net", "c", "write", "go", "b", "err", "list", "v", "i", "gc", "os", "or", "outer", "it", "gt", "cmd", "css", "null", "ou", "at", "aos", "g", "o", "outs", "nin", "ex", "again", "auto", "n", "io", "no", "Out", "file", "OUT", "can", "ne", "ot"], "ic": ["ric", "co", "ics", "wic", "rc", "ins", "mic", "ico", "cus", "bc", "iu", "c", "icy", "fc", "cu", "ci", "sic", "i", "irc", "ac", "pc", "vc", "tic", "inc", "ix", "it", "aic", "isc", "pic", "ican", "tc", "ip", "IC", "arc", "icc", "icon", "nic", "cin", "eric", "ik", "iac", "cc", "ot"], "oc": ["ric", "ocon", "co", "oct", "ict", "cos", "oe", "alloc", "oca", "toc", "mic", "voc", "osc", "ico", "cus", "ocr", "c", "OC", "ci", "soc", "cu", "irc", "gc", "oco", "mot", "ac", "ox", "aco", "pc", "vc", "roc", "ec", "aic", "pic", "tc", "og", "o", "unc", "nc", "arc", "yo", "oci", "ucc", "nic", "oly", "anc", "cot", "ot"]}}
{"id1": "14303294", "id2": "16556717", "code1": "    public String getServerHash(String passwordHash, String PasswordSalt) throws PasswordHashingException {\n        byte[] hash;\n        try {\n            MessageDigest digest = MessageDigest.getInstance(\"SHA-256\");\n            digest.reset();\n            digest.update(PasswordSalt.getBytes(\"UTF-16\"));\n            hash = digest.digest(passwordHash.getBytes(\"UTF-16\"));\n            return bytesToHex(hash);\n        } catch (NoSuchAlgorithmException ex) {\n            throw new PasswordHashingException(\"Current environment does not supply needed security algorithms. Please update Java\");\n        } catch (UnsupportedEncodingException ex) {\n            throw new PasswordHashingException(\"Current environment does not supply needed character encoding. Please update Java\");\n        }\n    }\n", "code2": "    public static String getSHADigest(String password) {\n        String digest = null;\n        MessageDigest sha = null;\n        try {\n            sha = MessageDigest.getInstance(\"SHA-1\");\n            sha.reset();\n            sha.update(password.getBytes());\n            byte[] pwhash = sha.digest();\n            digest = \"{SHA}\" + new String(Base64.encode(pwhash));\n        } catch (NoSuchAlgorithmException nsae) {\n            CofaxToolsUtil.log(\"Algorithme SHA-1 non supporte a la creation du hashage\" + nsae + id);\n        }\n        return digest;\n    }\n", "label": 1, "substitutes": {"getServerHash": ["toServerHash", "toServerSalt", "getServerPassword", "getServerMac", "toServerPassword", "getClientSalt", "getUserMac", "getServerSalt", "getUserHash", "getserverSalt", "toClientMac", "toClientPassword", "getUserSalt", "getserverHash", "toServerMac", "getserverMac", "getserverPassword", "getClientMac", "getClientHash", "getUserPassword", "toClientHash", "getClientPassword", "toClientSalt"], "passwordHash": ["passwordSalt", "swordHash", "passwordHas", "PasswordHas", "serverHash", "PasswordPassword", "passwordKey", "serverSalt", "PasswordKey", "emailHTML", "serverKey", "PasswordHash", "emailHas", "PasswordHTML", "swordSalt", "swordHas", "swordHTML", "serverPassword", "passwordPassword", " passwordSalt", " passwordPassword", "emailHash", "emailSalt", "passwordHTML", " passwordKey"], "PasswordSalt": ["PasswordToken", " PasswordToken", "passwordSalt", "UserSecret", "UserSalt", "passwordToken", "UserToken", "PasswordSecret", "passwordSecret", "PasswordPassword", " PasswordSecret", "PasswordHash", "passwordPassword", " passwordSalt", " passwordPassword", " passwordToken", "UserHash", " PasswordPassword", " PasswordHash"], "hash": ["echo", "report", "transform", "handle", "mask", "address", "value", "block", "ash", "Hash", "json", "response", "match", "shift", "sample", "test", "serial", "h", "word", "score", "sum", "tag", "sha", "char", "build", "log", "message", "result", "cache", "sh", "copy", "total", "hex", "search", "component", "height", "dig", "filter", "key", "row", "html", "password", "mac", "index", "map", "print", "crypt"], "digest": ["mdester", "dested", "descested", " digse", "decest", "diggest", "hashester", "dest", "decester", "digse", "Digester", "displaygest", "mdEST", "displayester", "Digse", "dEST", "digEST", "descse", "Diggest", "displayest", "mdest", "displayested", "descester", "decested", "hashested", " digester", "Digested", "hashest", "decse", "descest", "mdested", " digEST", "digested", "digester", "dester", "hashgest", "DigEST", " digested", "Digest"]}}
{"id1": "7945594", "id2": "12039034", "code1": "    public static void fileDownload(String fAddress, String destinationDir) {\n        int slashIndex = fAddress.lastIndexOf('/');\n        int periodIndex = fAddress.lastIndexOf('.');\n        String fileName = fAddress.substring(slashIndex + 1);\n        URL url;\n        try {\n            url = new URL(fAddress);\n            URLConnection uc = url.openConnection();\n            BufferedReader in = new BufferedReader(new InputStreamReader(uc.getInputStream()));\n            File file = new File(destinationDir + \"/download.pdf\");\n            FileOutputStream fos = new FileOutputStream(file);\n            BufferedWriter out = new BufferedWriter(new OutputStreamWriter(fos));\n            int inputLine;\n            while ((inputLine = in.read()) != -1) out.write(inputLine);\n            in.close();\n        } catch (Exception ex) {\n            Logger.getLogger(UrlDownload.class.getName()).log(Level.SEVERE, null, ex);\n        }\n    }\n", "code2": "    public static ArrayList<RoleName> importRoles(String urlString) {\n        ArrayList<RoleName> results = new ArrayList<RoleName>();\n        try {\n            URL url = new URL(urlString);\n            BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream()));\n            StringBuffer buff = new StringBuffer();\n            String line;\n            while ((line = in.readLine()) != null) {\n                buff.append(line);\n                if (line.equals(\"</RoleName>\")) {\n                    RoleName name = ProfileParser.parseRoleName(buff.toString());\n                    results.add(name);\n                    buff = new StringBuffer();\n                } else {\n                    buff.append(NL);\n                }\n            }\n        } catch (MalformedURLException e) {\n        } catch (IOException e) {\n        } catch (ParsingException e) {\n        }\n        return results;\n    }\n", "label": 1, "substitutes": {"fileDownload": ["urlGet", "urlUpdate", "FileGet", "fileUpdate", "urlDownload", "Filedownload", "FileUpdate", "filedownload", " filedownload", "fileGet", " fileUpdate", " fileGet", "FileDownload", "urldownload"], "fAddress": ["FAddress", "sfOrder", "feAdd", "fmOrder", "fdAddress", "fAdd", "eAdd", "xfLocation", "pAddress", "xfURI", "vAddress", "fiAlias", "pURI", "xfAddress", "fContact", "hURI", "FAdd", "pValue", "fdAdd", "eAdmin", "sfAddress", "vaddress", "FContact", " fURL", "eOrder", "feAdmin", "faddress", "fiLocation", "hAdd", "fmContact", "fiURL", "fAlias", "fiaddress", "xfAdd", "vLocation", "xfDomain", "fmAddress", "fmPart", "fdURL", "fURL", "fURI", "pAdd", "sfPart", " fAlias", "fiDomain", "hValue", "xfaddress", "feAddress", "vDomain", "fDomain", "eAddress", "FAdmin", "fAdmin", "fValue", "fOrder", "feOrder", " fAdd", "fiAddress", "fiAdd", "xfValue", "sfContact", "hAddress", "fLocation", "FOrder", "FPart", "fPart", "fdAlias"], "destinationDir": ["declinationDirectory", "DestificationDir", "DestinationDirector", "destinedFolder", "destificationDirectory", "declificationDirectory", "destarationdir", "declinationdir", "destinationsFolder", "DestinationFolder", "destinationFolder", "DestificationDirector", "destinedDirector", "destinationDirector", "destarationFolder", "DestinationDir", "destificationDirector", "destificationdir", "destacementDirectory", "declificationFolder", "Destinationdir", "destarationDirector", "declificationdir", "destificationFolder", "destinationdir", "destinationsDir", "declinationDir", "destificationDir", "destinationsDirectory", "Destificationdir", "destineddir", "destarationDir", "destinedDir", "declinationFolder", "destinationsdir", "destinationDirectory", "DestificationFolder", "destacementdir", "declificationDir", "destacementDir", "destacementFolder"], "slashIndex": ["swasherIndex", "slasherIndex", "swasherPosition", "slashedCount", "sllashCount", "slasherPosition", "slugindex", "slashedNumber", "swashIndex", "swasherNumber", "flashPosition", "slashesPosition", "flashInd", "sllashIndex", "sllashPosition", "sllashNumber", "swashPosition", "sllashInd", "slashPosition", "slashesIndex", "slugPosition", "sllashindex", "slashindex", "slashNumber", "swashCount", "slashedPosition", "slasherCount", "swasherCount", "slashInd", "slugInd", "slashedIndex", "fllashIndex", "slasherNumber", "flashindex", "swashNumber", "slashesInd", "slashesindex", "slugIndex", "flashIndex", "fllashInd", "fllashPosition", "slashCount", "fllashindex"], "periodIndex": ["pieCounter", "pieIndex", "dollarPosition", "tickCounter", "tickMax", "periodCounter", "dollarIndex", "pieMax", "tickIndex", "tickPosition", "dollarMax", "piePosition", "dollarCounter", "periodPosition", "periodMax"], "fileName": ["FileKey", "pageInfo", " filename", "pagename", " fileKey", "fileInfo", "filename", "Filename", "FileName", " fileInfo", "pageKey", "pageName", "fileKey", "FileInfo"], "url": ["browser", "hl", "gl", "address", "u", "con", "util", "www", "client", "https", "bel", "raw", "web", "ll", "base", "char", "link", "pl", "build", "sl", "cert", "impl", "re", "un", "ur", "org", "com", "rel", "mount", "uri", "URL", "xml", "str", "rl", "l", "or", "nl", "ul", "mail", "cal", "conn", "github", "r", "ssl", "el", "ret", "http", "job", "loc", "il", "Url", "ml", "cl"], "uc": ["co", "rc", "um", "us", "con", "cr", "ux", "oc", "auc", "cus", "bc", "c", "fc", "soc", "cu", "ci", "cur", "anc", "usc", "uf", "ec", "ub", "uu", "sc", "ul", "lc", "tc", "unc", "mc", "nc", "ucc", "loc", "UC", "userc", "dc", "cc", "cl"], "in": ["ze", "f", "rin", "en", "inn", "and", "gin", "con", "IN", "ins", "reader", "ln", "on", "al", "In", "init", "inner", "ill", "ic", "re", "conf", "i", "read", "bin", "inc", "l", "input", "iter", "it", " din", "ind", "r", "mc", "mm", "io", "din", "inf", "is", "isin", "body", "il", "cin"], "file": ["type", "f", "handle", "image", "output", "File", "piece", "task", "FILE", "resource", "view", "fil", "fp", "page", "table", "base", "po", "port", "spec", "log", "to", "document", "message", "result", "db", "filename", "ile", "format", "name", "fo", "form", "path", "model", "zip", "local", "io", "pdf", "print", "data"], "fos": ["Foss", "foes", " fof", "foss", "fof", "flos", "tos", "Foes", "toss", "to", "wOS", " foes", "Fios", "Fo", "wos", "fOS", "Fof", "Fos", "fo", "flios", "floes", "tOS", "woss", " fios", "fios", "wo", "FOS", "flof"], "out": ["all", "co", "nt", "flush", "con", "output", "cos", "w", "sum", "set", "conv", "inner", "dis", "net", "write", "to", "ot", "v", "conf", "crit", "writer", "os", "outer", "it", "OU", "st", "at", "ou", "outs", "g", "o", "news", "inv", "n", "gr", "io", "Out", "OUT", "print", "end", "ex"], "inputLine": ["InputRow", "configline", " inputRow", "inputFile", "inputCode", "inputLINE", "inLine", "textRow", "textLINE", "textLine", "submitRow", "InputLine", " inputCode", "configRow", "inputRow", " inputFile", "submitBlock", " inputLINE", "inputline", "InputFile", " inputline", "Inputline", " inputBlock", "inputBlock", "textCode", "InputLINE", "submitLINE", "submitLine", "configFile", "inCode", "configLine", "InputBlock", "inRow", "inLINE"]}}
{"id1": "13122204", "id2": "19322941", "code1": "    public static void unzipModel(String filename, String tempdir) throws EDITSException {\n        try {\n            BufferedOutputStream dest = null;\n            FileInputStream fis = new FileInputStream(filename);\n            int BUFFER = 2048;\n            ZipInputStream zis = new ZipInputStream(new BufferedInputStream(fis));\n            ZipEntry entry;\n            while ((entry = zis.getNextEntry()) != null) {\n                int count;\n                byte data[] = new byte[BUFFER];\n                FileOutputStream fos = new FileOutputStream(tempdir + entry.getName());\n                dest = new BufferedOutputStream(fos, BUFFER);\n                while ((count = zis.read(data, 0, BUFFER)) != -1) dest.write(data, 0, count);\n                dest.flush();\n                dest.close();\n            }\n            zis.close();\n        } catch (Exception e) {\n            throw new EDITSException(\"Can not expand model in \\\"\" + tempdir + \"\\\" because:\\n\" + e.getMessage());\n        }\n    }\n", "code2": "    @Test\n    public void test_lookupResourceType_FullSearch_TwoWordsInMiddle() throws Exception {\n        URL url = new URL(baseUrl + \"/lookupResourceType/armor+plates\");\n        HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n        connection.setRequestMethod(\"GET\");\n        connection.setRequestProperty(\"Accept\", \"application/json\");\n        assertThat(connection.getResponseCode(), equalTo(200));\n        assertThat(getResponse(connection), equalTo(\"[{\\\"itemTypeID\\\":25605,\\\"itemCategoryID\\\":4,\\\"name\\\":\\\"Armor Plates\\\",\\\"icon\\\":\\\"69_09\\\"},{\\\"itemTypeID\\\":25624,\\\"itemCategoryID\\\":4,\\\"name\\\":\\\"Intact Armor Plates\\\",\\\"icon\\\":\\\"69_10\\\"}]\"));\n        assertThat(connection.getHeaderField(\"Content-Type\"), equalTo(\"application/json; charset=utf-8\"));\n    }\n", "label": 0, "substitutes": {"unzipModel": ["unzipModule", "unlateModule", "Unzipmodel", "UnarchiveModule", "uncodeModel", "unlatemodel", "unarchivemodel", "UnzipModule", "uncodeModule", "UnzipModel", "uncodemodel", "UnarchiveModel", "unarchiveModel", "uncodeImage", "unlateImage", "unlateModel", "unarchiveModule", "unarchiveImage", "UnarchiveImage", "unzipmodel", "unzipImage", "Unarchivemodel", "UnzipImage"], "filename": ["origin", "nil", "txt", "nm", "subject", "output", "original", "FILE", "ln", "fil", "fp", "river", "wl", "directory", "SourceFile", "dra", "jpg", "println", "journal", "ename", "name", "til", "FN", "kl", "sql", "nl", "stem", "Filename", "path", "ivo", "n", "download", "location", "mson", "fn", "file", "source", "FIL", "username", "fle", "title"], "tempdir": ["tempDir", "testpath", " tempDir", " tempdirectory", "tempDIR", "testfolder", "tmpfile", "tempfolder", "tempdirectory", "Tempdir", "tmpDir", "Tempfile", "temdir", " tempfile", "tmppath", "tempath", "tmpfolder", "tmpdirectory", "temDir", "tempfile", "temDIR", "testdir", "testDir", "Tempdirectory", "TempDir", "tmpDIR", "tmpdir", "temfolder", "temdirectory", "temppath", " tempDIR"], "dest": ["origin", "decl", "coord", "nt", "tr", "comb", "usr", "default", "output", "test", "deep", "cont", "slave", "obj", "trans", "sum", "tmp", "stream", "table", "est", "pipe", "port", "generated", "rest", "del", "buffer", "dc", "write", "ctr", "document", "master", "result", "src", "ptr", "bin", "writer", "target", "foreign", "tail", "out", "pos", "des", "parent", "st", "null", "dat", "nom", "inv", "desc", "Dest", "dist", "temp", "display", "send", "source", "loc", "store", "dev", "peer"], "fis": ["flis", "fi", "ljs", "flos", "fljs", "ifatis", "los", "zatis", "ifos", "ifis", "fli", "fatis", "li", "zjs", "flatis", "lis", "fjs", "ifi", "zi", "zos"], "BUFFER": ["BLBER", "BLFFER", "BBER", "MAXBuffer", " BUMT", "BufferMT", "BLBuffer", " BUBuffer", "BFFER", "FFERMT", "CUBuffer", "CUBER", "FFERBuffer", "BUMT", " BUULT", "CUFR", "MAXBER", "LOCKFFER", "FFERBER", "BAULT", "BLOUNT", "BUFR", "MAXFFER", "CUFFER", "BAOUNT", "MAXOUNT", "BUBER", " BUFR", "FFERFFER", "LOCKBER", "BAFFER", "BULT", "BOUNT", "BUBuffer", "BufferBuffer", "LOCKFR", "BufferBER", " BUBER", "BABER", "BUOUNT", "BUULT", "LOCKBuffer", "BufferFFER", " BUOUNT"], "zis": ["zoneris", "zees", "Zi", "xis", "fi", " zIS", "Zos", "zoneits", "zIS", "ziis", "Ziss", " zi", "zits", "ozis", "ozip", "zoneis", "ziIS", "zies", "zoneiss", " zris", "zeris", " zits", "xos", "zes", "xiss", "zeos", " zos", "zeits", "fiss", "zeis", " zip", "xi", "Zis", "zeIS", " ziss", " zes", "zip", "fip", "oziss", "ozi", "zris", "zi", "zos", "zeiss", "ziss", "zios"], "entry": ["ze", "nt", "image", "element", "item", "match", "ie", "piece", "part", "comment", "way", "se", "word", "inter", "table", "ce", "connection", "chain", "link", "char", "log", "zo", "je", "cell", "result", "system", "jar", "e", "def", "jo", "name", "or", "ent", "ry", "enter", "record", "zip", "member", "Entry", "key", "row", "file", "source", "existent", "index", "card", "pe", "header", "escape"], "count": ["f", "all", "cloud", "nt", "z", "match", "OUNT", "cont", "comment", "part", "force", "sum", "page", "base", "ce", "code", "c", "buffer", "ctr", "current", "call", "max", "cell", "number", "read", "cache", "counter", "nb", "child", "ct", "ount", "total", "cond", "common", "len", "length", "amount", "found", "Count", "batch", "num", "add", "n", "core", "start", "size", "check", "index", "acc", "cc"], "data": ["all", "window", "image", "step", "text", "DATA", "dec", "value", "dl", "output", "sample", "next", "d", "part", "area", "ata", "ATA", "raw", "table", "accept", "done", "buffer", "message", "result", "rel", "content", "format", "cache", "mat", "str", " DATA", "out", "valid", "dat", "batch", "n", "size", "zero", "p", "bytes", "results"], "fos": ["Foss", "foes", "foss", "voses", "vos", "foses", "Foes", "los", "loss", " foses", " foes", "Fios", "fOS", "Fos", "voss", "voes", "lOS", "Foses", " fios", "fios", " fOS", "lios", " foss", "FOS"]}}
{"id1": "1362", "id2": "22752444", "code1": "    public static int[] bubbleSort(int... a) {\n        boolean swapped;\n        do {\n            swapped = false;\n            for (int i = 0; i < a.length - 1; i++) {\n                if (a[i] > a[i + 1]) {\n                    int tmp = a[i];\n                    a[i] = a[i + 1];\n                    a[i + 1] = tmp;\n                    swapped = true;\n                }\n            }\n        } while (swapped);\n        return a;\n    }\n", "code2": "    public synchronized String encrypt(String plainText) {\n        String hash = null;\n        try {\n            MessageDigest md = null;\n            try {\n                md = MessageDigest.getInstance(\"SHA\");\n            } catch (NoSuchAlgorithmException e) {\n                throw new NoSuchAlgorithmException();\n            }\n            try {\n                if (plainText != null) md.update(plainText.getBytes(\"UTF-8\"));\n            } catch (UnsupportedEncodingException e) {\n                throw new UnsupportedEncodingException();\n            }\n            byte raw[] = md.digest();\n            hash = (new BASE64Encoder()).encode(raw);\n        } catch (NoSuchAlgorithmException e) {\n            MessageLog.writeErrorMessage(e, this);\n        } catch (UnsupportedEncodingException e) {\n            MessageLog.writeErrorMessage(e, this);\n        }\n        return Util.stripChars(hash);\n    }\n", "label": 0, "substitutes": {"bubbleSort": ["bubblingCompare", "bubbleLess", "gobblingLess", "gobblingSort", "gobbleLess", "bubargeSort", "bubblesSort", "bubblesLess", "gobbleSort", "gobblingCompare", "bubblingSort", "bubargeCompare", "bubblesCompare", "bubblingLess", "bubargeLess", "bubbleCompare", "gobbleCompare"], "a": ["aaaa", "all", "f", "window", "na", "va", "alpha", "au", "z", "ao", "h", "es", "area", "la", "ata", "ia", "isa", "apa", "oa", "t", "sa", "app", "ae", "changes", "ea", "trace", "c", "list", "b", "go", "aka", "array", "ga", "aaa", "aa", "A", "v", "ac", "act", "cache", "era", "l", "out", "am", "order", "history", "form", "da", "g", "o", "ap", "ma", "el", "ed", "eas", "att", "as", "an", "arr", "p", "data", "ab", "w"], "swapped": ["Swaped", " snapping", "Swapping", "snapped", "Swap", " snaped", "scaped", "SWapping", "stickaps", "scapped", "wapped", "swaped", "stickapping", " snap", "snaps", "stickaped", " snapped", " swap", "wapping", "Swapped", "SWapped", " swapping", "swapping", "stickapped", "scaps", "SWaped", "scapping", "SWap", "snaped", "swap", " swaps", "waps", "waped", "snapping", "swaps", " swaped"], "i": ["origin", "f", "mi", "u", "ini", "j", "us", "y", "I", "ie", "qi", "di", "im", "ri", "ei", "m", "ki", "client", "status", "ami", "init", "x", "in", "base", "t", "iu", "ti", "chain", "bi", "c", "me", "cli", "ic", "multi", "ci", "ai", "sim", "gi", "ui", "uri", "uli", "pi", "ij", "ix", "iri", "it", "ji", "li", "my", "ori", "xi", "si", "hi", "ir", "ind", "ip", "zi", "key", "io", "ii", "is", "gu", "iso", "oi", "index", "id", "phi"], "tmp": ["attr", "same", "txt", "tg", "ctx", "cmp", "orig", "test", "sp", "obj", "m", "managed", "MP", "tt", "t", "mut", "sq", "xy", "pkg", "mp", "perm", "cur", "result", "db", "amp", "cache", "nb", "sup", "td", "lib", "tf", "gm", "comp", "my", "np", "pre", "nom", "etc", "emp", "mk", "temp", "timeout", "clip", "sam", "prefix"]}}
{"id1": "1362", "id2": "1357662", "code1": "    public static int[] bubbleSort(int... a) {\n        boolean swapped;\n        do {\n            swapped = false;\n            for (int i = 0; i < a.length - 1; i++) {\n                if (a[i] > a[i + 1]) {\n                    int tmp = a[i];\n                    a[i] = a[i + 1];\n                    a[i + 1] = tmp;\n                    swapped = true;\n                }\n            }\n        } while (swapped);\n        return a;\n    }\n", "code2": "    private void copyFileTo(File destination) throws IOException {\n        logger.fine(\"Copying from \" + destination + \"...\");\n        FileChannel srcChannel = new FileInputStream(getAbsolutePath()).getChannel();\n        logger.fine(\"...got source channel \" + srcChannel + \"...\");\n        FileChannel destChannel = new FileOutputStream(new File(destination.getAbsolutePath())).getChannel();\n        logger.fine(\"...got destination channel \" + destChannel + \"...\");\n        logger.fine(\"...Got channels...\");\n        destChannel.transferFrom(srcChannel, 0, srcChannel.size());\n        logger.fine(\"...transferred.\");\n        srcChannel.close();\n        destChannel.close();\n    }\n", "label": 0, "substitutes": {"bubbleSort": ["bubblingCompare", "bubbleLess", "gobblingLess", "gobblingSort", "gobbleLess", "bubargeSort", "bubblesSort", "bubblesLess", "gobbleSort", "gobblingCompare", "bubblingSort", "bubargeCompare", "bubblesCompare", "bubblingLess", "bubargeLess", "bubbleCompare", "gobbleCompare"], "a": ["aaaa", "all", "f", "window", "na", "va", "alpha", "au", "z", "ao", "h", "es", "area", "la", "ata", "ia", "isa", "apa", "oa", "t", "sa", "app", "ae", "changes", "ea", "trace", "c", "list", "b", "go", "aka", "array", "ga", "aaa", "aa", "A", "v", "ac", "act", "cache", "era", "l", "out", "am", "order", "history", "form", "da", "g", "o", "ap", "ma", "el", "ed", "eas", "att", "as", "an", "arr", "p", "data", "ab", "w"], "swapped": ["Swaped", " snapping", "Swapping", "snapped", "Swap", " snaped", "scaped", "SWapping", "stickaps", "scapped", "wapped", "swaped", "stickapping", " snap", "snaps", "stickaped", " snapped", " swap", "wapping", "Swapped", "SWapped", " swapping", "swapping", "stickapped", "scaps", "SWaped", "scapping", "SWap", "snaped", "swap", " swaps", "waps", "waped", "snapping", "swaps", " swaped"], "i": ["origin", "f", "mi", "u", "ini", "j", "us", "y", "I", "ie", "qi", "di", "im", "ri", "ei", "m", "ki", "client", "status", "ami", "init", "x", "in", "base", "t", "iu", "ti", "chain", "bi", "c", "me", "cli", "ic", "multi", "ci", "ai", "sim", "gi", "ui", "uri", "uli", "pi", "ij", "ix", "iri", "it", "ji", "li", "my", "ori", "xi", "si", "hi", "ir", "ind", "ip", "zi", "key", "io", "ii", "is", "gu", "iso", "oi", "index", "id", "phi"], "tmp": ["attr", "same", "txt", "tg", "ctx", "cmp", "orig", "test", "sp", "obj", "m", "managed", "MP", "tt", "t", "mut", "sq", "xy", "pkg", "mp", "perm", "cur", "result", "db", "amp", "cache", "nb", "sup", "td", "lib", "tf", "gm", "comp", "my", "np", "pre", "nom", "etc", "emp", "mk", "temp", "timeout", "clip", "sam", "prefix"]}}
{"id1": "18631594", "id2": "5723876", "code1": "    public static synchronized String getMD5_Base64(String input) {\n        MessageDigest msgDigest = null;\n        try {\n            msgDigest = MessageDigest.getInstance(\"MD5\");\n        } catch (NoSuchAlgorithmException e) {\n            throw new IllegalStateException(\"System doesn't support MD5 algorithm.\");\n        }\n        try {\n            msgDigest.update(input.getBytes(\"UTF-8\"));\n        } catch (java.io.UnsupportedEncodingException ex) {\n            throw new IllegalStateException(\"System doesn't support your  EncodingException.\");\n        }\n        byte[] rawData = msgDigest.digest();\n        byte[] encoded = Base64.encode(rawData);\n        String retValue = new String(encoded);\n        return retValue;\n    }\n", "code2": "    public static final String calculate(File f) {\n        MessageDigest md;\n        BufferedReader rd;\n        StringBuffer buffer = new StringBuffer(\"\");\n        try {\n            rd = new BufferedReader(new FileReader(f));\n            md = MessageDigest.getInstance(\"SHA\");\n            String line = \"\";\n            while ((line = rd.readLine()) != null) buffer.append(line);\n            md.update(buffer.toString().getBytes());\n            byte[] digest = md.digest();\n            String result = \"\";\n            for (byte b : digest) result += String.format(\"%h\", b & 0xFF);\n            return result;\n        } catch (Exception ex) {\n            ex.printStackTrace();\n            return \"\";\n        }\n    }\n", "label": 1, "substitutes": {"getMD5_Base64": ["getMD5Asbase64", "getMD5_Base32", "getMD5_Based24", "getMD5AsBase64", "getMD5AsBase32", "getMD5Asbase62", "getMD5_base62", "getMD5_Based62", "getMD5Asbase32", "getMD5_Based32", "getMD5_base64", "getMD5AsBase62", "getMD5_Base62", "getMD5Asbase24", "getMD5_Based64", "getMD5_base24", "getMD5_Base24", "getMD5AsBase24", "getMD5_base32"], "input": ["txt", "image", "value", "text", "subject", "address", "output", "qi", "hello", "request", " Input", "unknown", "raw", "in", "char", "attribute", "Input", "up", "format", "example", "str", "get", "initial", "valid", "out", "it", "this", "form", "pattern", "padding", "string", "config", "file", "source", "password", "check", "p", "data", "prefix"], "msgDigest": ["msgDetistry", "msgMDose", "msgCheckse", "MsgDert", "MsgDest", "gsDigest", "messagediger", "msgDest", "MsgDist", "gsdigester", "MsgDigist", "msgDesignest", "msgMDest", "msgDefer", "messageDigse", "msgDist", "msgDefest", "msgDigistry", "msgdigEST", "messageDigistry", "msgdigistry", "messagedigistry", "msgDigester", "MsgDigest", "MsgDigester", "msgdiger", "messageDigist", "msgDefist", "msgdigse", "msgIGose", "msgIGEST", "msgCheckist", "msgDeter", "messagedigest", "msgUploadest", "msgdigest", "msgDert", "gsDigose", "messagedigse", "gsdigest", "messageDigest", "messagedigist", "msgDester", "msgDetest", "msgDigist", "msgCheckest", "msgDigEST", "gsdigose", "MsgDigert", "msgDesignert", "msgDetist", "gsdigEST", "msgUploadester", "msgUploadist", "msgDigose", "msgMDester", "msgDigert", "msgDesignester", "msgdigester", "msgDiger", "msgIGester", "msgMDEST", "msgDefistry", "gsDigester", "msgdigist", "msgDigse", "msgDesignist", "msgIGest", "gsDigEST", "messageDiger", "msgUploadert", "MsgDester", "msgdigose"], "rawData": ["RAWData", "serialDATA", " rawInput", "serialData", "renderedResponse", "RAWDATA", "RAWValue", " rawResponse", "rawText", "rawInput", "rawValue", "RAWResponse", "renderedValue", "rawResponse", "rawdata", "rawDATA", "serialText", " rawDATA", "RAWdata", " rawValue", "RAWText", "RAWInput", "serialInput", " rawdata", "rendereddata", "renderedData", " rawText"], "encoded": ["endedcoded", "endedored", "enored", "enccoded", "coloded", "explended", "secoded", "loadedalled", "seccoded", "colalled", "encined", "exploded", "encored", "loadedoded", "secined", "encalled", "enined", "colcoded", "explcoded", "endedoded", "encended", "explalled", "loadedended", "enoded", "secored", "colended", "loadedcoded", "endedined"], "retValue": ["returnvalue", " retValues", "retvalue", "RetValue", "returnValues", "RetValues", "retValues", "returnValue", "returnVal", " retVal", "retVal", "RetVal", "Retvalue", " retvalue"]}}
{"id1": "12306305", "id2": "7908169", "code1": "    private static void doCopyFile(File srcFile, File destFile, boolean preserveFileDate) throws IOException {\n        if (destFile.exists() && destFile.isDirectory()) {\n            throw new IOException(\"Destination '\" + destFile + \"' exists but is a directory\");\n        }\n        FileChannel input = new FileInputStream(srcFile).getChannel();\n        try {\n            FileChannel output = new FileOutputStream(destFile).getChannel();\n            try {\n                output.transferFrom(input, 0, input.size());\n            } finally {\n                IOUtil.closeQuietly(output);\n            }\n        } finally {\n            IOUtil.closeQuietly(input);\n        }\n        if (srcFile.length() != destFile.length()) {\n            throw new IOException(\"Failed to copy full contents from '\" + srcFile + \"' to '\" + destFile + \"'\");\n        }\n        if (preserveFileDate) {\n            destFile.setLastModified(srcFile.lastModified());\n        }\n    }\n", "code2": "    public String execute() {\n        String dir = \"E:\\\\ganymede_workspace\\\\training01\\\\web\\\\user_imgs\\\\\";\n        HomeMap map = new HomeMap();\n        map.setDescription(description);\n        Integer id = homeMapDao.saveHomeMap(map);\n        FileOutputStream fos;\n        try {\n            fos = new FileOutputStream(dir + id);\n            IOUtils.copy(new FileInputStream(imageFile), fos);\n            IOUtils.closeQuietly(fos);\n        } catch (FileNotFoundException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return list();\n    }\n", "label": 1, "substitutes": {"doCopyFile": [" doCopyfile", "doMoveFile", " doCopFile", "docopyByte", " doCopyFiles", "doCopyfile", "doCopyFiles", "docopyFiles", " doCopfile", "doMovefile", "docopyFile", "docopyfile", " doCopByte", "doCopfile", " doCopFiles", "doCopFiles", " doCopyByte", "doCopByte", "doCopFile", "doMoveFiles", "doMoveByte", "doCopyByte"], "srcFile": ["rcile", "destfile", "sourceFile", "sourcefile", "rbFILE", "srcModel", "srcFilename", "srcPath", "destFilename", " srcDir", "sourceLine", "destPage", " srcFILE", "selFile", "srcDir", "selfile", " srcFilename", "rbFilename", "sourceDir", " srcPage", "srcLine", "srcFILE", "srcPage", " srcModel", "rbPath", "locFilename", "rcFilename", "destile", "locModel", "rcFile", "locFile", "rcPage", "rcDir", "selPage", "srcfile", "rbFile", "selFilename", "locPage", " srcile", "rcLine", "rcPath", " srcLine", "rcfile", "destLine", "srcile", "rcFILE", " srcPath", "destModel", " srcfile"], "destFile": [" destGrid", "DestFiles", "litFile", "memFILE", "srcOnly", "critfile", "destfile", "memFiles", "origDir", "critGrid", "descFile", "origOnly", "srcFiles", "srcFilename", "DestPage", " destDir", "DestMail", "DestGrid", "destFilename", "critDir", "distFile", "foreignOnly", "destFILE", "destPage", "declFILE", "destGrid", "srcDir", " destFILE", "distDir", " destFiles", "srcFILE", "srcPage", "origFile", "destDirectory", "DestDirectory", "srcGrid", "litMail", "litFILE", "origFILE", "DestDir", " destFilename", "DestFILE", "critFile", "destOnly", "descGrid", "destDir", "descPage", "declfile", "foreignFILE", "foreignFile", "memFile", "Destfile", "srcfile", " destDirectory", "memfile", "distfile", "foreignDir", " destPage", "destMail", "DestFile", "descDir", "distFilename", "srcDirectory", "destFiles", "litfile", "DestFilename", "declFile", "declMail", " destfile"], "preserveFileDate": ["presoreFileSize", "preserveSetDate", "preserveFilesSize", "preservesFileDay", "preservesFileTime", "preserveFilesdate", "preserveSetDay", "preservesfileTime", "preserveLinedate", "preserveFilenameDay", "preserveLineDate", "presoreLotSize", "preservesfileDuration", "preserveLotdate", "preserveFileSize", "preserveFileDay", "preserveLineSize", "presoreLotDate", "presoreFiledate", "preserveLotSize", "preserveFileTime", "preservesfileDate", "preservesFileDate", "preserveFiledate", "presoreLotDay", "preserveLineDay", "preservefileTime", "preserveFilenameTime", "preserveFilenameDate", "preserveFilenameDuration", "preservefileDay", "preserveSetTime", "preserveSetDuration", "presoreFileDate", "preservesfileDay", "preserveLotDate", "preserveFileDuration", "preserveFilesDate", "preservefileDuration", "preservefileDate", "presoreFileDay", "preserveFilesDay", "presoreLotdate", "preserveLotDay", "preservesFileDuration"], "input": ["installed", "image", "json", "alpha", "entry", "internal", "request", " Input", "reader", "op", "client", "raw", "stream", "context", "init", "feed", "accept", "in", "inner", "before", "q", "command", "buffer", "open", "current", "Input", "xml", "up", "read", "get", "partial", "hidden", "archive", "initial", "upload", "iter", "it", "history", "parse", "audio", "focus", "ip", "add", "auto", "pattern", "local", "info", "http", "io", "start", "exec", "source", "index", "from"], "output": ["response", "image", "block", "text", "ilo", "put", "console", "next", "client", "stream", "web", "page", "module", "Output", "connection", "port", "four", "generated", "net", "write", "open", "buffer", "message", "result", "format", "hidden", "writer", "success", "outer", "section", "out", "exit", "ou", "group", "network", "o", "auto", "cut", "channel", "remote", "icon", "file", "latest", "body", "print", "data", "display"]}}
{"id1": "1798720", "id2": "21656668", "code1": "    public static void save(String packageName, ArrayList<byte[]> fileContents, ArrayList<String> fileNames) throws Exception {\n        String dirBase = Util.JAVA_DIR + File.separator + packageName;\n        File packageDir = new File(dirBase);\n        if (!packageDir.exists()) {\n            boolean created = packageDir.mkdir();\n            if (!created) {\n                File currentPath = new File(\".\");\n                throw new Exception(\"Directory \" + packageName + \" could not be created. Current directory: \" + currentPath.getAbsolutePath());\n            }\n        }\n        for (int i = 0; i < fileContents.size(); i++) {\n            File file = new File(Util.JAVA_DIR + File.separator + fileNames.get(i));\n            FileOutputStream fos = new FileOutputStream(file);\n            fos.write(fileContents.get(i));\n            fos.flush();\n            fos.close();\n        }\n        for (int i = 0; i < fileNames.size(); i++) {\n            File fileSrc = new File(Util.JAVA_DIR + File.separator + fileNames.get(i));\n            File fileDst = new File(dirBase + File.separator + fileNames.get(i));\n            BufferedReader reader = new BufferedReader(new FileReader(fileSrc));\n            BufferedWriter writer = new BufferedWriter(new FileWriter(fileDst));\n            writer.append(\"package \" + packageName + \";\\n\");\n            String line = \"\";\n            while ((line = reader.readLine()) != null) writer.append(line + \"\\n\");\n            writer.flush();\n            writer.close();\n            reader.close();\n        }\n    }\n", "code2": "    private void copyResourceToFile(final String resourceFilename, final String destinationFilename) throws IOException {\n        InputStream inStream = null;\n        OutputStream outStream = null;\n        try {\n            inStream = MatsimResource.getAsInputStream(resourceFilename);\n            outStream = new FileOutputStream(destinationFilename);\n            IOUtils.copyStream(inStream, outStream);\n        } finally {\n            if (inStream != null) {\n                try {\n                    inStream.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            if (outStream != null) {\n                try {\n                    outStream.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n", "label": 1, "substitutes": {"save": ["export", " seal", "Save", " Save", "release", "init", "accept", "pkg", "filename", "saving", "archive", "upload", "dump", "data", "pack", "aw", "register", "zip", "download", "install", "send", "folder", "version", "store", "update", "delete"], "packageName": ["packagename", "modulename", "pkgKey", "packageNames", " packageNames", "moduleId", " packageId", " packageType", "packageCode", "moduleCode", " packageKey", "pkgNames", "pkgCode", "PackageId", "packageKey", "pkgId", "pkgname", "moduleNames", "pkgName", " packageCode", " packagename", "PackageType", "PackageName", "PackageNames", "moduleKey", "packageType", "pkgType", "moduleName", "packageId"], "fileContents": ["pageBytes", "packageNames", "packageContents", "FileContents", " fileIngredients", "packageContent", "FileNames", " fileBytes", "byteContent", "FileItems", "fileBytes", "pageContents", " fileValues", "byteContents", "FileIngredients", "fileItems", "byteNames", " fileItems", "pageNames", "fileIngredients", "byteValues", "packageIngredients", " fileContent", "fileValues", "fileContent", "FileBytes", "FileValues", "pageItems", "FileContent"], "fileNames": ["fieldContents", "issueContents", "messageValues", " fileKeys", "fileNumbers", "FileLeaks", "messageKeys", "dirLeaks", "FileName", " fileNumbers", "issueVaults", "fieldNames", "FileContents", "resourceNames", "FileNames", "dirNames", "resourceContents", "moduleVaults", "resourceTypes", "issueName", "FileKeys", " fileName", " fileValues", "fileLeaks", "messageName", "fileKeys", "messageNames", "fileTypes", "moduleNames", "fieldTypes", "resourceNumbers", "issueNames", "resourceValues", "fileValues", " fileTypes", "fileName", "FileTypes", "fileVaults", "FileValues", "moduleName", " fileLeaks", " fileVaults", "fieldNumbers", "dirTypes", "dirKeys", "moduleContents"], "dirBase": ["DIRBase", "DIRBuilder", "DirBuilder", "folderbase", "DirBase", "dirBasic", "folderBas", "pathBase", "dirBottom", " directoryBuilder", "folderBasic", "irBase", "DirBottom", "pkgBas", "irbase", "DirBas", " directoryBottom", "pkgSet", "directorySet", "dirbase", "pkgbase", "DIRBas", " directoryBas", "dirBuilder", "pkgBase", "dirBas", "irSet", "directoryBase", " directoryBase", "directoryBasic", "irBas", "directorybase", "pathBasic", "DIRBottom", "pathbase", "pathBas", "folderBase", "directoryBas", "dirSet"], "packageDir": ["installDist", "packageFolder", "packageD", " packageRel", " packagePath", "moduleDir", "podDef", "pkgDir", "pkgPath", "packageRel", "installD", "pkgDef", "podDist", "modulePath", " packageDef", " packageD", "installDir", "podDir", "moduleRel", "installDef", "moduleDef", "pkgFolder", "packagePath", " packageFolder", " packageDist", "podD", "moduleFolder", "packageDist", "pkgRel", "packageDef"], "created": ["defined", "installed", "Created", "creator", "developed", "provided", "locked", "create", "joined", " started", "registered", "generated", "associated", "creat", "raised", "forced", "founded", "called", "made", "mounted", "released", "started", "arted", "printed", "successful", "creation", "recorded", "loaded", "present", "allowed", "confirmed", "checked", " generated", "added", "TED", "ready", "ced", "produced", "existent", "activated", "reported", "filled", "given"], "currentPath": ["currentName", " currentFile", " currentParent", "CurrentFile", "currentCh", "recentName", "recentPoint", "currentlyFile", " currentCh", "recentParent", "currentlyPath", "recentPath", "CurrentName", "CurrentPath", " currentPoint", "CurrentCh", "currentlyName", "CurrentParent", "currentlyCh", "currentPoint", "currentParent", "CurrentPoint", " currentName", "currentFile"], "i": ["exp", "y", "I", "di", "ri", "ei", "yi", "ti", "me", "q", "cgi", "ic", "sim", "gi", "v", "pi", "it", "ip", "info", "oi", "index", "f", "iy", "ini", "them", "iq", "hi", "cli", "slice", "ci", "uri", "os", "xi", "si", "g", "ind", "batch", "key", "ity", "id", "ix", "major", "u", "j", "im", "iu", "in", "chain", "jj", "bi", "multi", "ui", "my", "o", "phi", "mi", "ski", "ie", "qi", "m", "ki", "status", "ami", "init", "go", "ai", "ij", "ji", "this", "li", "mu", "ii", "iii", "zi", "p", "ex"], "file": ["type", "f", "rule", "handle", "play", "File", "et", "FILE", "h", "resource", "comment", "disk", "set", "page", "table", "port", "base", "template", "link", "buffer", "log", "db", "ile", "format", "child", "le", "name", "sf", "l", "fo", "parent", "handler", "path", "dir", "local", "info", "row", "io", "pool", "source", "body", "p", "header"], "fos": ["Foss", "ffos", "foes", "fbos", "woes", "fow", "foss", "flos", " faos", "fbow", "ffo", "floses", "foses", "floss", "Foes", "sfoss", " fo", "faos", "flaos", "oo", "fbaos", " foses", " foes", "Fo", "wos", "fOS", "fbo", "Fos", "fo", "sfos", "floes", "flo", "woss", "oaos", " fOS", "Faos", " fow", " foss", "ffaos", "sfOS", "oos", "FOS", "ffoes", "woses", "sfaos", "oow"], "fileSrc": ["fileEri", "fileDci", "fileErc", "fileSci", "fileNrl", " fileSource", "fileNri", "fileInrc", " fileInsRC", "fileDsrc", "jobSrl", "fileInsrc", "fileDRC", "fileDource", "fileErl", "fileDrc", "jobSrc", "jobSri", " fileInsource", "fileSRC", " fileSsrc", "fileInssrc", "jobSci", "fileDrl", "jobNrl", "fileInRC", " fileSRC", " fileInssrc", "fileInsource", "fileSri", "fileDri", "jobNri", "fileInsRC", "fileSsrc", "fileSrl", "fileNrc", " fileInsrc", "fileNci", "jobNci", "fileSource", "fileInource", "jobNrc", "fileEci"], "fileDst": ["FileSld", "FileSnd", "fileDld", "fileNot", "fileDpl", "fileWst", "fileSld", "fileSst", "FileSst", "fileNcr", "fileSnd", "FileSpl", "FileDcr", "fileWpl", "fileNld", "FileDpl", "fileWot", "FileDlt", "fileNpl", "fileNnd", "fileDcr", "FileSot", "FileDst", "fileDlt", "fileWlt", "FileDld", "FileDot", "fileSlt", "FileScr", "FileDnd", "fileSpl", "FileSlt", "filedld", "filednd", "filedcr", "fileDnd", "fileNst", "fileNlt", "fileScr", "fileDot", "fileSot", "filedst"], "reader": ["runner", "author", "rar", "rc", "actor", "entry", "rer", "driver", "parser", "resource", "ri", "ro", "stream", "context", "inner", "Reader", "oder", "buffer", "readable", "dr", "roller", "review", "read", "ler", "rr", "rl", "iter", "ocker", "rot", "query", "upper", "rx", "ader", "handler", "controller", "iterator", "r", "Larry", "book", "row", "ner", "er", "reading", "loader"], "writer": ["runner", "browser", "report", "window", "worker", "creator", "flush", "writers", "Writer", "caster", "entry", "test", "console", "draw", "driver", "storage", "service", "word", "parser", "client", "wright", "builder", "writing", "stream", "table", "maker", "Reader", "editor", "write", "buffer", "print", "function", "document", "println", "format", "read", "variable", "liner", "operator", "outer", "wrapper", "iter", "order", "walker", "query", "handler", "wire", "iterator", "manager", "riter", "later", "player", "user", "adder", "store", "loader", "server", "ter", "w"], "line": ["rule", "LINE", "style", "block", "lin", "text", "eline", "entry", "ine", "sample", "column", "comment", "frame", "word", "ln", "sequence", "page", "stroke", "port", "chain", "range", "link", "code", "date", "label", "message", "cell", "kin", "detail", "number", "node", "le", "liner", "entity", "l", "valid", "nl", "lined", "point", "continue", "record", "edge", "Line", "row", "string", "inline", "source", "ole", "user", "print", "pe", "header"]}}
{"id1": "8770016", "id2": "88047", "code1": "    public InputStream loadResource(String location) throws GenericConfigException {\n        URL url = getURL(location);\n        try {\n            return url.openStream();\n        } catch (java.io.IOException e) {\n            throw new GenericConfigException(\"Error opening URL resource at location [\" + url.toExternalForm() + \"]\", e);\n        }\n    }\n", "code2": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "label": 0, "substitutes": {"loadResource": ["getResources", "selectFile", "selectResources", "loadRes", "getResource", "loadFile", "openResource", "openRes", "selectRes", "openFile", "openResources", "loadResources", "getFile", "getRes", "selectResource"], "location": ["ocation", "type", "ion", "layout", "address", "reference", "value", "options", "entry", "sample", " Location", "comment", "request", "resource", "description", "context", "library", "level", "base", "directory", "template", "command", "document", "message", "join", "Location", "filename", "program", "node", "uri", "name", "position", "LOC", "target", "localhost", "path", "collection", "slot", "href", "local", "remote", "string", "where", "loc", "file", "id", "translation", "server", "behavior"], "url": ["f", "browser", "address", "ref", "u", "dl", "ob", "resource", "client", "raw", "web", "ls", "ll", "base", "char", "link", "build", "sl", "open", "system", "db", "rel", "un", "ur", "mount", "uri", "URL", "name", "cl", "str", "get", "l", "nl", "ul", "mail", "path", "len", "ssl", "auto", "channel", "http", "job", "control", "file", "ld", "loc", "Url", "user", "host", "abs"]}}
{"id1": "16931472", "id2": "13981689", "code1": "    public void handler(Map<String, String> result, TargetPage target) {\n        try {\n            URL url = new URL(target.getUrl());\n            BufferedReader reader = new BufferedReader(new InputStreamReader(url.openStream()));\n            String line = null;\n            while ((line = reader.readLine()) != null) {\n                for (Map.Entry<String, String> entry : result.entrySet()) {\n                    if (line.indexOf(target.getInclude()) != -1) {\n                        int fromIndex = line.indexOf(target.getFromStr());\n                        String r = line.substring(fromIndex + target.getFromStr().length(), line.indexOf(target.getToStr(), fromIndex));\n                        entry.setValue(r);\n                        line = line.substring(line.indexOf(target.getToStr()) + target.getToStr().length());\n                    }\n                }\n            }\n            reader.close();\n        } catch (MalformedURLException e) {\n        } catch (IOException e) {\n        }\n    }\n", "code2": "    public static String md5Hash(String src) {\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"MD5\");\n            md.update(src.getBytes());\n            return bytesArrayToHexString(md.digest());\n        } catch (Exception e) {\n            return null;\n        }\n    }\n", "label": 0, "substitutes": {"handler": ["transform", "handle", "output", "Handler", "forward", "callback", "request", "execute", "processor", "processing", "init", "accept", "done", "action", "Handle", "adapt", "read", "success", "proc", "controller", "handled", "hook", "received", "index", "update", "end", "render"], "result": ["all", "report", "response", "product", "res", "output", "RESULTS", "mate", "details", "sequence", "status", "page", "table", "met", "done", "profile", "buffer", "master", "current", "list", "cache", "successful", "success", "complete", "total", "out", "valid", "hash", "created", "found", "full", "ret", "make", "source", "memory", "map", "data", "results", "Result"], "target": ["window", "expected", "output", "test", "next", "internal", "page", "t", "base", "to", "primary", "detail", "node", "top", "iter", "it", "gt", "term", "info", "jp", "bolt", "arget", "tif", "arg", "type", "handle", "subject", "that", "alias", "dest", "service", "thread", "tool", "template", "link", "buffer", "Target", "name", "tree", "controller", "cmd", "history", "prototype", "local", "manager", "http", "version", "report", "layout", "goal", "view", "table", "trace", "scope", "master", "e", "complete", "external", "parent", "object", "component", "peer", "proxy", "transform", "style", "closure", "match", "task", "pkg", "format", "valid", "this", "project", "self", "trigger", "remote", "source", "translation"], "url": ["f", "browser", "hl", "address", "git", "dl", "service", "client", "bel", "ls", "web", "ll", "base", "connection", "char", "link", "build", "sl", "cert", "impl", "lr", "rel", "ur", "mount", "uri", "URL", "rl", "l", "nl", "ul", "mail", "hub", "ssl", "el", "http", "html", "file", "loc", "Url", "loader"], "reader": ["runner", "rar", "linger", "and", "layer", "parser", "driver", "resource", "builder", "ro", "stream", "context", "inner", "Reader", "buffer", "redo", "readable", "cur", "review", "read", "uri", "writer", "liner", "rl", "operator", "rr", "iter", "rot", "upper", "iterator", "row", "ner", "er", "file", "reading", "older", "loader"], "line": ["rule", "LINE", "lo", "style", "zone", "block", "lock", "lin", "text", "eline", "sample", "ine", "email", "next", "word", "frame", "comment", "ln", "sequence", "lines", "status", "page", "port", "trace", "limit", "base", "chain", "range", "link", "log", "buffer", "date", "code", "message", "cell", "detail", "stay", "node", "state", "le", "now", "liner", "entity", "l", "out", "section", "iter", "nl", "level", "point", "continue", "queue", "network", "Line", "ip", "row", "string", "no", "inline", "file", "online", "source", "body", "user", "loop", "store", "print"], "entry": ["pair", "element", "match", "ie", "deep", "quick", "part", "comment", "se", "office", "inner", "char", "cell", "list", "e", "def", "ace", "or", "ary", "ent", "ry", "it", "exit", "search", "object", "term", "enter", "record", "instance", "add", "member", "Entry", "row", "key", "pixel", "job", "field", "check", "escape", "ex"], "fromIndex": ["fromindex", "oldLink", "forindex", "FromInd", "leftindex", "forIndex", "forPosition", "FromLink", "minindex", "fromLink", "oldIndex", "normalInt", "fromPosition", "normalindex", " fromInd", "fromInd", "FromAlpha", "normalInd", " fromLink", "minInd", "FromIndex", "forInd", " fromAlpha", "normalIndex", "fromAlpha", "fromInt", "minInt", " fromInt", " fromPosition", "leftInd", "oldAlpha", "leftIndex", " fromindex", "oldInd", "leftPosition", "minIndex"], "r": ["rar", "rc", "u", "rt", "res", "mr", "rg", "ar", "cr", "R", "m", "kr", "fr", "q", "range", "err", "b", "sr", "dr", "re", "v", "rd", "e", "rs", "rr", "rb", "l", "str", "rate", "rect", "g", "nr", "n", "vr", "er", "render", "p", "w"]}}
{"id1": "3046085", "id2": "8490297", "code1": "    public Song(String s) {\n        StringTokenizer tokenizer = new StringTokenizer(s, \";\");\n        free = false;\n        title = tokenizer.nextToken();\n        artist = tokenizer.nextToken();\n        location = tokenizer.nextToken();\n        rating = Integer.parseInt(tokenizer.nextToken());\n        overplay = Integer.parseInt(tokenizer.nextToken());\n        String temp = tokenizer.nextToken();\n        tokenizer = new StringTokenizer(temp, \",[] \");\n        tags = new ArrayList<String>();\n        while (tokenizer.hasMoreTokens()) {\n            tags.add(tokenizer.nextToken());\n        }\n        byte[] bytes = new byte[40];\n        try {\n            MessageDigest hasher = MessageDigest.getInstance(\"SHA-1\");\n            hasher.update(title.getBytes());\n            hasher.update(artist.getBytes());\n            bytes = hasher.digest();\n        } catch (Exception e) {\n            System.out.println(e);\n        }\n    }\n", "code2": "    public static void copyFile(File src, File dst) throws IOException {\n        try {\n            InputStream in = new FileInputStream(src);\n            OutputStream out = new FileOutputStream(dst);\n            byte[] buf = new byte[TEMP_FILE_BUFFER_SIZE];\n            int len;\n            while ((len = in.read(buf)) > 0) out.write(buf, 0, len);\n            in.close();\n            out.close();\n        } catch (FileNotFoundException e1) {\n            MLUtil.runtimeError(e1, src.toString());\n        } catch (IOException e2) {\n            MLUtil.runtimeError(e2, src.toString());\n        }\n    }\n", "label": 0, "substitutes": {"s": ["f", "ss", "text", "strings", "h", "es", "js", "m", "ls", "t", "ns", "q", "c", "b", "ps", "S", "v", "i", "e", "its", "name", "str", "rs", "os", "gs", " ts", "g", "r", "n", "string", "is", "p", "a", "data", "w"], "tokenizer": ["terminazer", "templateer", "tokenitor", "okenoser", "terminize", "okenzie", "webize", " tokenization", " tokenzer", "nodeisher", "templateisher", " tokenifier", "kinizer", "nodeized", "terminitor", "Tokenzer", "valueisher", "operatorazer", "Tokenized", "Tokenizers", "datezer", "operatorisher", "tokenisher", "operatorizer", "templateizable", "operatorzie", "tokenener", "Tokenize", "dateize", "operatoriner", "dateizable", "tokenization", "serializer", "tokenizable", "webisher", "dateizer", "okeniner", "terminiser", "tokeniner", "kinzer", "tokenazer", "tokenize", "tokeniter", "okenner", " tokenner", "Tokenization", "okenifier", "serialzer", "Tokenner", "okenitor", "okenzer", "tokenized", "Tokenisher", "tokenzer", "terminisher", "kinize", "operatorized", "terminizer", "kinizers", " tokenener", "templateization", "terminization", "okenisher", "okeniter", "webitor", "toolizer", "tokenifier", "Tokenener", "nodeization", "webizable", "webization", " tokeniner", " tokenizable", "webizer", "tokenzie", " tokenzie", "okenizable", "templateizer", "tokener", "valueizable", "serialize", "okenazer", "serializable", "tokenner", " tokenisher", "tokenizers", "Tokener", "okenener", "Tokenizer", "operatoriter", " tokenoser", "terminiter", "templatezer", "toolize", "valueizer", "tokenoser", "okenize", "toolzer", "operatoriser", "tokeniser", "toolizers", "Tokenifier", "operatorization", "okenizer", "okeniser", "valueoser", " tokener", "terminizable", "nodeizer"], "title": ["type", "phrase", "author", "lead", "tip", "text", "displayText", "itled", "part", "description", "summary", "article", "table", "tag", "t", "horse", "profile", "template", "label", "primary", "story", "filename", "name", "itle", "position", "important", "total", "meta", "art", "note", "metadata", "term", "holiday", "source", "Title", "version", "id", "prefix"], "artist": ["author", "track", "gallery", "creator", "image", "item", "picture", "part", "adult", "music", "tag", "rank", "directory", "attribute", "associated", "song", "album", "position", "archive", "person", "art", "audio", "metadata", "component", "project", "object", "photo", "assisted", "volume", "chapter", "voice", "Artist", "source", "folder", "player", "user", "username"], "location": ["origin", "zone", "layout", "address", "gallery", "reference", "time", "feature", "comment", "area", "description", "direction", "directory", "shape", "Location", "country", "near", "media", "phone", "position", "language", "activity", "local", "place", "loc", "folder", "source", "translation"], "rating": ["playing", "movie", "boarding", "score", "music", "credit", "erate", "genre", "library", "frequency", "rank", "profile", "average", "confidence", "rated", "media", "fps", "race", "meta", "training", "Rating", "rate", "metadata", "ranking", "scoring", "weight", "rates", "scale"], "overplay": ["Override", " override", "override", "Overplay", "overgrade", "appcast", " overgrade", " overcast", "appgrade", "Overgrade", "overcast", "appplay", "Overcast", "appride"], "temp": ["type", "empty", "output", "orig", "test", "time", "set", "Temp", "tmp", " tmp", "base", "flash", "template", "mem", "generated", "buffer", " Temp", "fake", "current", "cache", "name", "now", "partial", " temporary", "stem", "encrypted", "null", "term", "created", "porary", "tem", "emp", "local", "key", "texture", "source", "loc", "memory", "Temperature", "unit", "tm", "prefix"], "tags": ["terms", "tracks", "dates", "Tags", "options", "links", "assets", "flags", "reports", "strings", "parts", "keys", "details", "types", "lines", "packages", "marks", "names", "lights", "comments", "stats", "words", "ags", "weights", "styles", "lists", "images", "fields", "atts", "thumbnails", "stars", "balls", "groups", "pages", "files", "relations", "nets"], "bytes": ["terms", "services", "vals", "Bytes", "frames", "rows", "parts", "keys", "bps", "seconds", "loads", "lines", "bs", "classes", "comments", "bits", "gb", "uploads", "words", "ips", "ids", "images", "blocks", "tes", "fields", "len", "gs", "mb", "groups", "pages", "files", "gets", "values", "videos", "es"], "hasher": ["haser", " hasest", " hadher", " hasDR", "HasDR", "havehers", "hasger", "hydHer", "hahers", "hadher", "Haser", " hader", " hashers", "hashed", "haveter", "Hasher", " haster", "haveest", " hashed", " hasger", "hydher", "hasest", " hadDR", "haveher", "Haspher", "Hashed", "hydger", "haspher", " hadter", "hater", "hadger", "haest", "haher", " hascher", "hadHer", "hasDR", " hasHer", "Haster", "hydcher", " haspher", "haster", "hascher", "hasHer", "hadcher", "hadpher", "hadhed", "hadter", " haser", "hashers"]}}
{"id1": "6341264", "id2": "15905041", "code1": "    public static byte[] getJarEntry(String jarName, String entry, int port) {\n        byte[] b = null;\n        try {\n            String codebase = System.getProperty(\"java.rmi.server.codebase\", InetAddress.getLocalHost().getHostName());\n            String protocol = \"http://\";\n            int x = codebase.indexOf(protocol) + protocol.length();\n            String s2 = codebase.substring(x);\n            int x2 = s2.indexOf('/');\n            String downloadHost = s2.substring(0, x2);\n            if (downloadHost.indexOf(':') == -1) {\n                downloadHost += \":\" + port;\n            }\n            URL url = new URL(\"jar:http://\" + downloadHost + \"/\" + jarName + \"!/\" + entry);\n            JarURLConnection jurl = (JarURLConnection) url.openConnection();\n            JarEntry je = jurl.getJarEntry();\n            InputStream is = jurl.getInputStream();\n            BufferedInputStream bis = new BufferedInputStream(is);\n            int size = (int) je.getSize();\n            b = new byte[size];\n            int rb = 0;\n            int chunk = 0;\n            while ((size - rb) > 0) {\n                chunk = bis.read(b, rb, size - rb);\n                if (chunk == -1) {\n                    break;\n                }\n                rb += chunk;\n            }\n            bis.close();\n            is.close();\n            bis = null;\n            is = null;\n            url = null;\n            jurl = null;\n        } catch (UnknownHostException e) {\n            e.printStackTrace();\n            return null;\n        } catch (IOException e) {\n            e.printStackTrace();\n            return null;\n        }\n        return b;\n    }\n", "code2": "    public void createPartControl(Composite parent) {\n        viewer = new ScrollingGraphicalViewer();\n        viewer.setRootEditPart(new ScalableRootEditPart());\n        viewer.setEditPartFactory(new BlockEditPartFactory());\n        viewer.setEditDomain(new EditDomain());\n        viewer.createControl(parent);\n        viewer.setKeyHandler(new GraphicalViewerKeyHandler(viewer));\n        ActionRegistry actionRegistry = new ActionRegistry();\n        createActions(actionRegistry);\n        ContextMenuProvider cmProvider = new BlockContextMenuProvider(viewer, actionRegistry);\n        viewer.setContextMenu(cmProvider);\n        Block b = new Block();\n        b.addChild(new ChartItem());\n        viewer.setContents(b);\n        System.err.println(\"!!! \" + viewer.getContents().getChildren().get(0));\n        viewer.select((EditPart) viewer.getContents().getChildren().get(0));\n        PaletteRoot root = new PaletteRoot();\n        PaletteGroup toolGroup = new PaletteGroup(\"Chart Tools\");\n        List toolList = new ArrayList();\n        ToolEntry tool = new SelectionToolEntry();\n        toolList.add(tool);\n        root.setDefaultEntry(tool);\n        tool = new MarqueeToolEntry();\n        toolList.add(tool);\n        toolGroup.addAll(toolList);\n        PaletteGroup templateGroup = new PaletteGroup(\"Templates\");\n        List templateList = new ArrayList();\n        CombinedTemplateCreationEntry entry = new CombinedTemplateCreationEntry(\"Rect\", \"Rect\", new ChartItem(), new SimpleFactory(ChartItem.class), ImageDescriptor.getMissingImageDescriptor(), ImageDescriptor.getMissingImageDescriptor());\n        CombinedTemplateCreationEntry entry1 = new CombinedTemplateCreationEntry(\"Line\", \"Line\", new ChartLine(), new SimpleFactory(ChartLine.class), ImageDescriptor.getMissingImageDescriptor(), ImageDescriptor.getMissingImageDescriptor());\n        templateList.add(entry);\n        templateList.add(entry1);\n        templateGroup.addAll(templateList);\n        List rootList = new ArrayList();\n        rootList.add(toolGroup);\n        rootList.add(templateGroup);\n        root.addAll(rootList);\n        final PaletteViewer v = new PaletteViewer();\n        v.setPaletteRoot(root);\n        v.createControl(parent);\n        v.addSelectionChangedListener(new ISelectionChangedListener() {\n\n            public void selectionChanged(SelectionChangedEvent event) {\n                System.err.println(\"selectionChanged \" + v.getActiveTool());\n            }\n        });\n        deleteAction.setSelectionProvider(viewer);\n        viewer.getEditDomain().setPaletteViewer(v);\n        viewer.addSelectionChangedListener(new ISelectionChangedListener() {\n\n            public void selectionChanged(SelectionChangedEvent event) {\n                System.err.println(event.getSelection());\n                deleteAction.update();\n            }\n        });\n        viewer.getEditDomain().getCommandStack().addCommandStackEventListener(new CommandStackEventListener() {\n\n            public void stackChanged(CommandStackEvent event) {\n                undoAction.setEnabled(viewer.getEditDomain().getCommandStack().canUndo());\n                redoAction.setEnabled(viewer.getEditDomain().getCommandStack().canRedo());\n            }\n        });\n    }\n", "label": 0, "substitutes": {"getJarEntry": ["getJavaEntry", "getServerInfo", "getFileInfo", "getModuleItem", " getJarResource", "getJarInfo", " getJarItem", "getZipFile", "getJavaItem", " getZipItem", "getJarResource", " getJarInfo", " getJarFile", "getJavaFile", "getFileItem", "getJarFile", "getZipEntry", " getJarEnt", "getServerResource", "getModuleEntry", "getJavaEnt", "getResourceItem", "getModuleFile", " getFileEntry", " getFileResource", "getJarItem", "getJarEnt", " getFileInfo", "getResourceEntry", "getZipItem", " getZipEnt", "getServerItem", " getFileItem", "getServerEntry", " getZipEntry", " getZipFile", "getResourceInfo", "getFileEntry", "getModuleEnt", "getZipEnt", "getResourceResource", "getFileResource"], "jarName": [" jarKey", "JarLocal", "JarN", "jobName", "jobN", "jarN", "jarLocal", " jarLocal", "binaryName", "jarname", " jarN", "JarName", "jarKey", "sessionKey", "Jarname", " jarname", "jobLocal", "jobname", "binaryKey", "sessionname", "binaryname", "sessionName"], "entry": ["address", "text", "element", "ie", "comment", "word", "resource", "description", "command", "log", "jar", "cell", "xml", "e", "uri", "name", "archive", "input", "ent", "ry", "query", "data", "search", "path", "enter", "zip", "Entry", "key", "row", "string", "er", "field", "server", "file", "quit", "index", "print", "delete"], "port": ["type", "export", "Port", "address", "value", "page", "limit", "connection", "priority", "format", "pc", "position", "pt", "localhost", "pos", "age", "it", "offset", "project", "path", "point", "PORT", "length", "ports", "ip", "count", "row", "key", "string", "ort", "socket", "remote", "width", "eport", "start", "server", "version", "index", "p", "host"], "b": ["u", "f", "buf", "bt", "sb", "pb", "B", "j", "p", "bf", "br", "y", "bl", "buff", "bit", "cb", "d", "ob", "h", "bs", "wb", "base", "bas", "be", "buffer", "bi", "bits", "c", "bb", "db", "emb", "v", "i", "e", "bin", "nb", "bp", "ba", "l", "eb", "s", "mb", "r", "xb", "fb", "gb", "ib", "a", "ab"], "codebase": ["Codebas", "corefile", " codebased", "linkBase", "Codespace", "Codefile", "cebase", "Codease", "cebased", "corebase", "codefile", "Codebased", "CodeBase", "chebase", "codeBase", "codease", "linkbas", "codebased", "chespace", "linkbase", "cease", "corespace", " codeBase", " codebas", "Codebase", "ceBase", "cheBase", "codebas", "coreBase", "codespace", "chefile", " codease"], "protocol": ["phyication", "protication", "proos", "pronocol", "pertocol", "cryptos", "patocol", "protol", "patol", "proocol", "cryptility", "proavior", "pronavior", "cryptix", "cryptotype", "scheication", "pronotype", "protos", "proicle", "scheix", "cryptication", "prootype", "pertavior", "scheocol", "cryptol", "phyocol", "pertotype", "proticle", "phyix", "pronicle", "prototype", "scheility", "cryptocol", "prool", "phyility", "patos", "perticle", "protavior", "protix", "protility", "patotype"], "x": ["xs", "xa", "z", "y", "X", "tx", "ax", "ux", "inx", "w", "nex", "mx", "t", "wx", "xy", "max", "xx", "i", "xc", "ox", "xxxxxxxx", " cx", "xi", "rx", "xes", "dx", "n", "xp", "xd", "index", "px", "p", "xf", "ix", "ex"], "s2": ["ps1", "es2", " s1", "s02", "ts4", "estwo", "ts3", "es1", "ps02", "sv02", "slt", "svtwo", "x1", "ts02", "ss4", "ss02", "s1", "pslt", " slt", "ts2", " stwo", "x02", "s4", "ss3", " s02", "s3", "ps2", "ss2", "xlt", "sv2", "es02", "stwo", "sv1"], "x2": [" x02", "rx02", "ix02", "ax3", "rx2", "x1", " x1", "ex02", "x02", "ax02", "x3", "ix1", "rx1", "ex3", "ex2", "ix2", "ex1", "ax1", "ax2", " x3"], "downloadHost": ["transferhost", "DownloadDomain", "dumphost", "dumpUrl", "DownloadPort", "downloadUrl", "transferHost", "archiveHead", " downloadhost", "DownloadPath", "dumpNode", " downloadNode", " downloadDomain", "downloadHead", "transferPort", "downloadPort", "dumpDomain", "DownloadHead", " downloadPath", "downloadNode", " downloadUrl", " downloadPort", "archiveUrl", "DownloadHost", "dumpHost", "DownloadNode", "archiveHost", "transferUrl", "downloadDomain", "archivehost", "downloadPath", "DownloadUrl", " downloadHead", "downloadhost", "dumpPath", "Downloadhost"], "url": ["browser", "hl", "gl", "sb", "ref", "json", "dl", "ob", "obj", "lb", "www", "bel", "ls", "web", "ll", "base", "link", "pl", "build", "sl", "open", "log", "call", "lr", "jar", "rel", "ur", "mount", "uri", "URL", "serv", "name", "str", "rl", "l", "nl", "ul", "mail", "ssl", "el", "ret", "zip", "http", "arl", "download", "atl", "mil", "file", "loc", "il", "Url", "ml"], "jurl": ["zgl", " jll", "jcname", "jarkl", " jgl", "jcUrl", "jjurl", "jll", "jURL", "jarurl", "jpUrl", "jckl", "jarname", "zll", " jUrl", "jssl", "JUrl", "jUrl", "jsUrl", " jsl", "jpsl", "jjob", "jsjob", "jjjob", "Jurl", "jpgl", "jsURL", "Jkl", " jjob", "jjUrl", "jsl", "jname", " jURL", "jpurl", "jjURL", "jcurl", "jsurl", "jsll", "zurl", "zUrl", "jarUrl", "Jname", "jkl", "jgl", "jsgl"], "je": ["ze", "pet", "dj", "j", "ie", "oe", "ee", "js", "se", "ei", " Je", "zy", "jl", "jet", "nex", "ae", "ve", "jj", "exe", "ffe", "vre", "zo", "bj", "e", "ja", "sec", "jo", "jen", "ele", "ge", "ese", "zip", "te", "jp", "elt", "ne", "pe"], "is": ["mi", "sb", "ois", "ist", "ins", "Is", "im", "js", "ri", "nis", "fs", "bs", "isa", "ais", "in", "tis", "bi", "bits", "ai", "ires", "i", "its", "ris", "os", "IS", "atis", "isc", "ir", "isl", "si", "lis", "obs", "s", "ists", "ii", "isi", "ios", "\u00eds", "isin", "iso", "iss", "il", "ib", "es", "sis"], "bis": ["sb", "ses", "buff", "res", "oss", "cb", "ins", "ob", "nis", "ri", "bps", "bh", "fr", "fs", "bs", "rison", "sbm", "ls", "ais", "conv", "ns", "tis", "bi", "bits", "pins", "xy", "bb", "its", "abin", "serv", "ris", "rs", "os", "bos", "bes", "ibe", "gs", "obs", "lis", "binary", "aos", "rots", "ubis", "onis", "vs", "uds", "bil", "isin", "oi", "isi", "ios", "es", "bytes", "uffy"], "size": ["ze", "type", "empty", "year", "iz", "notice", "settings", "small", "sample", "time", "capacity", "score", "storage", "area", "se", "sum", "status", "sex", "range", "ose", "shape", "message", "max", "re", "mode", "number", "sv", "scroll", "name", "now", "zie", "pi", "SIZE", "len", "length", "space", "si", "news", "sn", "num", "sy", "use", "nr", "count", "n", "scale", "Size", "send", "body", "index", "ize", "unit"], "rb": ["buf", "buster", "rc", "bone", "rar", "rss", "sb", "br", "RB", "pb", "ord", "ref", "rt", "rab", "mr", "rg", "cb", "ob", "rw", "cr", "ri", "lb", "umb", "ro", "ring", "wb", "err", "ctr", "bb", "lr", "db", "rm", "bp", "rd", "ptr", "nb", "rf", "kb", "rs", "ru", "rid", "eb", "rod", "num", "r", "nr", "rex", "erb", "rob", "xb", "ruby", "fb", "gb"], "chunk": ["tchunk", "cpork", "echunk", "Chunks", "chunks", "cpow", "Chunk", "cunk", "chbyte", "charord", "echbyte", "tchunks", "echord", "chedunk", "cow", "ichunks", "cpunks", "chulk", " chunks", "echunks", "chork", " choint", " chord", " chbyte", "cpunk", "charbyte", "charoint", "ichunk", "tchork", "chow", "chedump", "ichulk", " chulk", "charunk", "charunks", "chedoint", "Chulk", "choint", "cork", "chedunks", " chump", "charump", "chump", "chord", "cunks", "tchow"]}}
{"id1": "8132219", "id2": "9727056", "code1": "    public static void copyFile(String inFile, String outFile) {\n        File in = new File(inFile);\n        File out = new File(outFile);\n        try {\n            FileChannel inChannel = new FileInputStream(in).getChannel();\n            FileChannel outChannel = new FileOutputStream(out).getChannel();\n            try {\n                inChannel.transferTo(0, inChannel.size(), outChannel);\n            } finally {\n                if (inChannel != null) inChannel.close();\n                if (outChannel != null) outChannel.close();\n            }\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        }\n    }\n", "code2": "    @Override\n    public OBJModel loadModel(URL url, String skin) throws IOException, IncorrectFormatException, ParsingErrorException {\n        boolean baseURLWasNull = setBaseURLFromModelURL(url);\n        OBJModel model = loadModel(url.openStream(), skin);\n        if (baseURLWasNull) {\n            popBaseURL();\n        }\n        return (model);\n    }\n", "label": 0, "substitutes": {"copyFile": ["CopyFiles", "copyFiles", " copyfile", "CopyStream", " copyStream", " CopyStream", "copyfile", " Copyfile", " CopyFiles", "CopyFile", "copyStream", " CopyFile", "Copyfile", " copyFiles"], "inFile": ["inputFilename", "inFilename", "inputFile", "ninFilename", "inputName", "dinEmail", "inName", "ninName", "outFilename", "inPath", "dinFile", "innEmail", " inRow", "inTemplate", "dinPath", "inputTemplate", "innFile", "innRow", "ninFile", "innPath", "outTemplate", " inEmail", "inEmail", "inRow", "dinRow", "outName", " inPath", "ninTemplate"], "outFile": ["outFILE", "destfile", "inFilename", "outputfile", "ouFilename", " outfile", "outputFile", "destFILE", "outputTable", "outputFilename", "outfile", "destFormat", "outFilename", "ouFile", "outputFILE", "outputFormat", " outFILE", "ouFILE", "inFILE", "outTable", "destFile", "outFormat", " outFormat", "ouTable", "inTable"], "in": ["ze", "rin", "en", "inn", "ini", "irm", "gin", "IN", "ins", "on", "In", "init", "inner", "old", "ic", "ai", "up", "i", "bin", "inc", "input", "sin", "it", " din", "ir", " input", "ain", "s", "ind", "o", "el", "info", "din", "inf", "is", "isin", "source", "cin", "id", "from"], "out": ["all", "co", "en", "by", "output", "res", "client", "w", "t", "one", "net", "c", "b", "to", "v", "e", "name", "os", "it", "gt", "ou", "at", "outs", "g", "o", "aos", "ex", "n", "io", "Out", "file", "OUT", "p", "can", "ne", "ot"], "inChannel": ["cinChannel", "cinStream", "innSlot", "inButton", "newCategory", "newPanel", "inChan", "inColumn", "sinCategory", "isinCase", " inHandler", "insideChannel", "outBlock", "isinCategory", " inButton", "insideHandler", "vinCase", "cinColumn", "cinBlock", "outConnection", "sinSlot", "inCase", "insideComponent", "cinComponent", "isinSlot", "inHandler", "innerChan", "cinHandler", "innChannel", "inComponent", "cinButton", "vinPanel", " inConnection", "ginChannel", " inComponent", " inchannel", "innerChannel", "newChannel", "innCategory", "vinCategory", "innerConnection", "sinStream", "ginCase", "sinColumn", "vinChannel", "inCategory", "inPanel", "outStream", "inBlock", "newCase", "outColumn", " inChan", "inConnection", "inSlot", "inchannel", "innerchannel", "outChan", "sinChannel", "sinCase", "sinBlock", "innCase", "insideButton", "isinChannel", "outchannel", "ginPanel", "inStream", "ginCategory"], "outChannel": ["nStream", "outputConnection", "nChan", "oChan", "inChan", "exChain", "outBlock", "exBlock", "outConnection", "OutChannel", " outCh", "oClient", "outChain", " outChan", "OutChan", "exChan", "nChannel", " outStream", "inPassword", " outChain", " outClient", "outPassword", "outStream", " outConnection", "OutConnection", " outchannel", "exChannel", "inchannel", "nchannel", "outChan", "outputChannel", "outputCh", "oPassword", " outPassword", "outchannel", "outClient", "inClient", "oChannel", " outBlock", "OutCh", "inStream", "outCh", "outputChan"]}}
{"id1": "14047629", "id2": "22401746", "code1": "    protected ExternalDecoder(InputStream source, Process process) {\n        super(source);\n        this.process = process;\n        this.processStdOut = process.getInputStream();\n        this.processStdIn = process.getOutputStream();\n        new Thread() {\n\n            @Override\n            public void run() {\n                try {\n                    IOUtils.copy(getSource(), processStdIn);\n                    System.err.println(\"Copy done.\");\n                    close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                    IOUtils.closeQuietly(ExternalDecoder.this);\n                }\n            }\n        }.start();\n    }\n", "code2": "    public String sendRequest(java.lang.String servletName, java.lang.String request) {\n        String reqxml = \"\";\n        org.jdom.Document retdoc = null;\n        String myurl = java.util.prefs.Preferences.systemRoot().get(\"serverurl\", \"\");\n        String myport = java.util.prefs.Preferences.systemRoot().get(\"portno\", \"8080\");\n        if (this.serverURL == null) {\n            try {\n                java.net.URL codebase = newgen.presentation.NewGenMain.getAppletInstance().getCodeBase();\n                if (codebase != null) serverURL = codebase.getHost(); else serverURL = \"localhost\";\n            } catch (Exception exp) {\n                exp.printStackTrace();\n                serverURL = \"localhost\";\n            }\n            newgen.presentation.component.IPAddressPortNoDialog ipdig = new newgen.presentation.component.IPAddressPortNoDialog(myurl, myport);\n            ipdig.show();\n            serverURL = myurl = ipdig.getIPAddress();\n            myport = ipdig.getPortNo();\n            java.util.prefs.Preferences.systemRoot().put(\"serverurl\", serverURL);\n            java.util.prefs.Preferences.systemRoot().put(\"portno\", myport);\n            System.out.println(serverURL);\n        }\n        try {\n            System.out.println(\"http://\" + serverURL + \":\" + myport + \"/newgenlibctxt/\" + servletName);\n            java.net.URL url = new java.net.URL(\"http://\" + serverURL + \":\" + myport + \"/newgenlibctxt/\" + servletName);\n            java.net.URLConnection urlconn = (java.net.URLConnection) url.openConnection();\n            urlconn.setDoOutput(true);\n            urlconn.setRequestProperty(\"Content-type\", \"text/xml; charset=UTF-8\");\n            java.io.OutputStream os = urlconn.getOutputStream();\n            String req1xml = request;\n            java.util.zip.CheckedOutputStream cos = new java.util.zip.CheckedOutputStream(os, new java.util.zip.Adler32());\n            java.util.zip.GZIPOutputStream gop = new java.util.zip.GZIPOutputStream(cos);\n            java.io.OutputStreamWriter dos = new java.io.OutputStreamWriter(gop, \"UTF-8\");\n            System.out.println(req1xml);\n            dos.write(req1xml);\n            dos.flush();\n            dos.close();\n            System.out.println(\"url conn: \" + urlconn.getContentEncoding() + \"  \" + urlconn.getContentType());\n            java.io.InputStream ios = urlconn.getInputStream();\n            java.util.zip.CheckedInputStream cis = new java.util.zip.CheckedInputStream(ios, new java.util.zip.Adler32());\n            java.util.zip.GZIPInputStream gip = new java.util.zip.GZIPInputStream(cis);\n            java.io.InputStreamReader br = new java.io.InputStreamReader(gip, \"UTF-8\");\n            retdoc = (new org.jdom.input.SAXBuilder()).build(br);\n        } catch (java.net.ConnectException conexp) {\n            javax.swing.JOptionPane.showMessageDialog(null, newgen.presentation.NewGenMain.getAppletInstance().getMyResource().getString(\"ConnectExceptionMessage\"), \"Critical error\", javax.swing.JOptionPane.ERROR_MESSAGE);\n        } catch (Exception exp) {\n            exp.printStackTrace(System.out);\n        }\n        System.out.println(reqxml);\n        return \"\";\n    }\n", "label": 0, "substitutes": {"source": ["event", "image", "address", "output", "sample", "console", "service", "request", "resource", "reader", "se", "sequence", "stream", "in", "q", "buffer", "message", "system", "src", "result", "content", "Source", "format", "copy", "position", "SOURCE", "input", "proc", "query", "sql", "seed", "ource", "iterator", "channel", "file", "shell", "from", "data", "expression"], "process": ["handle", "and", "Process", "pid", "console", "task", "service", "frame", "execute", "se", "pp", "init", "processor", "processing", "create", "thread", "status", "sys", "pipe", "run", "script", "work", "context", "mem", "chain", "link", "command", "code", "build", "function", "flow", "call", "post", "program", "node", "cp", "state", "condition", "method", "proc", "cmd", "parse", "project", "component", "object", "term", "complex", "network", "use", "connect", "place", "make", "pm", "job", "exec", "file", "class", "memory", "check", "store", "p", "session"], "processStdOut": ["processStdEx", "processStdEr", "processStrdIn", "processStrrOut", "processStrOut", "processStrEx", "processStrdEx", "processStstdIn", "processStrrEx", "processStrEr", "processStstdEx", "processStstEr", "processStstdOut", "processStstdEr", "processStrdEr", "processStstEx", "processStrrEr", "processStrdOut", "processStstIn", "processStrrIn", "processStstOut", "processStrIn"], "processStdIn": ["processSTdIN", "processStsIN", "processStdsin", "processStackdOut", "processSTdOut", "processStackdsIN", "processStackdin", "processStrOut", "processSttIN", "processStackdsIn", "processStdsIn", "processStdIns", "processStackdIN", "processSTtIN", "processSTtOut", "processSttIns", "processSttOut", "processStsOut", "processStdin", "processStackdsOut", "processSTdIn", "processStrin", "processStackdIn", "processStrIns", "processStsin", "processSttIn", "processStdsIns", "processSTdIns", "processStdsIN", "processStdsOut", "processStdIN", "processStackdsin", "processStrIN", "processStrIn", "processSTtIns", "processSTtIn", "processStsIn"]}}
{"id1": "693636", "id2": "12417893", "code1": "    public static int createEmptyCart() {\n        int SHOPPING_ID = 0;\n        Connection con = null;\n        try {\n            con = getConnection();\n        } catch (java.lang.Exception ex) {\n            ex.printStackTrace();\n        }\n        try {\n            PreparedStatement insert_cart = null;\n            SHOPPING_ID = Integer.parseInt(Sequence.getSequenceNumber(\"shopping_cart\"));\n            insert_cart = con.prepareStatement(\"INSERT INTO shopping_cart (sc_id, sc_time) VALUES ( ? , NOW() )\");\n            insert_cart.setInt(1, SHOPPING_ID);\n            insert_cart.executeUpdate();\n            con.commit();\n            insert_cart.close();\n            returnConnection(con);\n        } catch (java.lang.Exception ex) {\n            try {\n                con.rollback();\n                ex.printStackTrace();\n            } catch (Exception se) {\n                System.err.println(\"Transaction rollback failed.\");\n            }\n        }\n        return SHOPPING_ID;\n    }\n", "code2": "    @Override\n    public byte[] download(URI uri) throws NetworkException {\n        log.info(\"download: \" + uri);\n        HttpGet httpGet = new HttpGet(uri.toString());\n        try {\n            HttpResponse httpResponse = httpClient.execute(httpGet);\n            return EntityUtils.toByteArray(httpResponse.getEntity());\n        } catch (IOException e) {\n            throw new NetworkException(e);\n        } finally {\n            httpGet.abort();\n        }\n    }\n", "label": 0, "substitutes": {"createEmptyCart": ["createEmptyOrder", " createEmptyProduct", " createNewCart", "createThisTransaction", "createZeroTransaction", " createEmptyOrder", "createNewTransaction", "createThisCart", "createEmptyTransaction", "createNewProduct", "createNewCart", "createEmptyProduct", " createEmptyTransaction", "createThisProduct", "createZeroProduct", " createNewOrder", " createNewProduct", "createNewOrder", "createZeroOrder", " createNewTransaction", "createZeroCart", "createThisOrder"], "SHOPPING_ID": ["SHOPPAP_UID", "SHOPPING_URL", "SHOPPAP_ID", "SHOPPINGINGIDS", "SHOPPING_VID", "SHOPPAP_IDS", "SHOPPINGIdID", "SHOPPTINGIDID", "SHOPPINGINGNUM", "SHOPPING_NUM", "SHOPPING_IDS", "SHOPPINGIdVID", "SHOPPINGITNUM", "SHOPPINGINGID", "SHOPPINGVALID", "SHOPPOT_IDs", "SHOPPIP_UID", "SHOPPINGVALid", "SHOPPINGIDID", "SHOPPINGITUID", "SHOPPINGIdNAME", "SHOPPOT_UID", "SHOPPIP_id", "SHOPPTING_VID", "SHOPPINGINGId", "SHOPPTING_URL", "SHOPPINGITID", "SHOPPINGIDVID", "SHOPPING_id", "SHOPPINGIDId", "SHOPPTINGIDVID", "SHOPPTINGIDURL", "SHOPPTING_NAME", "SHOPPINGPUID", "SHOPPOT_ID", "SHOPPTINGIDNAME", "SHOPPOTINGNUM", "SHOPPOTINGIDs", "SHOPPINGITIDs", "SHOPPINGIDNAME", "SHOPPOT_NUM", "SHOPPINGINGIDs", "SHOPPINGPNUM", "SHOPPINGINGUID", "SHOPPINGIDIDS", "SHOPPAP_Id", "SHOPPOTINGUID", "SHOPPINGVALUID", "SHOPPOTINGID", "SHOPPING_UID", "SHOPPINGPIDs", "SHOPPINGIDURL", "SHOPPINGPID", "SHOPPING_Id", "SHOPPING_NAME", "SHOPPINGIDUID", "SHOPPINGIdURL", "SHOPPING_IDs", "SHOPPTING_ID", "SHOPPIP_ID"], "con": ["co", "en", "rc", "win", "cat", "ctx", "cos", "dial", "cn", "cont", "bo", "cover", "ln", "client", "col", "conv", "cons", "connection", "po", "CON", "c", "ca", "bon", "fc", "open", "pg", "cur", "soc", "db", "re", "un", "conf", "com", "xc", "ct", "ran", "cp", "gc", "Conn", "pc", "coll", "const", "pen", "ch", "cal", " conn", "conn", "ctrl", "ain", "connect", "ren", "mc", "nc", "cf", "pool", "can", "Con", "cc", "ex"], "insert_cart": ["insert___cart", "insert_art", "insert2cod", "import___art", "insertPpt", "insert_cod", "entryMemarticle", "insertMemarticle", "insertPcontroller", "entry_art", " insert_art", "insert_controller", "insert___pt", "insert2cart", " insert_quant", "entryMemcart", "insertptquant", "import_art", "entryMemprogress", " insert_start", "import_Cart", "insertThearticle", "insertptcart", "insertingstart", "insert_progress", "entry_article", " insert2pt", "insertPTcart", "entryMemart", " insert2art", "import_controller", "insert___art", " insert2quant", "insert_start", "insert_pt", "insertTheart", "insert_pot", "insertMemart", " insert_cod", "insert_article", "insert2Cart", "insert2art", "entry_cart", "import_cart", " insert2start", "insertTheprogress", " insert2cod", "insertingart", "insert2progress", "insertptart", "insertPTart", "import_pot", "insertMemcart", "insert2pot", "insertingcart", "insertPart", "insert2quant", "import_pt", "insert2start", "insertPTcod", "import___controller", "import___pt", "entry_progress", "insertPTquant", "insertThecart", "insertMemprogress", "insert2pt", "insert_Cart", "insert2controller", "insert___controller", "import___cart", "insertptcod", " insert_pt", "insert2article", "insert_quant", "insertPcart", "insertingpt", " insert2cart"]}}
{"id1": "9275622", "id2": "12066447", "code1": "    private boolean copyFile(File _file1, File _file2) {\n        FileInputStream fis;\n        FileOutputStream fos;\n        try {\n            fis = new FileInputStream(_file1);\n            fos = new FileOutputStream(_file2);\n            FileChannel canalFuente = fis.getChannel();\n            canalFuente.transferTo(0, canalFuente.size(), fos.getChannel());\n            fis.close();\n            fos.close();\n            return true;\n        } catch (FileNotFoundException e) {\n        } catch (IOException e) {\n        }\n        return false;\n    }\n", "code2": "    protected void truncate(final File file) {\n        LogLog.debug(\"Compression of file: \" + file.getAbsolutePath() + \" started.\");\n        if (FileUtils.isFileOlder(file, ManagementFactory.getRuntimeMXBean().getStartTime())) {\n            final File backupRoot = new File(this.getBackupDir());\n            if (!backupRoot.exists() && !backupRoot.mkdirs()) {\n                throw new AppenderInitializationError(\"Can't create backup dir for backup storage\");\n            }\n            SimpleDateFormat df;\n            try {\n                df = new SimpleDateFormat(this.getBackupDateFormat());\n            } catch (final Exception e) {\n                throw new AppenderInitializationError(\"Invalid date formate for backup files: \" + this.getBackupDateFormat(), e);\n            }\n            final String date = df.format(new Date(file.lastModified()));\n            final File zipFile = new File(backupRoot, file.getName() + \".\" + date + \".zip\");\n            ZipOutputStream zos = null;\n            FileInputStream fis = null;\n            try {\n                zos = new ZipOutputStream(new FileOutputStream(zipFile));\n                final ZipEntry entry = new ZipEntry(file.getName());\n                entry.setMethod(ZipEntry.DEFLATED);\n                entry.setCrc(FileUtils.checksumCRC32(file));\n                zos.putNextEntry(entry);\n                fis = FileUtils.openInputStream(file);\n                final byte[] buffer = new byte[1024];\n                int readed;\n                while ((readed = fis.read(buffer)) != -1) {\n                    zos.write(buffer, 0, readed);\n                }\n            } catch (final Exception e) {\n                throw new AppenderInitializationError(\"Can't create zip file\", e);\n            } finally {\n                if (zos != null) {\n                    try {\n                        zos.close();\n                    } catch (final IOException e) {\n                        LogLog.warn(\"Can't close zip file\", e);\n                    }\n                }\n                if (fis != null) {\n                    try {\n                        fis.close();\n                    } catch (final IOException e) {\n                        LogLog.warn(\"Can't close zipped file\", e);\n                    }\n                }\n            }\n            if (!file.delete()) {\n                throw new AppenderInitializationError(\"Can't delete old log file \" + file.getAbsolutePath());\n            }\n        }\n    }\n", "label": 1, "substitutes": {"copyFile": [" cpfile", "copyFiles", " copyfile", " copyStream", " duplicatefile", " duplicateFiles", " cpFile", " duplicateFile", "copyStream", "copyfile", " copyFiles", " cpFiles", " cpStream", " duplicateStream"], "_file1": ["_FileInit", "_files1", "_ileOne", "_fileOne", "_linkInit", "_link2", "_fileInit", "_files2", "_link1", "_ile2", "_ileInit", "_File2", "_ile1", "_FileFirst", "_linkOne", "_File1", "_ileFirst", "_FileOne", "_filesOne", "_fileFirst", "_filesFirst"], "_file2": [" _file02", "_FILEb", "_FILE1", "_File02", "_file02", "_Fileb", "_image1", "_link2", "_linkTwo", "_link1", " _fileb", "_File2", " _File1", "_fileb", " _fileTwo", "_FILE2", " _FILEb", "_linktwo", "_fileTwo", "_image2", "_image02", "_Filetwo", "_FILE02", " _FileTwo", "_File1", " _File2", "_imageb", " _FILE2", " _filetwo", " _FILE02", " _Filetwo", "_filetwo", " _FILE1", "_FileTwo"], "fis": ["flis", "fais", "kis", "fi", "Fis", "ufi", "cfis", "qiss", "cos", "fris", " fris", "ufis", "Fris", "ufiss", "cfois", "cis", " fi", "ufios", "Fiss", "qis", "qios", "Fios", "cfiss", " fais", " fois", "kios", "fliss", "fli", "fiss", "Fos", "flios", "cios", "cais", "Fois", " fios", "fios", "qos", "fois", "kos", "cfris", " fiss", "kais"], "fos": ["flis", "ffos", "foes", "woes", "hose", "mos", "foss", "fose", "flos", " faos", " fows", "wis", "floss", "sfoss", "mows", "faos", " foes", "fows", "wos", "moes", "ffis", "hos", "wows", " fose", "hoes", "sfos", "floes", "ffoss", "woss", "sfoes", "maos", " foss", "sfose", "hoss", "ffoes", "waos"], "canalFuente": ["canalFalperor", "canallfuestro", "canallfuenza", "canalUteree", "canalTenente", "canalKuperor", "canalFalje", "canalfuent", "canalUtestro", "canallFuperor", "canalFuje", "canalFalestro", "canalUtente", "canalFiente", "canallFuent", "canalFueree", "canallfuperor", "canalfuenza", "canalKuje", "canallfuje", "canallFuestro", "canalTenent", "canalFuestro", "canalTenperor", "canalFient", "canalFalente", "canallFuenza", "canallFuje", "canallFueree", "canallFuente", "canallfuent", "canalFienza", "canalfuperor", "canalFuenza", "canalFalent", "canalfuente", "canallfuente", "canalfuje", "canalfuestro", "canalTenenza", "canalFiperor", "canalKuent", "canalFuperor", "canalKuente", "canalFuent", "canalFaleree", "canalUtent", "canallfueree", "canalfueree"]}}
{"id1": "810342", "id2": "16623181", "code1": "    public static void doVersionCheck(View view) {\n        view.showWaitCursor();\n        try {\n            URL url = new URL(jEdit.getProperty(\"version-check.url\"));\n            InputStream in = url.openStream();\n            BufferedReader bin = new BufferedReader(new InputStreamReader(in));\n            String line;\n            String version = null;\n            String build = null;\n            while ((line = bin.readLine()) != null) {\n                if (line.startsWith(\".version\")) version = line.substring(8).trim(); else if (line.startsWith(\".build\")) build = line.substring(6).trim();\n            }\n            bin.close();\n            if (version != null && build != null) {\n                if (jEdit.getBuild().compareTo(build) < 0) newVersionAvailable(view, version, url); else {\n                    GUIUtilities.message(view, \"version-check\" + \".up-to-date\", new String[0]);\n                }\n            }\n        } catch (IOException e) {\n            String[] args = { jEdit.getProperty(\"version-check.url\"), e.toString() };\n            GUIUtilities.error(view, \"read-error\", args);\n        }\n        view.hideWaitCursor();\n    }\n", "code2": "    public static void main(String[] args) {\n        File srcDir = new File(args[0]);\n        File dstDir = new File(args[1]);\n        File[] srcFiles = srcDir.listFiles();\n        for (File f : srcFiles) {\n            if (f.isDirectory()) continue;\n            try {\n                FileChannel srcChannel = new FileInputStream(f).getChannel();\n                FileChannel dstChannel = new FileOutputStream(dstDir.getAbsolutePath() + System.getProperty(\"file.separator\") + f.getName()).getChannel();\n                ByteBuffer buffer = ByteBuffer.allocate(1024);\n                int nr = 0;\n                srcChannel.position(nr);\n                nr += srcChannel.read(buffer);\n                while (nr < f.length()) {\n                    buffer.flip();\n                    dstChannel.write(buffer);\n                    buffer.clear();\n                    nr += srcChannel.read(buffer);\n                }\n                srcChannel.close();\n                dstChannel.close();\n            } catch (IOException e) {\n            }\n        }\n    }\n", "label": 0, "substitutes": {"doVersionCheck": ["DoDatecheck", "doDateCheck", "doVersionsCheck", "DoDateFix", "doVersionFix", "doLicensecheck", "DoVersioncheck", "DoVersionCheck", "DoVersionFix", "DoDateCheck", "doDateUpdate", "doDateFix", "DoDateUpdate", "DoVersionUpdate", "doVersionsUpdate", "doVersionsFix", "doDatecheck", "doVersionUpdate", "doLicenseFix", "doVersionscheck", "doLicenseCheck", "doVersioncheck", "doLicenseUpdate"], "view": ["browser", "report", "window", "hl", "cv", "layout", "image", "block", "subject", "util", "console", "engine", "client", "doc", "VIEW", "tv", "views", "table", "help", "context", "web", "page", "update", "q", "buffer", "open", "document", "call", "cell", "v", "widget", "review", "see", "iew", "host", "get", "input", "out", "wrapper", "query", "this", "controller", "tree", "form", "show", "component", "blade", "eye", "model", "View", "manager", "self", "row", "http", "html", "server", "file", "check", "index", "print", "display"], "url": ["f", "browser", "hl", "gl", "address", "json", "dl", "lb", "client", "bel", "web", "ls", "ll", "char", "date", "link", "pl", "sl", "log", "b", "lr", "rel", "ur", "v", "mount", "org", "uri", "URL", "str", "rl", "l", "oul", "nl", "ul", "path", "null", "language", "github", "r", "ssl", "http", "html", "socket", "string", "location", "file", "loc", "Url", "id", "host"], "in": ["f", "rin", "inn", "gin", "IN", "vin", "ins", "reader", "ln", "stream", "In", "init", "inner", "b", "asin", "kin", "i", "mat", "inc", "l", "input", "out", "sin", " IN", " din", "ain", "mn", "info", "n", "din", "inf", "is", "isin", "source", "file", "body", "cin"], "bin": ["rin", " Bin", "win", "inn", "buff", "stock", "by", "gin", "con", "bl", "bg", "cos", "obin", "reader", "bur", "ln", "bed", "pipe", "inner", "mem", "bi", "spin", "buffer", "b", "mon", "thin", "ran", "nb", " bins", "lib", "abin", "cache", "rb", "out", "sin", "len", " din", "conn", "binary", "local", "din", "sam", "file", "bn", "cin", "ebin", "loader"], "line": ["LINE", "lo", "style", "lin", "block", "text", "cat", "eline", "entry", "ine", "sample", "column", "part", "comment", "frame", "lane", "se", "ln", "ide", "word", "lines", "page", "ls", "col", "level", "base", "trace", "char", "chain", "range", "link", "log", "code", "one", "err", "load", "port", "cell", "ice", "state", "le", "liner", "l", "section", "iter", "cmd", "point", "path", "record", "Line", "el", "channel", " Line", "row", "string", "job", "no", "field", "inline", "file", "body", "store", "print"], "version": ["type", "browser", "ion", "translation", "major", "video", "license", "image", "value", "virtual", "match", "test", "versions", "serial", "release", "feature", "resource", "description", "client", "sequence", "river", "status", "tag", "VER", "Version", "software", "spec", "date", "command", "v", "number", "format", "vision", "name", "position", "hash", "project", "form", "language", "info", "key", "volume", "string", "scale", "vers", "usage", "iso", "VERSION", "latest", "index", "ver", "update", "python", "title"], "build": ["building", "style", "built", "match", "test", "fail", "util", "release", "builder", "other", "update", "tag", "work", "date", "link", "round", "ship", "log", "th", "load", "b", "old", "be", "db", "hold", "lib", "hash", "last", "Build", "project", "boost", "binary", "add", "use", "bor", "ble", "full", "make", "uild", "arch", "dist", "bug", "develop", "install", "where", "latest", "ward", "ver", "unit", "dev", "print", "struct"]}}
{"id1": "23310397", "id2": "15768167", "code1": "    public void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.main);\n        mButton1 = (Button) findViewById(R.id.myButton1);\n        mButton2 = (Button) findViewById(R.id.myButton2);\n        mTextView1 = (TextView) findViewById(R.id.myTextView1);\n        mButton1.setOnClickListener(new Button.OnClickListener() {\n\n            public void onClick(View v) {\n                String uriAPI = \"http://www.sina.com\";\n                HttpPost httpRequest = new HttpPost(uriAPI);\n                List<NameValuePair> params = new ArrayList<NameValuePair>();\n                params.add(new BasicNameValuePair(\"str\", \"post string\"));\n                try {\n                    httpRequest.setEntity(new UrlEncodedFormEntity(params, HTTP.UTF_8));\n                    HttpResponse httpResponse = new DefaultHttpClient().execute(httpRequest);\n                    if (httpResponse.getStatusLine().getStatusCode() == 200) {\n                        String strResult = EntityUtils.toString(httpResponse.getEntity());\n                        mTextView1.setText(strResult);\n                    } else {\n                        mTextView1.setText(\"Error Response: \" + httpResponse.getStatusLine().toString());\n                    }\n                } catch (ClientProtocolException e) {\n                    mTextView1.setText(e.getMessage().toString());\n                    e.printStackTrace();\n                } catch (IOException e) {\n                    mTextView1.setText(e.getMessage().toString());\n                    e.printStackTrace();\n                } catch (Exception e) {\n                    mTextView1.setText(e.getMessage().toString());\n                    e.printStackTrace();\n                }\n            }\n        });\n        mButton2.setOnClickListener(new Button.OnClickListener() {\n\n            public void onClick(View v) {\n                String uriAPI = \"http://www.sina.com\";\n                HttpGet httpRequest = new HttpGet(uriAPI);\n                try {\n                    HttpResponse httpResponse = new DefaultHttpClient().execute(httpRequest);\n                    if (httpResponse.getStatusLine().getStatusCode() == 200) {\n                        String strResult = EntityUtils.toString(httpResponse.getEntity());\n                        strResult = eregi_replace(\"(\\r\\n|\\r|\\n|\\n\\r)\", \"\", strResult);\n                        mTextView1.setText(strResult);\n                    } else {\n                        mTextView1.setText(\"Error Response: \" + httpResponse.getStatusLine().toString());\n                    }\n                } catch (ClientProtocolException e) {\n                    mTextView1.setText(e.getMessage().toString());\n                    e.printStackTrace();\n                } catch (IOException e) {\n                    mTextView1.setText(e.getMessage().toString());\n                    e.printStackTrace();\n                } catch (Exception e) {\n                    mTextView1.setText(e.getMessage().toString());\n                    e.printStackTrace();\n                }\n            }\n        });\n    }\n", "code2": "    public static void copyFile(File in, File out) throws Exception {\n        FileChannel sourceChannel = null;\n        FileChannel destinationChannel = null;\n        try {\n            sourceChannel = new FileInputStream(in).getChannel();\n            destinationChannel = new FileOutputStream(out).getChannel();\n            sourceChannel.transferTo(0, sourceChannel.size(), destinationChannel);\n        } finally {\n            if (sourceChannel != null) sourceChannel.close();\n            if (destinationChannel != null) destinationChannel.close();\n        }\n    }\n", "label": 0, "substitutes": {"onCreate": ["onCre", "OnNew", "onCreated", " onNew", " onCre", "onsCre", "onNew", "onsCreate", "whenCreated", " onCreat", "whenCreate", "onCreat", "onsNew", "OnCreate", "whenCreat", "whenCre", "OnCreated", " onCreated", "onsCreat", "onsCreated"], "savedInstanceState": ["savedInstantIn", "savedinstanceEx", "savedinstance_", "savedInstIn", "savingInstInfo", "savedInstState", "savedInstInfo", "savedInstancestate", "savedInstEx", "savingInstEx", "savedanceEx", "savedInst_", "savedanceState", "saveinstance_", "saveinstanceState", "savedInstanceInfo", "savedInstant_", "savedinstanceIn", "savedanceInfo", "savingInstanceState", "savedInstanceEx", "saveInstance_", "saveinstancestate", "savingInstanceEx", "savingInstState", "savedInstance_", "savedInststate", "savedInstantstate", "savedinstancestate", "savedinstanceState", "savedInstantState", "saveInstancestate", "savedinstanceInfo", "saveInstanceIn", "saveinstanceIn", "saveInstanceState", "savedInstanceIn", "savingInstanceInfo"], "mButton1": ["mAction11", "mDialog0", " mAction1", "mSwitchOne", "mAction1", "MLabel1", "MLabelOne", "mButton11", " mButtonOne", "mButtonA", "mLabel0", "mAction2", "mButtonOne", "mLabelOne", "mActionA", "MButton1", "MButton2", " mAction0", "mDialogOne", "MLabel2", " mActionOne", "MLabel11", "mSwitch11", "mLabel11", "mSwitch1", "mAction0", " mButtonA", "mButton0", "mActionOne", "mLabel2", "MButton11", "mDialog1", "mLabelA", " mActionA", "mSwitch2", " mButton0", "mLabel1", "MButtonOne", "mDialogA"], "mButton2": [" mAction6", "mConnector3", "mButton6", "mLabel0", " mAction2", "mAction2", "pButton2", "mConnector2", "pButton3", "pBut0", "mQueue3", "pButtonTwo", "pBut3", "mQueue6", " mAction3", "mLabelTwo", " mButton6", "mLabel2", "mButton0", "pBut2", "mBut0", "mConnectorTwo", "mAction3", "mButTwo", " mButton3", "mConnector6", "mConnector0", "mButtonTwo", "mLabel3", "pButton0", "mQueue2", "mBut3", "mButton3", "mBut2", "pButTwo", "mAction6"], "mTextView1": ["mTextModel3", "mTEXTView4", "mTEXTViewOne", "mTEXTview0", "mTEXTModel1", "mTextView8", "mTEXTStream4", "mTextviewOne", "mTEXTStream2", "mTextBoxOne", "mTEXTViewOnce", "mTEXTview8", "mTextV1", "mTEXTModelName", "mTEXTViewName", "mTextStream1", "mTextRow2", "mTEXTModelOnce", "mTextModelOne", "mTEXTView0", "mTEXTView8", "mTextview4", "mTEXTview1", "mTextViewOne", "mTextV3", "mTextViewOnce", "mTextView3", "mTextViewTab", "mTextModel8", "mTextRow0", "mTextview0", "mTextModelTab", "mTEXTView3", "mTEXTModel3", "mTextRow1", "mTEXTModel2", "mTextBox8", "mTextView2", "mTextStream4", "mTextview3", "mTextBoxTab", "mTextviewOnce", "mTextV2", "mTEXTviewTab", "mTextviewTab", "mTextView4", "mTEXTStream1", "mTextView0", "mTextModel2", "mTextModel1", "mTextViewName", "mTEXTView2", "mTEXTviewOne", "mTextModel4", "mTextStreamOne", "mTextBox1", "mTextStream2", "mTextModelOnce", "mTextview8", "mTextview1", "mTextModelName", "mTEXTview2", "mTextVName", "mTEXTViewTab", "mTextModel0", "mTextviewName", "mTextview2", "mTextBox2", "mTextRowOne", "mTEXTStreamOne", "mTEXTView1", "mTEXTModelOne"], "v": ["f", "u", "j", "z", "y", "uv", "vp", "d", "h", "m", "view", "t", "x", "q", "c", "b", "lv", "i", "e", "ov", "sv", "l", "V", "g", "o", "n", "vm", "id", "p", "a", "w"], "uriAPI": ["uriPLE", "uriVM", "uriPI", "databaseNP", "originAPI", "directionII", "directoryII", "originII", "pictureCI", "pictureAPI", "doiVM", "databasePLE", "pictureVM", "originapi", "URIID", "databasePI", "uiAPI", "paralleNP", "folderURI", "uriURI", "doiAPI", "uiII", "paralleAPI", "directionID", "uriapi", "uriCI", "surfacePI", "surfacePLE", "uriNP", "directoryURI", "parallePI", "URIAPI", "directionAPI", "databaseAPI", "uriID", "folderapi", "databaseCI", "picturePI", "parallePLE", "uiID", "originURI", "surfaceAPI", "doiCI", "surfaceNP", "directoryAPI", "directionURI", "doiPI", "URIURI", "URIII", "databaseVM", "folderAPI", "uriII", "uiURI", "folderII", "directoryapi"], "httpRequest": ["ttpRequest", " httpUpon", "HttpCommand", "HttpRequest", "facebookUpon", "httpsRequest", " httpCommand", "facebookResponse", "httpCommand", " httprequest", " httpQUEST", "facebookrequest", "httpQUEST", "httpQuery", "httpsQuery", "httpsCommand", "Httprequest", "httpUpon", "facebookRequest", "httQUEST", "ttpCommand", "ttpResponse", "httpsResponse", "httprequest", "httRequest", "HttpUpon", "ttpQuery", "ttpQUEST", "HttpResponse", "HttpQuery", "httResponse", " httpQuery"], "params": ["terms", "times", "forms", "tags", "photos", "json", "vals", "settings", "options", "pas", "parts", "request", "keys", "details", "lines", "marks", "names", "changes", "packages", "phys", "pins", "ps", "multi", "conf", "ams", "param", "properties", "pi", "pps", "rs", "caps", "pos", "api", "fields", "sql", "actions", "np", "gs", "pres", "Parameters", "members", "AMS", "objects", "padding", "groups", "requires", "values", "posts", "mas", "p", "data", "pass"], "httpResponse": ["httpresponse", "httpResult", "httpsResults", "ttpRequest", "htmlResults", "httpsReturn", "httpsRes", "HttpRequest", "htmlresponse", "httpsRequest", " httpReturn", "ttpResp", "httpsResult", "HTTPresponse", "HttpRes", "httpsResp", "htmlRequest", " httpResults", "htmlResponse", "httpResults", "htmlResult", " httpResp", " httpRes", " httpresponse", "ttpresponse", "httpRes", "HttpResult", "httpsresponse", "HTTPRequest", "Httpresponse", "httpResp", "httpsResponse", "ttpResponse", "HTTPResponse", "ttpResult", " httpResult", "HTTPResult", "HttpResponse", "httpReturn", "HttpReturn"], "strResult": ["StrResponse", "StrResults", "stringResponse", "stringResult", "STRResults", "Strresult", "stringRes", "StrResult", "stringresult", "StrRes", " strRes", "strresult", " strresult", "STRResult", "strResults", "strRes", "strResponse", "STRresult", " strResults", "STRResponse", "stringResults"]}}
{"id1": "12236729", "id2": "18974466", "code1": "        private void copy(File inputFile, File outputFile) throws Exception {\n            FileReader in = new FileReader(inputFile);\n            FileWriter out = new FileWriter(outputFile);\n            int c;\n            while ((c = in.read()) != -1) out.write(c);\n            in.close();\n            out.close();\n        }\n", "code2": "    protected boolean copyFile(File sourceFile, File destinationFile) {\n        try {\n            FileChannel srcChannel = new FileInputStream(sourceFile).getChannel();\n            FileChannel dstChannel = new FileOutputStream(destinationFile).getChannel();\n            dstChannel.transferFrom(srcChannel, 0, srcChannel.size());\n            srcChannel.close();\n            dstChannel.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n            return false;\n        }\n        return true;\n    }\n", "label": 1, "substitutes": {"copy": [" replicate", " combine", " operate", " recover", " merge", " transfer", " Copy", "transfer", "Copy", " restore", " seek", " upload", "cp", "read", " copying", " move", "paste", " append", " join", " parallel", " duplicate", " paste", " delete", " clone", " dup", " download", " cp", " cat"], "inputFile": [" inputfile", "outputDir", "outputPath", "configPost", "argumentfile", "inputPost", "argumentPath", "inile", "inputDir", " inputPost", " inputile", "inPath", "argumentFile", " inputPath", " inputDir", "inFile", "configfile", "configPath", "inputfile", "argumentPost", "outputile", "configFile", "inputPath", "inputile", "inDir"], "outputFile": ["outputDir", "outputPath", "outputPlace", " outputFilename", "outputfile", "outFile", "targetFile", "inputDir", "outputFilename", "writeFilename", "outfile", "targetDir", "writeDir", "outFilename", "targetfile", "targetPath", "writeFile", " outputPlace", "writePlace", "inputfile", "outPath", "inputPath", " outputDir", "outPlace", "outDir"], "in": ["ze", "all", "rin", "en", "inn", "ini", "min", "gin", "con", "IN", "ins", "ri", "reader", "on", "al", "In", "init", "inner", "inside", "old", "ic", "ai", "up", "i", "read", "bin", "inc", "input", "sin", "iter", "it", "per", " din", "ir", "ind", "info", "din", "inf", "is", "isin", "cin", "from"], "out": ["co", "en", "nt", "flush", "by", "con", "output", "res", "cos", "cn", "obj", "on", "client", "sys", "dis", "one", "net", "write", "print", "to", "end", "log", "ot", "v", "cache", "writer", "os", "outer", "it", "null", "ou", "at", "outs", "aos", "o", "g", "auto", "n", "io", "Out", "user", "check", "OUT", "can", "ne", "ex"], "c": ["f", "rc", "u", "z", "con", "cos", "character", "cb", "d", "cont", "cr", "C", "bc", "t", "x", "ce", "char", "code", "k", "cc", "chain", "cu", "current", "v", "i", "conf", "cp", "ct", "ac", "gc", "pc", "cache", "cm", "l", "ec", "cod", "ch", "lc", "cd", "unc", "r", "nc", "count", "n", "uc", "arc", "mc", "cap", "cf", "cs", "cl"]}}
{"id1": "6371607", "id2": "13233761", "code1": "    public void removeRealm(final List<Integer> realmIds) {\n        try {\n            connection.setAutoCommit(false);\n            new ProcessEnvelope().executeNull(new ExecuteProcessAbstractImpl(connection, false, false, true, true) {\n\n                @Override\n                public void executeProcessReturnNull() throws SQLException {\n                    psImpl = connImpl.prepareStatement(sqlCommands.getProperty(\"realm.remove\"));\n                    Iterator<Integer> iter = realmIds.iterator();\n                    int realmId;\n                    while (iter.hasNext()) {\n                        realmId = iter.next();\n                        psImpl.setInt(1, realmId);\n                        psImpl.executeUpdate();\n                        cmDB.removeRealm(realmId);\n                    }\n                }\n            });\n            connection.commit();\n        } catch (SQLException sqle) {\n            log.error(sqle);\n            if (connection != null) {\n                try {\n                    connection.rollback();\n                } catch (SQLException ex) {\n                }\n            }\n        } finally {\n            if (connection != null) {\n                try {\n                    connection.setAutoCommit(true);\n                } catch (SQLException ex) {\n                }\n            }\n        }\n    }\n", "code2": "    public void executeUpdateTransaction(List queries) throws SQLException {\n        assert connection != null;\n        boolean autoCommit = connection.getAutoCommit();\n        connection.setAutoCommit(false);\n        try {\n            Iterator iterator = queries.iterator();\n            while (iterator.hasNext()) {\n                String query = (String) iterator.next();\n                Statement statement = connection.createStatement();\n                statement.executeUpdate(query);\n            }\n            connection.commit();\n            connection.setAutoCommit(autoCommit);\n        } catch (SQLException e) {\n            connection.rollback();\n            throw new SQLException(e.getMessage());\n        }\n    }\n", "label": 1, "substitutes": {"removeRealm": ["removeAlmo", "remRealmo", "remrealarm", "removeSchems", "remrealM", "removeAlms", "removePerm", "removerealmo", "removePermo", "removeSchemo", "removeSchem", "removeRealarm", "remRealm", "remrealms", "removeAlm", "removerealM", "removerealm", "remrealm", "removerealarm", "remrealmo", "removePerms", "removePerM", "removeScheM", "removerealms", "removeRealms", "removeRealM", "removePerarm", "remRealarm", "remRealM", "remRealms", "removeRealmo", "removeAlarm"], "realmIds": ["realmidsNames", "realmsIdids", "realmByIdParts", "realmidsParts", "realmIdList", "realmsIdParts", "realmPathls", "realmByIdList", "realmIdNames", "realmIDList", "realmPathParts", "realmsIds", "realmsIdList", "realmIdids", "realmPaths", "realmsByIds", "realmsByIdNames", "realmIdls", "realmPathids", "realmsIdNames", "realmIdParts", "realmIDls", "realmidsids", "realmByIdids", "realmidsls", "realmByIdls", "realmByIds", "realmsByIdParts", "realmsByIdList", "realmByIdNames", "realmIDNames", "realmidsList", "realmsIdls", "realmidss", "realmsByIdls", "realmIDs", "realmsByIdids"], "psImpl": ["ppsImpl", " psimpl", "psObj", "epsObj", "PSImpl", "PSimpl", "pseImpl", "epsImpl", " psStack", "pseInstance", "psEl", "ppsInstance", "psExpl", "psInstance", "ppsExpl", " psInstance", " psEl", "psStack", "ppsEl", "PSEl", "ppsimpl", " psObj", "epsimpl", "epsExpl", "pseEl", "psimpl", "ppsStack", "PSExpl", "pseStack", "PSObj", " psExpl"], "iter": ["ser", "iz", "oper", "her", " iterator", "Iter", "inter", "liter", "vis", "loop", "i", "its", "ptr", "ator", "ait", "gen", "coll", "outer", "valid", "it", "hex", " iv", "walker", "li", "ori", "ir", "former", "ider", "upper", "gener", "per", "iv", "iner", "ind", "ev", "ip", "fer", "iterator", "nr", "inv", "ger", "ner", "vers", "lim", "er", "loc", "cer", "ver", "older", "iller", "ter", "ipper"], "realmId": ["realvmIs", "realgRef", "realMId", "balgmid", "realmiIs", "balmId", "realnRef", "trmReference", "pallemId", "realmeId", "realomID", "realmInd", "realmeInt", "realnId", "realomInd", "realmPath", "realvmId", "reallemId", "realvID", "realgId", "RealMId", "realmanReference", "trmID", "trvId", "RealmById", "realvInd", "realmeID", "trvReference", "RealMPath", "realMRef", "realgmID", "realmiId", "realmById", "RealMById", "pallemid", "realgmIs", "palmInt", "realmiid", "realvmid", "palmId", "realmanInd", "RealmId", "balmIs", "reallemid", "trvID", "realmInt", "realnPath", "realmID", "realmid", "realmeid", "balgmIs", "reallemInt", "realMById", "palmID", "realgmId", "pallemID", "realmanId", "pallemInt", "realvReference", "realmiID", "balgmID", "realmanID", "realmReference", "trmId", "realomReference", "palmid", "realgmid", "RealMRef", "realvmID", "realnById", "balmid", "RealmRef", "realmiInt", "realmIs", "trmInd", "reallemID", "realvId", "realMPath", "realgById", "realomId", "balmID", "realmRef", "realgPath", "balgmId", "trvInd", "RealmPath"]}}
{"id1": "21979462", "id2": "3809087", "code1": "    protected String downloadURLtoString(URL url) throws IOException {\n        BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream()));\n        StringBuffer sb = new StringBuffer(100 * 1024);\n        String str;\n        while ((str = in.readLine()) != null) {\n            sb.append(str);\n        }\n        in.close();\n        return sb.toString();\n    }\n", "code2": "    private boolean getWave(String url, String Word) {\n        try {\n            File FF = new File(f.getParent() + \"/\" + f.getName() + \"pron\");\n            FF.mkdir();\n            URL url2 = new URL(url);\n            BufferedReader stream = new BufferedReader(new InputStreamReader(url2.openStream()));\n            File Fdel = new File(f.getParent() + \"/\" + f.getName() + \"pron/\" + Word + \".wav\");\n            if (!Fdel.exists()) {\n                FileOutputStream outstream = new FileOutputStream(f.getParent() + \"/\" + f.getName() + \"pron/\" + Word + \".wav\");\n                BufferedWriter bwriter = new BufferedWriter(new OutputStreamWriter(outstream));\n                char[] binput = new char[1024];\n                int len = stream.read(binput, 0, 1024);\n                while (len > 0) {\n                    bwriter.write(binput, 0, len);\n                    len = stream.read(binput, 0, 1024);\n                }\n                bwriter.close();\n                outstream.close();\n            }\n            stream.close();\n        } catch (Exception e) {\n            System.out.println(e.getMessage());\n            return false;\n        }\n        return true;\n    }\n", "label": 0, "substitutes": {"downloadURLtoString": [" downloadURLToString", " downloadurloBytes", " downloadURLtoBytes", " downloadURL2Text", " downloadurltoJSON", " downloadURLoBytes", " downloadURLoString", " downloadURLToBytes", " downloadurltoBytes", " downloadURLToText", " downloadurltoString", " downloadURL2Bytes", " downloadURLoText", " downloadURL2JSON", " downloadURLoJSON", " downloadURL2String", " downloadURLToJSON", " downloadurloJSON", " downloadurloText", " downloadURLtoJSON", " downloadURLtoText", " downloadurltoText", " downloadurloString"], "url": ["browser", "all", "gl", "address", "ref", "dl", "resource", "bel", "web", "ls", "ll", "run", "base", "char", "link", "log", "sl", "un", "ur", "mount", "uri", "URL", "name", "l", "uu", "ul", "mail", "rect", "ssl", "domain", "ret", "http", "location", "job", "file", "Url", "id"], "in": ["all", "inn", "and", "by", "gin", "con", "IN", "ins", "reader", "on", "oin", "sum", "al", "In", "inner", "ill", "ic", "thin", "ai", "re", "up", "conf", "i", "read", "bin", "copy", "inc", "input", "out", "or", "it", "again", "ind", "ma", "mn", "mc", "info", "io", "din", "inf", "er", "is", "isin", "cin", "check", "from"], "sb": ["bt", "pa", "pb", "bf", "bg", "sp", "cb", "zb", "lb", "bh", "bs", "bsp", "wb", "sa", "sq", "sg", "b", "bb", "db", "bj", "SB", "bp", "gc", "sd", "sk", "nb", "kb", "rb", "sf", "ub", "eb", "lp", "mb", "bis", "ssl", "erb", "sam", "xb", "rob", "bn", "gob", "gb", "ib", "bd", "ab"], "str": ["txt", "div", "tr", "br", "text", "j", "block", "cat", "vol", "bl", "next", "comm", "sp", "cont", "comment", "part", "obj", "m", "fr", "set", "ls", "bc", "t", "char", "chain", "del", "err", "sl", "b", "cur", "Str", "dr", "re", "list", "i", "req", "def", "pt", "l", "iter", "comp", "ch", "expr", "st", "s", "dat", "syn", "r", "n", "sts", "string", "gr", "msg", "STR", "exec", "source", "arr", "p", "print"]}}
{"id1": "16048516", "id2": "6371589", "code1": "    public static SVNConfiguracion load(URL urlConfiguracion) {\n        SVNConfiguracion configuracion = null;\n        try {\n            XMLDecoder xenc = new XMLDecoder(urlConfiguracion.openStream());\n            configuracion = (SVNConfiguracion) xenc.readObject();\n            configuracion.setFicheroConfiguracion(urlConfiguracion);\n            xenc.close();\n        } catch (Exception exception) {\n            exception.printStackTrace();\n        }\n        return configuracion;\n    }\n", "code2": "    public void insertUser(final List<NewUser> newUsers) {\n        try {\n            connection.setAutoCommit(false);\n            final Map<String, PasswordAndSalt> pass = new HashMap<String, PasswordAndSalt>();\n            final Map<String, List<RealmWithEncryptedPass>> realmPass = new HashMap<String, List<RealmWithEncryptedPass>>();\n            final List<String> userDirs = new ArrayList<String>();\n            Iterator<NewUser> iter = newUsers.iterator();\n            NewUser user;\n            Realm realm;\n            String username;\n            PasswordHasher ph;\n            while (iter.hasNext()) {\n                user = iter.next();\n                username = user.username.toLowerCase(locale);\n                ph = PasswordFactory.getInstance().getPasswordHasher();\n                pass.put(user.username, new PasswordAndSalt(ph.hashPassword(user.password), ph.getSalt()));\n                realmPass.put(user.username, new ArrayList<RealmWithEncryptedPass>());\n                realmPass.get(user.username).add(new RealmWithEncryptedPass(cm.getRealm(\"null\"), PasswordFactory.getInstance().getPasswordHasher().hashRealmPassword(username, \"\", user.password)));\n                if (user.realms != null) {\n                    for (String realmName : user.realms) {\n                        realm = cm.getRealm(realmName);\n                        realmPass.get(user.username).add(new RealmWithEncryptedPass(realm, PasswordFactory.getInstance().getPasswordHasher().hashRealmPassword(username, realm.getFullRealmName(), user.password)));\n                    }\n                    user.realms = null;\n                }\n            }\n            new ProcessEnvelope().executeNull(new ExecuteProcessAbstractImpl(connection, false, false, true, true) {\n\n                @Override\n                public void executeProcessReturnNull() throws SQLException {\n                    psImpl = connImpl.prepareStatement(sqlCommands.getProperty(\"user.add\"), Statement.RETURN_GENERATED_KEYS);\n                    Iterator<NewUser> iter = newUsers.iterator();\n                    NewUser user;\n                    DomainDb domain = null;\n                    while (iter.hasNext()) {\n                        user = iter.next();\n                        psImpl.setString(1, user.username);\n                        psImpl.setString(2, user.username.toLowerCase(locale));\n                        if (domain == null || (domain.getDomainId() != user.domainId)) {\n                            domain = (DomainDb) cmDB.getDomain(user.domainId);\n                        }\n                        userDirs.add(user.username + '@' + domain.getDomainName());\n                        psImpl.setInt(3, user.domainId);\n                        psImpl.setString(4, pass.get(user.username).password);\n                        psImpl.setString(5, pass.get(user.username).salt);\n                        psImpl.executeUpdate();\n                        rsImpl = psImpl.getGeneratedKeys();\n                        if (rsImpl.next()) {\n                            user.userId = rsImpl.getInt(1);\n                            rsImpl.close();\n                        } else {\n                            throw new SQLException(\"Need to have a user id generated.\");\n                        }\n                    }\n                }\n            });\n            new ProcessEnvelope().executeNull(new ExecuteProcessAbstractImpl(connection, false, false, true, true) {\n\n                @Override\n                public void executeProcessReturnNull() throws SQLException {\n                    psImpl = connImpl.prepareStatement(sqlCommands.getProperty(\"realm.addUser\"));\n                    Iterator<NewUser> iter = newUsers.iterator();\n                    NewUser user;\n                    List<RealmWithEncryptedPass> list;\n                    RealmWithEncryptedPass rwep;\n                    RealmDb realm;\n                    while (iter.hasNext()) {\n                        user = iter.next();\n                        list = realmPass.get(user.username);\n                        if (list != null) {\n                            Iterator<RealmWithEncryptedPass> iter1 = list.iterator();\n                            while (iter1.hasNext()) {\n                                rwep = iter1.next();\n                                realm = (RealmDb) rwep.realm;\n                                psImpl.setInt(1, realm.getRealmId());\n                                psImpl.setInt(2, user.userId);\n                                psImpl.setInt(3, user.domainId);\n                                psImpl.setString(4, rwep.password);\n                                psImpl.executeUpdate();\n                            }\n                        }\n                    }\n                }\n            });\n            connection.commit();\n            Iterator<String> iterator = userDirs.iterator();\n            while (iterator.hasNext()) {\n                cm.requestDirCreation(new File(cm.getUsersDirectory(), iterator.next()).getPath());\n            }\n            cm.createDirectories();\n        } catch (GeneralSecurityException e) {\n            log.error(e);\n            if (connection != null) {\n                try {\n                    connection.rollback();\n                } catch (SQLException ex) {\n                }\n            }\n            throw new RuntimeException(\"Error updating Realms. Unable to continue Operation.\");\n        } catch (SQLException sqle) {\n            log.error(sqle);\n            if (connection != null) {\n                try {\n                    connection.rollback();\n                } catch (SQLException ex) {\n                }\n            }\n        } finally {\n            if (connection != null) {\n                try {\n                    connection.setAutoCommit(true);\n                } catch (SQLException ex) {\n                }\n            }\n        }\n    }\n", "label": 0, "substitutes": {"load": [" loader", " fill", " reconstruct", "loads", " reload", "create", "init", " loads", "build", "open", " restore", "content", "read", "get", "upload", "dump", " loaded", "LOAD", "construct", "parse", "Load", "download", "config", " overload", " Load", " download", "loader"], "urlConfiguracion": ["urlConfigoraci", "urlconfigoracion", "urlConfigoracion", "urlConfigureatable", "urlConfigulaton", "urlconfiguaton", "urlConfigurateacion", "urlConfiguriacion", "urlConfiguicion", "urlConfiguriicion", "urlconfigoraci", "urlConfigURATION", "urlConfigulaci", "urlConfigruator", "urlconfiguraci", "urlConfigureaton", "urlConfigurateatable", "urlExecurateaton", "urlConfigruaton", "urlConfiguriaton", "urlExecuratable", "urlConfigurator", "urlconfiguracion", "urlConfigurateator", "urlConfiguraci", "urlExecurateacion", "urlConfigoraton", "urlConfigurateaton", "urlConfiguaci", "urlExecuraton", "urlConfigureator", "urlExecurator", "urlConfigureacion", "urlConfiguriaci", "urlConfigoricion", "urlConfigruatable", "urlExecuracion", "urlConfigulacion", "urlConfiguaton", "urlConfigURacion", "urlConfiguraton", "urlConfigurATION", "urlconfigoraton", "urlConfiguATION", "urlconfiguATION", "urlConfiguacion", "urlconfiguacion", "urlconfiguraton", "urlconfiguricion", "urlconfigurATION", "urlConfigulATION", "urlConfiguratable", "urlConfiguricion", "urlconfigoricion", "urlconfiguaci", "urlConfigURaci", "urlConfigURaton", "urlExecurateatable", "urlConfigruacion", "urlExecurateator"], "configuracion": ["configureraton", "configurateaton", "configuraton", "configuraci", "configurericion", "configurcation", "configurATION", "configurationation", "configuacion", " configureicion", "configureATION", "configureaci", "configurance", " configureacion", "configuicion", "configureacion", " configurecation", "execurableation", "figuricion", " configureaci", "configauracion", "configureance", "configureracion", "configauricion", "configuricion", "execuraton", "execurableaton", "configurationicion", "configurableaton", "configureation", " configureATION", "execurATION", " configuraci", "figureance", "execurableacion", "configurableation", "configurationATION", "configauraci", "configuration", "configuance", "figurance", "execurableATION", "figuracion", "configurerATION", "configauraton", "configurationacion", " configureaton", "configuaton", "configurableacion", "figureacion", "configurateaci", "configaurcation", "configureaton", "figuraton", "configaurance", "configureicion", "figureicion", "execuracion", " configurATION", "configurecation", "execuration", " configurcation", "configurableATION", " configuricion", "figureaton", "configuratecation", "configurateacion", " configuraton", "configurationaton"], "xenc": ["xen", "axvec", "Xenc", " xen", "xten", "xtdec", "axorc", "Xdec", "xEnc", "uxdec", " xorc", "xorc", " xdec", "xtenc", "xtEnc", "uxorc", "uxvec", "axdec", " xvec", "rxec", "Xen", "rxEnc", "XEnc", "uxenc", "axenc", " xec", "rxenc", " xEnc", "Xec", "xvec", "xdec", "rxen", "xec"]}}
{"id1": "8064604", "id2": "7761195", "code1": "    public void init(ConnectionManager mgr, Hashtable cfg, Socket sock) throws RemoteException {\n        _cman = mgr;\n        _sock = sock;\n        for (int i = 0; i < 256; i++) {\n            String key = Integer.toHexString(i);\n            if (key.length() < 2) key = \"0\" + key;\n            availcmd.push(key);\n            commands.put(key, null);\n        }\n        try {\n            _sout = new PrintWriter(_sock.getOutputStream(), true);\n            _sinp = new BufferedReader(new InputStreamReader(_sock.getInputStream()));\n            String seed = \"\";\n            Random rand = new Random();\n            for (int i = 0; i < 16; i++) {\n                String hex = Integer.toHexString(rand.nextInt(256));\n                if (hex.length() < 2) hex = \"0\" + hex;\n                seed += hex.substring(hex.length() - 2);\n            }\n            String pass = _mpsw + seed + _spsw;\n            MessageDigest md5 = MessageDigest.getInstance(\"MD5\");\n            md5.reset();\n            md5.update(pass.getBytes());\n            String hash = hash2hex(md5.digest()).toLowerCase();\n            String banner = \"INIT \" + \"servername\" + \" \" + hash + \" \" + seed;\n            sendLine(banner);\n            String txt = readLine(5);\n            if (txt == null) {\n                throw new IOException(\"Slave did not send banner !!\");\n            }\n            String sname = \"\";\n            String spass = \"\";\n            String sseed = \"\";\n            try {\n                String[] items = txt.split(\" \");\n                sname = items[1].trim();\n                spass = items[2].trim();\n                sseed = items[3].trim();\n            } catch (Exception e) {\n                AsyncSlaveListener.invalidSlave(\"INITFAIL BadKey\", _sock);\n            }\n            pass = _spsw + sseed + _mpsw;\n            md5 = MessageDigest.getInstance(\"MD5\");\n            md5.reset();\n            md5.update(pass.getBytes());\n            hash = hash2hex(md5.digest()).toLowerCase();\n            if (!sname.equals(_name)) {\n                AsyncSlaveListener.invalidSlave(\"INITFAIL Unknown\", _sock);\n            }\n            if (!spass.toLowerCase().equals(hash.toLowerCase())) {\n                AsyncSlaveListener.invalidSlave(\"INITFAIL BadKey\", _sock);\n            }\n            _cman.getSlaveManager().addSlave(_name, this, getSlaveStatus(), -1);\n            start();\n        } catch (IOException e) {\n            if (e instanceof ConnectIOException && e.getCause() instanceof EOFException) {\n                logger.info(\"Check slaves.xml on the master that you are allowed to connect.\");\n            }\n            logger.info(\"IOException: \" + e.toString());\n            try {\n                sock.close();\n            } catch (Exception e1) {\n            }\n        } catch (Exception e) {\n            logger.warn(\"Exception: \" + e.toString());\n            try {\n                sock.close();\n            } catch (Exception e2) {\n            }\n        }\n        System.gc();\n    }\n", "code2": "    public synchronized String encrypt(String plaintext) throws Exception {\n        StringBuffer sb = new StringBuffer();\n        MessageDigest md = null;\n        try {\n            md = MessageDigest.getInstance(\"SHA-512\");\n        } catch (NoSuchAlgorithmException e) {\n            throw new Exception(e.getMessage());\n        }\n        try {\n            md.update(plaintext.getBytes(\"UTF-8\"));\n        } catch (UnsupportedEncodingException e) {\n            throw new Exception(e.getMessage());\n        }\n        byte raw[] = md.digest();\n        String hash = (new BASE64Encoder()).encode(raw);\n        return hash;\n    }\n", "label": 1, "substitutes": {"init": ["Init", "dial", "reset", "prep", " Init", "create", "set", "open", "load", "get", "bind", "initial", "login", "it", "dump", "construct", "auth", "use", "register", "connect", "config", "start", "update", "hook", "setup"], "mgr": ["rmgr", "mmg", "lGr", "mGr", "mnd", "lnd", "Mdr", "cGr", "cmg", "rmGr", "lmg", "Mmg", "lgr", "cdr", " mdr", "MGr", "mdr", "cgr", " mnd", "Mgr", "rmmg", " mmg", "rmnd", " mGr"], "cfg": [" conf", " setup", " config", " mc", " sch", "cb", " msg", " cf", "keys", " sched", " md", " caps", "ctr", "db", " cz", "Config", "conf", "ct", " sp", "Conf", " cc", "g", " df", " cs", "config", "cf", " sane", "map", " cp"], "sock": ["slip", " sip", " sox", "jsox", "jsock", "slock", "sox", "snip", "sow", "snow", "snock", "jsink", "spock", " sow", "snvc", " sink", "svc", " svc", "socks", "slow", "spink", "spocks", " socks", "jsocks", "slvc", "sink", "sip", "spox"], "_cman": ["_dman", "_rgr", "_mman", " _dgr", "_dctr", " _dml", " _dctr", "_mctr", " _dman", "_mgr", " _cctr", "_mml", "_cctr", "_cgr", "_rml", "_dgr", " _cml", "_rctr", "_cml", "_dml", "_rman", " _cgr"], "_sock": ["_sq", "_csck", "_socks", "_Socks", "_lsice", "_rsock", " _ssock", "_lsock", "_Socket", "_tocks", "_sice", "_nsice", "_ssock", "_lsoc", " _ssek", "_svock", "_src", "_csock", " _sck", "_dsrc", "_svice", "_sockey", "_svq", "_dsck", " _socket", " _socked", "_svoc", "_Socked", " _rsck", "_dsock", "_rsocket", "_socked", " _sockey", "_Sock", "_nsq", "_ssockey", "_sourceockey", " _rsocket", " _ssockey", "_dsocks", "_ssek", "_sourceek", "_spocked", "_spockey", " _rsock", " _ssocked", "_rsck", "_soc", "_csocked", "_Sck", "_rsocked", "_tock", "_trc", "_lsq", "_sourceocked", "_spek", "_Src", " _sek", "_sourceock", "_nsock", "_nsoc", "_spock", "_socket", "_sck", " _rsocked", "_csocket", "_ssocked", "_sek", "_tck"], "i": ["y", "I", "di", "ti", "t", "me", "q", "err", "c", "ic", "sim", "gi", "v", "pi", "it", "sql", "\u0438", "ip", "info", "n", "io", "index", "loop", "f", "iy", "ini", "us", "x", "hi", "cli", "integer", "ci", "name", "xi", "si", "g", "batch", "is", "ity", "mac", "id", "ix", "gu", "u", "j", "im", "iu", "in", "chain", "k", "bi", "multi", "ui", "e", "counter", "my", "o", "phi", "mi", "ie", "qi", "m", "ki", "client", "set", "ami", "ai", "l", "this", "li", "ii", " I", "p", "print", "ex"], "key": ["phrase", "tip", "pair", "json", "value", "lock", "item", "by", "y", "entry", "ke", "ie", "test", "et", "word", "client", "foo", "air", "sum", "cy", "col", "x", "Key", "char", "chain", "k", "q", "command", "code", "cert", "primary", "list", "conf", "def", "cp", "name", "important", "str", "ch", "cmd", "parent", "my", "this", "path", "ip", "row", "string", "n", "mk", "mac", "check", "index", "p", "print", "ex", "prefix", "title", "KEY"], "_sout": ["_svamp", "_wsout", "_ssco", " _sres", "_ssout", "_sco", " _svamp", "_svco", "_wsres", "_wsamp", " _svco", "_wsco", "_ssres", " _svout", "_sres", " _svres", "_svout", "_samp", "_ssamp", "_svres", " _samp", " _sco"], "_sinp": ["_cinp", "_binh", " _sinm", "_sinh", "_binp", " _cinP", " _cinh", " _sinh", "_sinP", " _cinp", "_senP", "_cinh", "_senh", "_cinP", "_sinm", "_senm", "_binP", " _cinm", " _sinP", "_binm", "_senp", "_cinm"], "seed": ["ser", "insert", " seeded", "Salt", "sample", "random", "test", "entry", "sp", "serial", "shift", "pse", "draw", "se", "then", "sequence", "secret", "set", "sum", "tmp", "sudo", "feed", "shadow", "sid", "stable", "sl", "sett", "db", "finger", "node", "now", "token", "sel", "iter", "delay", "dd", "offset", "mix", "sn", "uid", "slot", "zip", "row", "socket", "temp", "eed", "source", "password", "prime", "index", "id", "store", "dev", "server", "prefix"], "rand": ["rc", "z", "by", "and", "rt", "res", "random", "mr", "ng", "draw", "sys", "ro", "range", "red", "round", "rest", "dr", "max", "reg", "rd", "kick", "pos", "rot", "rx", "Rand", "rad", "rev", "normal", "add", "r", "inv", "mk", "spr", "user", "dev", "nd", "gen", "bot", "radius"], "hex": ["exp", "pex", "hl", "oct", "tr", "json", "prop", " Hex", "buff", "alpha", "tx", "random", "hello", "serial", "h", "raw", "x", "mem", "char", "sex", "hw", "cas", "cert", "lit", "tex", "color", "ph", "com", "def", "none", "sh", "str", "des", "iter", "ch", "form", "length", "term", "mix", "hp", "hook", "rex", "full", "zip", "kw", "html", "string", "cf", "temp", "rh", "mac", "wh", "password", "he", "index", "print", "bytes", "prefix", "ex"], "pass": ["phrase", "access", "handle", "PASS", "pair", "step", "process", "pillar", "ress", "reset", "pas", "rep", "test", "fail", "res", "task", "word", "pp", "secret", "allow", "sum", "gate", "prefix", "ack", "push", "ps", "strip", "wd", "conf", "read", "def", "act", "alt", "name", "str", "ask", "pos", "out", "pack", "parse", "val", "path", "press", "add", "ret", "Pass", "ass", "password", "send", "p", "print", "gen"], "md5": [" MD2", " MD64", "MD45", "md45", "MD2", "dig4", "dig45", "MD5", " md_", "MD3", " md64", "hash2", " md3", "dig5", " md2", " MD3", "MD_", " Md5", "MD23", "dig3", "hash23", "MD4", " Md2", "dig_", " md23", "md_", "md4", " md45", " md4", "hash3", "hash5", "md23", "md3", "MD64", "md2", " Md4", " MD5", "md64"], "hash": ["type", "browser", "buster", "handle", "style", "ash", "Hash", "her", "random", "test", "h", "sum", "sha", "flash", "addr", "hz", "cert", "name", "token", "total", "alph", "data", "search", "height", "crypt", "html", "hat", "temp", "rh", "bolt", "password", "mac", "ssh", "version", "id", "print", "host", "header", "title"], "banner": ["buginner", "rainer", "binner", " banler", "scannel", " baninner", "raininner", "broadner", "banler", "rainler", "rainner", "broadinner", "baner", "banline", "bugner", "bininner", "broadline", "bugter", "baninner", "Banler", "Baninner", "scaninner", " banline", "bannel", "broadnel", "Banner", "scanline", "scanker", "Baner", "banker", "bugker", "binker", "scanter", "scanner", "binter", "banter", " bannel", " baner"], "txt": ["nt", "nm", "json", "tg", "text", "buff", "writers", "tp", "res", "tx", "rt", "sit", "tk", "cont", "js", "obj", "details", "ws", "htm", "lt", "kt", "tmp", "tin", "t", "tch", "ns", "mint", "print", "notes", "words", "xml", "tn", "ext", "ct", "xt", "plain", "def", "str", "out", "TEXT", "XT", "btn", "wt", "priv", "dat", "utt", "Text", "typ", "ret", "html", "msg", "fn", "qt", "tif", "tm", "data"], "sname": ["lsname", "same", "spadmin", "ssname", "lsnam", "ssame", "ssnam", " same", "snam", " sName", "lsame", "ssName", "sName", "spnam", "ssadmin", "spame", "lsadmin", "spname", " snam", "sadmin"], "spass": ["psss", "spwd", "pswd", "SPASS", "ospass", "ospss", "sposs", "SPack", "SPass", "ospwd", " spss", "spASS", " sposs", " spack", "ospASS", "spss", " spred", "psass", "ospred", "psred", "osposs", " spwd", "ospack", " spASS", "spack", "SPoss", "spred"], "sseed": ["srandom", " siter", "psentry", "pseed", "peed", "wssel", "tsser", "ssiter", "prandom", "wspass", "Srandom", "Seed", "tsseed", "siter", "wsentry", " sser", "pspass", "psseed", "ssseed", "ssser", "wsseed", "ssecret", "psecret", "sser", "Ssecret", "tsiter", "pssel", "Sseed", "sentry", "tseed", "ssel"], "items": ["terms", "times", "amps", "xs", "stuff", "ics", "els", "item", "ms", "links", "orders", "rows", "ins", "Items", "arts", "EMS", "keys", "details", "types", "lines", "qs", "ites", "phones", "stats", "airs", "mods", "flows", "boxes", "its", "styles", "ips", "rs", "images", "ids", "blocks", "ops", "actions", "ims", "cats", "objects", "ars", "aux", "cases", "pages", "groups", "files", "values", "lets", "arms", "ues", "results", "faces", "abs"]}}
{"id1": "21092340", "id2": "21125261", "code1": "    public static URL addToArchive(Pod pod, ZipOutputStream podArchiveOutputStream, String filename, InputStream source) throws IOException {\n        ZipEntry entry = new ZipEntry(filename);\n        podArchiveOutputStream.putNextEntry(entry);\n        IOUtils.copy(source, podArchiveOutputStream);\n        podArchiveOutputStream.closeEntry();\n        return PodArchiveResolver.withinPodArchive(pod, filename);\n    }\n", "code2": "    @Test\n    public void test() throws Exception {\n        InputStream is = this.getClass().getResourceAsStream(\"originAndDestination.xml\");\n        ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();\n        IOUtils.copy(is, byteArrayOutputStream);\n        TrafficModelDefinition def = MDFReader.read(byteArrayOutputStream.toByteArray());\n        TrafficSimulationEngine se = new TrafficSimulationEngine();\n        se.init(def);\n        int linkId = 2;\n        int segmentId = 0;\n        Map<Integer, Set<Integer>> linkSegments = new HashMap<Integer, Set<Integer>>();\n        Set<Integer> segments = new HashSet<Integer>();\n        segments.add(segmentId);\n        linkSegments.put(linkId, segments);\n        FrameProperties frameProperties = new FrameProperties(linkSegments, new HashSet<Integer>());\n        se.setFrameProperties(frameProperties);\n        for (float time = 0; time < 60 * 10; time += 0.1f) {\n            se.step(0.1f);\n            for (RoadObject vehicle : se.getDynamicObjects()) {\n                System.out.println(time + \": X=\" + vehicle.getPosition() + \"\\tV=\" + vehicle.getSpeed());\n            }\n        }\n    }\n", "label": 1, "substitutes": {"addToArchive": ["addInHarive", "addInArchFile", "addToArchFile", "addToHarZip", "addToExiver", "addToArchiver", "addInHariver", "addInHarZip", "addToHarFile", "addInArchZip", "addToZipFile", "addToHariver", "addInHarFile", "addInArchive", "addToArchZip", "addToZipiver", "addInArchiver", "addToZipive", "addToExive", "addToZipZip", "addToHarive", "addToExZip", "addToExFile"], "pod": ["report", "zone", "od", "policy", "poll", "task", "disk", "op", "table", "pad", "module", "spec", "pkg", "device", "message", "post", "cp", "pc", "pick", "archive", "top", "proc", "pack", "project", "component", "point", "ods", "ad", "Pod", "volume", "job", "wp", "start", "body", "check", "p", "ack"], "podArchiveOutputStream": ["podArchiveInputStreamer", "podArchiveStreamStream", "podArchiveOutputstream", "podArchiveStreamSync", "podArchiveOutSteam", "podArchiveOutputPoint", "podArchiveOUForm", "podArchiverInputstream", "podArchiveMainStreamer", "podArchiveInputContext", "podArchiverInputContext", "podArchiverInputStreamer", "podArchiveOUMap", "podArchiverInputForm", "podArchiveInputStream", "podArchiveOUSync", "podArchiveOutputSteam", "podArchiveInputstream", "podArchiverOutputSync", "podArchiverOutputPoint", "podArchiverInputSteam", "podArchiverInputMap", "podArchiveOUStream", "podArchiveoutputStream", "podArchiveoutputStreamer", "podArchiveStreamMap", "podArchiverOutputSteam", "podArchiverOutputMap", "podArchiveOutputForm", "podArchiveInputForm", "podArchiveOutPoint", "podArchiveInputSync", "podArchiveMainSteam", "podArchiveOutputSync", "podArchiveoutputForm", "podArchiverOutputstream", "podArchiveOutStream", "podArchiverOutputForm", "podArchiveInputSteam", "podArchiverOutputContext", "podArchiverOutputStreamer", "podArchiveMainForm", "podArchiveResourceStream", "podArchiveOutContext", "podArchiveOutputMap", "podArchiveEntryPoint", "podArchiveoutputSteam", "podArchiveEntryStream", "podArchiverInputStream", "podArchiverInputSync", "podArchiverOutputStream", "podArchiveOutputContext", "podArchiveStreamForm", "podArchiveEntrySteam", "podArchiveMainStream", "podArchiveInputPoint", "podArchiveResourcestream", "podArchiveResourceContext", "podArchiveOutputStreamer", "podArchiveOutstream", "podArchiveResourceSteam", "podArchiverInputPoint", "podArchiveInputMap"], "filename": ["nil", "txt", "nm", "subject", "p", "output", "original", "FILE", "release", "resource", "description", "fil", "fp", "names", "directory", "jpg", "message", "println", "ename", "family", "url", "uri", "name", "archive", "upload", "NAME", "FN", "png", "kl", "Filename", "path", "stem", "binary", "ame", "key", "location", "string", "file", "fn", "latest", "folder", "version", "username", "prefix", "title"], "source": ["series", "ser", "style", "image", "address", "select", "sample", "supp", "service", "resource", "view", "sequence", "force", "stream", "context", "inner", "template", "spec", "store", "src", "Source", "copy", "get", "SOURCE", "input", "proc", "sql", "seed", "ource", "component", "iterator", "use", "info", "start", "file", "password", "body", "shell", "loader", "from"], "entry": ["good", "nt", "element", "ie", "quick", "task", "comment", "word", "resource", "obj", "se", "set", "tmp", "ce", "connection", "char", "ment", "attribute", "link", "log", "system", "cell", "ace", "archive", "or", "ent", "ry", "query", "component", "enter", "record", "line", "sheet", "book", "channel", "zip", "Entry", "row", "key", "job", "file", "card", "data", "cue"]}}
{"id1": "16590954", "id2": "11005804", "code1": "    public void createJAR(String fileString, String ext) {\n        try {\n            File file = new File(fileString);\n            int i = fileString.lastIndexOf(java.io.File.separator);\n            String dir = fileString.substring(0, i + 1);\n            if (ext.matches(\"jar\")) {\n                jarFile = new File(getClass().getClassLoader().getResource(\"jsdviewer.jar\").toURI());\n                java.io.FileOutputStream fstrm = new java.io.FileOutputStream(file);\n                FileChannel in = (new java.io.FileInputStream(jarFile)).getChannel();\n                FileChannel out = fstrm.getChannel();\n                in.transferTo(0, jarFile.length(), out);\n                in.close();\n                out.close();\n            } else {\n                file.mkdir();\n            }\n            File.umount(file);\n            File temp = new File(dir + \"document.jsd\");\n            FileOutputStream fstrm2 = new FileOutputStream(temp.getCanonicalPath());\n            ostrm = new ObjectOutputStream(fstrm2);\n            ostrm.writeObject(doc);\n            ostrm.flush();\n            ostrm.close();\n            File.umount();\n            File docFile = new File(file.getCanonicalPath() + java.io.File.separator + \"document.jsd\");\n            File.cp_p(temp, docFile);\n            File.umount();\n            temp.delete();\n            File.umount(file);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n", "code2": "    public String kodetu(String testusoila) {\n        MessageDigest md = null;\n        try {\n            md = MessageDigest.getInstance(\"SHA\");\n        } catch (NoSuchAlgorithmException e) {\n            new MezuLeiho(\"Ez da zifraketa algoritmoa aurkitu\", \"Ados\", \"Zifraketa Arazoa\", JOptionPane.ERROR_MESSAGE);\n            e.printStackTrace();\n        }\n        try {\n            md.update(testusoila.getBytes(\"UTF-8\"));\n        } catch (UnsupportedEncodingException e) {\n            new MezuLeiho(\"Errorea kodetzerakoan\", \"Ados\", \"Kodeketa Errorea\", JOptionPane.ERROR_MESSAGE);\n            e.printStackTrace();\n        }\n        byte raw[] = md.digest();\n        String hash = (new BASE64Encoder()).encode(raw);\n        return hash;\n    }\n", "label": 0, "substitutes": {"createJAR": ["saveIJARS", "saveJART", "saveJARS", "createGART", "createJAP", "createIJAP", "createJARS", "createPHARS", "createGARS", "saveJAP", "saveIJART", "createGAR", "createIJAR", "saveJAR", "createPHAR", "createGAP", "createPHAP", "createIJARS", "createIJART", "createJART", "createPHART", "saveIJAR", "saveIJAP"], "fileString": [" fileStr", "pathString", "pathStr", "ileStr", "FileRest", "FileText", "FileName", "fileRest", "messageText", "ileString", "messageStr", "ileRest", "FileString", " fileName", "messageName", " fileText", " fileRest", "messageString", "FileStr", "filestring", "ilestring", "fileName", " filestring", "fileText", "ileName", "fileStr", "Filestring", "pathstring"], "ext": ["exp", "type", "ime", "txt", "gz", "text", "suff", "cont", "js", "enc", "fr", "append", "t", "char", "rest", "exe", "tex", "Ext", "xt", "e", "format", "off", "req", "name", "str", "external", "cmd", "path", "EXT", "ind", "typ", "desc", "ort", "pat", "xp", "prot", "except", "end", "ix", "ex"], "file": ["type", "f", "report", "handle", "image", "lock", "default", "output", "File", "time", "FILE", "h", "disk", "resource", "foo", "force", "doc", "fp", "page", "table", "run", "t", "port", "base", "module", "work", "link", "buffer", "log", "open", "to", "document", "message", "db", "list", "ile", "format", "cache", "url", "name", "le", "get", " File", "input", "tree", "parent", "this", "mail", "path", "null", "line", "model", "channel", "local", "info", "http", "io", "source", "pool", "class", "user", "memory", "store", "from", "data"], "i": ["f", "mi", "j", "ini", "I", "di", "ri", "m", "ami", "t", " j", "x", "bi", "c", "ci", "ai", "gi", "v", "ui", "pi", "li", "xi", "ir", "si", "s", "ind", "o", "ip", "n", "id", "ii", "is", "index", "ati", "p", "phi"], "dir": ["div", "home", " directory", "vol", "d", "part", "disk", "direction", " folder", "tmp", "mod", "directory", "done", "del", "addr", "pkg", "db", "wd", "rel", "org", "url", "uri", "lib", " Dir", "dd", "Dir", "project", "ir", "path", "ind", "DIR", "star", " d", "dist", "folder", "loc", "root", "id", "direct", "dy"], "jarFile": ["pkgField", "tarEmail", "JarEmail", "javaFile", "jarField", "JarFILE", "pkgFILE", " jarFilename", "javafile", " jarEmail", "javaName", "JarFile", "jarEmail", "tarfile", "jName", "tarFilename", " jarName", " jarField", "Jarfile", "JarFilename", "jfile", "jarfile", "jarName", "JarField", "jFilename", "tarFile", "javaFilename", " jarfile", " jarFILE", "jFile", "jarFILE", "pkgFile", "jarFilename"], "fstrm": ["fbstrdm", " fdrm", "fbsprm", "fstrum", "ftrum", "fdrm", "fstrdm", "fbsprms", "fdrum", "fsprm", "fbsprdm", "fstrp", "ftrm", "fsprdm", "ftrp", "fslum", "fsprp", "fbstrms", "fslmed", "ftrmed", "fstrms", "fdrmed", "fcrms", "ftrdm", " fdrum", "fdrcm", " fstrmed", "fbstrm", "ftrcm", "fcrdm", "fbstrp", " fstrum", "fslcm", " fstrcm", "fbsprp", "fstrcm", "fcrp", " fdrcm", "fsprms", "fslm", " fdrmed", "fstrmed", "ftrms", "fcrm"], "in": ["f", "rin", "en", "inn", "gin", "IN", "ins", "pin", "im", "m", "oin", "In", "init", "inner", "inside", "ic", "ai", "re", "up", "read", "bin", "pi", "inc", "input", "sin", "iter", "it", " IN", " din", "ind", "o", "add", "r", "mm", "io", "din", "inf", "is", "isin", "cin", "from"], "out": ["co", "output", "cos", "cn", "cont", "obj", "m", "client", "conv", "t", "inner", "net", "c", "to", "v", "gc", "serv", "writer", "os", "cm", "outer", "OU", "ch", "it", "conn", "null", "ou", "s", "outs", "aos", "o", "at", "inv", "channel", "n", "io", "Out", "OUT", "p", "ex", "w"], "temp": ["orig", "TM", "tx", "output", "res", "dest", "util", "cont", "mt", "tar", "wrap", "m", "Temp", "tmp", "thread", "t", " tmp", "tt", "mem", "template", "mod", "Tem", "directory", "buffer", " Temp", "mp", "fake", "mint", "to", "current", "document", "cp", "cache", "name", "copy", "pt", " temporary", "tree", "parent", "stem", "path", "null", "term", "tc", "porary", "tem", "full", "emp", "mm", "local", "zip", "mk", "pool", "EMP", "memory", "p", "tm"], "fstrm2": ["fstrp7", "fStrp2", "fStrm2", "fStrp7", "fStrm7", "fStrp1", "fStrm1", "fStrtm2", "fStrtm1", "fstrm1", "fstrcm7", "fstrp1", "fstrtm2", "fstrtm1", "fstrp2", "fstrm7", "fstrmm2", "fstrM1", "fstrcm2", "fstrmm1", "fstrcm1", "fstrM2", "fstrM7"], "ostrm": ["ostrem", "istRM", "osrem", "astm", " ostRM", "oslamm", "ortlamm", " ostlamm", " ostm", "ostRM", "ostmr", "ortrm", "osmr", "astmr", "istrm", "astrem", "ostnm", "ostlamm", " ostrem", "astrom", " ostnm", "osm", "ostm", "istnm", "ostrom", "ortrom", "istmr", "istrem", "astRM", "astrm", "osrm", "osRM", "astlamm", "istm", "osnm", "ortRM", " ostrom"], "docFile": [" docfile", "docFiles", " docFiles", "manfile", "manDir", "DocFile", "documentFile", "docPath", "manFile", "documentFiles", "docLine", "DocPath", "Docfile", " docLine", "DocFiles", " docDir", "documentDir", "DocLine", "manPath", "docfile", "documentLine", " docPath", "docDir", "DocDir"]}}
{"id1": "19849797", "id2": "189963", "code1": "    public static void copyFile(File sourceFile, File destFile) throws IOException {\n        if (!destFile.exists()) {\n            destFile.createNewFile();\n        }\n        FileChannel source = null;\n        FileChannel destination = null;\n        try {\n            source = new FileInputStream(sourceFile).getChannel();\n            destination = new FileOutputStream(destFile).getChannel();\n            destination.transferFrom(source, 0, source.size());\n        } finally {\n            if (source != null) {\n                source.close();\n            }\n            if (destination != null) {\n                destination.close();\n            }\n        }\n    }\n", "code2": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "label": 1, "substitutes": {"copyFile": [" cpfile", "copyFiles", " copyfile", " copyStream", "transferFile", "transferStream", " cpFile", "copyStream", "copyfile", " copyFiles", " cpFiles", "transferfile", " cpStream", "transferFiles"], "sourceFile": ["ourcePath", "ourceTable", "sourcePath", "ourceLine", "sourcefile", " sourcefile", "ourceFile", "srcPath", "srcField", "sourceLine", "sourceField", "srcLine", "srcPage", "ourcefile", " sourceTable", "srcTable", " sourceLine", " sourcePath", "srcfile", " sourcePage", " sourceField", "sourceTable", "ourcePage", "ourceField", "sourcePage", "srcFile"], "destFile": ["DestPath", "optPath", "destPath", "DestFiles", " destPlace", "optEntity", "optFilename", "srcFolder", "restPlace", "DestFilename", "destFolder", "destPlace", "srcFiles", "optDir", "srcPath", " destDir", "optFile", "datPlace", "srcDir", " destFiles", "declFolder", "srcEntity", " destFilename", "DestDir", "destDir", "datFilename", "destEntity", "optFolder", "srcFile", "datFile", "datFiles", "restFile", "DestFile", " destPath", "declEntity", "restFiles", "restFilename", "declFile", "declDir", "destFilename", "destFiles"], "source": ["origin", "proxy", "back", "series", "style", "image", "subject", "match", "sample", "ie", "console", "service", "slave", "resource", "reader", "se", "comment", "score", "sequence", "force", "create", "stream", "table", "standard", "update", "init", "in", "inner", "ce", "char", "before", "store", "attribute", "spec", "scope", "load", "pose", "result", "src", "missing", "Source", "none", "owner", "copy", "target", "SOURCE", "input", "iter", "query", "note", "parent", "parse", "search", "component", "ource", "show", "iterator", "OURCE", "channel", "use", "local", "scale", "start", "send", "body", "shell", "index", "check", "cause", "from"], "destination": ["terminined", "Destation", "separinated", "Destinate", "destment", " destation", "verinated", "termininate", "separination", "restinator", "termininated", "Destment", "descinator", "separment", "noninated", "destinate", "separation", " destment", "descinate", "destinator", " destinate", "nonination", "decined", "decination", "verination", "restination", "descation", "destation", "restinate", "terminination", "Destinated", " destinator", "Destinator", "descination", "noninator", "noninate", " destinated", "veration", "verificate", " destined", "decinate", "destinated", "Destificate", "Destination", "destined", " destificate", "decinated", "destificate", "restinated"]}}
{"id1": "6987642", "id2": "9398454", "code1": "    public static String encodePassword(String password) {\n        MessageDigest md;\n        try {\n            md = MessageDigest.getInstance(\"SHA\");\n            md.update(password.getBytes());\n            String encodedPassword = new String(md.digest(), new Base64Provider().charsetForName(\"x-base64\"));\n            return encodedPassword;\n        } catch (NoSuchAlgorithmException e) {\n            return null;\n        }\n    }\n", "code2": "    private static RemoteFile getRemoteFile(String url) {\n        long size = 0;\n        String realUrl = \"\";\n        try {\n            HttpURLConnection conn = (HttpURLConnection) (new URL(url)).openConnection();\n            size = conn.getContentLength();\n            realUrl = conn.getURL().toString();\n            conn.disconnect();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        RemoteFile rf = new RemoteFile(size, realUrl);\n        return rf;\n    }\n", "label": 0, "substitutes": {"encodePassword": ["Encodepassword", "enodePass", "EncodePassword", "EnodeValue", "enodePassword", "encodedpassword", "enodepassword", "enlatepassword", "enlatePass", "enlateValue", "EnodePass", "enlatePassword", "EncodePass", "encodeValue", "EnodePassword", "encodedValue", "encodedPass", "enodeValue", "Enodepassword", "EncodeValue", "encodepassword", "encodePass"], "password": ["phrase", "expected", "address", "value", "text", "p", "default", "reset", "random", "email", "hello", "word", "description", "secret", "shadow", "command", "attribute", "Password", "message", "wd", "name", "token", "input", "login", "path", "sword", "database", "pattern", "padding", "key", "string", "user", "username", "data", "prefix", "pass"], "md": [" Md", " mc", "nt", "sm", "bf", "ms", "pd", "od", " mac", " ms", "d", "hm", "der", " mo", "mt", "di", " cmd", "m", "mo", "mod", "sha", "mg", "red", "mp", "mond", "dr", "rm", "det", "dm", "sd", " mg", " cd", " rm", "nd", "dd", "cmd", "mand", "metadata", " dd", "cd", "mb", "hd", "MD", "ind", "add", " mt", "ad", "mn", "mc", "mm", "grad", "pm", "mk", "msg", "exec", "ld", "ke", "bd", "df", "dh"], "encodedPassword": ["ecodingSecret", "equatedConnection", "encodingString", "equodedPassword", "encachedString", "ecodedPassword", "encodedpassword", "ecodedString", "encodingpassword", "encryptedpassword", "encodedSecret", "encatedUser", "encatedpassword", "encodingUser", "encachedPassword", "encodedUser", "equatedUser", "encodingSecret", "encodedString", "equodedpassword", "encryptedPassword", "encryptedUser", "encodingPassword", "ecodingPassword", "equatedpassword", "encatedSecret", "encatedConnection", "ecodingString", "encryptedConnection", "ecodedpassword", "encatedPassword", "encachedSecret", "equodedUser", "encodedConnection", "ecodedSecret", "encodingConnection", "encachedpassword", "ecodingpassword", "equatedPassword", "encatedString", "equodedConnection"]}}
{"id1": "10451698", "id2": "3806532", "code1": "    private void copy(File source, File destinationDirectory) throws IOException {\n        if (source.isDirectory()) {\n            File newDir = new File(destinationDirectory, source.getName());\n            newDir.mkdir();\n            File[] children = source.listFiles();\n            for (int i = 0; i < children.length; i++) {\n                if (children[i].getName().equals(\".svn\")) {\n                    continue;\n                }\n                copy(children[i], newDir);\n            }\n        } else {\n            File newFile = new File(destinationDirectory, source.getName());\n            if (newFile.exists() && source.lastModified() == newFile.lastModified()) {\n                return;\n            }\n            FileOutputStream output = new FileOutputStream(newFile);\n            FileInputStream input = new FileInputStream(source);\n            byte[] buff = new byte[2048];\n            int read = 0;\n            while ((read = input.read(buff)) > 0) {\n                output.write(buff, 0, read);\n            }\n            output.flush();\n            output.close();\n            input.close();\n        }\n    }\n", "code2": "    public Resource createNew(String name, InputStream in, Long length, String contentType) throws IOException {\n        File dest = new File(this.getRealFile(), name);\n        LOGGER.debug(\"PUT?? - real file: \" + this.getRealFile() + \",name: \" + name);\n        if (isOwner) {\n            if (!\".request\".equals(name) && !\".tokens\".equals(name)) {\n                FileOutputStream out = null;\n                try {\n                    out = new FileOutputStream(dest);\n                    IOUtils.copy(in, out);\n                } finally {\n                    IOUtils.closeQuietly(out);\n                }\n            } else {\n                if (ServerConfiguration.isDynamicSEL()) {\n                } else {\n                }\n                FileOutputStream out = null;\n                try {\n                    out = new FileOutputStream(dest);\n                    IOUtils.copy(in, out);\n                } finally {\n                    IOUtils.closeQuietly(out);\n                }\n            }\n            return factory.resolveFile(this.host, dest);\n        } else {\n            LOGGER.error(\"User isn't owner of this folder\");\n            return null;\n        }\n    }\n", "label": 1, "substitutes": {"copy": ["proxy", "export", "co", "cop", "cat", "sync", "share", "remove", "create", "link", "Copy", "write", "transfer", "slice", "perm", "cp", "gc", "archive", "paste", "continue", "split", "opy", "zip", "Cop", "download", "core", "pixel", "crop", "file", "clip", "clone", "map", "delete", "move"], "source": ["origin", "empty", "style", "image", "subject", "entry", "ie", "sit", "sp", "original", "service", "resource", "se", "details", "force", "create", "raw", "status", "table", "site", "init", "in", "base", "directory", "template", "spec", "store", "ce", "inner", "scope", "secure", "current", "src", "Source", "none", "cache", "name", "get", "target", "SOURCE", "sin", "query", "note", "parent", "sql", "ource", "null", "space", "instance", "use", "local", "remote", "http", "config", "start", "file", "size", "shell", "body", "class", "unit", "from", "index"], "destinationDirectory": ["targetinationDirectory", "identinatorLocation", "destmentDir", "identinationInternal", "destinationsInternal", "destinatorLocation", "destationFolder", "destinationsdirectory", "destinationsLocation", "destarationInternal", "destinationInternal", "destineApplication", "targetinationsdirectory", "destineDirectory", "targetinationsDirectory", "identinatorDirectory", "destinationsFolder", "identinatorInternal", "destarationDirectory", "destinationFolder", "destinationApplication", " destationDirectory", "targetinationdirectory", "identinationLocation", "destinateDirectory", " destinationFolder", "targetinationsDir", "destarationLocation", "destinatorDirectory", "destmentdirectory", "destationdirectory", "destationApplication", "targetinationFolder", " destationApplication", "destinateFolder", "destmentDirectory", " destationdirectory", "destinationsDirectory", "destineFolder", "destinationsDir", "destinationLocation", "destinatorInternal", "destinatedirectory", " destinationdirectory", "identinationDirectory", "targetinationsFolder", "destinedirectory", "destinationdirectory", "targetinationDir", "destinationDir", "destmentFolder", "destationDirectory", "destinateApplication", " destinationApplication", " destationFolder"], "newDir": ["newDirectory", "newdir", "NewDir", "newFolder", " newdir", "Newdir", "nextDir", " newDirectory", "newsFile", "NewFolder", "nextFile", "newRel", "newsDirectory", "nextRel", "newsFolder", "NewDirectory", "newsdir", "nextdir", "NewRel", " newRel", "newsDir", " newFolder", "NewFile"], "children": ["parents", "times", "services", "apps", "all", "nil", "each", "these", "reports", "links", "users", "items", "keys", "his", "details", "Children", "modules", "jobs", "unknown", "lines", "ls", "bc", "packages", "classes", "names", "ml", "uploads", "its", "gc", "cache", "when", "cont", "child", "blocks", "images", "many", "ids", "resources", "members", "pres", "projects", "objects", "ports", "stories", "related", "ren", "desc", "groups", "pages", "files", "relations", "sub", "may", "kids", "follow"], "i": ["mi", "span", "json", "u", "j", "ms", "um", "y", "us", "I", "ski", "ini", "qi", "di", "ie", "im", "ri", "m", "iq", "ki", "client", "init", "x", "base", "t", "me", "in", "q", "iu", "hi", "ti", "chain", "bi", "ic", "multi", "ci", "ai", "sim", "you", "gi", "ui", "pi", "ij", "ix", "iter", "ji", "it", "uu", "li", "my", "ims", "point", "si", "xi", "g", "batch", "ip", "info", "key", "remote", "io", "gu", "is", "ii", "oi", "index", "id", "phi", "ex"], "newFile": ["ewLe", "newSourceFile", " newGlobal", "NEWDir", "NewDir", "NewLe", "createDir", "newfile", "NEWfile", "createFile", "newsGlobal", "nextDir", "newsfile", "createfile", "nextLe", " newfile", "newsFile", "NEWFile", "newLe", "NewGlobal", "nextFile", "NEWTh", "createSourceFile", "newTh", " newSourceFile", "ewDir", "newsTh", "newGlobal", "goodSourceFile", "goodFile", "Newfile", "goodDir", "ewfile", "NewTh", "goodfile", "newsDir", "nextfile", "NewFile", "ewFile"], "output": ["export", "admin", "response", "block", "text", "ilo", "put", "console", "next", "internal", "client", "stream", "web", "update", "Output", "connection", "four", "net", "write", "buffer", "open", "print", "document", "current", "message", "result", "format", "position", "writer", "enabled", "success", "outer", "out", "exit", "parent", "object", "batch", "network", "monitor", "connect", "auto", "cut", "io", "config", "blue", "file", "online", "body", "pretty", "display"], "input": ["back", "rc", "active", "image", "insert", "internal", "storage", "ink", "reader", "op", "raw", "init", "feed", "in", "inner", "before", "buffer", "open", "ic", "Input", "current", "unsigned", "child", "get", "error", "inc", "operator", "initial", "upload", "out", "iter", "it", "form", "ahead", "ip", "add", "local", "info", "io", "inf", "start", "exec", "from"], "buff": ["seq", "buf", "txt", "sb", "pb", "bf", "text", "cat", "img", "bl", "bg", "cb", " buf", "bo", "uff", "bound", "bs", "bed", "tt", "box", "mem", "buffer", "xff", "old", "b", "bb", "xx", "hold", "bin", "nb", "nd", "uf", "black", "tab", "qq", "cond", "comp", "ch", "data", "eb", "cmd", "mb", "batch", "ind", "Buff", "msg", "ff", "fb", "gb", "printf", "bytes"], "read": ["handle", "en", "each", "text", "find", "and", "select", "test", "hello", "d", " write", "ink", "wait", "raw", "stream", "set", "run", "t", "mem", "feed", "in", "before", "q", "print", "write", "old", "buffer", "readable", "load", "reads", "seek", "hold", "skip", "get", "str", " Read", "bind", "give", "need", "iter", " count", "query", "len", "length", "height", "ind", "Read", "add", "count", "ready", "config", "start", "tell", "send", "reading", "size", "check", "index", "READ", "end", "like", "push"]}}
{"id1": "5543349", "id2": "20568568", "code1": "    public UserFunction loadMFileViaWeb(URL codeBase, String directoryAndFile, String mFileName) {\n        String code = \"\";\n        UserFunction function = null;\n        ErrorLogger.debugLine(\"MFileLoader: loading >\" + mFileName + \".m<\");\n        try {\n            URL url = new URL(codeBase, directoryAndFile);\n            InputStream in = url.openStream();\n            BufferedReader inReader = new BufferedReader(new InputStreamReader(in));\n            String line;\n            while ((line = inReader.readLine()) != null) {\n                code += line + \"\\n\";\n            }\n            inReader.close();\n        } catch (Exception e) {\n            Errors.throwMathLibException(\"MFileLoader: m-file exception via web\");\n        }\n        ErrorLogger.debugLine(\"MFileLoader: code: begin \\n\" + code + \"\\ncode end\");\n        FunctionParser funcParser = new FunctionParser();\n        function = funcParser.parseFunction(code);\n        function.setName(mFileName);\n        ErrorLogger.debugLine(\"MFileLoader: finished webloading >\" + mFileName + \".m<\");\n        return function;\n    }\n", "code2": "    private String createHTML(PAGE_TYPE requestPage) {\n        String result = \"<html><head>\";\n        URL url = getClass().getClassLoader().getResource(\"org/compiere/images/PAPanel.css\");\n        InputStreamReader ins;\n        try {\n            ins = new InputStreamReader(url.openStream());\n            BufferedReader bufferedReader = new BufferedReader(ins);\n            String cssLine;\n            while ((cssLine = bufferedReader.readLine()) != null) result += cssLine + \"\\n\";\n        } catch (IOException e1) {\n            log.log(Level.SEVERE, e1.getLocalizedMessage(), e1);\n        }\n        switch(requestPage) {\n            case PAGE_LOGO:\n                result += \"</head><body class=\\\"header\\\">\" + \"<table width=\\\"100%\\\"><tr><td>\" + \"<img src=\\\"res:org/compiere/images/logo_ad.png\\\">\" + \"</td><td></td><td width=\\\"290\\\">\" + \"</td></tr></table>\" + \"</body></html>\";\n                break;\n            case PAGE_HOME:\n                result += \"</head><body><div class=\\\"content\\\">\\n\";\n                queryZoom = null;\n                queryZoom = new ArrayList<MQuery>();\n                String appendToHome = null;\n                String sql = \" SELECT x.AD_CLIENT_ID, x.NAME, x.DESCRIPTION, x.AD_WINDOW_ID, x.PA_GOAL_ID, x.LINE, x.HTML, m.AD_MENU_ID\" + \" FROM PA_DASHBOARDCONTENT x\" + \" LEFT OUTER JOIN AD_MENU m ON x.ad_window_id=m.ad_window_id\" + \" WHERE (x.AD_Client_ID=0 OR x.AD_Client_ID=?) AND x.IsActive='Y'\" + \" ORDER BY LINE\";\n                PreparedStatement pstmt = null;\n                ResultSet rs = null;\n                try {\n                    pstmt = DB.prepareStatement(sql, null);\n                    pstmt.setInt(1, Env.getAD_Client_ID(Env.getCtx()));\n                    rs = pstmt.executeQuery();\n                    while (rs.next()) {\n                        appendToHome = rs.getString(\"HTML\");\n                        if (appendToHome != null) {\n                            if (rs.getString(\"DESCRIPTION\") != null) result += \"<H2>\" + rs.getString(\"DESCRIPTION\") + \"</H2>\\n\";\n                            result += stripHtml(appendToHome, false) + \"<br>\\n\";\n                        }\n                        if (rs.getInt(\"AD_MENU_ID\") > 0) {\n                            result += \"<a class=\\\"hrefNode\\\" href=\\\"http:///window/node#\" + String.valueOf(rs.getInt(\"AD_WINDOW_ID\") + \"\\\">\" + rs.getString(\"DESCRIPTION\") + \"</a><br>\\n\");\n                        }\n                        result += \"<br>\\n\";\n                        if (rs.getInt(\"PA_GOAL_ID\") > 0) result += goalsDetail(rs.getInt(\"PA_GOAL_ID\"));\n                    }\n                } catch (SQLException e) {\n                    log.log(Level.SEVERE, sql, e);\n                } finally {\n                    DB.close(rs, pstmt);\n                    rs = null;\n                    pstmt = null;\n                }\n                result += \"<br><br><br>\\n\" + \"</div>\\n</body>\\n</html>\\n\";\n                break;\n            default:\n                log.warning(\"Unknown option - \" + requestPage);\n        }\n        return result;\n    }\n", "label": 1, "substitutes": {"loadMFileViaWeb": ["loadMFileviaWe", "loadMFileByWeb", "loadMFilesviaweb", "loadMFileviaweb", "loadMFileByweb", "loadMFilesViaweb", "loadMFilesviaWe", "loadMFileByWe", "loadMFilesViaWe", "loadMFileUsingWeb", "loadMFileViaweb", "loadMFileUsingweb", "loadMFileViaWe", "loadMFileUsingWe", "loadMFilesViaWeb", "loadMFilesviaWeb", "loadMFileviaWeb"], "codeBase": [" codeRoot", "fileBase", "codeMark", "uriBase", "uribase", "CodeBased", "CodeRoot", " codebase", "codebase", "CodeBase", " codeMark", " codeBased", "codeBased", "uriMark", "Codebase", "CodeMark", "filebase", "uriBased", "fileRoot", "codeRoot", "fileBased"], "directoryAndFile": ["directoryOrfile", "directoryandModel", " directoryOrFile", "directoryandType", " directoryOrType", "DirectoryAndFile", " directoryOrDirectory", "DirectoryAndPath", "DirectoryandModel", " directoryAndDirectory", "directoryButfile", "directoryAndType", " directoryOrfile", "directoryandPath", "directoryOrModel", "directoryButDirectory", "directoryButFile", "directoryButType", "directoryOrPath", "directoryandfile", " directoryAndfile", "directoryAndModel", "Directoryandfile", "directoryAndDirectory", "directoryOrType", "directoryandDirectory", "directoryOrFile", "DirectoryandPath", "directoryAndPath", "DirectoryAndModel", " directoryAndType", "directoryandFile", "directoryAndfile", "DirectoryAndfile", "directoryOrDirectory", "DirectoryandFile"], "mFileName": ["mFilePart", "mFileSize", "mFilenamePath", " mFilePath", "MFileSize", "mSourceFileSource", "MFilenameName", "mFilePath", "mfileType", "MFilenamePart", "MFileBody", "MFileSource", "mFileSource", "mfileName", " mFileType", "mSourceFileSize", "mfileBody", "mFilenameBody", "mFilenamename", "MFileName", "mSourceFileNames", " mfileName", "mSourceFileType", "MFilePath", "mFolderName", "MFilenameNames", "mSourceFilePath", " mfilePath", "mSourceFileName", "mfileFile", "mFolderPart", " mFileFile", "mTablePath", "mFilenameName", "mFilenameNames", "mTableName", " mfileFile", "mTablePart", " mfileType", "mfileSource", "MFilenameSource", "mFilenameSource", "mSourceFileBody", "mFileBody", "mSourceFileFile", "MFilenamePath", "mTablename", "MFilename", "MFilenamename", "mFoldername", "mFolderPath", "mFilename", "mFilenameFile", "mFileNames", "mfileNames", "mFilenameType", "MFilenameSize", "MFilenameBody", "mFilenamePart", "mfilePath", "mFilenameSize", "mFileFile", "MFileNames", "MFilePart", "mFileType", "mfileSize"], "code": ["event", "value", "output", "test", "stroke", "t", "Code", "c", "to", "node", "coe", "hex", "form", "n", "core", "html", " content", " Code", "time", "reason", "x", "ce", "template", "buffer", "cell", " data", "cache", "cod", "codes", "coded", "text", "hello", "comment", "frame", " to", "create", "module", "done", "e", "input", "query", "component", "length", "body", "data", "expression", "ode", "json", "func", "sequence", "script", "command", "action", "message", "result", "content", "program", "copy", "l", "scene", "zip", " coding", "string", "source"], "function": ["event", "f", "lambda", "closure", "value", "process", "and", "func", "callback", "feature", "service", "resource", " computation", "production", " Function", "library", "module", "connection", " command", "command", "action", "document", "result", "family", " functions", "program", "Function", " func", "false", "foreign", "partial", "method", "expression", "fun", " program", "object", "component", "normal", "handler", "form", "FUN", "instance", "role", "relation", "foundation", "full", "job", "fn", "file", "functional", " functionality", "class", "user", "from", "python"], "url": ["browser", "hl", "gl", "address", "dl", "resource", "bel", "web", "ll", "base", "char", "link", "build", "log", "sl", "open", "b", "rel", "re", "ur", "mount", "URL", "get", "rl", "str", "l", "out", "nl", "li", "mail", "r", "ssl", "el", "http", "location", "io", "job", "file", "loc", "il", "Url", "p"], "in": ["f", "rin", "inn", "gin", "IN", "ins", "reader", "stream", "In", "inner", "ic", "i", "bin", "inc", "l", "input", "out", "sin", "it", " din", "null", "ind", "r", "info", "n", "din", "inf", "is", "isin", "source", "file", "body", "cin", "p", "from"], "inReader": ["innerReader", "fromReader", "innLine", "innRead", "inWriter", "cinWriter", "inBuilder", "innReader", "inLine", "fromRunner", "fromWriter", "fromBuilder", "cinRunner", "innerR", "cinReader", "fromLoader", "InStream", "inRunner", "innerBuilder", "InRead", "innStream", "InLine", " inWriter", "fromR", "inR", " inStream", " inLoader", "innerRunner", "inLoader", "inRead", " inRead", "InReader", " inBuilder", " inR", " inLine", " inRunner", "cinLoader", "inStream"], "line": ["rule", "LINE", "ode", "zone", "lin", "block", "text", "element", "eline", "entry", "ine", "email", "sample", "column", "comment", "frame", "lane", "ln", "sequence", "page", "stroke", "port", "char", "link", "message", "cell", "e", "number", "stay", "le", "liner", "error", "entity", "l", "section", "lined", "point", "change", "record", "Line", "row", "key", "string", "inline", "file", "online", "print", "header"], "end": ["export", "END", "block", "reset", "next", "stop", "run", "log", "open", "load", "close", "list", "e", "data", "length", "End", "ended", "ed", "info", "begin", "start", "class", "id"]}}
{"id1": "14783950", "id2": "11562165", "code1": "    public static void compressWithZip(Vector fileList, String zipFileName) throws IOException {\n        if (fileList == null || fileList.size() == 0) return;\n        FileOutputStream fos = new FileOutputStream(zipFileName);\n        ZipOutputStream zos = new ZipOutputStream(fos);\n        Iterator iter = fileList.iterator();\n        while (iter.hasNext()) {\n            String fileName = (String) iter.next();\n            int ind = Math.max(fileName.lastIndexOf('/'), fileName.lastIndexOf('\\\\'));\n            String shortName = \"unknown\";\n            if (ind < fileName.length() - 1) shortName = fileName.substring(ind + 1);\n            zos.putNextEntry(new ZipEntry(shortName));\n            FileInputStream fis = new FileInputStream(fileName);\n            byte[] buf = new byte[10000];\n            int bytesRead;\n            while ((bytesRead = fis.read(buf)) > 0) zos.write(buf, 0, bytesRead);\n            fis.close();\n            zos.closeEntry();\n        }\n        zos.close();\n    }\n", "code2": "    private void streamContains(String in, InputStream stream) throws IOException {\n        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n        IOUtils.copy(stream, baos);\n        byte[] bytes = baos.toByteArray();\n        String cmp = new String(bytes, \"UTF-8\");\n        assertTrue(cmp.contains(in));\n        baos.close();\n    }\n", "label": 1, "substitutes": {"compressWithZip": ["compressByFiles", "composeWithoutExt", "compresswithZip", "composeWithoutzip", "composeWithFiles", "compresswithExt", "compressWithoutExt", "compressWithoutFiles", "composeWithzip", "composeWithZip", "compresswithzip", "compressWithFiles", "compressWithExt", "compresswithFiles", "compressByExt", "composeWithoutZip", "compressWithoutZip", "compressByZip", "compressWithoutzip", "composeWithExt", "compressByzip", "compressWithzip", "composeWithoutFiles"], "fileList": [" fileL", "resourceList", "tileIterator", "wordIterator", "fileLock", "fileCode", "pageList", "fileIterator", " fileIterator", "resourceNames", "itemLock", "pageL", "resourceLock", " fileLIST", "fileSet", "ileL", "ileList", "fileLIST", "filelist", "tileSet", "pagelist", "tileList", "wordList", "wordLIST", " FileCode", " fileSet", " FileLIST", "pageCode", "tileLIST", " filelist", "wordSet", " fileLock", "fileNames", " FileSet", " fileNames", "ilelist", " fileCode", "pageLIST", "fileL", "pageSet", " FileList", "ileLIST", "itemNames", "itemList"], "zipFileName": ["zipFilenamename", "zFileFilename", "zFilename", "zipDirNames", "zipileName", " zipFilePath", " zipfileFilename", "zipfilePath", " zipFileFilename", "zFilenamename", "zipFilenameName", "zFilenamePath", "zFilenameFilename", "zipFilenameNames", " zipfileName", " zipFileNames", "zipDirName", "zipfileNames", "zFilePath", "zipDirFilename", "zipileFilename", "zipFilenamePath", "zipFilename", "zipFileNames", "zipfileName", " zipfileNames", "zipfileFilename", "zipDirPath", "zipfilename", "zFileName", "zipFileFilename", "zFilenameName", "zipFilePath", " zipfilePath", "zipilename", "zipFilenameFilename", "zipilePath"], "fos": ["flis", "Foss", "foss", "loos", "flos", "foos", "los", "loss", "wOS", "wos", " foos", "fOS", "lfis", "Fos", "lOS", "lfoos", "floos", "woss", " fOS", "Foos", "lfOS", "FOS", "lfos", "flOS", "woos"], "zos": ["ze", "zag", "Sax", "ss", "nz", "ses", "zon", "z", "rys", "webkit", "zin", "oss", "js", "zb", "jas", "ws", "sbm", "zen", "ess", "zh", "hz", "los", "iaz", "ps", "zo", "ossus", "less", "enos", "zes", "han", "os", "ez", "za", "enz", "iners", "bes", "cz", "zan", "css", "zu", "eros", "zzle", "zip", "zers", "zar", "rez", "ippers", "hess", "zik", "zer", "zero", "zi", "es", "sis"], "iter": ["exp", "ser", "oper", "tr", "ee", "izer", "reader", "Iter", "inter", "here", "inner", "maker", "liter", "orient", "vis", "train", "Iterator", "list", "re", "i", "its", "ptr", "ator", "coll", "ait", "outer", "valid", "it", "former", "walker", "ver", "li", "order", "iver", "ir", "gener", "iv", "iner", "ip", "fer", "iterator", "el", "ger", "ner", "er", "is", "where", "loc", "cer", "user", "loop", "loader", "ter", "kit", "ipper"], "fileName": ["ilePath", "ileSet", " filename", " fileNumber", "getStore", "tableSet", "shortStore", "fileNAME", "shortname", "getSource", "FileName", "FileCurrent", " filePath", "fSource", "getName", " fileSource", "localList", "FileNames", "localName", "ileString", "fieldname", " fileCurrent", "fileSet", "ileList", "fieldNAME", "FileString", "shortSource", " fileString", "ileBody", "ileNumber", "tablePath", "fileStore", "fieldName", "fileCurrent", "filename", "ilename", "fName", " fileSet", "tableName", "localname", "ileNAME", " fileStore", "fString", "fBody", "fname", "fileBody", "localNAME", "Filename", "filePath", "fileNames", "ileCurrent", "ileName", "fNames", "fNumber", " fileNames", "FilePath", "ileSource", " fileBody", "getname", "fileSource", "fileString", "fileNumber", "fieldList"], "ind": ["pred", "div", "dj", "find", "j", "dial", "inn", "roll", "d", "draw", "IND", "mod", "md", "red", "pl", "Ind", "mind", "stick", "butt", "wind", "i", "req", "ded", "ptr", "td", "inc", "bind", "pos", "cand", "cond", "sign", "ent", "cod", "seed", "cd", "hend", "num", "kind", "typ", "count", "n", "att", "ld", "loc", "index", "inder", "med", "nd"], "shortName": [" shortname", "fullString", "recentname", "shortname", "shortFilename", "recentCode", "smallname", "smallName", "recentName", "Shortname", "ShortKey", "ShortType", "recentFilename", "quickName", " shortKey", "quickString", "ShortString", "ShortName", "fullName", " shortString", "quickKey", "smallFilename", "shortCode", "fullname", " shortType", "shortKey", "shortString", "smallCode", "fullType", "ShortFilename", "ShortCode", "quickname", "shortType"], "fis": ["fi", "Fis", "ufi", "cfis", "fris", " fris", "ufis", "sfi", "his", "Fris", "wis", "cfois", "hi", " fIs", "sfis", "ufois", "wois", "pi", "ufris", "sfIs", "wIs", "wi", "pris", "FIs", "fois", "sfois", "fIs", "pis", "pois", "hris", "hois", "cfris", "ufIs", "cfi"], "buf": ["seq", "cv", "tr", "block", "br", "buff", "var", "img", "cat", "ref", "orig", "bl", "cb", "bed", "bc", "conv", "box", "mem", "bus", "wb", "buffer", "pkg", "bag", "b", "fam", "cur", "db", "aka", "fg", "bin", "Buffer", "uf", "rb", "tab", "cmd", "mu", "batch", "bar", "Buff", "cap", "msg", "temp", "arr", "fb", "vec", "bytes"], "bytesRead": ["postsFind", "blocksRead", "secondsWritten", "blocksWrite", "bytesLength", "usersLoad", "secondsWrite", "linesNeed", "secondsLoad", "flowsFind", "usersFind", "flowsLoad", "blocksWritten", "secondsRead", " bytesLoad", "bytesLoad", "bytesFind", " bytesWritten", "flowsReady", "flowsRead", "bytesWritten", "BytesRead", "postsRead", " bytesWrite", "linesLength", "BytesLength", "usersRead", "linesWritten", " bytesLength", "bytesReady", "postsReady", "BytesWritten", "bytesNeed", "blocksLoad", " bytesNeed", "postsLoad", "bytesWrite", "BytesNeed", "linesRead", "usersReady"]}}
{"id1": "5759961", "id2": "1371265", "code1": "    @Override\n    public User saveUser(User user) {\n        try {\n            MessageDigest digest = java.security.MessageDigest.getInstance(\"MD5\");\n            digest.update(user.getPassword().getBytes(\"UTF-8\"));\n            byte[] hash = digest.digest();\n            BigInteger bigInt = new BigInteger(1, hash);\n            String hashtext = bigInt.toString(16);\n            while (hashtext.length() < 32) {\n                hashtext = \"0\" + hashtext;\n            }\n            user.setPassword(hashtext);\n            user.setDataRegjistrimit(new Date());\n            return em.merge(user);\n        } catch (Exception e) {\n            throw new NestedException(e.getMessage(), e);\n        }\n    }\n", "code2": "    public void update(String channelPath, String dataField, String fatherDocId) {\n        String sqlInitial = \"select uri from t_ip_doc_res where doc_id = '\" + fatherDocId + \"' and type=\" + \" '\" + ces.platform.infoplat.core.DocResource.DOC_MAGAZINE_TYPE + \"' \";\n        String sqlsortURL = \"update t_ip_doc_res set uri = ? where doc_id = '\" + fatherDocId + \"' \" + \" and type = '\" + ces.platform.infoplat.core.DocResource.DOC_MAGAZINE_TYPE + \"' \";\n        Connection conn = null;\n        ResultSet rs = null;\n        PreparedStatement ps = null;\n        try {\n            dbo = (ERDBOperation) createDBOperation();\n            String url = \"\";\n            boolean flag = true;\n            StringTokenizer st = null;\n            conn = dbo.getConnection();\n            conn.setAutoCommit(false);\n            ps = conn.prepareStatement(sqlInitial);\n            rs = ps.executeQuery();\n            if (rs.next()) url = rs.getString(1);\n            if (!url.equals(\"\")) {\n                st = new StringTokenizer(url, \",\");\n                String sortDocId = \"\";\n                while (st.hasMoreTokens()) {\n                    if (flag) {\n                        sortDocId = \"'\" + st.nextToken() + \"'\";\n                        flag = false;\n                    } else {\n                        sortDocId = sortDocId + \",\" + \"'\" + st.nextToken() + \"'\";\n                    }\n                }\n                String sqlsort = \"select id from t_ip_doc where id in (\" + sortDocId + \") order by \" + dataField;\n                ps = conn.prepareStatement(sqlsort);\n                rs = ps.executeQuery();\n                String sortURL = \"\";\n                boolean sortflag = true;\n                while (rs.next()) {\n                    if (sortflag) {\n                        sortURL = rs.getString(1);\n                        sortflag = false;\n                    } else {\n                        sortURL = sortURL + \",\" + rs.getString(1);\n                    }\n                }\n                ps = conn.prepareStatement(sqlsortURL);\n                ps.setString(1, sortURL);\n                ps.executeUpdate();\n            }\n            conn.commit();\n        } catch (Exception e) {\n            e.printStackTrace();\n            try {\n                conn.rollback();\n            } catch (SQLException e1) {\n                e1.printStackTrace();\n            }\n        } finally {\n            close(rs, null, ps, conn, dbo);\n        }\n    }\n", "label": 0, "substitutes": {"saveUser": [" enrichUser", "saveAccount", " enrichuser", " saveAccount", " manipulateuser", "saveGroup", " saveuser", " enrichAccount", " manipulateGroup", "saveuser", " saveGroup", " enrichGroup", " manipulateAccount", " manipulateUser"], "user": ["rule", "report", "author", "usr", "response", "u", "actor", "item", "by", "us", "entry", "test", "email", "word", "client", "force", "create", "ro", "update", "table", "base", "profile", "me", "char", "USER", "human", "write", "load", "replace", "message", "used", "result", "cert", "post", "v", "content", "e", "url", "owner", "name", "get", "person", "login", "or", "data", "this", "per", "object", "project", "auth", "responsible", "record", "uid", "add", "use", "info", "row", "account", "usage", "job", "file", "password", "User", "ver", "store", "username", "print", "server", "version"], "digest": ["mdester", "readester", "compests", " digse", "hashester", "hashEST", "digests", "digse", "compest", "Digester", " digests", "readse", "Digse", "digEST", "mdest", "readest", "compested", "hashests", "compress", "hashested", " digester", "Digested", "hashest", "mdse", "readested", "mdested", " digress", " digEST", "digested", "digress", "hashress", "digester", "DigEST", " digested", "Digest"], "hash": ["type", "ashes", "handle", "mask", "block", "ash", "Hash", "her", "test", "h", "sum", "tag", "sha", "init", "char", "max", "result", "number", "cache", "sh", "hed", "has", "hex", "search", "height", "dig", "add", "num", "full", "count", "key", "html", "uh", "rh", "size", "password", "mac", "version", "check", "id", "index"], "bigInt": [" bigInteger", "pgINT", "BigInt", "hugeInteger", "longINT", "Bigint", "bigint", "bigInteger", "BigInteger", "bigLong", " bigint", "BigLong", "hugeint", "pgint", "littleINT", "hugeInt", "littleint", "littleInt", "hugeLong", "longInt", " bigLong", "longint", "bigINT", "pgInt"], "hashtext": ["sumtext", "Hashpath", "hextxt", " hashstr", "hexvalue", "ashinfo", " hashread", "ashread", "shatxt", "ashtext", "hashpath", "sumstr", "shatext", "hashvalue", "sumpath", "hexText", "ashtxt", " hashvalue", "shavalue", " hashtxt", "hashread", " hashfunction", "ashText", "hashstr", "Hashfunction", "sumfunction", "hashText", "HashText", "Hashtext", "ashstr", "hashfunction", "hextext", "hashinfo", "shaText", "Hashinfo", " hashText", "hexread", "hexpath", "hashtxt", "sumText", " hashinfo", "Hashstr"]}}
{"id1": "8000624", "id2": "659316", "code1": "    private void CopyTo(File dest) throws IOException {\n        FileReader in = null;\n        FileWriter out = null;\n        int c;\n        try {\n            in = new FileReader(image);\n            out = new FileWriter(dest);\n            while ((c = in.read()) != -1) out.write(c);\n        } finally {\n            if (in != null) try {\n                in.close();\n            } catch (Exception e) {\n            }\n            if (out != null) try {\n                out.close();\n            } catch (Exception e) {\n            }\n        }\n    }\n", "code2": "    public static void main(String[] argv) {\n        if (1 < argv.length) {\n            File[] sources = Source(argv[0]);\n            if (null != sources) {\n                for (File src : sources) {\n                    File[] targets = Target(src, argv);\n                    if (null != targets) {\n                        final long srclen = src.length();\n                        try {\n                            FileChannel source = new FileInputStream(src).getChannel();\n                            try {\n                                for (File tgt : targets) {\n                                    FileChannel target = new FileOutputStream(tgt).getChannel();\n                                    try {\n                                        source.transferTo(0L, srclen, target);\n                                    } finally {\n                                        target.close();\n                                    }\n                                    System.out.printf(\"Updated %s\\n\", tgt.getPath());\n                                    File[] deletes = Delete(src, tgt);\n                                    if (null != deletes) {\n                                        for (File del : deletes) {\n                                            if (SVN) {\n                                                if (SvnDelete(del)) System.out.printf(\"Deleted %s\\n\", del.getPath()); else System.out.printf(\"Failed to delete %s\\n\", del.getPath());\n                                            } else if (del.delete()) System.out.printf(\"Deleted %s\\n\", del.getPath()); else System.out.printf(\"Failed to delete %s\\n\", del.getPath());\n                                        }\n                                    }\n                                    if (SVN) SvnAdd(tgt);\n                                }\n                            } finally {\n                                source.close();\n                            }\n                        } catch (Exception exc) {\n                            exc.printStackTrace();\n                            System.exit(1);\n                        }\n                    }\n                }\n                System.exit(0);\n            } else {\n                System.err.printf(\"Source file(s) not found in '%s'\\n\", argv[0]);\n                System.exit(1);\n            }\n        } else {\n            usage();\n            System.exit(1);\n        }\n    }\n", "label": 1, "substitutes": {"CopyTo": [" copiesInt", "CopyInt", " copyInt", " copyFrom", " CopyFrom", " copiesFrom", " CopyInt", " copiesTo", " copyTo", "CopyFrom"], "dest": ["origin", "txt", "usr", "image", "img", "cat", "output", "orig", "them", "sp", "d", "cont", "tmp", "est", "pipe", "mem", "rest", "th", "result", "src", "opt", "v", "filename", "name", "copy", "target", "it", "st", "path", "null", "dir", "nom", "Dest", "temp", "fn", "source", "loc", "p", "w"], "in": ["mi", "rin", "en", "image", "win", "inn", "ini", "by", "gin", "min", "con", "IN", "internal", "ins", "ar", "reader", "m", "on", "client", "al", "In", "t", "inner", "inside", "init", "one", "net", "from", "thin", "ai", "re", "up", "i", "read", "bin", "ac", "inc", "l", "input", "sin", "login", "iter", "it", "per", " din", "ir", " input", "ain", "ind", "o", "nin", "r", "local", "din", "inf", "is", "isin", "source", "file", "cin", "ire"], "out": ["all", "co", "en", "nt", "na", "flush", "by", "con", "output", "cos", "oe", "res", "oss", "cn", "op", "other", "obj", "ln", "client", "w", "not", "t", "inner", "dis", "ns", "one", "conv", "net", "write", "b", "to", "end", "loss", "list", "up", "v", "e", "writer", "os", "outer", "it", "gt", "note", "null", "at", "ou", "outs", "aos", "o", "batch", "boot", "ex", "full", "n", "io", "Out", "fn", "OUT", "user", "can", "ne", "ot"], "c": ["f", "rc", "u", "cat", "z", "con", "character", "cb", "d", "cont", "cr", "C", "bc", "t", "ce", "char", "code", "k", "cc", "ca", "current", "v", "i", "e", "ct", "conf", "ac", "cp", "gc", "cm", "l", "ec", "cod", "ch", "sc", "lc", "cd", "g", "unc", "cut", "nc", "count", "n", "arc", "uc", "cap", "cf", "cs", "cl"]}}
{"id1": "6906419", "id2": "9550506", "code1": "    public static String encryptPassword(String password) {\n        try {\n            MessageDigest digest = java.security.MessageDigest.getInstance(\"SHA1\");\n            digest.update(password.getBytes(\"UTF-8\"));\n            byte[] hash = digest.digest();\n            StringBuffer buf = new StringBuffer();\n            for (int i = 0; i < hash.length; i++) {\n                int halfbyte = (hash[i] >>> 4) & 0x0F;\n                int two_halfs = 0;\n                do {\n                    if ((0 <= halfbyte) && (halfbyte <= 9)) {\n                        buf.append((char) ('0' + halfbyte));\n                    } else {\n                        buf.append((char) ('a' + (halfbyte - 10)));\n                    }\n                    halfbyte = hash[i] & 0x0F;\n                } while (two_halfs++ < 1);\n            }\n            return buf.toString();\n        } catch (Exception e) {\n        }\n        return null;\n    }\n", "code2": "    private String cookieString(String url, String ip) {\n        MessageDigest md = null;\n        try {\n            md = MessageDigest.getInstance(\"SHA-1\");\n            md.update((url + \"&&\" + ip + \"&&\" + salt.toString()).getBytes());\n            java.math.BigInteger hash = new java.math.BigInteger(1, md.digest());\n            return hash.toString(16);\n        } catch (NoSuchAlgorithmException e) {\n            filterConfig.getServletContext().log(this.getClass().getName() + \" error \" + e);\n            return null;\n        }\n    }\n", "label": 1, "substitutes": {"encryptPassword": ["decryptPass", "encryptString", "encryptionString", "decryptString", "enccryptPass", "encryptpassword", "encryptedpassword", "decryptedPassword", "enccryptPassword", "decryptpassword", "decryptedString", "encryptionPassword", "encryptedPassword", "encryptionPass", "decryptedpassword", "encryptedPass", "encryptedString", "encryptionpassword", "enccryptString", "decryptedPass", "encryptPass", "enccryptpassword", "decryptPassword"], "password": ["phrase", "address", "value", "text", "default", "reset", "email", "hello", "word", "description", "secret", "shadow", "command", "attribute", "Password", "message", "wd", "wordpress", "name", "token", "input", "login", "auth", "sword", "database", "pattern", "padding", "key", "string", "user", "username", "print", "data", "prefix", "pass"], "digest": ["persester", "dested", " digse", "decest", "digist", "persest", "dest", "hashester", "hashEST", "decester", "digse", "Digester", "minested", "Digse", "digEST", "persested", "hashse", "Digist", "decested", "persist", " digester", "Digested", "hashest", "minester", "minest", "decse", "minist", "dse", " digEST", "digested", "digester", "dester", "DigEST", " digested", "Digest"], "hash": ["ashes", "ah", "report", "all", "handle", "hist", "mask", "address", "block", "stock", "ash", "her", "Hash", "match", "shift", "test", "h", "score", "share", "sum", "table", "esh", "here", "sha", "attribute", "hz", "have", "array", "cache", "sh", "alt", "hed", "square", "has", "total", "hex", "query", "history", "search", "height", "dig", "filter", "html", "oh", "rh", "where", "mac", "memory", "check", "map", "print", "host"], "buf": ["window", "txt", "cv", "usr", "block", "pb", "buff", "br", "img", "var", "bg", "func", "cb", "ob", "bo", "bh", "foo", "tmp", "bc", "agg", "conv", "box", "buffer", "pkg", "bag", "b", "printf", "fam", "db", "font", "off", "Buffer", "nb", "rb", "uf", "hung", "alph", "bu", "mu", "cmd", "np", "queue", "mb", "batch", "etc", "bar", "Buff", "forge", "msg", "cf", "cap", "pool", "fb", "vec"], "i": ["exp", "f", "mi", "major", "json", "u", "ini", "j", "ski", "y", "cli", "ie", "I", "qi", "di", "im", "ri", "ei", "slice", "m", "iq", "conv", "init", "x", "in", "t", "iu", "hi", "q", "ti", "bi", "c", "print", "b", "ic", "go", "ci", "multi", "ai", "sim", "to", "gi", "v", "ui", "e", "uri", "pi", "get", "it", "phi", "ji", "li", "xi", "\u0438", "my", "si", "point", "g", "ind", "ip", "zi", "info", "n", "key", "me", "io", "ii", "is", "oi", "index", "id", "a", "ix", "ex"], "halfbyte": ["halfpiece", " halfbuffer", "Halfpage", "halfpixel", "phypair", "phypiece", "Halfbytes", " halfletter", " halfcoin", " halfpixel", "phybytes", "Halfletter", "quarterchar", " halfnode", "Halfpiece", "halfletter", " halfpage", " halfpair", "quarterword", "halfnode", "quarterpair", "phychar", "halfbytes", "halfchar", "halfword", "phylen", "Halfbyte", "Halfnode", " halfchar", "Halfchannel", " halflen", "halfchannel", "halfpair", " halfchannel", "phypixel", "Halfword", " halfbytes", "quarterbyte", " halfword", "quarterletter", "halfcoin", "Halfpixel", "quarterpixel", "leftnode", "leftchar", "quarterchannel", "Halfcoin", "quartercoin", "halfpage", "quarterpage", "halflen", "leftbuffer", "halfbuffer", "Halfbuffer", " halfpiece", "Halfchar", "quarterlen", "leftbyte", "phybyte"], "two_halfs": ["two_roundls", "two_enthalsets", "two_shakes", "two_turnls", "two_leds", "two_enthalss", "two_enthalisters", "two_ledsets", "two_roundi", "two_halfls", "two_parenls", "two_ledss", "two_halfups", "two_turns", "two_turnups", "two_parenups", "two_rounds", "two_halfss", "two_halfsets", "two_shakeisters", "two_shakesets", "two_halfisters", "two_shakess", "two_roundups", "two_enthals", "two_halfi", "two_pareni", "two_parens", "two_turni", "two_ledisters"]}}
{"id1": "14567939", "id2": "10715601", "code1": "    private static byte[] baseHash(String name, String password) {\n        try {\n            MessageDigest digest = MessageDigest.getInstance(\"MD5\");\n            digest.reset();\n            digest.update(name.toLowerCase().getBytes());\n            digest.update(password.getBytes());\n            return digest.digest();\n        } catch (NoSuchAlgorithmException ex) {\n            d(\"MD5 algorithm not found!\");\n            throw new RuntimeException(\"MD5 algorithm not found! Unable to authenticate\");\n        }\n    }\n", "code2": "    public static synchronized String toSHA1(String str) {\n        Nulls.failIfNull(str, \"Cannot create an SHA1 encryption form a NULL string\");\n        try {\n            MessageDigest md;\n            md = MessageDigest.getInstance(SHA1);\n            byte[] sha1hash = new byte[40];\n            md.update(str.getBytes(ISO_CHARSET), 0, str.length());\n            sha1hash = md.digest();\n            return convertToHex(sha1hash);\n        } catch (NoSuchAlgorithmException ex) {\n            ex.printStackTrace();\n        } catch (UnsupportedEncodingException ex) {\n            ex.printStackTrace();\n        }\n        return null;\n    }\n", "label": 1, "substitutes": {"baseHash": [" basehash", " baseSign", " baseKey", "basichash", "basicKey", "BaseKey", "baseKey", "basehash", "Basehash", "BaseHash", "basicSign", "BaseSign", "basicHash", "baseSign"], "name": ["admin", "author", "address", "default", "named", "alias", "word", "create", "table", "run", "names", "current", "family", "person", "hash", "initial", "john", "NAME", "login", "order", "common", "parent", "search", "term", "ame", "ident", "local", "domain", "key", "info", "account", "n", "user", "id", "username", "Name", "prefix", "title"], "password": ["phrase", "value", "picture", "reset", "entry", "hello", "word", "description", "secret", "shadow", "restricted", "command", "attribute", "Password", "message", "wd", "token", "hash", "login", "auth", "sword", "database", "padding", "key", "user", "remember", "username", "prefix", "session", "crypt", "pass"], "digest": ["mdester", "dested", "descested", "dgest", "decest", "Digend", "diger", " Diger", "descgest", "diggest", " digum", "dest", "decester", "Diger", "digse", "digum", " Digest", "Digester", "mdgest", "digend", "dEST", "Digum", " Digend", "mdEST", "decgest", "displayester", "Digse", " digend", "digEST", "descse", "mdest", "displayest", "Diggest", " Digester", "displayested", "descester", "displayum", "displayEST", "decested", " digester", "Digested", "mdse", "mdested", "descest", "digested", " diger", "digester", "DigEST", " digested", "Digest"]}}
{"id1": "4501356", "id2": "6517139", "code1": "    static String calculateProfileDiffDigest(String profileDiff, boolean normaliseWhitespace) throws Exception {\n        if (normaliseWhitespace) {\n            profileDiff = removeWhitespaces(profileDiff);\n        }\n        MessageDigest md = MessageDigest.getInstance(\"MD5\");\n        md.update(profileDiff.getBytes());\n        return new BASE64Encoder().encode(md.digest());\n    }\n", "code2": "    private String getPrefsKey(String key) {\n        try {\n            if (MD5 == null) MD5 = MessageDigest.getInstance(\"MD5\");\n            MD5.reset();\n            MD5.update(key.getBytes(\"UTF-8\"));\n            byte[] resultBytes = MD5.digest();\n            return toHexString(resultBytes);\n        } catch (Exception nsae) {\n            return key;\n        }\n    }\n", "label": 1, "substitutes": {"calculateProfileDiffDigest": ["calculateProfileDiffdigst", "calculateProfileDiffdige", "calculateProfileChangedige", "calculateProfileDiffdigests", "calculateProfileChangedigest", "calculateProfileDiffSigne", "calculateProfileDiffSignests", "calculateProfileChangeDigest", "calculateProfileDiffdigest", "calculateProfileChangeDige", "calculateProfileDiffDiffe", "calculateProfileDiffDige", "calculateProfileDiffDiffest", "calculateProfileChangedigests", "calculateProfileChangeDigst", "calculateProfileDiffDiffests", "calculateProfileDiffDigst", "calculateProfileChangeDigests", "calculateProfileDiffSignst", "calculateProfileDiffDigests", "calculateProfileDiffSignest", "calculateProfileDiffDiffst", "calculateProfileChangedigst"], "profileDiff": ["jsonDifferent", "profileInf", "templateData", "caseDiff", "phdiff", "userDelta", "pictureChange", " profileInf", "jsonDiff", "personUpdate", "pictureDiff", " profileDelta", "caseUpdate", "userChange", "templateDelta", "profilediff", "phDiff", " profileUpdate", "profileChange", "caseDelta", "ProfileDelta", "ProfileChange", "jsonDelta", "profileDelta", "profileData", "ProfileData", "ProfileDifferent", "userDiff", "ProfileDiff", "templateDiff", "phChange", "phInf", "profileDifferent", "personDiff", "templateDifferent", "profileUpdate", " profilediff", "jsonData", "picturediff", "personDelta", "casediff", "persondiff", " profileChange", "pictureInf"], "normaliseWhitespace": ["normaliseWhatsace", "normaliseWhipspaces", "normaliseWitespaces", "normaliseWitesspace", "normaliseWitesace", "normaliseWhatspace", "normaliseWhipsSpace", "normaliseWipspace", "normaliseWitesSpace", "normaliseWhipsspace", "normaliseWhitespaces", "normaliseWipsspace", "normaliseWhitesace", "normaliseWhatspaces", "normaliseWitespace", "normaliseWhipspace", "normaliseWatspace", "normaliseWipsSpace", "normaliseWatsspace", "normaliseWatsace", "normaliseWhitesSpace", "normaliseWhitsspace", "normaliseWhitspaces", "normaliseWhitsSpace", "normaliseWhipsace", "normaliseWatsSpace", "normaliseWhitspace", "normaliseWhatsSpace", "normaliseWipspaces", "normaliseWhatsspace", "normaliseWhitesspace"], "md": ["nt", "sm", "pd", "ms", "and", "od", "deep", "d", "der", "js", "mt", "amd", "obj", "m", "mod", "mg", "red", "fd", "dr", " sd", "rm", "det", "dm", "sd", "nd", "dd", "cmd", "dir", "cd", "hd", "MD", "ind", "add", "ad", "grad", "mn", "mc", "mm", " df", "pm", "mk", "de", "dist", "ld", "mac", "sam", "pdf", "bd", "df"]}}
{"id1": "15362793", "id2": "1235538", "code1": "    public static String ReadURL(URL url, boolean textonly) {\n        try {\n            URLConnection uconn = url.openConnection();\n            Object ucont = uconn.getContent();\n            if (ucont instanceof InputStream) return ReadInputStream((java.io.InputStream) ucont, textonly); else return \"\" + ucont;\n        } catch (java.io.IOException e) {\n            e.printStackTrace();\n        }\n        return null;\n    }\n", "code2": "    public static String encrypt(final String pass) {\n        try {\n            final MessageDigest md = MessageDigest.getInstance(\"SHA\");\n            md.update(pass.getBytes(\"UTF-8\"));\n            return new String(Base64.encodeBase64(md.digest()));\n        } catch (final Exception e) {\n            throw new RuntimeException(\"No se pudo encriptar el password.\", e);\n        }\n    }\n", "label": 0, "substitutes": {"ReadURL": ["readUR", " readURL", " ReadUR", " ReadString", " readString", "readURL", " ReadUrl", "ReadString", "ReadUR", "ReadUrl", " readUrl", "readString", " readUR", "readUrl"], "url": ["f", "browser", "address", "dl", "request", "bel", "page", "ls", "ll", "base", "char", "link", "q", "build", "b", "call", "xml", "ur", "mount", "un", "uri", "URL", "name", "str", "l", "nl", "ul", "path", "conn", "rect", "ssl", "el", "key", "http", "html", "job", "file", "Url", "p"], "textonly": ["inputonly", "readonly", " textrender", "readOnly", "textfirst", "textOnly", "Textonly", " textall", " textfirst", "readall", "Textall", "inputfirst", "readfirst", " textOnly", "textrender", "inputOnly", "readrender", "textall", "inputrender", "TextOnly"], "uconn": ["pucon", "puphys", "uucon", "ucert", "uphys", "cucert", "uiss", "puConn", " uphys", "cuconn", "cuiss", "Uiss", "uConn", "cucon", "UConn", " uConn", "uucert", "puconn", "uuconn", " ucon", "uuiss", "Uconn", "ucon", "Ucon", "Uphys", "Ucert"], "ucont": ["unicict", "uvannot", "uuond", "bcnt", "usercont", "ucict", "ucannot", "ancany", "usercond", "ucnt", "ucond", "uuont", "unicond", "unicront", "uphrypt", "uscond", "ucront", "cuond", "ucrypt", "unicannot", "uphont", "uscong", "uudet", "uscdet", "unicong", "unicany", "uscont", "unicrypt", "uniconto", "uuong", "bcount", "uvonto", "uvrypt", "unicont", "uconto", "bcont", "uphannot", "uccont", "uvont", "cunt", "ancront", "uphonto", "ancont", "usercnt", "uccany", "ucdet", "usercount", "ancict", "bcond", "uccront", "ucong", "uccict", "cuount", "cuont", "ucount", "unicdet", "ucany"]}}
{"id1": "5676111", "id2": "19687456", "code1": "    public void get() {\n        try {\n            int cnt;\n            URL url = new URL(urlStr);\n            URLConnection conn = url.openConnection();\n            conn.setDoInput(true);\n            conn.setDoOutput(false);\n            InputStream is = conn.getInputStream();\n            String filename = new File(url.getFile()).getName();\n            FileOutputStream fos = new FileOutputStream(dstDir + File.separator + filename);\n            byte[] buffer = new byte[4096];\n            while ((cnt = is.read(buffer, 0, buffer.length)) != -1) fos.write(buffer, 0, cnt);\n            fos.close();\n            is.close();\n        } catch (Exception ex) {\n            ex.printStackTrace();\n        }\n    }\n", "code2": "    public void testReadPerMemberSixSmall() throws IOException {\n        GZIPMembersInputStream gzin = new GZIPMembersInputStream(new ByteArrayInputStream(sixsmall_gz));\n        gzin.setEofEachMember(true);\n        for (int i = 0; i < 3; i++) {\n            int count2 = IOUtils.copy(gzin, new NullOutputStream());\n            assertEquals(\"wrong 1-byte member count\", 1, count2);\n            gzin.nextMember();\n            int count3 = IOUtils.copy(gzin, new NullOutputStream());\n            assertEquals(\"wrong 5-byte member count\", 5, count3);\n            gzin.nextMember();\n        }\n        int countEnd = IOUtils.copy(gzin, new NullOutputStream());\n        assertEquals(\"wrong eof count\", 0, countEnd);\n    }\n", "label": 0, "substitutes": {"get": ["Download", "export", " fetch", " finish", "sync", " recover", "execute", " reload", "run", "init", "call", "gc", " construct", "upload", "dump", "GET", " copy", "zip", "info", "Get", "download", "exec", " delete", " put", " download", "print", "delete"], "cnt": [" cnc", "nccount", "nnc", "ncht", "uncNT", "Cnt", "acNT", "CNT", "ccount", "Cct", "nNT", "uncnt", "Cht", "cNT", "cht", "unclen", "Cnc", "ncct", " cNT", "clen", "acnt", "ncnt", "nnt", " cht", " clen", "aclen", "cnc", " ccount", "uncnc", "acnc", "Ccount", "nct", "cct", " cct"], "url": ["f", "browser", "handle", "hl", "gl", "ref", "google", "dl", "con", "www", "client", "fs", "https", "bel", "ls", "web", "ll", "base", "char", "link", "pl", "build", "sl", "open", "addr", "cert", "rel", "xml", "ur", "mount", "cp", "uri", "URL", "str", "l", "nl", "ul", "mail", "path", "null", "r", "ssl", "el", "ret", "http", "socket", "loc", "Url", "host", "fl"], "conn": ["co", "en", "nt", "access", "ctx", "gn", "con", "dial", "pas", "comm", "cn", "cb", "cont", "enc", "obj", "yn", "client", "nec", "col", "conv", "init", "ns", "connection", "cons", "ca", "c", "net", "open", "addr", "cert", "resp", "cur", "rel", "org", "com", "cp", "act", "ct", "Conn", "serv", "coll", "cm", "os", "l", "ens", "ch", "cmd", "nl", "syn", "connect", "nc", "jp", "exec", "loc"], "is": ["mis", "ist", "ms", "iris", "us", "ends", "imp", "sit", "ins", "Is", "im", "ri", "nis", "fs", "sys", "bs", "isa", "ais", "icks", "init", "in", "dis", "vis", "ps", "ic", "sim", "i", "its", "rs", "ris", "os", "IS", "has", "ys", "iter", "it", "isc", "isl", "si", "lis", "bis", "isf", "ip", "ists", "isi", "ios", "isin", "iso", "iss", "ib", "es", "abs"], "filename": ["f", "txt", "LCS", "nm", "subject", "continental", "FILE", "fil", "fp", "river", "sbm", "journal", "println", "ename", "family", "lua", "name", "knife", "str", "nu", "til", "kl", "sql", "stem", "Filename", "path", "ame", "ren", "string", "mson", "file", "fn", "source", "latest", "FIL", "username", "prefix", "title"], "fos": ["Foss", "foes", "vres", "fres", "foss", "voses", "flos", " faos", "bows", " fows", "vos", "Foes", "floss", "foses", " fres", "faos", "los", "flaos", "loes", "Fows", "loss", "Fres", " foses", " foes", "fows", "bos", "boss", "Fos", "floes", "Foses", "Faos", "boes", " foss", "vaos", "laos"], "buffer": ["event", "phrase", "buf", "window", "bone", "block", "buff", "text", "output", "sample", "frame", "comment", "view", "sequence", "page", "table", "append", "library", "mem", "base", "template", "char", "command", "attribute", "document", "message", "result", "stack", "available", "cache", "Buffer", "scroll", "variable", "total", "iter", "data", "note", "history", "length", "queue", "paste", "binary", "batch", "database", "bar", "temp", "button", "source", "memory", "print", "bytes", "display"]}}
{"id1": "4599372", "id2": "411595", "code1": "    @Override\n    public String readFixString(final int len) {\n        if (len < 1) {\n            return StringUtils.EMPTY;\n        }\n        final StringWriter sw = new StringWriter();\n        try {\n            IOUtils.copy(createLimitedInputStream(len), sw, null);\n        } catch (IOException e) {\n            throw createRuntimeException(e);\n        }\n        return sw.toString();\n    }\n", "code2": "    private void displayDiffResults() throws IOException {\n        File outFile = File.createTempFile(\"diff\", \".htm\");\n        outFile.deleteOnExit();\n        FileOutputStream outStream = new FileOutputStream(outFile);\n        BufferedWriter out = new BufferedWriter(new OutputStreamWriter(outStream));\n        out.write(\"<html><head><title>LOC Differences</title>\\n\" + SCRIPT + \"</head>\\n\" + \"<body bgcolor='#ffffff'>\\n\" + \"<div onMouseOver=\\\"window.defaultStatus='Metrics'\\\">\\n\");\n        if (addedTable.length() > 0) {\n            out.write(\"<table border><tr><th>Files Added:</th>\" + \"<th>Add</th><th>Type</th></tr>\");\n            out.write(addedTable.toString());\n            out.write(\"</table><br><br>\");\n        }\n        if (modifiedTable.length() > 0) {\n            out.write(\"<table border><tr><th>Files Modified:</th>\" + \"<th>Base</th><th>Del</th><th>Mod</th><th>Add</th>\" + \"<th>Total</th><th>Type</th></tr>\");\n            out.write(modifiedTable.toString());\n            out.write(\"</table><br><br>\");\n        }\n        if (deletedTable.length() > 0) {\n            out.write(\"<table border><tr><th>Files Deleted:</th>\" + \"<th>Del</th><th>Type</th></tr>\");\n            out.write(deletedTable.toString());\n            out.write(\"</table><br><br>\");\n        }\n        out.write(\"<table name=METRICS BORDER>\\n\");\n        if (modifiedTable.length() > 0 || deletedTable.length() > 0) {\n            out.write(\"<tr><td>Base:&nbsp;</td><td>\");\n            out.write(Long.toString(base));\n            out.write(\"</td></tr>\\n<tr><td>Deleted:&nbsp;</td><td>\");\n            out.write(Long.toString(deleted));\n            out.write(\"</td></tr>\\n<tr><td>Modified:&nbsp;</td><td>\");\n            out.write(Long.toString(modified));\n            out.write(\"</td></tr>\\n<tr><td>Added:&nbsp;</td><td>\");\n            out.write(Long.toString(added));\n            out.write(\"</td></tr>\\n<tr><td>New & Changed:&nbsp;</td><td>\");\n            out.write(Long.toString(added + modified));\n            out.write(\"</td></tr>\\n\");\n        }\n        out.write(\"<tr><td>Total:&nbsp;</td><td>\");\n        out.write(Long.toString(total));\n        out.write(\"</td></tr>\\n</table></div>\");\n        redlinesOut.close();\n        out.flush();\n        InputStream redlines = new FileInputStream(redlinesTempFile);\n        byte[] buffer = new byte[4096];\n        int bytesRead;\n        while ((bytesRead = redlines.read(buffer)) != -1) outStream.write(buffer, 0, bytesRead);\n        outStream.write(\"</BODY></HTML>\".getBytes());\n        outStream.close();\n        Browser.launch(outFile.toURL().toString());\n    }\n", "label": 1, "substitutes": {"readFixString": [" readFixList", "readFixStream", "readByteString", " readContentStream", " readByteList", " readFixShort", " readByteString", " readContentShort", " readRichList", " readRichShort", " readFixStream", " readByteShort", " readContentString", "readFixShort", " readByteStream", " readContentList", "readByteStream", "readByteShort", "readFixList", " readRichStream", " readRichString", "readByteList"], "len": ["seq", "en", "nt", "dl", "vol", "enc", "ln", "ls", "ll", "lf", "ell", "pl", "sl", "lan", "le", "coll", "l", "pos", "kl", "nl", "length", "lp", "lc", "syn", "num", "lon", "el", "inv", "n", "L", "Len", "ld", "fin", "fn", "size", "elt", "vec", "bytes", "fl", "cl"], "sw": ["wr", "sb", "sm", "Sw", "sp", "rw", "sur", "ow", "ws", "wa", "wl", "sa", "rew", "hw", "we", "sl", "sr", "iw", "sk", "sh", "sv", "wra", "sf", "wn", "wt", "sc", "ew", "aw", "sn", "SW", "kw", "wo", "nw", "tw", "wh", "sem", "sam", "w"]}}
{"id1": "4686922", "id2": "19147281", "code1": "    public void extractResourceToFile(String resourcePath, File dest) {\n        InputStream in = getClass().getResourceAsStream(resourcePath);\n        try {\n            FileOutputStream out = FileUtils.openOutputStream(dest);\n            try {\n                IOUtils.copy(in, out);\n            } finally {\n                if (out != null) {\n                    out.close();\n                }\n            }\n        } finally {\n            if (in != null) {\n                in.close();\n            }\n        }\n    }\n", "code2": "    public boolean actualizarDatosPrevia(int idJugadorDiv, int idRonda, int idPareoRival, int color, int flotante) {\n        int intResult = 0;\n        String sql = \"UPDATE jugadorxdivxronda \" + \" SET idPareoRival = \" + idPareoRival + \" , color = \" + color + \" , flotante = \" + flotante + \" \" + \" WHERE jugadorxDivision_idJugadorxDivision = \" + idJugadorDiv + \" AND ronda_numeroRonda = \" + idRonda;\n        try {\n            connection = conexionBD.getConnection();\n            connection.setAutoCommit(false);\n            ps = connection.prepareStatement(sql);\n            intResult = ps.executeUpdate();\n            connection.commit();\n        } catch (SQLException ex) {\n            ex.printStackTrace();\n            try {\n                connection.rollback();\n            } catch (SQLException exe) {\n                exe.printStackTrace();\n            }\n        } finally {\n            conexionBD.close(ps);\n            conexionBD.close(connection);\n        }\n        return (intResult > 0);\n    }\n", "label": 0, "substitutes": {"extractResourceToFile": ["extractResourcesTofile", "extractResourcesToFiles", "extractResourceAsFiles", "extractResourcesToStream", "extractResources2Stream", "extractResourceTofile", "extractResources2file", "extractResourceToStream", "extractResourceAsfile", "extractResource2file", "extractResource2File", "extractResources2File", "extractResources2Files", "extractResourceAsStream", "extractResourceFromFile", "extractResource2Stream", "extractResourceToFiles", "extractResourceFromFiles", "extractResource2Files", "extractResourceFromStream", "extractResourcesToFile", "extractResourceFromfile", "extractResourceAsFile"], "resourcePath": ["Resourcepath", "resourceLocation", "attributeLocation", "resourceUrl", "attributeName", "ResourceUrl", " resourceName", "templateIn", "ResourceLocation", "uriName", "ResourceName", " resourcepath", "resourcepath", "templateName", "ResourceIn", "templatePath", "uriUrl", "ResourcePath", "uriPath", "resourceName", " resourceIn", "templatepath", "uriLocation", "resourceIn", "attributeUrl", "attributePath"], "dest": ["origin", "decl", "coord", "good", "comb", "prop", "home", "img", "cat", "output", "orig", "sp", "cont", "trans", "tmp", "mem", "rest", "to", "lit", "result", "src", "opt", "target", "des", "this", "parent", "null", "dir", "nom", "dat", "gov", "etc", "self", "desc", "Dest", "temp", "dist", "source", "loc", "end", "w"], "in": ["f", "all", "mi", "rin", "inn", "ini", "gin", "con", "IN", "ins", "resource", "ln", "on", "m", "al", "raw", "In", "init", "inner", "inside", "re", "up", "conf", "i", "none", "bin", "inc", "l", "input", "or", "sin", "iter", "it", " din", "ind", "r", "mc", "local", "din", "inf", "no", "is", "isin", "source", "file", "cin", "id", "from", "ne"], "out": ["f", "co", "en", "nt", "na", "con", "output", "res", "cos", "oss", "cn", "obj", "client", "on", "sys", "tmp", "col", "conv", "t", "inner", "stable", "net", "print", "write", "b", "to", "ot", "v", "i", " Out", "cache", "writer", "os", "outer", "it", "ch", "note", "exit", "null", "ou", "at", "outs", "aos", "o", "again", "n", "io", "no", "Out", "pool", "OUT", "can", "ne", "w"]}}
{"id1": "21125261", "id2": "23452437", "code1": "    @Test\n    public void test() throws Exception {\n        InputStream is = this.getClass().getResourceAsStream(\"originAndDestination.xml\");\n        ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();\n        IOUtils.copy(is, byteArrayOutputStream);\n        TrafficModelDefinition def = MDFReader.read(byteArrayOutputStream.toByteArray());\n        TrafficSimulationEngine se = new TrafficSimulationEngine();\n        se.init(def);\n        int linkId = 2;\n        int segmentId = 0;\n        Map<Integer, Set<Integer>> linkSegments = new HashMap<Integer, Set<Integer>>();\n        Set<Integer> segments = new HashSet<Integer>();\n        segments.add(segmentId);\n        linkSegments.put(linkId, segments);\n        FrameProperties frameProperties = new FrameProperties(linkSegments, new HashSet<Integer>());\n        se.setFrameProperties(frameProperties);\n        for (float time = 0; time < 60 * 10; time += 0.1f) {\n            se.step(0.1f);\n            for (RoadObject vehicle : se.getDynamicObjects()) {\n                System.out.println(time + \": X=\" + vehicle.getPosition() + \"\\tV=\" + vehicle.getSpeed());\n            }\n        }\n    }\n", "code2": "        private void internalCopy(File fSource, File file) throws FileNotFoundException, IOException {\n            if (fSource.getName().equals(\"Thums.db\")) return;\n            System.out.println(\"copying \" + fSource + \" in \" + file);\n            OutputStream o = new BufferedOutputStream(new FileOutputStream(file));\n            InputStream i = new BufferedInputStream(new FileInputStream(fSource));\n            byte[] b = new byte[8192];\n            int n;\n            while ((n = i.read(b)) > 0) o.write(b, 0, n);\n            i.close();\n            o.close();\n        }\n", "label": 1, "substitutes": {"test": ["Test", "sample", "hello", "feature", "execute", " tests", "tests", "launch", "run", "t", "debug", "train", "load", "testing", "read", "example", "fit", " evaluate", "show", "volt", " sample", "evaluate", "T", " testing", "unit", "server"], "is": ["mis", "xs", "does", "ms", "us", "sit", "Is", "ri", "ws", "fs", "sys", "bs", "stream", "ls", "isa", "ais", "in", "tis", "ps", "ai", "xml", "i", "its", "serv", "rs", "ris", "IS", "os", "input", "out", "has", "are", "isc", "lis", "s", "isi", "iso", "as", "ios", "es", "sis"], "byteArrayOutputStream": ["byteArrayOutputView", "byteArray4Stream", "byteArrayOutputForm", "byteStringOutputSteam", "byteArrayApplicationStream", "byteArrayOutputString", "byteStringoutputSteam", "byteArray4View", "byteArrayoutputStream", "byteArrayOutputStyle", "byteArrayInputString", "byteStreamInputStream", "byteArray4Steam", "byteStringInputStream", "byteArray4String", "byteStreamInputSteam", "byteStreamOutputStyle", "byteStringOutputString", "byteArrayByteView", "byteArrayoutputString", "byteStringOutputForm", "byteStreamOutputForm", "byteArrayApplicationStyle", "byteArrayoutputSteam", "byteStreamOutputSteam", "byteStringInputView", "byteArrayByteStyle", "byteStringOutputStream", "byteArrayInputStyle", "byteArrayoutputForm", "byteArrayByteForm", "byteArrayInputStream", "byteArrayOutputSteam", "byteArrayByteStream", "byteArrayByteString", "byteArrayApplicationForm", "byteArrayInputSteam", "byteStreamInputStyle", "byteArrayByteSteam", "byteStringoutputForm", "byteArrayInputForm", "byteStreamInputForm", "byteStringInputSteam", "byteStringoutputStream", "byteStringInputString", "byteArrayApplicationSteam", "byteStringoutputString", "byteStreamOutputStream", "byteStringOutputView", "byteArrayInputView"], "def": ["dem", "defined", "decl", "dec", "json", "dl", "default", "d", "Def", "dict", "Definition", "sche", "del", "md", "ef", "db", "pro", "det", "conf", "ded", "sd", "crit", "definition", "dal", "des", "ds", "da", "cd", "define", "hd", "DE", "desc", "DEF", "de", "dev", "df"], "se": ["ze", "ode", "ser", "ses", "su", "SE", "ie", "ine", "sed", "sp", "ee", "engine", "pse", "es", "ide", "ene", "set", "est", "sa", "ae", "sche", "me", "ve", "ce", "we", "sl", "be", "ade", "ense", "Se", "e", "sd", "sec", "see", "ste", "le", "sel", "ase", "parse", "spe", "ge", "ese", "she", "te", "de", "sea", "ane", "so", "sem", "he", "ke", "ne", "pe"], "linkId": ["lineName", "Linkid", " linkID", "connectionID", "linkID", " linkid", "linkid", "linkedId", "chainId", "lineID", "lineId", "LinkId", "linkedID", "LinkName", "connectionIdent", "LinkID", "linkedIdent", "chainID", "linkName", " linkName", "lineid", "connectionId", "linkIdent", "chainIdent"], "segmentId": ["segmentById", "idegementRef", "begmentName", "semissionid", "begroupName", "begroupId", "idegmentId", "segementid", "semissionRef", "idegmentRef", "segroupId", "begroupID", "segmentRef", "segementId", "sementID", "segroupName", "segroupById", "segementName", "segementID", "idegementName", "idegementid", "sementRef", "begmentID", "segementRef", "sementById", "idegmentid", "segmentName", "idegementId", "idegmentName", "semissionName", "segmentID", "segementById", "begmentById", "segmentid", "begroupById", "sementId", "segroupID", "sementName", "semissionId", "begmentId", "sementid"], "linkSegments": ["linkGroups", "linkBuildets", " linkBuildets", " linkGments", "linkSeggments", "linkFragroups", " linkThreadroups", "linkGment", " linkSeggments", "linkSegroups", "linkConnectets", "linkThreadroups", " linkSeglements", " linkThreadments", "linkParlements", " linkSegroups", " linkBuildables", "linkParments", "linkFraggments", " linkGgments", " linkBuildgments", "linkFragment", " linkSegets", "linkBuildroups", " linkBuildments", "linkSegables", "linkConnectments", "linkGgments", "linkConnectables", "linkSeglements", "linkThreadgments", " linkThreadlements", "linkBuildables", "linkSements", " linkThreadgments", "linkBuildgments", "linkThreadlements", "linkGments", "linkConnectlements", "linkSegets", "linkBuildments", "linkThreadments", " linkSegables", "linkSeables", "linkParroups", " linkGment", "linkSeets", "linkSegment", "linkConnectgments", "linkPargments", "linkConnectroups", " linkGroups", "linkBuildment", " linkSegment", "linkFragments"], "segments": ["sements", "megs", "megments", " segs", "velements", "sevals", " Segments", "segins", " sevals", "bevals", "seges", " Sements", "usements", "parsements", "segs", "vectors", "parsegments", " sements", " seges", "usegments", "selements", "parsectors", "usegins", "parselements", " Seges", " Sevals", "beges", "vements", "begments", "bements", " segins", " sectors", "usegs", "vegments", "mements", "megins", "sectors", " selements"], "frameProperties": ["framePrperties", "frameProfilities", "frameByperties", "framePrps", "framePrptions", "frameProilities", " frameProps", " frameProptions", "frameParrics", "frameProps", " frameProilities", "frameByptions", "frameComperties", "frameProfperties", "frameProrics", "framePropilities", "frameParptions", "frameByilities", " framePrperties", " framePrptions", "framePropps", "framePropptions", "frameProfps", " frameByptions", "frameProptions", " framePrrics", "frameParps", "frameComps", "framePropperties", " frameByperties", " framePrps", "framePrrics", " frameByps", "frameByps", "frameComrics", "frameProfptions", " frameProrics", "frameComptions", " frameByilities", "frameParperties"], "time": ["event", "times", "ime", "window", "transform", "year", "step", "value", "each", "money", "tx", "task", "speed", "runtime", "distance", "Time", "depth", "sequence", "set", "context", "t", "TIME", "x", "tt", "frequency", "before", "trace", "date", "message", "timer", "system", "ts", "second", "counter", "now", "trust", "total", "etime", "delay", "rate", "think", "point", "length", "slow", "estamp", "clock", "tim", "count", "start", "size", "timeout", "version", "check", "duration"], "vehicle": ["survendor", "vehocity", "survogram", "vehogram", "yardicle", "survocity", "vehICLE", "verogram", "venticle", "VehICLE", "vertic", "vertocity", "vehicles", "venticles", "heroocity", " vehicles", "verticle", "Vehic", "heroicles", "vericle", "yardocity", "survicle", "yardendor", "heroICLE", "Vehicles", "verendor", "vehic", "vehendor", "yardogram", " vehocity", "verocity", "verticles", "Vehocity", " vehICLE", "ventocity", "Vehicle", "ventic", "heroicle"]}}
{"id1": "3309233", "id2": "19322946", "code1": "        @Override\n        protected String doInBackground(String... params) {\n            try {\n                final HttpParams param = new BasicHttpParams();\n                HttpConnectionParams.setConnectionTimeout(param, 30000);\n                HttpConnectionParams.setSoTimeout(param, 30000);\n                DefaultHttpClient client = new DefaultHttpClient(param);\n                HttpPost post = new HttpPost(\"http://www.google.com/loc/json\");\n                post.setEntity(new StringEntity(params[0]));\n                if (DEBUG) Log.d(\"Location\", params[0]);\n                HttpResponse resp = client.execute(post);\n                if (resp.getStatusLine().getStatusCode() == 200) {\n                    HttpEntity entity = resp.getEntity();\n                    String result = EntityUtils.toString(entity);\n                    return result;\n                } else {\n                    if (isFirstLocation) {\n                        requestGearsLocation(1);\n                        isFirstLocation = false;\n                        return RESULT_FIRST_FAILE;\n                    }\n                }\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n            return null;\n        }\n", "code2": "    @Test\n    public void test_lookupType_FullSearch_MatchingWordInMiddle() throws Exception {\n        URL url = new URL(baseUrl + \"/lookupType/cluster\");\n        HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n        connection.setRequestMethod(\"GET\");\n        connection.setRequestProperty(\"Accept\", \"application/json\");\n        assertThat(connection.getResponseCode(), equalTo(200));\n        assertThat(getResponse(connection), equalTo(\"[{\\\"itemTypeID\\\":29055,\\\"itemCategoryID\\\":17,\\\"name\\\":\\\"Capital Gravimetric Sensor Cluster\\\",\\\"icon\\\":\\\"37_05\\\"},{\\\"itemTypeID\\\":29056,\\\"itemCategoryID\\\":9,\\\"name\\\":\\\"Capital Gravimetric Sensor Cluster Blueprint\\\",\\\"icon\\\":\\\"03_02\\\"},{\\\"itemTypeID\\\":29065,\\\"itemCategoryID\\\":17,\\\"name\\\":\\\"Capital Ladar Sensor Cluster\\\",\\\"icon\\\":\\\"37_07\\\"},{\\\"itemTypeID\\\":29066,\\\"itemCategoryID\\\":9,\\\"name\\\":\\\"Capital Ladar Sensor Cluster Blueprint\\\",\\\"icon\\\":\\\"03_02\\\"},{\\\"itemTypeID\\\":29069,\\\"itemCategoryID\\\":17,\\\"name\\\":\\\"Capital Magnetometric Sensor Cluster\\\",\\\"icon\\\":\\\"37_06\\\"},{\\\"itemTypeID\\\":29070,\\\"itemCategoryID\\\":9,\\\"name\\\":\\\"Capital Magnetometric Sensor Cluster Blueprint\\\",\\\"icon\\\":\\\"03_02\\\"},{\\\"itemTypeID\\\":29095,\\\"itemCategoryID\\\":17,\\\"name\\\":\\\"Capital Radar Sensor Cluster\\\",\\\"icon\\\":\\\"37_08\\\"},{\\\"itemTypeID\\\":29096,\\\"itemCategoryID\\\":9,\\\"name\\\":\\\"Capital Radar Sensor Cluster Blueprint\\\",\\\"icon\\\":\\\"03_02\\\"},{\\\"itemTypeID\\\":21013,\\\"itemCategoryID\\\":17,\\\"name\\\":\\\"Capital Sensor Cluster\\\",\\\"icon\\\":\\\"54_03\\\"},{\\\"itemTypeID\\\":21014,\\\"itemCategoryID\\\":9,\\\"name\\\":\\\"Capital Sensor Cluster Blueprint\\\",\\\"icon\\\":\\\"03_02\\\"},{\\\"itemTypeID\\\":32241,\\\"itemCategoryID\\\":17,\\\"name\\\":\\\"Drive Cluster EDF-285\\\",\\\"icon\\\":\\\"24_11\\\"},{\\\"itemTypeID\\\":5279,\\\"itemCategoryID\\\":7,\\\"name\\\":\\\"F-23 Reciprocal Sensor Cluster Link\\\",\\\"icon\\\":\\\"03_09\\\",\\\"metaLevel\\\":4},{\\\"itemTypeID\\\":11534,\\\"itemCategoryID\\\":17,\\\"name\\\":\\\"Gravimetric Sensor Cluster\\\",\\\"icon\\\":\\\"37_05\\\"},{\\\"itemTypeID\\\":17340,\\\"itemCategoryID\\\":9,\\\"name\\\":\\\"Gravimetric Sensor Cluster Blueprint\\\",\\\"icon\\\":\\\"03_02\\\"},{\\\"itemTypeID\\\":11536,\\\"itemCategoryID\\\":17,\\\"name\\\":\\\"Ladar Sensor Cluster\\\",\\\"icon\\\":\\\"37_07\\\"},{\\\"itemTypeID\\\":17333,\\\"itemCategoryID\\\":9,\\\"name\\\":\\\"Ladar Sensor Cluster Blueprint\\\",\\\"icon\\\":\\\"03_02\\\"},{\\\"itemTypeID\\\":11535,\\\"itemCategoryID\\\":17,\\\"name\\\":\\\"Magnetometric Sensor Cluster\\\",\\\"icon\\\":\\\"37_06\\\"},{\\\"itemTypeID\\\":17345,\\\"itemCategoryID\\\":9,\\\"name\\\":\\\"Magnetometric Sensor Cluster Blueprint\\\",\\\"icon\\\":\\\"03_02\\\"},{\\\"itemTypeID\\\":6218,\\\"itemCategoryID\\\":7,\\\"name\\\":\\\"Protected Gravimetric Backup Cluster I\\\",\\\"icon\\\":\\\"04_10\\\",\\\"metaLevel\\\":1},{\\\"itemTypeID\\\":6222,\\\"itemCategoryID\\\":7,\\\"name\\\":\\\"Protected LADAR Backup Cluster I\\\",\\\"icon\\\":\\\"04_10\\\",\\\"metaLevel\\\":1},{\\\"itemTypeID\\\":6226,\\\"itemCategoryID\\\":7,\\\"name\\\":\\\"Protected Magnetometric Backup Cluster I\\\",\\\"icon\\\":\\\"04_10\\\",\\\"metaLevel\\\":1},{\\\"itemTypeID\\\":6230,\\\"itemCategoryID\\\":7,\\\"name\\\":\\\"Protected Multi-Frequency Backup Cluster I\\\",\\\"icon\\\":\\\"04_10\\\",\\\"metaLevel\\\":1},{\\\"itemTypeID\\\":6234,\\\"itemCategoryID\\\":7,\\\"name\\\":\\\"Protected RADAR Backup Cluster I\\\",\\\"icon\\\":\\\"04_10\\\",\\\"metaLevel\\\":1},{\\\"itemTypeID\\\":7895,\\\"itemCategoryID\\\":7,\\\"name\\\":\\\"Prototype ECCM I Gravimetric Sensor Cluster\\\",\\\"icon\\\":\\\"04_10\\\",\\\"metaLevel\\\":4},{\\\"itemTypeID\\\":7893,\\\"itemCategoryID\\\":7,\\\"name\\\":\\\"Prototype ECCM I Ladar Sensor Cluster\\\",\\\"icon\\\":\\\"04_10\\\",\\\"metaLevel\\\":4},{\\\"itemTypeID\\\":7914,\\\"itemCategoryID\\\":7,\\\"name\\\":\\\"Prototype ECCM I Magnetometric Sensor Cluster\\\",\\\"icon\\\":\\\"04_10\\\",\\\"metaLevel\\\":4},{\\\"itemTypeID\\\":7896,\\\"itemCategoryID\\\":7,\\\"name\\\":\\\"Prototype ECCM I Omni Sensor Cluster\\\",\\\"icon\\\":\\\"04_10\\\",\\\"metaLevel\\\":4},{\\\"itemTypeID\\\":7892,\\\"itemCategoryID\\\":7,\\\"name\\\":\\\"Prototype ECCM I Radar Sensor Cluster\\\",\\\"icon\\\":\\\"04_10\\\",\\\"metaLevel\\\":4},{\\\"itemTypeID\\\":11537,\\\"itemCategoryID\\\":17,\\\"name\\\":\\\"Radar Sensor Cluster\\\",\\\"icon\\\":\\\"37_08\\\"},{\\\"itemTypeID\\\":17336,\\\"itemCategoryID\\\":9,\\\"name\\\":\\\"Radar Sensor Cluster Blueprint\\\",\\\"icon\\\":\\\"03_02\\\"},{\\\"itemTypeID\\\":6242,\\\"itemCategoryID\\\":7,\\\"name\\\":\\\"Sealed Gravimetric Backup Cluster\\\",\\\"icon\\\":\\\"04_10\\\",\\\"metaLevel\\\":0},{\\\"itemTypeID\\\":6241,\\\"itemCategoryID\\\":7,\\\"name\\\":\\\"Sealed LADAR Backup Cluster\\\",\\\"icon\\\":\\\"04_10\\\",\\\"metaLevel\\\":0},{\\\"itemTypeID\\\":6238,\\\"itemCategoryID\\\":7,\\\"name\\\":\\\"Sealed Magnetometric Backup Cluster\\\",\\\"icon\\\":\\\"04_10\\\",\\\"metaLevel\\\":0},{\\\"itemTypeID\\\":6239,\\\"itemCategoryID\\\":7,\\\"name\\\":\\\"Sealed Multi-Frequency Backup Cluster\\\",\\\"icon\\\":\\\"04_10\\\",\\\"metaLevel\\\":0},{\\\"itemTypeID\\\":6225,\\\"itemCategoryID\\\":7,\\\"name\\\":\\\"Sealed RADAR Backup Cluster\\\",\\\"icon\\\":\\\"04_10\\\",\\\"metaLevel\\\":0},{\\\"itemTypeID\\\":20238,\\\"itemCategoryID\\\":7,\\\"name\\\":\\\"Secure Gravimetric Backup Cluster I\\\",\\\"icon\\\":\\\"04_10\\\",\\\"metaLevel\\\":2},{\\\"itemTypeID\\\":20244,\\\"itemCategoryID\\\":7,\\\"name\\\":\\\"Secure Ladar Backup Cluster I\\\",\\\"icon\\\":\\\"04_10\\\",\\\"metaLevel\\\":2},{\\\"itemTypeID\\\":20250,\\\"itemCategoryID\\\":7,\\\"name\\\":\\\"Secure Magnetometric Backup Cluster I\\\",\\\"icon\\\":\\\"04_10\\\",\\\"metaLevel\\\":2},{\\\"itemTypeID\\\":20260,\\\"itemCategoryID\\\":7,\\\"name\\\":\\\"Secure Radar Backup Cluster I\\\",\\\"icon\\\":\\\"04_10\\\",\\\"metaLevel\\\":2},{\\\"itemTypeID\\\":20240,\\\"itemCategoryID\\\":7,\\\"name\\\":\\\"Shielded Gravimetric Backup Cluster I\\\",\\\"icon\\\":\\\"04_10\\\",\\\"metaLevel\\\":3},{\\\"itemTypeID\\\":20246,\\\"itemCategoryID\\\":7,\\\"name\\\":\\\"Shielded Ladar Backup Cluster I\\\",\\\"icon\\\":\\\"04_10\\\",\\\"metaLevel\\\":3},{\\\"itemTypeID\\\":20252,\\\"itemCategoryID\\\":7,\\\"name\\\":\\\"Shielded Magnetometric Backup Cluster I\\\",\\\"icon\\\":\\\"04_10\\\",\\\"metaLevel\\\":3},{\\\"itemTypeID\\\":20262,\\\"itemCategoryID\\\":7,\\\"name\\\":\\\"Shielded Radar Backup Cluster I\\\",\\\"icon\\\":\\\"04_10\\\",\\\"metaLevel\\\":3},{\\\"itemTypeID\\\":21722,\\\"itemCategoryID\\\":17,\\\"name\\\":\\\"Sleeper Nanite Cluster\\\",\\\"icon\\\":\\\"55_15\\\"},{\\\"itemTypeID\\\":20242,\\\"itemCategoryID\\\":7,\\\"name\\\":\\\"Warded Gravimetric Backup Cluster I\\\",\\\"icon\\\":\\\"04_10\\\",\\\"metaLevel\\\":4},{\\\"itemTypeID\\\":20248,\\\"itemCategoryID\\\":7,\\\"name\\\":\\\"Warded Ladar Backup Cluster I\\\",\\\"icon\\\":\\\"04_10\\\",\\\"metaLevel\\\":4},{\\\"itemTypeID\\\":20254,\\\"itemCategoryID\\\":7,\\\"name\\\":\\\"Warded Magnetometric Backup Cluster I\\\",\\\"icon\\\":\\\"04_10\\\",\\\"metaLevel\\\":4},{\\\"itemTypeID\\\":20264,\\\"itemCategoryID\\\":7,\\\"name\\\":\\\"Warded Radar Backup Cluster I\\\",\\\"icon\\\":\\\"04_10\\\",\\\"metaLevel\\\":4}]\"));\n        assertThat(connection.getHeaderField(\"Content-Type\"), equalTo(\"application/json; charset=utf-8\"));\n    }\n", "label": 0, "substitutes": {"doInBackground": [" doAsHttp", " doInMemory", "doAsBackground", " doAsMemory", " doIfBackground", "doAsAsync", "doInAsync", " doAsAsync", " doIfAsync", " doIfMemory", "doAsHttp", "doInMemory", " doIntHttp", "doInHttp", " doAsBackground", " doIntBackground", " doIntMemory", " doInAsync", " doIfHttp", " doInHttp", " doIntAsync", "doAsMemory"], "params": ["terms", "times", "amps", "xs", "tags", "services", "photos", "json", "settings", "ms", "options", "reports", "parts", "items", "js", "keys", "details", "types", "lines", "ls", "months", "names", "models", "stats", "pins", "ps", "shape", "words", "steps", "styles", "ams", "properties", "aws", "pps", "ids", "points", "images", "resources", "sql", "actions", "members", "ims", "fixes", "vs", "values", "posts", "p", "units", "data", "results"], "param": ["meter", "dem", "admin", "sm", "ctx", "par", "min", "pai", "sp", "resource", "m", "option", "set", "mem", "rank", "perm", "rem", "conf", "property", "amp", "cp", "ams", "minute", "dm", "cm", "pri", "initial", "input", "prom", "proc", "am", "Param", "aram", "parse", "cal", "project", "form", "conn", "space", "ram", "ad", "num", "member", "mm", "jp", "iam", "pm", "config", "arg", "pool", "vm", "Parameter", "sem", "sam", "p", "power"], "client": ["co", "response", "google", "con", "console", "cn", "city", "service", "resource", "Client", "grid", "context", "app", "connection", "c", "net", "secure", "cli", "call", "system", "cell", "close", "cp", "cache", "phone", "cm", "api", "ch", "cmd", "conn", "tc", "ip", "channel", "local", "http", "remote", "io", "wrapper", "server", "cl"], "post": ["process", "ost", "and", "tx", "put", "next", "request", "op", "pp", "pod", "create", "set", " POST", "col", "mod", "feed", "link", "rest", "build", "write", "req", "read", "def", "head", "get", "after", "upload", " Post", "dd", "parse", "form", "pre", "Post", "POST", "add", "zip", "follow", "row", "http", "wp", "save", "submit", "send", "install", "patch", "body", "ld", "p", "end", "pass"], "resp": ["exp", "respons", "response", "cmp", "dl", "res", "rep", "responsive", "sp", "comm", "cb", "obj", "wait", "https", "bs", "Response", "status", "col", "conv", "ess", "rest", "err", "soc", "bb", "rem", "re", "rel", "req", "serv", "pos", "esp", "out", "respond", "comp", "proc", "cmd", "conn", "Resp", "inv", "rex", "desc", "jp", "http", "html", "repl", "body", "rec", "cl"], "entity": ["event", "active", "response", "json", "output", "entry", "email", "ee", "resource", "obj", "details", "se", "enc", "cy", "ce", "me", "document", "xml", "content", "e", "detail", "eme", "owner", "le", "person", "ent", "note", "my", "object", "encrypted", "security", "group", "line", "el", "activity", "member", "info", "Entity", "ity", "orm", "body", "existent", "unit", "data", "pe"], "result": ["csv", "report", "response", "product", "output", "res", "match", "test", "feature", "comment", "request", "description", "summary", "sequence", "currency", "status", "table", "profile", "date", "message", "current", "join", "detail", "success", "total", "successful", "complete", "valid", "true", "answer", "continue", "group", "relation", "ret", "root", "results", "Result"]}}
{"id1": "10445819", "id2": "7927042", "code1": "    private Reader getReader() throws IOException {\n        if (data != null) {\n            if (url != null) throw new IllegalArgumentException(\"URL for source data and the data itself must never be specified together.\");\n            if (charset != null) throw new IllegalArgumentException(\"Charset has sense only for URL-based data\");\n            return new StringReader(data);\n        } else if (url != null) {\n            InputStream stream = url.openStream();\n            if (charset == null) return new InputStreamReader(stream); else return new InputStreamReader(stream, charset);\n        }\n        return null;\n    }\n", "code2": "    private void loadDynamically(File result, String extraPath) {\n        URL url = null;\n        InputStream is = null;\n        FileOutputStream fos = null;\n        try {\n            url = new URL(homeServerUrl + extraPath);\n            is = url.openStream();\n            fos = new FileOutputStream(result);\n            byte[] buff = new byte[8192];\n            int nbRead;\n            while ((nbRead = is.read(buff)) > 0) fos.write(buff, 0, nbRead);\n        } catch (IOException e) {\n            throw new StellariumException(\"Cannot dynamically load \" + result + \" from \" + url);\n        } finally {\n            if (is != null) {\n                try {\n                    is.close();\n                } catch (IOException e) {\n                    e.printStackTrace(System.out);\n                }\n            }\n            if (fos != null) {\n                try {\n                    fos.close();\n                } catch (IOException e) {\n                    e.printStackTrace(System.out);\n                }\n            }\n        }\n    }\n", "label": 0, "substitutes": {"getReader": ["getreader", "newRead", "getStream", "getRead", " getreader", " getStream", "newReader", "GetReader", "GetStream", "Getreader", "GetRead", " getRead", "newreader", "newStream"], "stream": ["window", "style", "sample", "console", "engine", "cont", "draw", "resource", "reader", "trans", "sequence", "clean", "Stream", "page", "pipe", "context", "feed", "inner", "port", "chain", "buffer", "sl", "secure", "open", "log", "message", "system", "stack", "list", "ream", "url", "out", "input", "proc", "metadata", "form", "st", "sw", "present", "instance", "filter", "iterator", "ssl", "channel", "row", "socket", "body", "user", "wrapper", "store", "data"]}}
{"id1": "17999474", "id2": "15409512", "code1": "    private static File getZipAsFile(DigitalObject digOb) {\n        String folderName = randomizeFileName(getFolderNameFromDigObject(digOb));\n        File tmpFolder = new File(utils_tmp, folderName);\n        File zip = null;\n        try {\n            FileUtils.forceMkdir(tmpFolder);\n            zip = new File(tmpFolder, getFileNameFromDigObject(digOb, null));\n            FileOutputStream out = new FileOutputStream(zip);\n            IOUtils.copyLarge(digOb.getContent().getInputStream(), out);\n            out.close();\n        } catch (FileNotFoundException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return zip;\n    }\n", "code2": "    public static void main(String args[]) throws IOException {\n        String inFileName = args[0];\n        String outFileName = args[1];\n        long position = 0L;\n        try {\n            position = Long.parseLong(args[2]);\n        } catch (NumberFormatException nfex1) {\n            try {\n                position = Long.parseLong(args[2], 16);\n            } catch (NumberFormatException nfex2) {\n                System.err.println(\"Wrong offset\");\n                System.exit(0);\n            }\n        }\n        if (position < 1L) {\n            System.err.println(\"Wrong offset. Must be more than 0\");\n            System.exit(0);\n        }\n        System.out.println(\"Copying  input: \" + inFileName);\n        System.out.println(\"        output: \" + outFileName);\n        System.out.println(\"          from: \" + position);\n        BufferedInputStream bis = new BufferedInputStream(new FileInputStream(inFileName));\n        BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(outFileName));\n        bis.skip(position);\n        for (byte[] b = new byte[1]; bis.read(b) > 0; bos.write(b)) ;\n        bis.close();\n        bos.close();\n    }\n", "label": 1, "substitutes": {"getZipAsFile": ["getZipInfile", "getZipAsLocal", "getZipToFile", "getBoxFromFile", "getBoxFromPath", "getZipInFile", "getZipTofile", "getZipFromPath", "getBoxFromLocal", "getBoxAsLocal", "getZipToLocal", "getZipFromfile", "getBoxAsfile", "getZipAsfile", "getBoxAsPath", "getZipAsPath", "getZipToPath", "getZipInLocal", "getZipInPath", "getZipFromLocal", "getBoxFromfile", "getBoxAsFile", "getZipFromFile"], "digOb": ["DigObj", "gradObj", " digEx", " digObject", "DigOcc", "digObj", "gradOb", "DigOB", "gradOB", "DigEx", " digOcc", "divObj", "chemOB", "chemOb", "digOB", "digObject", "chemEx", " digOB", "digEx", "digOcc", "chemObj", "DigObject", "divOcc", " digObj", "divOb", "gradObject", "DigOb", "divObject"], "folderName": ["foldKey", "folderKey", "foldNames", "folderSize", "foldPath", "FolderPath", "foldername", "foldName", "fileSize", "fileKey", " folderNames", "FolderNames", "foldname", "Foldername", "fileName", "fileNames", " foldername", "foldSize", " folderKey", "folderPath", "FolderName", "folderNames", " folderSize", " folderPath"], "tmpFolder": ["tempDir", "mpDirectory", "mpFolder", "mpParent", " tmpDirectory", "tempDirectory", "cmpDir", "tempfolder", "tmpParent", "tmpDir", " tmpfolder", "cmpParent", " tmpDir", "cmpFolder", "tmpfolder", "tempFolder", "mpDir", "tmpDirectory", "tempParent", "mpfolder", "cmpfolder"], "zip": ["proxy", "f", "exp", "report", "drop", "csv", "cloud", "zone", "gz", "json", "lock", "z", "entry", "sample", "test", "sp", "se", "ow", "tar", "wrap", "tmp", "col", "library", "feed", "box", "template", "link", "pkg", "bag", "jar", "post", "xml", "content", "archive", "Zip", "upload", "pack", "project", "mail", "form", "ip", "sheet", "row", "quote", "io", "sea", "temp", "install", "file", "folder", "pool", "body", "cf", "pdf"], "out": ["all", "co", "en", "flush", "us", "output", "res", "cos", "oss", "sp", "ins", "ln", "set", "tmp", "conv", "t", "in", "inner", "one", "net", "write", "to", "list", "up", "v", "i", "serv", "copy", "writer", "os", "ent", "it", "OU", "null", "ou", "s", "outs", "aos", "o", "inv", "auto", "n", "io", "Out", "check", "OUT", "print", "ex"]}}
{"id1": "8150996", "id2": "19134229", "code1": "    private static boolean copyFile(File in, File out) {\n        boolean ok = true;\n        InputStream is = null;\n        OutputStream os = null;\n        try {\n            is = new FileInputStream(in);\n            os = new FileOutputStream(out);\n            byte[] buffer = new byte[0xFFFF];\n            for (int len; (len = is.read(buffer)) != -1; ) os.write(buffer, 0, len);\n        } catch (IOException e) {\n            System.err.println(e);\n            ok = false;\n        } finally {\n            if (is != null) {\n                try {\n                    is.close();\n                } catch (IOException e) {\n                    System.err.println(e);\n                }\n            }\n            if (os != null) {\n                try {\n                    os.close();\n                } catch (IOException e) {\n                    System.err.println(e);\n                }\n            }\n        }\n        return ok;\n    }\n", "code2": "    private void copyFile(final String sourceFileName, final File path) throws IOException {\n        final File source = new File(sourceFileName);\n        final File destination = new File(path, source.getName());\n        FileChannel srcChannel = null;\n        FileChannel dstChannel = null;\n        try {\n            srcChannel = new FileInputStream(source).getChannel();\n            dstChannel = new FileOutputStream(destination).getChannel();\n            dstChannel.transferFrom(srcChannel, 0, srcChannel.size());\n        } finally {\n            try {\n                if (dstChannel != null) {\n                    dstChannel.close();\n                }\n            } catch (Exception exception) {\n            }\n            try {\n                if (srcChannel != null) {\n                    srcChannel.close();\n                }\n            } catch (Exception exception) {\n            }\n        }\n    }\n", "label": 1, "substitutes": {"copyFile": ["cpDir", "CopyChannel", "cpFile", "CopyStream", " copyStream", "cpChannel", " dupFile", "cpStream", " copyDir", " dupStream", " dupDir", "CopyDir", " copyChannel", "CopyFile", " dupChannel"], "in": ["rin", "en", "inn", "by", "gin", "con", "IN", "vin", "ins", "on", "doc", "In", "init", "old", "b", "ic", "v", "i", "inc", "l", "input", "or", "it", "ch", " input", "s", "ind", "r", "el", "n", "din", "inf", "isin", "source", "as", "file", "cin", "id", "from"], "out": ["nt", "output", "oss", "obj", "w", "set", "t", "ns", "po", "one", "net", "write", "b", "to", "v", "l", "it", "ch", "gt", "null", "ou", "at", "outs", "aos", "o", "s", "n", "io", "ne", "Out", "OUT", "p", "can", "ex", "ot"], "is": ["mis", "ans", "xs", "ics", "ois", "ms", "iris", "us", "ie", "mos", "ins", "Is", "im", "js", "nis", "ri", "fs", "sys", "bs", "ains", "isa", "ais", "icks", "init", "dis", "ns", "tis", "vis", "ires", "i", "its", "ris", "IS", "are", "eps", "iter", "it", "atis", "sis", "isal", "ys", "isc", "ims", "ir", "si", "lis", "isl", "s", "obs", "bis", "ind", "ip", "isi", "ios", "iso", "isin", "iss", "ils", "es", "cs", "abs"], "os": ["ows", "oes", "ss", "dos", "Os", "ost", "ms", "cos", "oss", "mos", "osi", "js", "oses", "ws", "fs", "sys", "bs", "ros", "ls", "ns", "tis", "los", "mes", "nos", "ts", "less", "mot", "ox", "ols", "pos", "bos", "eps", "ops", "acs", "ens", "ds", "des", "gs", "obs", "css", "s", "aos", "outs", "o", "oS", "vs", "OS", "io", "ios", "oos", "ks", "es", "cs", "ot"], "buffer": ["event", "phrase", "buf", "window", "block", "buff", "sample", "bridge", "frame", "comment", "word", "view", "sequence", "append", "table", "reason", "pad", "stroke", "mem", "base", "template", "command", "document", "message", "stack", "number", "cache", "variable", "Buffer", "initial", "iter", "tree", "length", "paste", "binary", "batch", "bar", "padding", "temp", "button", "source", "memory", "print", "display"], "len": ["seq", "all", "en", "nt", "wid", "gl", "hl", "z", " el", "els", "et", " length", "yn", "ln", " l", "ls", "ll", "t", "lf", "del", "err", "sl", "lan", "rel", "un", "e", "le", "coll", " clen", "l", "pos", "val", "li", "length", "ind", "lon", "num", "el", "full", " le", "n", "count", "L", "cap", "lim", "no", "Len", "ld", "fin", "size", "body", "elt", "tl", "end", "fl"], "ok": ["f", "rc", "good", "ook", "dec", "u", "ko", "ms", "par", "y", "quick", "bo", "oc", "clean", "yes", "kok", "status", "ocr", "ll", "app", "ack", "k", "md", "cs", "up", " okay", "req", " Ok", "sk", "state", " good", "coll", "ak", "valid", "it", "ch", "comp", "ck", "og", "ol", "boot", "full", "arc", "ready", "Ok", "msg", "oh", "iro", "ku", "check", "ik", "OK", "ot"]}}
{"id1": "10281203", "id2": "5707205", "code1": "    public void makeRead(String user, long databaseID, long time) throws SQLException {\n        String query = \"replace into fs.read_post (post, user, read_date) values (?, ?, ?)\";\n        ensureConnection();\n        PreparedStatement statement = m_connection.prepareStatement(query);\n        try {\n            statement.setLong(1, databaseID);\n            statement.setString(2, user);\n            statement.setTimestamp(3, new Timestamp(time));\n            int count = statement.executeUpdate();\n            if (0 == count) throw new SQLException(\"Nothing updated.\");\n            m_connection.commit();\n        } catch (SQLException e) {\n            m_connection.rollback();\n            throw e;\n        } finally {\n            statement.close();\n        }\n    }\n", "code2": "            public void run() {\n                Log.d(LOG_TAG, \"Fetching \" + url);\n                WebDbAdapter dbHelper = new WebDbAdapter(mContext);\n                dbHelper.open();\n                boolean errorOccurred = true;\n                int notifyId = 0;\n                String host = AppUtils.getHostFromUrl(url);\n                try {\n                    if (host == null) {\n                        Log.d(LOG_TAG, \"Bad url \" + url);\n                        errorOccurred = true;\n                    } else {\n                        notifyId = showNotification(\"Fetching \" + host, \"Fetching \" + host, android.R.drawable.stat_sys_download, 0);\n                        SharedPreferences sp = PreferenceManager.getDefaultSharedPreferences(mContext);\n                        String userAgent = sp.getString(mContext.getString(R.string.pref_key_user_agent), mContext.getString(R.string.default_user_agent));\n                        Log.d(LOG_TAG, \"Using user agent=\" + userAgent);\n                        AndroidHttpClient ahc = AndroidHttpClient.newInstance(mContext, url, userAgent);\n                        URI uri = new URI(url);\n                        URI norm = new URI(uri.getScheme().toLowerCase(), uri.getUserInfo(), uri.getHost().toLowerCase(), uri.getPort(), uri.getPath(), uri.getQuery(), null);\n                        norm = norm.normalize();\n                        HttpUriRequest get = new HttpGet(norm);\n                        HttpResponse response = ahc.execute(get);\n                        if (response.getStatusLine().getStatusCode() == 200) {\n                            HttpEntity entity = response.getEntity();\n                            ByteArrayOutputStream baos = new ByteArrayOutputStream();\n                            entity.writeTo(baos);\n                            String data = baos.toString();\n                            for (int i = 0; i < undesirables.length; i++) {\n                                Pattern p = Pattern.compile(undesirables[i], Pattern.CASE_INSENSITIVE | Pattern.DOTALL);\n                                data = data.replaceAll(p.pattern(), \"\");\n                            }\n                            long sysMillis = System.currentTimeMillis();\n                            String newFileName = getPath(sysMillis, sp.getBoolean(mContext.getString(R.string.pref_key_store_sdcard), false));\n                            FileOutputStream strm = new FileOutputStream(newFileName);\n                            Log.d(LOG_TAG, \"Writing to \" + newFileName + \" for url \" + url);\n                            String jsData = AppUtils.fromRawResourceFile(R.raw.retain_loadcolors, mContext);\n                            jsData = jsData.replaceAll(\"@css_file\", RETAIN_COLORS_CSS);\n                            strm.write(jsData.getBytes());\n                            strm.write(data.getBytes());\n                            strm.write(jsData.getBytes());\n                            strm.flush();\n                            strm.close();\n                            String entryName = getTitle(newFileName, url);\n                            long newRowId = dbHelper.createEntry(entryName, newFileName, url, sysMillis);\n                            postToast(\"Downloaded \\\"\" + entryName + \"\\\"\");\n                            errorOccurred = false;\n                            if (deleteRowId != 0) {\n                                Log.d(LOG_TAG, \"Deleting rowId=\" + deleteRowId);\n                                dbHelper.deleteEntry(deleteRowId);\n                                if (url == null) postToast(\"Item Deleted\");\n                                mContext.startActivity(new Intent(mContext, RetainActivity.class));\n                            } else {\n                                showNotification(\"Download Complete\", entryName, android.R.drawable.stat_sys_download_done, newRowId);\n                            }\n                        } else {\n                            Log.e(LOG_TAG, \"Response code=\" + String.valueOf(response.getStatusLine().getStatusCode()));\n                        }\n                    }\n                } catch (IOException ioe) {\n                    Log.e(LOG_TAG, \"RETAIN IOException: \" + ioe.getMessage());\n                } catch (URISyntaxException u) {\n                    Log.e(LOG_TAG, \"RETAIN URISyntaxException: \" + u.getMessage());\n                } catch (OutOfMemoryError oome) {\n                    Log.e(LOG_TAG, \"RETAIN OutOfMemoryError: \" + oome.getMessage());\n                } catch (Exception e) {\n                    Log.e(LOG_TAG, \"RETAIN Exception: \" + e.getMessage());\n                }\n                hideNotification(notifyId);\n                if (errorOccurred && host != null) {\n                    showNotification(\"Error Downloading\", host, android.R.drawable.stat_notify_error, 0);\n                    postToast(\"Error fetching \" + host);\n                }\n                dbHelper.close();\n            }\n", "label": 0, "substitutes": {"makeRead": [" makeReading", " doPrint", "makeread", "recordread", " doRead", "recordReading", "recordPrint", "makePrint", " makeread", " makePrint", "makeReading", " doread", " doReading", "recordRead"], "user": ["rule", "author", "creator", "by", "users", "word", "client", "table", "connection", "date", "command", "USER", "human", "message", "post", "owner", "url", "name", "host", "person", "auth", "project", "uid", "use", "database", "string", "usage", "field", "file", "password", "User", "id", "student", "username", "server"], "databaseID": ["databaseIDs", " databaseId", "connectionID", "directoryIDs", "directoryID", "databaseId", "connectionIDs", "directorySet", "databaseType", "directoryId", "directoryType", " databaseType", " databaseIDs", "connectionType", "connectionSet", "databaseSet", "connectionId", " databaseSet"], "time": ["type", "times", "ime", "window", "year", "value", "text", "runtime", "Time", "m", "sequence", "create", "TIME", "t", "tt", "port", "frequency", "date", " Time", "message", "timer", "second", "now", "etime", "age", "delay", "ty", "rate", "estamp", "clock", "tim", "info", "string", "start", "timeout", "version", "id", "tm", "end", "duration"], "query": ["transform", "text", "select", "entry", "task", "comment", "request", "description", "then", "view", "sequence", "create", "quest", "what", "script", "sq", "template", "q", "command", "menu", "code", "message", "call", "join", "Query", "condition", "ql", "ask", "sql", "cmd", "search", "term", "question", "qu", "string", "quote", "body", "check", "update", "qa", "title"], "statement": ["rule", "policy", "storage", "article", "connection", "call", "number", "minute", "state", "cm", "bind", "stat", "sql", "continue", "confirmed", "Statement", "database", "relation", "volume", "memory", "session", "phrase", "response", "that", "se", "fr", "processor", "template", "buffer", "function", "document", "list", "position", "cmd", "st", "binary", "language", "sn", "batch", "usage", "shell", "report", "entry", "sp", "comment", "execute", "application", "table", "library", "frequency", "ment", "ts", "journal", "le", "yahoo", "quote", "pretty", "expression", "word", "mt", "description", "sequence", "status", "init", "command", "ct", "condition", "copy", "commit", "ements", "communication", "print"], "count": ["all", "report", "handle", "nt", "find", "ctx", "OUNT", "contact", "parts", "sum", "status", "table", "code", "c", "message", "call", "current", "list", "number", "counter", "nb", "state", "now", "ount", "complete", "total", "cond", "length", "amount", "found", "Count", "batch", "ind", "num", "any", "n", "size", "loc", "index", "check"]}}
{"id1": "18793482", "id2": "16590954", "code1": "    public void modifyApplicationMessage(String locale, String messageName, String messageValue) {\n        Properties properties = new Properties();\n        try {\n            String i18nPath = ServerUtil.removelastResourceURL(ConfigurationServiceImpl.class.getResource(\"/es/ua/tranube/prototype/main/client/TranubeConstants_en.properties\").getPath()).toString();\n            File englishFile = new File(i18nPath + \"TranubeConstants_en.properties\");\n            if (!englishFile.exists()) throw new Exception(\"English file not found\");\n            String propertiesFilePath = i18nPath + \"TranubeConstants_\" + locale + \".properties\";\n            File file = new File(propertiesFilePath);\n            if (!file.exists()) {\n                FileReader in = new FileReader(englishFile);\n                FileWriter out = new FileWriter(file);\n                int c;\n                while ((c = in.read()) != -1) out.write(c);\n                in.close();\n                out.close();\n            }\n            InputStream is = ConfigurationServiceImpl.class.getResourceAsStream(\"/es/ua/tranube/prototype/main/client/TranubeConstants_\" + locale + \".properties\");\n            BufferedReader breader = new BufferedReader(new InputStreamReader(is));\n            String line = null;\n            StringBuilder strBuilder = new StringBuilder();\n            boolean found = false;\n            while ((line = breader.readLine()) != null) {\n                if (line.startsWith(\"#\")) strBuilder.append(line).append(\"\\n\"); else {\n                    String[] pieces = line.split(\"=\");\n                    if (pieces.length == 2) {\n                        if (pieces[0].trim().equals(messageName)) {\n                            strBuilder.append(pieces[0].trim() + \" = \" + messageValue + \"\\n\");\n                            found = true;\n                        } else strBuilder.append(line).append(\"\\n\");\n                    } else strBuilder.append(line).append(\"\\n\");\n                }\n            }\n            if (!found) strBuilder.append(messageName).append(\" = \").append(messageValue).append(\"\\n\");\n            breader.close();\n            is.close();\n            FileWriter writer = new FileWriter(file);\n            writer.write(strBuilder.toString());\n            writer.close();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n", "code2": "    public void createJAR(String fileString, String ext) {\n        try {\n            File file = new File(fileString);\n            int i = fileString.lastIndexOf(java.io.File.separator);\n            String dir = fileString.substring(0, i + 1);\n            if (ext.matches(\"jar\")) {\n                jarFile = new File(getClass().getClassLoader().getResource(\"jsdviewer.jar\").toURI());\n                java.io.FileOutputStream fstrm = new java.io.FileOutputStream(file);\n                FileChannel in = (new java.io.FileInputStream(jarFile)).getChannel();\n                FileChannel out = fstrm.getChannel();\n                in.transferTo(0, jarFile.length(), out);\n                in.close();\n                out.close();\n            } else {\n                file.mkdir();\n            }\n            File.umount(file);\n            File temp = new File(dir + \"document.jsd\");\n            FileOutputStream fstrm2 = new FileOutputStream(temp.getCanonicalPath());\n            ostrm = new ObjectOutputStream(fstrm2);\n            ostrm.writeObject(doc);\n            ostrm.flush();\n            ostrm.close();\n            File.umount();\n            File docFile = new File(file.getCanonicalPath() + java.io.File.separator + \"document.jsd\");\n            File.cp_p(temp, docFile);\n            File.umount();\n            temp.delete();\n            File.umount(file);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n", "label": 1, "substitutes": {"modifyApplicationMessage": ["modifyapplicationData", "modureAppData", "modifyapplicationMessage", "modifyAppmessage", "modureApplicationmessage", "modifyApplicationMsg", "modifyapplicationMsg", "modifyApplicationmessage", "modifyServerMessage", "modureAppMessage", "modifyServerMsg", "modureAppMsg", "modureApplicationData", "modureApplicationMsg", "modifyAppMsg", "modureAppmessage", "modifyServermessage", "modifyAppMessage", "modifyAppData", "modureApplicationMessage", "modifyApplicationData", "modifyServerData", "modifyapplicationmessage"], "locale": ["localaley", "locales", "LocALE", "locational", " locALE", "Locale", "Localey", "localales", "Locales", "localALE", "regational", " localey", " locales", "locALE", "regales", "localational", "localey", "regale", "Locational", "localale", " locational", "regALE"], "messageName": ["mediaKey", "MessageName", " messageNAME", "mediaNames", "MessageType", "msgValue", "msgType", "msgKey", "messageKey", "messageNames", "mediaNAME", "MessageKey", " messageNames", "mediaName", "MessageNAME", "MessageValue", "MessageNames", "messageNAME", "msgName", " messageType", " messageKey", "messageType"], "messageValue": ["msgvalue", " messageVal", "essageVal", "MessageVALUE", "messageVal", "MessageName", "essageName", "MessageType", "msgValue", "msgVALUE", "languagevalue", "languageName", "messageVALUE", "messagevalue", "Messagevalue", "languageVALUE", "MessageValue", "languageValue", "msgName", " messageType", "MessageVal", "essageValue", "essageType", "messageType"], "properties": ["report", "json", "prop", "settings", "options", "pid", "policy", "params", "parts", "utils", "details", "types", "profile", "ps", "message", "perties", "pro", "property", " props", "metadata", "project", " Properties", "config", "files", "pdf", "data", "results"], "i18nPath": ["i8lDir", "i8lUrl", "i18nyPath", "i18anDriver", "i18nUrl", "i8lStr", "i8nStr", "i18bStr", "i18lDir", "i18neUrl", "i18rDir", "i8lPath", "i18nDriver", "i18nePoints", "i18natP", "i18bUrl", "i18lUrl", "i18nyDir", "i18nePath", "i18anPath", "i18bPath", "i18nStr", "i18rIf", "i8nDir", "i18nIf", "i18natPoints", "i18bDir", "i18nP", "i18lStr", "i18neDriver", "i18neStr", "i18rDriver", "i18nyDriver", "i18anP", "i18natDriver", "i18neP", "i18anIf", "i18nPoints", "i18nDir", "i8nUrl", "i18lPath", "i18neDir", "i18nyIf", "i8nPath", "i18natPath", "i18rPath", "i18anPoints", "i18anDir"], "englishFile": ["enfile", "englishFilename", "ianafile", "languageFile", "ianaDir", " englishTable", "englishfile", "electricDir", "wikiTable", "ianaPort", "englishFiles", "ianaFile", "EnglishFiles", "ianaPath", "englishDir", "englishTable", "ianaTable", "electricDirectory", "languageFilename", "Englishfile", " englishfile", "EnglishFilename", "enFile", "electricFile", "enFilename", "electricPort", " englishPort", "languagefile", " englishDir", " englishDirectory", "wikifile", "wikiFile", "EnglishFile", "enFiles", "englishDirectory", "englishPath", " englishPath", "languageFiles", "englishPort", "wikiPath", "ianaDirectory"], "propertiesFilePath": ["pertiesfilepath", "pertiesfileName", "propertiesFileName", "propertiesFileType", "pertiesfileType", "propertiesFilesName", "settingsFileName", "propertiesfileLocation", "settingsFilepath", "propertiesFilepath", "settingsFileLocation", "pertiesFilepath", "propertiesfilepath", "propertiesFilenamepath", "propertiesfilePath", "propertiesFilenameType", "propertiesFilenameName", "propertiesfileType", "settingsFilePath", "settingsFilenamepath", "settingsFilenamePath", "pertiesFileType", "propertiesfileName", "propertiesFilesPath", "settingsFilenameName", "propertiesFilenameLocation", "propertiesFilenamePath", "propertiesFilespath", "pertiesFilePath", "propertiesFilesType", "pertiesfilePath", "propertiesFilesLocation", "settingsFilenameLocation", "pertiesFileName", "propertiesFileLocation"], "file": ["type", "f", "rule", "report", "handle", "style", "fi", "image", "output", "entry", "File", "console", "FILE", "comment", "resource", "application", "fp", "create", "page", "table", "run", "library", "module", "connection", "port", "base", "be", "attribute", "buffer", "write", "document", "message", "current", "result", "xml", "filename", "content", "format", "ile", "name", "complete", "os", "parent", "object", "path", "null", "language", "record", "model", "use", "channel", "domain", "local", "key", "info", "string", "files", "io", "class", "source", "pool", "print", "data"], "in": ["rin", "en", "inn", "ini", "gin", "IN", "ins", "ar", "ri", "reader", "oin", "al", "In", "init", "inner", "inside", "ic", "ai", "asin", "i", "read", "bin", "get", "inc", "input", "sin", "iter", "it", " din", "ir", "ain", "ind", "io", "din", "inf", "isin", "cin", "from"], "out": ["csv", "co", "nt", "con", "output", "cos", "put", "w", "set", "conv", "inner", "net", "write", "we", "log", "to", "print", "conf", "cache", "os", "external", "outer", "it", "sw", "ou", "at", "aos", "outs", "o", "again", "screen", "n", "io", "Out", "OUT", "check", "can", "end", "ex"], "c": ["rc", "co", "u", "con", "cos", "character", "\u00e7", "cb", "d", "cont", "cr", "C", "bc", "col", "t", "x", "ce", "cc", "code", "k", "ca", "char", "chain", "fc", "cu", "call", "v", "conf", "i", "ct", "cache", "ac", "gc", "pc", "cp", "cm", "l", "ec", "cod", "ch", "lc", "cd", "etc", "unc", "r", "nc", "count", "n", "mc", "arc", "cap", "cf", "dc", "cs", "cl"], "is": ["iris", "sit", "ins", "Is", "ri", "nis", "sys", "isa", "ais", "tis", "ic", "i", "its", "ris", "os", "IS", "it", "isc", "isl", "lis", "bis", "isf", "isi", "isin", "iso", "ios", "as", "iss", "\u00eds", "es", "sis"], "breader": ["brewe", " breadr", "bler", " breadder", "bbr", "breadr", " breadger", "bbar", " breade", " breadar", "breadder", "breadar", "browber", "bleder", "breade", "bleer", "browe", "brewer", "bbder", "brewger", "brewber", "breadber", "breadger", "bber", "browger", "brower", " breadber", "blear"], "line": ["phrase", "LINE", "lo", "rule", "handle", "block", "lin", "text", "eline", "entry", "ine", "sample", "email", "next", "column", "part", "comment", "frame", "lane", "se", "word", "ln", "left", "sequence", "lines", "page", "stroke", "port", "trace", "char", "chain", "range", "link", "log", "label", "code", "slice", "message", "cell", "ice", "detail", "node", "stay", "le", "liner", "entity", "l", "section", "iter", "query", "note", "nl", "parse", "point", "mail", "normal", "continue", "queue", "cmd", "record", "edge", "Line", "ip", "row", "string", "no", "inline", "online", "body", "shell", "side", "header"], "strBuilder": ["stringBuild", "strBuild", "stringParser", "objBuffer", "arrBuffer", "StrBuffer", "strBuilt", " strBu", "stringBuilder", " strbuilder", "arrbuilder", "Strbuilder", "frBuild", "strBu", "arrBu", " strParser", " strBuild", "objbuilder", "arrBuilder", "StrBuild", "objBuilder", "StrBuilder", "StrBu", "frBuilder", "strbuilder", "stringBuilt", " strBuffer", "strBuffer", "stringBuffer", "StrBuilt", "frBuilt", "strParser", "frParser", "StrParser", "arrBuild", "objBuild", "stringbuilder", "arrParser"], "pieces": ["terms", "maps", "services", "times", "cars", "links", "cuts", "strings", "feet", "parts", "piece", "items", "keys", "tools", "plates", "tips", "types", "lines", "letters", "finals", "bits", "pins", "fits", "places", "ps", "steps", "words", "its", "powers", "players", "knife", "Parts", "caps", "blocks", "eps", "ops", "ces", "xes", "fixes", "ctors", "groups", "sts", "sections", "pointers", "rings", "units", "bytes", "ties", "checks"], "found": ["first", "defined", "installed", "expected", "empty", "good", "focused", "Found", "opened", "find", "built", " Found", "finder", "changed", "finished", "done", "err", "old", "forced", "used", "available", "mounted", "supported", "read", "started", "released", "fixed", "printed", "successful", "success", "valid", "tested", "loaded", "search", "bool", "confirmed", " detected", "created", " founded", " caught", "sold", "ed", "sent", "count", "failed", "compl", "index", "needed", "identified", "filled", "given"]}}
{"id1": "19206412", "id2": "7372311", "code1": "    public static String md5String(String str) {\n        try {\n            MessageDigest md;\n            md = MessageDigest.getInstance(\"MD5\");\n            md.update(str.getBytes());\n            byte[] hash = md.digest();\n            final char[] hexChars = { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f' };\n            StringBuffer res = new StringBuffer();\n            for (int i = 0; i < hash.length; i++) {\n                res.append(hexChars[(0xF0 & hash[i]) >> 4]);\n                res.append(hexChars[0x0F & hash[i]]);\n            }\n            return res.toString();\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n            return null;\n        }\n    }\n", "code2": "    private void generateDeviceUUID() {\n        try {\n            MessageDigest md5 = MessageDigest.getInstance(\"MD5\");\n            md5.update(deviceType.getBytes());\n            md5.update(internalId.getBytes());\n            md5.update(bindAddress.getHostName().getBytes());\n            StringBuffer hexString = new StringBuffer();\n            byte[] digest = md5.digest();\n            for (int i = 0; i < digest.length; i++) {\n                hexString.append(Integer.toHexString(0xFF & digest[i]));\n            }\n            uuid = hexString.toString().toUpperCase();\n        } catch (Exception ex) {\n            RuntimeException runTimeEx = new RuntimeException(\"Unexpected error during MD5 hash creation, check your JRE\");\n            runTimeEx.initCause(ex);\n            throw runTimeEx;\n        }\n    }\n", "label": 1, "substitutes": {"md5String": ["md4String", "md4Str", "md5Str", "md2string", "md7String", "MD4Str", "md5Bytes", "md7Str", "MD5Str", "md4Bytes", "md4string", "MD4String", "MD4string", "md2String", "MD5String", "md2Str", "md5string", "md7string", "MD5string", "md7Bytes", "MD5Bytes", "md2Bytes", "MD4Bytes"], "str": ["wr", "txt", "oct", "tr", "br", "text", "vol", "piece", "sp", "cr", "enc", "obj", "t", "wcs", "char", "spec", "c", "cs", "b", "ctr", "cur", "Str", "v", "e", "name", "input", "out", "ch", "this", "st", "s", "r", "n", "string", "STR", "msg", "arr", "p", "print", "data", "w"], "md": [" Md", "nt", " sch", "sm", "bf", "ms", "pd", "vol", "od", " mac", " ms", "d", "di", "der", "mt", " cmd", "m", "mod", "sha", "me", "mg", "red", "del", "mp", "man", "dr", "det", "dm", "sd", " de", "def", " cd", "nd", "cond", "dd", "cmd", " img", "mand", "metadata", " dd", " def", "mail", "dir", "cd", "hd", "MD", "dig", "ind", "ad", "grad", " man", "mc", "mm", " df", "mn", "add", "html", "mk", "de", "exec", "ld", "mac", "bd", "df", "dh"], "hash": ["ashes", "ah", "all", "handle", "style", "stock", "ash", "her", "Hash", "match", "sample", "test", "h", "score", "sum", "esh", "here", "sha", "flash", "char", "dash", "hz", "log", "used", "result", "stack", "array", "cache", "node", "sh", "hed", "has", "total", "hex", "ch", "history", "search", "show", "height", "dig", "filter", "key", "oh", "html", "rh", "where", "mac", "check", "id", "map", "print", "host"], "hexChars": ["hexCHroups", "hexchaps", "exChaps", "hexChroups", " hexChables", "exChrs", "hexCHords", " hexChords", "hexChrs", "hexThrs", "hexchables", "hexchars", "hexchrs", "hexChords", " hexChroups", "exchaps", "hexChaps", "hexCars", "hexChables", "hexCaps", "hexCords", "hexCroups", "hexThaps", "hexThars", " hexChaps", "hexCrs", "hexThables", "exchrs", "hexCHars", "hexCHaps", " hexChrs", "exChars", "exchars"], "res": ["ser", "rc", "response", "fresh", "usr", "us", "vol", "reset", "ress", "rep", "next", "ins", "pas", "cr", "js", "fr", "sys", "bs", "cons", "red", "rest", "resh", "ber", "resp", "ps", "ts", "Res", "rem", "re", "result", "rel", "req", "rs", "RES", "sol", "rx", "expr", "pres", "pers", "r", "rex", "full", "ret", "gr", "rez", "rus", "pr", "results", "cs"], "i": ["series", "mi", "major", "span", "json", "u", "j", "ini", "us", "y", "z", "I", "qi", "di", "im", "gravity", "ei", "ri", "m", "iq", "ki", "t", "x", "in", "ti", "hi", "me", "k", "q", "bi", "c", "cli", "ic", "slice", "ci", "multi", "ai", "sim", "gi", "ui", "e", "v", "uri", "pi", "it", "ji", "li", "xi", "\u0438", "my", "si", "point", "ind", "o", "zi", "info", "n", "io", "ii", "is", "index", "id", "a", "ix", "ex"]}}
{"id1": "11341711", "id2": "14785308", "code1": "    public static void makeBackup(File dir, String sourcedir, String destinationdir, String destinationDirEnding) {\n        String[] files;\n        files = dir.list();\n        File checkdir = new File(destinationdir + System.getProperty(\"file.separator\") + destinationDirEnding);\n        if (!checkdir.isDirectory()) {\n            checkdir.mkdir();\n        }\n        ;\n        Date date = new Date();\n        long msec = date.getTime();\n        checkdir.setLastModified(msec);\n        File checkFile = new File(checkdir + System.getProperty(\"file.separator\") + \"azureus.config\");\n        if (checkFile.exists()) {\n            checkFile.setLastModified(msec);\n        }\n        try {\n            for (int i = 0; i < files.length; i++) {\n                File f = new File(dir, files[i]);\n                File g = new File(files[i]);\n                if (f.isDirectory()) {\n                } else {\n                    String destinationFile = checkdir + System.getProperty(\"file.separator\") + g;\n                    String sourceFile = sourcedir + System.getProperty(\"file.separator\") + g;\n                    FileInputStream infile = new FileInputStream(sourceFile);\n                    FileOutputStream outfile = new FileOutputStream(destinationFile);\n                    int c;\n                    while ((c = infile.read()) != -1) outfile.write(c);\n                    infile.close();\n                    outfile.close();\n                }\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n", "code2": "    public static String sha1(String text) throws NoSuchAlgorithmException, UnsupportedEncodingException {\n        MessageDigest md;\n        md = MessageDigest.getInstance(\"SHA-1\");\n        byte[] sha1hash = new byte[40];\n        md.update(text.getBytes(\"iso-8859-1\"), 0, text.length());\n        sha1hash = md.digest();\n        return convertToHex(sha1hash);\n    }\n", "label": 0, "substitutes": {"makeBackup": ["createbackup", "makeDupid", "makeDup", "makeDups", "makebackupid", "makeStupid", "createbackups", "createbackupid", "makeStup", "createbackpoint", "makeStpoint", "createBackups", "makeBackups", "makebackup", "makeStups", "createBackpoint", "makeBackpoint", "createBackup", "createBackupid", "makeBackupid", "makebackups", "makeDpoint", "makebackpoint"], "dir": ["window", "handle", "dl", "y", "vol", "d", "draw", "disk", "doc", "Directory", "tmp", "in", "base", "directory", "dis", "store", "md", "del", "pkg", "addr", "fd", "dr", "db", "wd", "src", "dm", "url", "out", "or", "iter", "dd", "Dir", "ir", "path", "rad", "mail", "dat", "ind", "DIR", "zip", "local", " d", "dist", "file", "folder", "loc", "dep", "direct", "data"], "sourcedir": [" sourcesirs", "isourcedel", "isourcedr", "isourceir", "senderel", "soredir", "senderdir", " sourcedirs", "isourcedir", "isourceddir", " sourcesdir", "sourceire", "isourceel", " sourcedire", " sourcesir", "soreddir", "sourcedirs", "sourcesdir", "sourcesirs", "sourcedire", " sourceddir", "senderir", "sourcedr", "sourcedel", "sourcesel", "sourceirs", "sourcesir", " sourcesire", "sourceir", "sourceddir", "sourcesire", "sourcer", "soredire", "senderr", "isourcer", "sourceel", "sourcesr", "soredirs"], "destinationdir": ["stinationsir", "destensiondir", "stinationsdiv", "stinationdir", "estinationfolder", "destinatordir", "destinationfolder", "estinatordb", "estinationdir", "estinatorfolder", "destineddb", "stinationsdb", "destensionDir", "destinedir", "destinationsdb", "stinationsdir", "destinationdb", "stinationdb", "stinationdiv", "destinatordb", "destinatordiv", "destinationdiv", "destensionfolder", "destiondb", "destinatorir", "destinationir", "destinationsir", "destineddir", "destionfolder", "destensiondb", "destinationsdiv", "destionDir", "estinationDir", "estinatorDir", "destinatorfolder", "destineddiv", "destinationsdir", "destinationDir", "destinatorDir", "estinatordir", "destiondir", "estinationdb", "stinationir"], "destinationDirEnding": ["destinationDirENDing", "destinationDirectoryENDer", "destinationFileEvener", "destinationDirectoryEnding", "destinationDirENDer", "destinationDirENDiting", "destinationDirENDging", "destinationDirEnditing", "destinationDirServing", "destinationDirEnder", "destinationDirEvening", "destinationDirectoryEndging", "destinationDirServding", "destinationDirEveniting", "destinationDirENDding", "destinationDirServging", "destinationDirFeedING", "destinationDirEndING", "destinationFileEndING", "destinationFileEnditing", "destinationDirENDING", "destinationDirFeeder", "destinationDirEndding", "destinationFileEnder", "destinationFileEvenING", "destinationDirEvenING", "destinationFileEveniting", "destinationDirectoryEndding", "destinationFileEnding", "destinationDirectoryEnder", "destinationDirEvener", "destinationDirectoryENDding", "destinationFileEvening", "destinationDirFeediting", "destinationDirEvenging", "destinationDirectoryENDing", "destinationDirServer", "destinationDirectoryENDging", "destinationDirEndging", "destinationDirFeeding", "destinationDirEvending"], "files": ["parents", "forms", "prints", "reports", "links", "assets", "strings", "params", "parts", "users", "items", "facts", "plates", "keys", "tools", "details", "fs", "modules", "lines", "tests", "docs", "ls", "errors", "types", "bs", "names", "qs", "classes", "iles", "uploads", "issues", "list", "words", "filename", "ames", "its", "images", "ids", "fields", "resources", "actions", "members", "projects", "events", "obs", "fixes", "objects", "headers", "ports", "mails", "states", "Files", "pages", "sections", "features", "values", "file", "lets", "bytes", "faces"], "checkdir": ["keyroom", "Checkdb", "getdir", "workdir", "getfolder", "keydir", "Checkfolder", "checkDir", "workurl", "getdb", "ckDir", "checkblock", " checkfolder", "ckdb", " checkdb", " checkurl", "workthis", "checkedfolder", " checkDir", "CheckDir", "keydb", " checkblock", "checkeddb", " checkir", "checkroom", "checkedDir", "checkfolder", "workDir", "ckfolder", "checkthis", " checkdirectory", "Checkblock", "ckroom", "checkdirectory", "ckthis", "keyfolder", "checkeddirectory", "ckurl", "getblock", "ckdir", "ckdirectory", "checkurl", "Checkroom", " checkthis", "Checkir", "Checkdirectory", "checkedir", "checkdb", "checkir", "checkeddir", "Checkdir"], "date": ["event", "year", "today", "zone", "time", "d", "resource", "doc", "set", "tag", "day", "ate", "close", "none", "when", "now", "get", "Date", "dt", "note", "cal", "month", "dat", " day", "add", "late", "use", "te", "key", "msg", "de", " Date", "ATE", "start", "iso", "diff", "file", "user", "data"], "msec": ["mcl", "gmstr", " msc", "MSec", "gmsc", "mSec", "mtcl", "cmcl", "mtstr", "cmisec", "mtsec", "mtisec", " mct", "msc", " mcl", "mstr", " mSec", "cmsc", "mct", "gmSec", "mtsc", "Msec", "Mct", "misec", "cmsec", "mtct", " mstr", "mtSec", " misec", "gmsec"], "checkFile": ["CheckFiles", " checkfile", "Checkfile", " checkFILE", "readFiles", "readFILE", "checkfile", "readSourceFile", "CheckFILE", " checkSourceFile", "readFile", "checkFiles", "updateFiles", "updateFile", "readfile", "updateSourceFile", "checkSourceFile", "updateFILE", " checkFiles", "CheckFile", "checkFILE"], "i": ["exp", "mi", "major", "ini", "j", "y", "I", "ie", "qi", "di", "im", "ri", "ei", "m", "iq", "sequence", "ki", "init", "in", "base", "hi", "me", "iu", "ti", "x", "bi", "cli", "ic", "ci", "multi", "ai", "sim", "gi", "ui", "name", "pi", "ij", "ix", "it", "ji", "xi", "li", "my", "si", "batch", "ind", "ip", "info", "key", "id", "io", "ii", "is", "gu", "index", "zi", "phi", "ex"], "f": ["fi", "fe", "u", "bf", "j", "d", "m", "fs", "fr", "fp", "fac", "t", "lf", "b", "fc", "fd", "v", "e", "fg", "tf", "fw", "uf", "l", "fo", "o", "fa", "F", "cf", "file", "ft", "fb", "p", "df", "fl"], "g": ["gl", "tg", "G", "j", "gp", "bg", "d", "m", "gd", "t", "mg", "gg", "graph", "go", "pg", "b", "gi", "ga", "v", "vg", "gy", "gc", "fg", "e", "l", "out", "gm", "ig", "gs", "s", "group", "og", "eg", "ge", "cfg", "config", "msg", "file", "gb", "p", "gu", "w"], "destinationFile": ["destationFiles", "destinationsFiles", "DestationFile", "transinationDirectory", "DestationFilename", "transinatedFile", "transinationFilename", "destarationDirectory", "destarationFilename", "DestationFiles", "destinateEmail", "destationFilename", "destarationFile", "destinatedFiles", "destinatedFile", "destinatedFilename", "transinationFiles", "destinatorDirectory", "destinateFiles", "DestinationFiles", "transinatedFiles", "transinationFile", "DestinationFilename", "destinationsFile", "destarationFiles", "destinatorFile", "transinatedDirectory", "destationFile", "destinatorFiles", "destinatorFilename", "destinationsFilename", "transinatedFilename", "DestinationEmail", "destationEmail", "DestationEmail", "destinationDirectory", "destinatedDirectory", "destinateFile", "destinationFiles", "destinateFilename", "destinationEmail", "destinationFilename", "DestinationFile", "destinationsEmail"], "sourceFile": ["sourcefile", " sourcefile", "SourceFilename", "ourceFile", "srcFilename", "sourceLine", "sourceFilename", "SourceFile", " sourceFiles", "srcLine", "SourceLine", "ourcefile", "staticFiles", "staticFILE", "sourceFiles", "srcFile", "Sourcefile", "srcfile", "SourceFILE", "staticFile", "staticfile", "SourceFiles", " sourceFILE", "ourceFilename", "sourceFILE", "ourceLine"], "infile": ["instream", "inputFile", "Instream", "outline", " instream", " inFile", "insblock", "pinfield", "outFile", "INfield", "pinline", "Inblock", " inline", "InFile", "INline", "insfile", "outblock", "INfile", "inputline", "inFile", " inblock", "insstream", "insFile", "infield", "inputfile", "inblock", "INFile", " infield", "pinfile", "pinFile", "inline", "inputblock", "Infile"], "outfile": [" outstream", " outbuffer", "outpage", "instream", "inpage", "outline", "outputline", "inview", "outputfile", "outFile", "outstream", " outlink", "outerstream", "Outstream", "outerview", "outlink", "Outfile", "OutFile", "outerbuffer", "outerfile", "inFile", " outview", "outputstream", " outFile", "outview", "inbuffer", " outline", "inline", "outbuffer", "inlink", "outputpage", "Outlink", " outpage"], "c": ["rc", "u", "p", "z", "y", "cos", "\u00e7", "cb", "d", "cr", "m", "C", "bc", "col", "t", "x", "ce", "char", "code", "k", "ca", "err", "cs", "chain", "cu", "close", "v", "conf", "e", "ct", "cache", "ac", "cp", "pc", "gc", "cm", "out", "ec", "ch", "sc", "lc", "cd", "o", "r", "unc", "mc", "count", "n", "arc", "uc", "nc", "cf", "dc", "a", "cc", "cl"]}}
{"id1": "6009527", "id2": "12783713", "code1": "    private void doFinishLoadAttachment(long attachmentId) {\n        if (attachmentId != mLoadAttachmentId) {\n            return;\n        }\n        Attachment attachment = Attachment.restoreAttachmentWithId(MessageView.this, attachmentId);\n        Uri attachmentUri = AttachmentProvider.getAttachmentUri(mAccountId, attachment.mId);\n        Uri contentUri = AttachmentProvider.resolveAttachmentIdToContentUri(getContentResolver(), attachmentUri);\n        if (mLoadAttachmentSave) {\n            try {\n                File file = createUniqueFile(Environment.getExternalStorageDirectory(), attachment.mFileName);\n                InputStream in = getContentResolver().openInputStream(contentUri);\n                OutputStream out = new FileOutputStream(file);\n                IOUtils.copy(in, out);\n                out.flush();\n                out.close();\n                in.close();\n                Toast.makeText(MessageView.this, String.format(getString(R.string.message_view_status_attachment_saved), file.getName()), Toast.LENGTH_LONG).show();\n                new MediaScannerNotifier(this, file, mHandler);\n            } catch (IOException ioe) {\n                Toast.makeText(MessageView.this, getString(R.string.message_view_status_attachment_not_saved), Toast.LENGTH_LONG).show();\n            }\n        } else {\n            try {\n                Intent intent = new Intent(Intent.ACTION_VIEW);\n                intent.setData(contentUri);\n                intent.addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION);\n                startActivity(intent);\n            } catch (ActivityNotFoundException e) {\n                mHandler.attachmentViewError();\n            }\n        }\n    }\n", "code2": "    @Override\n    public void sendErrorMessage(String message) throws EntriesException, StatementNotExecutedException, NotConnectedException, MessagingException {\n        if (query == null) {\n            throw new NotConnectedException();\n        }\n        ArrayList<String> recipients = query.getUserManager().getTecMail();\n        Mail mail = new Mail(recipients);\n        try {\n            ZipOutputStream zos = new ZipOutputStream(new FileOutputStream(\"log/ossobooklog.zip\"));\n            FileInputStream fis = new FileInputStream(\"log/ossobook.log\");\n            ZipEntry entry = new ZipEntry(\"ossobook.log\");\n            zos.putNextEntry(entry);\n            byte[] buffer = new byte[8192];\n            int read = 0;\n            while ((read = fis.read(buffer, 0, 1024)) != -1) {\n                zos.write(buffer, 0, read);\n            }\n            zos.closeEntry();\n            fis.close();\n            zos.close();\n            mail.sendErrorMessage(message, new File(\"log/ossobooklog.zip\"), getUserName());\n        } catch (Exception ex) {\n            ex.printStackTrace();\n        }\n    }\n", "label": 1, "substitutes": {"doFinishLoadAttachment": ["doFinishLoadAttachachment", "doFinishLoadAttachention", "doFinishLoadDetachment", "doFinishShowAttention", "doFinishShowDetachment", "doFinishLoadAttention", "doFinishLoadAttachached", "doFinishLoadAssached", "doFinishLoadDetention", "doFinishLoadAssachment", "doFinishLoadAssention", "doFinishLoadDetached", "doFinishShowDetention", "doFinishShowAttachment", "doFinishShowAttached", "doFinishLoadAttached", "doFinishShowDetached"], "attachmentId": ["attachmentById", "atachmentId", "detachmentid", "attentionName", "attentionById", "detachedKey", "attutationId", "attociationName", "attachmentid", "atachmentById", "attutationName", "ATTachmentById", "ATTachmentId", "attagramid", "ATTachmentid", "ATTociationKey", "attachmentKey", "attociationId", "attagramId", "detachedid", "attachmentID", "atutationId", "ATTociationById", "attentionID", "attachedById", "detachmentId", "atachmentName", "attgmentid", "atutationById", "attentionId", "atutationID", "attachedKey", "attociationById", "attutationID", "detachedId", "ATTociationId", "ATTociationid", "attgmentKey", "attachmentName", "attociationID", "attachedId", "attagramKey", "ATTachmentKey", "attociationKey", "detachmentKey", "atutationName", "attutationById", "attgmentId", "attagramById", "attachedid", "attociationid", "atachmentID"], "attachment": [" attment", "attaching", "addached", "attachaching", "detachment", "attention", "assachment", "attment", "detached", "attachached", "ATTached", "contachment", "attachachment", "assached", "attachociation", "ATTachment", "attachacher", "detacher", "contacher", "contment", "attociation", "ATTention", "addachment", "addaching", "assacher", "association", "ATTacher", " attacher", "assaching", "addociation", "attacher", " attached", "attachention", "detment", "assention", "attached", "contached"], "attachmentUri": ["attachmentUpi", "attachmentUtRI", "attentionUtri", "attachmentTpi", "attachableOri", "attachmentTuri", "attachableUri", "attachmentURI", "attentionUpi", "attachmentUnURI", "attentionUri", "attachmenturi", "attachableOpi", "attachmentTURI", "attachmenturid", "attachmentOURI", "attachmentTri", "attachmentUuri", "attachmentOri", "attachmentUtpi", "attachmentUnri", "attachableUuri", "attachmentUtri", "attentionUrid", "attachmentUtrid", "attachmentOuri", "attachableUpi", "attentionUtrid", "attachmentUrid", "attentionUtRI", "attentionUtpi", "attachableOURI", "attachableUURI", "attachmentuRI", "attachmentupi", "attachmentUURI", "attachmentUnuri", "attachmentOpi", "attentionURI", "attachmentUnpi", "attachableOuri"], "contentUri": ["contentUsri", "contentUuri", "messageUuri", "contentUtris", "contentUtri", "contentURI", "contentUsris", "contentUrid", "ContentUsrid", "ContentUrid", "contentSuri", "resourceURuri", "resourceUri", "contentUtRI", "resourceUuri", "ContentUsri", "contentUris", "contentUsuri", "contentUnris", "contentUres", "resourceURI", "ContentUri", "contentures", "contentSric", "contentUnri", "contentUnuri", "contentURuri", "resourceURri", "contentUturi", "contentuuri", "contentUrri", "contentUtiri", "contentUric", "contentUtres", "ContentUsris", "ContentUris", "contentURri", "messageUiri", "contentUruri", "messageUturi", "contentUriri", "resourceUres", "contentUtrid", "contentUnrid", "contentuRI", "contenturi", "contentUiri", "resourceURRI", "messageUtric", "messageUtri", "contentUsrid", "resourceURres", "messageUtiri", "messageUric", "contentSiri", "contentUrric", "contentURres", "contentSri", "contentUtric", "contentURRI", "ContentUuri", "ContentUsuri", "messageUri"], "file": ["type", "f", "rule", "play", "image", "picture", "output", "File", "FILE", "h", "disk", "resource", "fp", "create", "page", "table", "init", "port", "base", "template", "work", "link", "ca", "buffer", "to", "document", "message", "from", "result", "db", "filename", "ile", "format", "content", "media", "name", "le", "sf", "entity", "upload", "tree", "path", "dir", "line", "channel", "zip", "local", "files", "save", "source", "pool", "il", "folder", "user", "angle", "header"], "in": ["mi", "rin", "en", "play", "inn", "ini", "and", "gin", "con", "IN", "ins", "ar", "on", "al", "In", "inside", "inner", "ic", "up", "i", "read", "bin", "inc", "l", "input", "it", " IN", "sql", " din", "ain", "ind", "io", "din", "inf", "is", "isin", "source", "body", "cin", "from"], "out": ["all", "co", "nt", "flush", "con", "output", "res", "put", "oss", "ao", "obj", "client", "sys", "conv", "stable", "net", "write", "print", "b", "to", "v", "i", "serv", "writer", "os", "outer", "OU", "it", "null", "ou", "outs", "g", "aos", "o", "auto", "screen", "n", "io", "Out", "OUT", "check", "can", "ex", "w"], "intent": ["event", "automatic", "phrase", "window", "json", "text", "spirit", "displayText", "ant", "concept", "entry", "service", "ink", "skill", "intention", "asso", "animate", "context", "init", "q", "ment", "action", "agent", "man", "device", "ic", "alert", "xml", "wordpress", "widget", "act", "condition", "activate", "venture", "statement", "entity", "complete", "initial", "method", "prom", "ent", "query", "term", "continue", "ident", "inv", "activity", "express", "verbal", "voice", "communication", " Intent", "Activity", "inst", "activation", "ence"]}}
{"id1": "12782570", "id2": "22977189", "code1": "    public void logging() throws Fault {\n        final InterceptorWrapper wrap = new InterceptorWrapper(message);\n        final LoggingMessage buffer = new LoggingMessage(\"Inbound Message\\n----------------------------\");\n        String encoding = (String) wrap.getEncoding();\n        if (encoding != null) {\n            buffer.getEncoding().append(encoding);\n        }\n        Object headers = wrap.getProtocolHeaders();\n        if (headers != null) {\n            buffer.getHeader().append(headers);\n        }\n        InputStream is = (InputStream) wrap.getContent(InputStream.class);\n        if (is != null) {\n            CachedOutputStream bos = new CachedOutputStream();\n            try {\n                IOUtils.copy(is, bos);\n                bos.flush();\n                is.close();\n                this.message.setContent(InputStream.class, bos.getInputStream());\n                if (bos.getTempFile() != null) {\n                    logger.error(\"\\nMessage (saved to tmp file):\\n\");\n                    logger.error(\"Filename: \" + bos.getTempFile().getAbsolutePath() + \"\\n\");\n                }\n                if (bos.size() > limit) {\n                    logger.error(\"(message truncated to \" + limit + \" bytes)\\n\");\n                }\n                bos.writeCacheTo(buffer.getPayload(), limit);\n                bos.close();\n            } catch (IOException e) {\n                throw new Fault(e);\n            }\n        }\n        logger.debug(\"Message received :\\n\" + buffer.getPayload().toString());\n    }\n", "code2": "    public static void main(String args[]) throws IOException {\n        BufferedReader in = new BufferedReader(new FileReader(args[0]));\n        Writer out = new FileWriter(args[1]);\n        out = new WrapFilter(new BufferedWriter(out), 40);\n        out = new TitleCaseFilter(out);\n        String line;\n        while ((line = in.readLine()) != null) out.write(line + \"\\n\");\n        out.close();\n        in.close();\n    }\n", "label": 1, "substitutes": {"logging": ["debugging", "Logifying", "debugged", " logged", " logifying", "logger", "logifying", "debugger", " logger", "debugifying", "Logger", "Logged", "Logging", "logged"], "wrap": ["transform", "window", "handle", "embed", "find", "reset", "W", "sp", "word", "ow", "ws", "force", "create", "wa", "web", "rap", "inter", "gate", "box", "x", "work", "pad", "me", "chain", "wx", "link", "we", "build", "shape", "message", "wind", " wrapper", "grow", "safe", "read", "format", "wra", " wrapped", "pack", "ew", "sw", "parse", "wire", "aw", "form", "add", "use", "ad", "zip", "core", "nw", "start", "pool", "root", "wrapper", "store", "xf", "python", "w"], "buffer": ["phrase", "buf", "window", "report", "reply", "block", "pb", "buff", "output", "bridge", "console", "ob", "frame", "comment", "builder", "word", "view", "bo", "sequence", "append", "table", "flash", "base", "profile", "template", "ve", "command", "attribute", "document", "message", "cache", "Buffer", "face", "position", "writer", "complete", "iter", "note", "queue", "binary", "batch", "flag", "line", "database", "bar", "row", "quote", "display", "where", "size", "body", "memory", "wrapper", "store", "print", "header"], "encoding": ["enoding", "coding", "encoded", "caling", "enryption", "enging", "octging", "octoder", "octoding", "presoder", "presryption", "cging", "Encoder", "enoder", "enaling", "Encaling", "presoded", "coder", "encryption", "cryption", "Encryption", "enoded", "encaling", "octoded", "Encoding", "encoder", "coded", "presoding", "encging"], "getEncoding": ["getEncling", "getEnryption", " getEncoded", "getEncryption", "GetEnling", "getContinocol", "getEncocol", "GetEncryption", " getEncocol", "GetEncoding", " getEnoded", "getencoding", "getUrlryption", "getencName", " getEnryption", " getEnocol", "getContinryption", "getEnling", "getencling", "GetEncling", "getEnoded", "GetEncName", "getContinoding", "GetEnryption", "getUrloding", "getencryption", " getEncryption", "GetEnName", " getEnoding", "getUrlName", "getEnoding", "getUrlling", "getEncName", "getEnocol", "getEncoded", "getEnName", "GetEnoding", "getContinoded"], "headers": ["terms", "tags", "ilers", "writers", "frames", "reports", "params", "users", "keys", "limits", "modules", "ters", "ppers", "names", "comments", "pins", "drivers", "builders", "boxes", "weights", "styles", "properties", "head", "rs", "caps", "blocks", "images", "ids", "fields", "heads", "actions", "members", "pres", "ctors", "holders", "ers", "authors", "chains", "objects", "ports", "groups", "relations", "values", "codes", "header", "checks"], "is": ["mis", "ois", "ist", "does", "ms", "iris", "us", "ins", "Is", "nis", "ri", "fs", "sys", "bs", "isa", "ais", "in", "isd", "dis", "tis", "bits", "ic", "ui", "i", "its", "ris", "os", "IS", "or", "has", "was", "ys", "isc", "ims", "isl", "obs", "lis", "si", "bis", "isf", "ip", "ists", "isi", "ios", "isin", "iso", "\u00eds", "iss", "as", "sis"], "bos": ["ows", "dos", "ses", "vals", "cos", "bones", "oss", "bo", "js", "tops", "jas", "windows", "bh", "fs", "sys", "bs", "pod", "bas", "tis", "uts", "los", "bits", "boards", "bi", "fits", "soc", "stats", "ts", "ui", "bin", "os", "ols", "bytes", "ys", "des", "bes", "edes", "ones", "obs", "aos", "ods", "bis", "eros", "ubis", "ots", "uds", "isi", "ios", "oids", "lets", "oos", "tes", "nos", "banks", "bot", "cs"], "e": ["E", "f", "eeee", "en", "ie", "oe", "ee", "d", "se", "a", "m", "t", "x", "ae", "me", "err", "c", "ate", "re", "v", "i", "le", "error", "ent", "exc", "g", "o", "ge", "r", "ev", "ed", "n", "er", "de", "p", "es", "ne", "ex"]}}
{"id1": "22977189", "id2": "20924119", "code1": "    public static void main(String args[]) throws IOException {\n        BufferedReader in = new BufferedReader(new FileReader(args[0]));\n        Writer out = new FileWriter(args[1]);\n        out = new WrapFilter(new BufferedWriter(out), 40);\n        out = new TitleCaseFilter(out);\n        String line;\n        while ((line = in.readLine()) != null) out.write(line + \"\\n\");\n        out.close();\n        in.close();\n    }\n", "code2": "    public static void gzip() throws Exception {\n        System.out.println(\"gzip()\");\n        GZIPOutputStream zipout = new GZIPOutputStream(new FileOutputStream(\"/zip/myzip.gz\"));\n        byte buffer[] = new byte[BLOCKSIZE];\n        File dir = new File(\"/zip/covers\");\n        System.out.println(\"Dir '\" + dir.getAbsolutePath() + \"' exists: \" + dir.exists());\n        FileInputStream in = new FileInputStream(dir);\n        for (int length; (length = in.read(buffer, 0, BLOCKSIZE)) != -1; ) zipout.write(buffer, 0, length);\n        in.close();\n        zipout.close();\n    }\n", "label": 1, "substitutes": {"in": ["ze", "rin", "inn", "ini", "gin", "con", "IN", "ins", "ar", "ri", "reader", "ln", "on", "ro", "raw", "In", "init", "inner", "inside", "ill", "ic", "up", "conf", "i", "read", "bin", "get", "inc", "input", "are", "iter", "it", "ind", "r", "io", "din", "inf", "is", "cin", "user", "from"], "out": ["all", "report", "co", "en", "nt", "flush", "j", "by", "con", "output", "res", "bit", "console", "obj", "on", "client", "sys", "set", "tmp", "not", "conv", "mem", "port", "inner", "chain", "net", "write", "print", "b", "to", "log", "result", "db", "ot", "list", "v", "i", "rem", "cache", "writer", "os", "l", "outer", "or", "it", "cmd", "gt", "note", "conn", "null", "at", "news", "outs", "o", "aos", "auto", "full", "ret", "screen", "n", "io", "Out", "pool", "timeout", "OUT", "can", "end", "w"], "line": ["rule", "LINE", "style", "lin", "block", "text", "eline", "match", "entry", "ine", "next", "column", "word", "comment", "frame", "lane", "ln", "sequence", "page", "stroke", "day", "base", "char", "code", "link", "chain", "date", "message", "cell", "ice", "name", "le", "error", "entity", "l", "valid", "iter", "lined", "point", "Line", "key", "n", "string", "row", "inline", "file", "online", "user", "print", "header", "character"]}}
{"id1": "15241397", "id2": "6403868", "code1": "    @Override\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String rewrittenQueryString = URLDecoder.decode(request.getRequestURI(), \"UTF-8\").replaceFirst(\"^.*?\\\\/(id:.*)\\\\/.*?$\", \"$1\");\n        logger.debug(\"rewrittenQueryString: \" + rewrittenQueryString);\n        URL rewrittenUrl = new URL(fedoraUrl + rewrittenQueryString);\n        logger.debug(\"rewrittenUrl: \" + rewrittenUrl.getProtocol() + \"://\" + rewrittenUrl.getHost() + \":\" + rewrittenUrl.getPort() + rewrittenUrl.getFile());\n        HttpURLConnection httpURLConnection = (HttpURLConnection) rewrittenUrl.openConnection();\n        HttpURLConnection.setFollowRedirects(false);\n        httpURLConnection.connect();\n        response.setStatus(httpURLConnection.getResponseCode());\n        logger.debug(\"[status=\" + httpURLConnection.getResponseCode() + \"]\");\n        logger.debug(\"[headers]\");\n        for (Entry<String, List<String>> header : httpURLConnection.getHeaderFields().entrySet()) {\n            if (header.getKey() != null) {\n                for (String value : header.getValue()) {\n                    if (value != null) {\n                        logger.debug(header.getKey() + \": \" + value);\n                        if (!header.getKey().equals(\"Server\") && !header.getKey().equals(\"Transfer-Encoding\")) {\n                            response.addHeader(header.getKey(), value);\n                        }\n                    }\n                }\n            }\n        }\n        logger.debug(\"[/headers]\");\n        InputStream inputStream = httpURLConnection.getInputStream();\n        OutputStream outputStream = response.getOutputStream();\n        IOUtils.copy(inputStream, outputStream);\n    }\n", "code2": "    private File extractUninstallFiles(File _destPath, boolean upgrade, String lastVer) {\n        File oldlog = null;\n        try {\n            boolean oldClassCopied = false;\n            File destPath = new File(_destPath, \"vai_\" + VAGlobals.APP_NAME + \"_\" + VAGlobals.APP_VERSION);\n            if (upgrade) {\n                File lastVerPath = new File(_destPath, \"vai_\" + VAGlobals.APP_NAME + \"_\" + lastVer);\n                if (destPath.equals(lastVerPath)) {\n                    File bkdir = new File(destPath.getAbsolutePath() + \".bak\");\n                    if (!destPath.renameTo(bkdir)) {\n                        throw new IOException(VAGlobals.i18n(\"Setup_NotCreateDirectory\") + \" \" + destPath);\n                    }\n                    oldlog = new File(bkdir.getAbsolutePath() + System.getProperty(\"file.separator\") + \"uninstall.vai\");\n                    lastVerPath = bkdir;\n                } else {\n                    oldlog = new File(lastVerPath.getAbsolutePath() + System.getProperty(\"file.separator\") + \"uninstall.vai\");\n                }\n                if ((!destPath.exists()) && (!destPath.mkdirs())) {\n                    throw new IOException(VAGlobals.i18n(\"Setup_NotCreateDirectory\") + \" \" + destPath);\n                }\n                if (uInfo_.module) oldClassCopied = copyOldSetupClass(lastVerPath, destPath);\n            } else {\n                if ((!destPath.exists()) && (!destPath.mkdirs())) {\n                    throw new IOException(VAGlobals.i18n(\"Setup_NotCreateDirectory\") + \" \" + destPath);\n                }\n            }\n            dirty_ = true;\n            File[] ls = destPath.listFiles();\n            for (int i = 0; i < ls.length; i++) {\n                if (!oldClassCopied) ls[i].delete(); else if (!ls[i].getPath().equals(destPath.getAbsolutePath() + File.separator + installClassName_ + \".class\")) ls[i].delete();\n            }\n            byte[] buf = new byte[0];\n            int read = 0;\n            if (!oldClassCopied && (installClassSize_ > 0 || jarOffset_ > 0)) {\n                final File outClassFile = new File(destPath.getAbsolutePath() + File.separator + installClassName_ + \".class\");\n                if (outClassFile.exists() && !outClassFile.delete()) {\n                    ui_.showError(new Exception(VAGlobals.i18n(\"Setup_FileNotCreated\") + \":\\n\" + outClassFile.getName()));\n                }\n                final FileOutputStream out = new FileOutputStream(outClassFile);\n                final FileInputStream in = new FileInputStream(fileWithArchive_);\n                if (installClassOffset_ > 0) {\n                    in.skip(installClassOffset_);\n                }\n                buf = new byte[0];\n                if (installClassSize_ < 0) buf = new byte[(int) jarOffset_]; else buf = new byte[(int) installClassSize_];\n                read = in.read(buf, 0, buf.length);\n                out.write(buf, 0, read);\n                out.close();\n                in.close();\n            }\n            final FileInputStream in = new FileInputStream(fileWithArchive_);\n            if (jarOffset_ > 0) {\n                in.skip(jarOffset_);\n            }\n            JarInputStream jar = new JarInputStream(in);\n            final File outJarFile = new File(destPath.getAbsolutePath() + File.separator + \"install.jar\");\n            if (outJarFile.exists() && !outJarFile.delete()) {\n                ui_.showError(new Exception(VAGlobals.i18n(\"Setup_FileNotCreated\") + \":\\n\" + outJarFile.getName()));\n            }\n            JarOutputStream outJar = new JarOutputStream(new FileOutputStream(outJarFile));\n            ZipEntry entry = jar.getNextEntry();\n            final int bufSize = 32768;\n            buf = new byte[bufSize];\n            while (entry != null) {\n                String entryName = entry.getName();\n                if (entryName.equals(\"com/memoire/vainstall/resources/vainstall.properties\")) {\n                } else if (entryName.equals(installClassName_ + \".class\") && !oldClassCopied) {\n                    FileOutputStream out = null;\n                    try {\n                        out = new FileOutputStream(destPath.getAbsolutePath() + File.separator + installClassName_ + \".class\");\n                        VAGlobals.copyStream(jar, out, buf);\n                    } catch (IOException e) {\n                        throw e;\n                    } finally {\n                        if (out != null) out.close();\n                    }\n                } else if (!entryName.endsWith(\".zip\")) {\n                    if (VAGlobals.DEBUG) VAGlobals.printDebug(\"jar entry name \" + entryName);\n                    ZipEntry outEntry = new ZipEntry(entryName);\n                    CRC32 crc = new CRC32();\n                    outJar.putNextEntry(outEntry);\n                    int size = 0;\n                    while ((read = jar.read(buf, 0, bufSize)) >= 0) {\n                        size += read;\n                        if (read == 0) {\n                            Thread.yield();\n                        } else {\n                            outJar.write(buf, 0, read);\n                            crc.update(buf, 0, read);\n                        }\n                    }\n                    outEntry.setSize(size);\n                    outEntry.setCrc(crc.getValue());\n                    outJar.flush();\n                    outJar.closeEntry();\n                }\n                jar.closeEntry();\n                entry = jar.getNextEntry();\n            }\n            InputStream pin = getClass().getResourceAsStream(\"resources/vainstall.properties\");\n            Properties prop = new Properties();\n            try {\n                prop.load(pin);\n            } catch (IOException exc) {\n            }\n            if (language == null) language = \"default\";\n            prop.setProperty(\"vainstall.destination.language\", language);\n            ZipEntry outEntry = new ZipEntry(\"com/memoire/vainstall/resources/vainstall.properties\");\n            CRC32 crc = new CRC32();\n            outEntry.setCrc(crc.getValue());\n            outEntry.setSize(prop.size());\n            outJar.putNextEntry(outEntry);\n            prop.store(outJar, VAGlobals.NAME + \" \" + VAGlobals.VERSION);\n            outEntry.setCrc(crc.getValue());\n            outJar.closeEntry();\n            jar.close();\n            outJar.close();\n            in.close();\n        } catch (IOException e) {\n            String message = e.getLocalizedMessage();\n            message += \"\\n\" + VAGlobals.i18n(\"Setup_ErrorUninstallScripts\");\n            e.printStackTrace();\n            exitOnError(new IOException(message));\n        }\n        return oldlog;\n    }\n", "label": 1, "substitutes": {"doGet": ["DoPut", "doGET", " doPut", " doGET", "handlePut", "Doget", "handleGET", "doget", " doget", "doPut", "handleget", "handleGet", "DoGET", "DoGet"], "request": ["first", "report", "transform", "address", "reference", "each", "reset", "the", "hello", "forward", "frame", "application", "client", "create", "quest", "context", "in", "connection", "command", "attribute", "document", "message", "current", "Request", "re", "req", "position", "get", "complete", "input", "initial", "query", "question", "http", "start", "QUEST", "user", "server", "setup"], "response": ["report", "reply", "image", "json", "block", "output", "reset", "res", "next", "console", "service", "frame", "description", "application", "resource", "view", "sequence", "Response", "status", "page", "site", "context", "fire", "connection", "ce", "ve", "write", "resp", "document", "message", "result", "onse", "xml", "content", "position", "success", "respond", "exit", "object", "form", "answer", "network", "session", "http", "send", "body", "version", "print", "server"], "rewrittenQueryString": ["rewrittenCurrentStr", "rewrittenRequestStr", "rewartedQuerystring", "rewliedqueryStr", "rewrittenURLString", "rewrittenQuStream", "rewrittenHeaderStr", "rewrittenHeaderStream", "rewrittenRequestQuery", "rewwrittenQueryString", "rewrittenqueryStr", "rewrittenQuestionString", "rewrittenCurrentQuery", "rewrittenURLStr", "rewwrittenqueryQuery", "rewrittenCurrentstring", "rewrittenQuString", "rewrittenURLStream", "rewrittenqueryQuery", "rewartedQueryStream", "rewartedQueryString", "rewwrittenQueryStr", "rewrittenRequeststring", "rewrittenURLstring", "rewliedQueryString", "rewliedqueryString", "rewwrittenquerystring", "rewartedHeaderstring", "rewrittenQuestionStr", "rewrittenQueryStream", "rewrittenHeaderString", "rewartedHeaderStr", "rewrittenQustring", "rewrittenHeaderstring", "rewartedQueryStr", "rewliedqueryStream", "rewrittenquerystring", "rewartedHeaderStream", "rewrittenQueryStr", "rewwrittenQuerystring", "rewrittenQuStr", "rewliedQueryStr", "rewartedHeaderString", "rewwrittenqueryString", "rewliedQueryStream", "rewrittenQuerystring", "rewrittenqueryString", "rewwrittenQueryQuery", "rewrittenqueryStream", "rewwrittenqueryStr", "rewrittenQueryQuery", "rewrittenCurrentString", "rewrittenQuestionStream", "rewrittenRequestString"], "rewrittenUrl": ["RewrittenPosition", "rewrittenPosition", "RewwrittenString", "rewrapedURL", "rewadjustedUrl", "RewrittenString", "rewriddenUr", "RewrittenLink", "rewrownUrl", "RewwrittenUr", "rewittenLink", "RewrittenUrl", "rewriterUrl", "rewwrittenPort", "rewriteurl", "rewrittenUr", "rewwrittenUrl", "rewadjustedUr", "RewwrittenURL", "rewriteUr", "rewroteLink", "rewriteURL", "rewrapedUr", "rewwrittenPosition", "RewwrittenPosition", "rewroteurl", "rewittenURL", "rewartedurl", "rewadjustedURL", "rewwrittenLink", "rewriddenURL", "rewrapedPort", "rewrownURL", "rewrownPosition", "rewartedUr", "rewriteUrl", "rewroteUr", "rewrittenLink", "rewedString", "rewittenUrl", "RewrittenURL", "rewwrittenString", "rewrittenurl", "rewartedUrl", "RewwrittenLink", "rewrapedUrl", "rewedUrl", "RewrittenUr", "rewedUr", "rewwrittenURL", "rewroteURL", "rewrownUr", "rewadjustedPort", "rewrotePosition", "RewwrittenUrl", "rewittenurl", "rewrittenString", "rewedURL", "rewriterURL", "rewroteUrl", "Rewwrittenurl", "rewwrittenUr", "rewartedURL", "RewrittenPort", "RewwrittenPort", "rewriddenUrl", "rewrittenURL", "rewriterUr", "rewriddenPosition", "rewwrittenurl", "Rewrittenurl", "rewriterString", "rewrittenPort", "rewartedPosition"], "httpURLConnection": ["httpSRConnect", "httpUrlConn", " httpURLConnect", "HttpHTTPApplication", "ttpUrlConnection", "httpFileConn", "ttpUrlApplication", "httpURLConfiguration", "HttpURLApplication", "httpMLconnection", "httpURLconnection", "httpSRConnection", "ttpURLConnection", "httpURLConn", "httpFileConnection", "ttpURLApplication", "httpUrlControl", "ttpURLConnect", "httpMLApplication", "ttpURLconnection", " httpUrlConnection", "httpUrlConnect", "httpHTTPApplication", "httpRLconnection", "httpSRconnection", " httpUrlApplication", "HttpURLConnection", "ttpUrlConnect", "httpHTTPControl", "httpRLConnect", "httpURLConnect", "HttpHTTPconnection", "httpFileConnect", "httpUrlconnection", "httpHTTPConfiguration", " httpUrlConnect", "HttpUrlconnection", "httpRLApplication", "httpURLControl", "HttpUrlConnect", " httpURLconnection", "ttpUrlConn", "ttpURLConn", "HttpHTTPConnect", "httpHTTPconnection", "httpRLConnection", "httpUrlApplication", "httpFileApplication", "httpSRControl", "HttpHTTPConfiguration", "ttpUrlconnection", "httpSRConfiguration", "httpHTTPConnection", "httpUrlConfiguration", "ttpURLControl", "httpSRApplication", "ttpUrlControl", "httpHTTPConn", "HttpURLconnection", "httpUrlConnection", "HttpURLConnect", "httpURLApplication", "HttpURLConfiguration", " httpUrlconnection", "httpMLConnection", "HttpUrlConnection", " httpURLApplication", "httpHTTPConnect", "httpMLConnect", "HttpHTTPConnection"], "header": ["event", "rule", "handle", "zone", "block", "address", "shift", "policy", "layer", "column", "part", "comment", "feature", "argument", "h", "option", "client", "status", "page", "tag", "prefix", "init", "port", "attribute", "buffer", "device", "dr", "detail", "format", "variable", "state", "head", "token", "hidden", "hash", "operator", "section", "meta", "query", "Header", "metadata", "handler", "component", "term", "peer", "headers", "line", "filter", "relation", "padding", "info", "core", "er", "heading", "field", "version", "user", "wrapper", "check", "holder", "ter", "title"], "value": ["json", "text", "zone", "vector", "element", "default", "pair", "sample", "entry", "test", "hello", "email", "comment", "description", "sequence", "create", "VALUE", "label", "attribute", "ue", "message", "current", "v", "property", "content", "format", "sv", "see", "example", "Value", "address", "name", "hash", "des", "val", "language", "record", "instance", "key", "python", "string", "save", "values", "server", "field", "job", "password", "version", "unit", "data", "expression"], "inputStream": ["InputStream", "outputWindow", "outputView", "inputLoop", " inputSteam", "inputSteam", "errorStream", "errorWindow", "InputView", "outputThread", " inputWindow", "InputThread", "errorstream", "outputSteam", "outputstream", "inputstream", " inputLoop", "inputView", " inputThread", "errorSteam", "InputLoop", "outputLoop", " inputView", "inputThread", " inputstream", "inputWindow"], "outputStream": [" outputLength", "outputView", "responseForm", "outputForm", "inputSteam", "displayView", "OutputStream", " outputView", "displayStream", "displaySteam", "OutputLength", "responseLength", "displaystream", "responseSteam", "OutputSteam", " outputSteam", "outputSteam", "outputstream", "inputstream", "OutputForm", "outputLength", "inputView", " outputstream", " outputForm", "responseStream"]}}
{"id1": "22046596", "id2": "471804", "code1": "        public void copy(File s, File t) throws IOException {\n            FileChannel in = (new FileInputStream(s)).getChannel();\n            FileChannel out = (new FileOutputStream(t)).getChannel();\n            in.transferTo(0, s.length(), out);\n            in.close();\n            out.close();\n        }\n", "code2": "    public static void doVersionCheck(View view) {\n        view.showWaitCursor();\n        try {\n            URL url = new URL(jEdit.getProperty(\"version-check.url\"));\n            InputStream in = url.openStream();\n            BufferedReader bin = new BufferedReader(new InputStreamReader(in));\n            String line;\n            String version = null;\n            String build = null;\n            while ((line = bin.readLine()) != null) {\n                if (line.startsWith(\".version\")) version = line.substring(8).trim(); else if (line.startsWith(\".build\")) build = line.substring(6).trim();\n            }\n            bin.close();\n            if (version != null && build != null) {\n                if (jEdit.getBuild().compareTo(build) < 0) newVersionAvailable(view, version, url); else {\n                    GUIUtilities.message(view, \"version-check\" + \".up-to-date\", new String[0]);\n                }\n            }\n        } catch (IOException e) {\n            String[] args = { jEdit.getProperty(\"version-check.url\"), e.toString() };\n            GUIUtilities.error(view, \"read-error\", args);\n        }\n        view.hideWaitCursor();\n    }\n", "label": 0, "substitutes": {"copy": [" replace", " replicate", " Transfer", " extend", "Copy", "transfer", "write", " restore", " seek", "cp", " share", " copying", " swap", "upload", " rename", " move", " mirror", "paste", " insert", " overwrite", " parallel", " populate", " duplicate", " paste", " dup", " cp", " cop"], "s": ["f", "xs", "ss", "sb", "ses", "p", "z", "ms", "ins", "js", "south", "ws", "fs", "qs", "ls", "ns", "sq", "sl", "b", "ps", "S", "ts", "src", "v", "its", "less", "sv", "ats", "rs", "os", "sf", "l", "input", "ys", "ds", "str", "gs", "st", "g", "n", "sts", "string", "gets", "is", "source", "es", "ies", "cs"], "t": ["f", "txt", "nt", "tr", "j", "rt", "test", "h", "mt", "unt", "kt", "w", "tt", "template", "k", "ts", "v", "i", "ct", "pt", "l", "ent", "it", "gt", "wt", "st", "at", "tc", "g", "o", "ret", "te", "n", "ht", "T", "p", "title", "ot"], "in": ["mi", "rin", "en", "inn", "and", "gin", "con", "ie", "IN", "ins", "im", "ar", "oin", "In", "init", "inside", "inner", "ic", "ai", "up", "i", "bin", "inc", "input", "sin", "iter", "it", " din", "ir", "ind", "info", "io", "din", "inf", "is", "isin", "source", "cin", "user", "from"], "out": ["co", "en", "nt", "j", "by", "con", "output", "res", "cn", "client", "sys", "k", "net", "c", "b", "to", "result", "ot", "up", "v", "i", "ac", "l", "outer", "or", "it", "ch", "gt", "this", "conn", "ou", "outs", "g", "o", "aos", "channel", "n", "io", "msg", "Out", "check", "OUT", "can", "ex", "w"]}}
{"id1": "14820302", "id2": "22411381", "code1": "    protected void innerProcess(ProcessorURI curi) throws InterruptedException {\n        Pattern regexpr = curi.get(this, STRIP_REG_EXPR);\n        ReplayCharSequence cs = null;\n        try {\n            cs = curi.getRecorder().getReplayCharSequence();\n        } catch (Exception e) {\n            curi.getNonFatalFailures().add(e);\n            logger.warning(\"Failed get of replay char sequence \" + curi.toString() + \" \" + e.getMessage() + \" \" + Thread.currentThread().getName());\n            return;\n        }\n        MessageDigest digest = null;\n        try {\n            try {\n                digest = MessageDigest.getInstance(SHA1);\n            } catch (NoSuchAlgorithmException e1) {\n                e1.printStackTrace();\n                return;\n            }\n            digest.reset();\n            String s = null;\n            if (regexpr != null) {\n                s = cs.toString();\n            } else {\n                Matcher m = regexpr.matcher(cs);\n                s = m.replaceAll(\" \");\n            }\n            digest.update(s.getBytes());\n            byte[] newDigestValue = digest.digest();\n            curi.setContentDigest(SHA1, newDigestValue);\n        } finally {\n            if (cs != null) {\n                try {\n                    cs.close();\n                } catch (IOException ioe) {\n                    logger.warning(TextUtils.exceptionToString(\"Failed close of ReplayCharSequence.\", ioe));\n                }\n            }\n        }\n    }\n", "code2": "    public PTask stop(PTask task, SyrupConnection con) throws Exception {\n        PreparedStatement s = null;\n        ResultSet result = null;\n        try {\n            s = con.prepareStatementFromCache(sqlImpl().sqlStatements().checkWorkerStatement());\n            s.setString(1, task.key());\n            result = s.executeQuery();\n            con.commit();\n            if (result.next()) {\n                String url = result.getString(\"worker\");\n                InputStream i = null;\n                try {\n                    Object b = new URL(url).getContent();\n                    if (b instanceof InputStream) {\n                        i = (InputStream) b;\n                        byte[] bb = new byte[256];\n                        int ll = i.read(bb);\n                        String k = new String(bb, 0, ll);\n                        if (k.equals(task.key())) {\n                            return task;\n                        }\n                    }\n                } catch (Exception e) {\n                } finally {\n                    if (i != null) {\n                        i.close();\n                    }\n                }\n                PreparedStatement s2 = null;\n                s2 = con.prepareStatementFromCache(sqlImpl().sqlStatements().resetWorkerStatement());\n                s2.setString(1, task.key());\n                s2.executeUpdate();\n                task = sqlImpl().queryFunctions().readPTask(task.key(), con);\n                sqlImpl().loggingFunctions().log(task.key(), LogEntry.STOPPED, con);\n                con.commit();\n            }\n        } finally {\n            con.rollback();\n            close(result);\n        }\n        return task;\n    }\n", "label": 0, "substitutes": {"innerProcess": [" doWork", " doHandle", " doRun", "internalWork", " innerWork", " inlineRun", "internalProcess", " doProcess", "internalHandle", " inlineWork", " innerHandle", "internalRun", " inlineHandle", " inlineProcess", " innerRun"], "curi": ["vcuri", "gcumi", "cpurl", "mcri", "contumi", " cURI", "conturi", "Curl", "cpu", "cumi", " citi", "CURI", "cris", " cri", "cpri", "rcumi", "cURI", "lciri", "ccuri", "cpiri", "pcdu", "contdu", "gcui", "rcuri", "mcuri", "ccris", "cdu", "cui", "vcumi", "cri", "lcri", "gcdu", "ccumi", "gcuri", "vcris", "Cri", "rcdu", " ciri", "mciti", "Ciri", "curl", "ctiti", " cui", "vcui", "ctURI", " curl", "Curi", "pcuri", "pcpu", "ctri", "lcuri", "lcURI", " cdu", "citi", "rcui", "contpu", "pcumi", " cris", "cturi", "ciri", "cpuri", " cpu", "mcURI", "ccui", " cumi"], "regexpr": ["cregexpr", "frentaxpr", "revrePr", "reroxpr", "reacepr", "fregexpre", "revelopPR", "revelopexpr", "reactfr", "rentaxexpr", "revrep", "regexp", "cregexexpr", "regexfr", "revreexpr", "fregexPR", "reacep", "regexexpr", "fregexpr", "cregexPr", "frentaxpre", "rentaxpre", "frentaxPR", "Regexp", "reactexpr", "regexpre", "remaexpr", "reveloppr", "rentaxPR", "Regexfr", "reactpr", "Regexexpr", "Regexpr", "remaPR", "reroxfr", "reveloppre", "fregexexpr", "reaceexpr", "reactp", "remapre", "frentaxexpr", "reroxexpr", "regexPr", "regexPR", "reroxp", "reacePr", "cregexp", "rentaxpr", "revrepr", "remapr"], "cs": ["csv", "rc", "ics", "ss", "ms", "ctx", "Cs", "cos", "res", "cks", "cn", "js", "cms", "ws", "fs", "bs", "qs", "cus", "ls", "wcs", "hs", "ns", "cons", "acts", "c", "fc", "cas", "ctr", "ts", "ps", "cp", "gc", "pc", "ats", "rs", "caps", "CS", "acs", "sc", "ces", "ck", "gs", "css", "cd", "tc", "nc", "mc", "vs", "sts", "cf", "cer", "ks", "aches", "cc"], "digest": [" digse", "digist", "diger", "dest", "hashester", "der", " digum", "hashEST", "columnist", "Diger", "signested", "digse", "digum", "Digester", "columnest", "Digum", "displayer", "columnum", "mixse", "signist", "displayester", "Digse", "digEST", "displayest", "displayested", " digist", "displayEST", "hashse", "mixest", "Digist", " digester", "Digested", "hashest", "displayse", "mixist", "dse", "dist", "signse", "digested", " digEST", " diger", "mixested", "signest", "digester", "DigEST", " digested", "Digest"], "s": ["services", "ss", "sb", "prints", "ms", "ins", "h", "js", "ws", "fs", "https", "bs", "qs", "ls", "t", "hs", "ns", "sq", "c", "b", "ps", "S", "ts", "reads", "e", "its", "less", "sv", "ats", "rs", "str", "has", "eps", "ds", "sol", "sql", "ims", "gs", "space", "n", "sts", "gets", "is", "sam", "p", "es", "bytes", "abs"], "m": ["f", "nm", "sm", "ms", "om", "mr", "d", "mt", " M", "managed", "mo", "t", "mem", "met", "me", "md", "em", "esm", "b", "perm", "rm", "v", "i", "dm", "cm", "M", "l", "gm", "mu", "ma", "mc", "mm", "n", "vm", "mac", "p", "tm"], "newDigestValue": ["newdigestV", "newDigseData", "newDigestedData", "newDigestedV", "newdigestValue", "newDigestVal", "newDigestedVal", "newDigestedValues", "newdigistData", "newdigestedValue", "newDigumentValues", "newDigestedValue", "newDigistData", "newDigseValue", "newDigestV", "newDigestData", "newdigestVal", "newDigestValues", "newDigistValue", "newdigestedV", "newdigestValues", "newDigseValues", "newDigumentValue", "newdigistValue", "newdigestData", "newdigestedVal", "newdigestedValues", "newDigumentVal", "newDigseV", "newDigumentV", "newDigseVal", "newdigistVal", "newDigistVal"]}}
{"id1": "2668634", "id2": "10795866", "code1": "    public WebmillDeploy(String inputName, String outputName, boolean stripLoggers) throws Exception {\n        File tempFile = null;\n        JarFile jin = null;\n        JarOutputStream jout = null;\n        FileChannel srcChannel = null;\n        FileChannel dstChannel = null;\n        try {\n            String portletApplicationName = getPortletApplicationName(outputName);\n            System.out.println(\"portletApplicationName = \" + portletApplicationName);\n            tempFile = File.createTempFile(\"webmill-delpoy-\", \"\");\n            tempFile.deleteOnExit();\n            jin = new JarFile(inputName);\n            jout = new JarOutputStream(new FileOutputStream(tempFile));\n            Document webXml = null;\n            Document portletXml = null;\n            Document contextXml = null;\n            ZipEntry src;\n            InputStream source;\n            Enumeration zipEntries = jin.entries();\n            while (zipEntries.hasMoreElements()) {\n                src = (ZipEntry) zipEntries.nextElement();\n                source = jin.getInputStream(src);\n                try {\n                    String target = src.getName();\n                    if (WEB_INF_WEB_XML.equals(target)) {\n                        System.out.println(\"Found web.xml\");\n                        webXml = parseXml(source);\n                    } else if (WEB_INF_PORTLET_XML.equals(target)) {\n                        System.out.println(\"Found WEB-INF/portlet.xml\");\n                        portletXml = parseXml(source);\n                    } else if (META_INF_CONTEXT_XML.equals(target)) {\n                        System.out.println(\"Found META-INF/context.xml\");\n                        contextXml = parseXml(source);\n                    }\n                } finally {\n                    source.close();\n                }\n            }\n            if (webXml == null) {\n                throw new IllegalArgumentException(\"WEB-INF/web.xml not found\");\n            }\n            if (portletXml == null) {\n                throw new IllegalArgumentException(\"WEB-INF/portlet.xml not found\");\n            }\n            WebmillWebApplicationRewriter webRewriter = new WebmillWebApplicationRewriter(webXml);\n            webRewriter.processWebXML();\n            WebmillContextRewriter contextRewriter = new WebmillContextRewriter(contextXml, portletApplicationName);\n            contextRewriter.processContextXML();\n            jin = new JarFile(inputName);\n            zipEntries = jin.entries();\n            while (zipEntries.hasMoreElements()) {\n                src = (ZipEntry) zipEntries.nextElement();\n                source = jin.getInputStream(src);\n                try {\n                    String target = src.getName();\n                    String fullTarget = '/' + target;\n                    if (stripLoggers && target.endsWith(\".jar\") && (target.startsWith(\"WEB-INF/lib/commons-logging\") || target.startsWith(\"WEB-INF/lib/log4j\"))) {\n                        System.out.println(\"Skip logger \" + target);\n                        continue;\n                    } else {\n                        if (webRewriter.getRealPortletTldFile() != null && fullTarget.equals(webRewriter.getRealPortletTldFile())) {\n                            System.out.println(\"Skip portlet tld file \" + fullTarget);\n                            continue;\n                        } else if (target.equals(WEB_INF_WEB_XML)) {\n                            System.out.println(\"Skip web.xml file \" + target);\n                            continue;\n                        } else if (target.equals(WEB_INF_PORTLET_XML)) {\n                            System.out.println(\"Skip portlet.xml file \" + target);\n                            continue;\n                        } else if (target.equals(META_INF_CONTEXT_XML)) {\n                            System.out.println(\"Skip context.xml file \" + target);\n                            continue;\n                        }\n                        System.out.println(\"Add file \" + target);\n                    }\n                    addFile(target, source, jout);\n                } finally {\n                    source.close();\n                }\n            }\n            addFile(WEB_INF_WEB_XML, webXml, jout);\n            addFile(WEB_INF_PORTLET_XML, portletXml, jout);\n            addFile(META_INF_CONTEXT_XML, contextXml, jout);\n            System.out.println(\"Attempting to add portlet.tld to war...\");\n            InputStream is = this.getClass().getResourceAsStream(\"/org/riverock/webmill/container/tags/portlet.tld\");\n            if (is == null) {\n                System.out.println(\"Failed to find portlet.tld in classpath\");\n            } else {\n                String portletTldFile = webRewriter.getRealPortletTldFile();\n                if (portletTldFile.charAt(0) == '/') {\n                    portletTldFile = portletTldFile.substring(1);\n                }\n                System.out.println(\"Adding file \" + portletTldFile);\n                try {\n                    addFile(portletTldFile, is, jout);\n                } finally {\n                    is.close();\n                }\n            }\n            jout.close();\n            jin.close();\n            jin = null;\n            jout = null;\n            System.out.println(\"Creating war \" + outputName + \" ...\");\n            System.out.flush();\n            srcChannel = new FileInputStream(tempFile).getChannel();\n            dstChannel = new FileOutputStream(outputName).getChannel();\n            dstChannel.transferFrom(srcChannel, 0, srcChannel.size());\n            srcChannel.close();\n            srcChannel = null;\n            dstChannel.close();\n            dstChannel = null;\n            tempFile.delete();\n            tempFile = null;\n            System.out.println(\"War \" + outputName + \" created\");\n            System.out.flush();\n        } finally {\n            if (srcChannel != null && srcChannel.isOpen()) {\n                try {\n                    srcChannel.close();\n                } catch (IOException e1) {\n                }\n            }\n            if (dstChannel != null && dstChannel.isOpen()) {\n                try {\n                    dstChannel.close();\n                } catch (IOException e1) {\n                }\n            }\n            if (jin != null) {\n                try {\n                    jin.close();\n                    jin = null;\n                } catch (IOException e1) {\n                }\n            }\n            if (jout != null) {\n                try {\n                    jout.close();\n                    jout = null;\n                } catch (IOException e1) {\n                }\n            }\n            if (tempFile != null && tempFile.exists()) {\n                tempFile.delete();\n            }\n        }\n    }\n", "code2": "    public String upload() {\n        System.out.println(imgFile);\n        String destDir = \"E:\\\\ganymede_workspace\\\\training01\\\\web\\\\user_imgs\\\\map_bg.jpg\";\n        FileOutputStream fos;\n        try {\n            fos = new FileOutputStream(new File(destDir));\n            IOUtils.copy(new FileInputStream(imgFile), fos);\n            IOUtils.closeQuietly(fos);\n        } catch (FileNotFoundException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return \"show\";\n    }\n", "label": 1, "substitutes": {"inputName": ["inputFilename", "inputFile", "outputPath", "outputNames", "outputFile", "outputFilename", "inputNames", " inputFile", "interfacePath", "interfaceFilename", " inputPath", "InputFile", "InputName", "InputNames", "InputPath", "InputFilename", "interfaceName", "inputPath", " inputNames", "interfaceFile"], "outputName": ["outputDir", " outputPath", "outputPath", " outputType", "outputNames", "inputDir", "OutputPort", " outputPort", "OutputName", "OutputDir", "inputNames", "outputType", "inputType", " outputNames", "OutputNames", "OutputPath", "OutputType", "inputPort", "outputPort", "inputPath", " outputDir"], "stripLoggers": ["skipLogging", "skiplogger", "stripPathgers", "stripPathger", "stripPathging", "striplogger", "striplogReferences", "stripLogReferences", "stripDebugging", "skiplogReferences", "stripPathReferences", "skiploggers", "striplogging", "striploggers", "skipLogger", "stripDebugReferences", "stripDebugger", "skipLoggers", "skipLogReferences", "stripLogging", "stripDebuggers", "stripLogger", "skiplogging"], "tempFile": ["tempDir", " tempDir", "TempPath", "tempLock", "TempDirectory", "TempPlace", "temFile", "tmpfile", "tempDirectory", "tempPath", "empFile", " temporaryFile", "temfile", "tmpDir", "tmpFile", "Tempfile", " temporaryField", " tempfile", "tempField", " temporaryDir", " tempDirectory", " tempPlace", "tmpLock", "temDir", " temporaryDirectory", "TempFile", "tempfile", "tmpField", " temporaryLock", " tempPath", "temPath", "empfile", "TempDir", "tmpPath", " temporaryfile", "tmpPlace", "empField", "empLock", "tempPlace"], "jin": ["pak", "via", "txt", "rin", "lin", "json", "zon", "ini", "alin", "gin", "yang", "tan", "pai", "vin", " inj", "jiang", "pin", "jing", "zin", "rir", "ln", "inx", "tin", "jl", "jet", "ju", "rison", "spin", "thin", "lah", "kin", "ran", "ja", "bin", "jo", "lu", "jc", "lig", "rake", "nu", "john", "jen", "xi", "jac", " Jin", "jad", "jon", "nik", "nin", "olin", "zip", "jp", "erb", "din", "quin", "cin", "JR", "von"], "jout": ["zio", "qou", "jOut", "jaos", "jpout", " jou", "zout", "jpOut", "jpin", "jsin", " jOut", " jaos", "jsOut", " jio", "qio", "jou", "qout", "zaos", "qaos", "jio", "zou", "jsout"], "srcChannel": ["rcChan", "rcCh", "sourceChan", "srcChan", "srcCh", "rcChannel", "sourcechannel", "sourceChannel", "rcchannel", "sourceCh", " srcchannel", " srcCh", " srcChan", "srcchannel"], "dstChannel": [" ddestCh", "dstFile", " ddestChan", "doutChan", "ddestCh", " ddestChannel", "doutCh", " dstChan", "dgtFile", "ddestFile", "dstCh", "doutChannel", "dgtChan", "doutFile", "ddestChannel", "ddestChan", "dstChan", "dgtChannel", " ddestFile", " dstCh", " dstFile", "dgtCh"], "portletApplicationName": ["portletAppName", "portletCollectionType", "portableAppType", "portletapplicationOrder", "portletAppCode", "portletApplicationCode", "portletCollectionName", "portableApplicationName", "portletServiceName", "portableApplicationType", "portletApplicationKey", "portableAppName", "portletCollectionCode", "portletAppType", "portletApplicationOrder", "portletApplicationValue", "portableAppOrder", "portableApplicationOrder", "portletAppKey", "portletapplicationType", "portletAppValue", "portableApplicationCode", "portletCollectionValue", "portletapplicationKey", "portableAppKey", "portableApplicationKey", "portletAppOrder", "portletServiceType", "portletServiceOrder", "portletServiceKey", "portletapplicationName", "portableApplicationValue", "portletApplicationType"], "webXml": ["webTxml", "webMml", " webYaml", " webYom", "webXxml", "webXm", "webTxm", "WebXxml", "WebTxml", "webExxml", "WebXm", " webTxxml", " webXML", "webMaml", "WebXML", " webYML", "webExml", "webTxlim", "WebTxpl", "webExML", "webXMom", "WebXpl", "webMom", "webTxpl", "webYom", "webXom", "webWorklim", "WebTxm", "webWorkxml", "webWorkML", " webXlim", "webXMxml", "webXMML", "webXMpl", "webXlim", "webXpl", "webYaml", " webTxlim", "webYml", "webExm", " webXxml", "WebTxML", "webYML", " webTxML", " webXom", " webTxml", "WebTxxml", "WebXml", "webXMm", "webYpl", "webYxml", "webXMlim", "webXMml", "webWorkml", "webXaml", "webMML", "webTxxml", " webXaml", " webYml", "webTxML", "webXMaml", "webXML"], "portletXml": ["portantTxxml", "portableYml", "portletYbl", "portletTxxml", "portantTxml", "portableYML", "portantTxng", "portletTxml", "portletXMml", "portletXMxml", "portletExml", "portvetXMxml", "portletEng", "portletXMbl", "portableYql", "portableXML", "portantXML", "portletYql", "portvetXMml", "portletYml", "portvetXml", "portableXql", "portantXng", "portvetXng", "portletXxml", "portletHeML", "portableXxml", "portletXMML", "portletYxml", "portletHeml", "portletXng", "portletXML", "portletXMng", "portletTxML", "portletXql", "portvetXbl", "portvetXxml", "portvetXMbl", "portvetXMng", "portletXbl", "portantXml", "portletEml", "portletEbl", "portableYxml", "portletTxql", "portletHeng", "portletHexml", "portletYng", "portletXMql", "portableXml", "portantXxml", "portletTxng", "portantTxML", "portletYML"], "contextXml": ["contextYML", "contextEML", "contextCML", "contextYmx", "contextXmm", "contextXiML", "componentYmx", "ctxXML", "contextEml", "componentYmm", "contextXML", "contextYtml", "contextXiml", "contextYml", "contextEmm", "contextYmm", "componentYml", "contextAxmx", "contextCml", "contextXiaml", "componentXML", "contextXaml", "contextAxML", "ctxXiml", "ctxXiaml", "contextAxml", "ctxXaml", "contextYaml", "contextXtml", "ctxXiML", "contextEmx", "componentXmx", "componentXml", "contextXmx", "contextCtml", "ctxXtml", "contextCaml", "contextXitml", "ctxXitml", "contextAxmm", "componentYML", "ctxXml", "componentXmm"], "src": ["ser", "buster", "rc", "via", "txt", "usr", "sb", "su", "entry", "ie", "supp", "sp", "dest", "sit", "cont", "resource", "obj", "ln", "bh", "sys", "https", "tmp", "sq", "zh", "addr", "sl", "scope", "secure", "ctr", "slice", "cur", "sr", "rel", "filename", "sec", "Source", "url", "sup", "crit", "str", "sel", "SOURCE", "proc", "comp", "sol", "sc", "st", "sn", "ident", "kk", "syn", "ind", "desc", "skin", "rob", "loc", " sou", "inst", "from", "sing"], "source": ["origin", "series", "ser", "style", "image", "sample", "entry", "ie", "console", "sp", "dest", "service", "feature", "resource", "single", "reader", "se", "sequence", "set", "stream", "status", "sum", "table", "context", "raw", "site", "inner", "base", "template", "spec", "store", "in", "buffer", "scope", "secure", "result", "Source", "format", "state", "copy", "get", "SOURCE", "input", "iter", "it", "query", "tree", "parent", "sql", "seed", "ource", "null", "instance", "iterator", "channel", "zip", "start", "file", "size", "shell", "unit", "check", "from", "session"], "zipEntries": ["zipEies", "zipIntries", "zoneEnables", "zipEnies", "zipenties", "zipentries", "zipEs", "zipEntryarts", "ipEries", "zipentables", "ZipEntries", "zipInties", "zoneEnties", "zipEriers", "ZipEnties", "zipEntryires", "zipEnties", "Zipentrs", "zoneEnities", "ipEntries", "zipErs", "ipEntarts", "zipEntrys", "zipentities", "zoneEntables", "zipEarts", "zipEnarts", "zipEns", "zipEnables", "zipEries", "Zipenties", "zipEntarts", "zipEntriers", "zipentrs", "zoneEntries", "ipEires", "Zipentries", "zipEnities", "zipEnts", "zipEntires", "Zipentriers", "zipEntables", "zipEnires", "zipEntrs", "zipEntryries", "zipIntriers", "zipEnries", "zoneEnies", "zoneEntities", "ipEnts", "zipentriers", "ZipEntriers", "zipIntrs", "ipEntires", "ipEarts", "zipEities", "zoneEnries", "ipEs", "zipEables", "zipEires", "ZipEntrs", "zipEntities"], "target": ["type", "handle", "layout", "prop", "text", "match", "alias", "test", "task", "goal", "resource", "tag", "table", "t", "tool", "base", "module", "template", "chain", "label", "buffer", "pkg", "scope", "primary", "result", "family", "rel", "filename", "format", "route", "url", "Target", "name", "owner", "top", "gt", "parent", "controller", "project", "compatible", "term", "pattern", "local", "location", "bolt", "class", "version", "arget", "tif", "host", "arg", "peer", "title"], "webRewriter": ["WebWler", "WebRewrite", "_", "webRewler", "webRewactor", "Log", "json", "entry", "File", "WebRewriter", "WebWrite", "webRepler", "WebRewactor", "cont", "WebRewler", "webRewrite", "WebWactor", "log", "webRebler", "Supp", "webWriter", "webRebriter", "println", "impl", "Input", "webRepactor", "get", "webRebactor", "webWactor", "webReprite", "webRebrite", "aos", "New", "Entry", "webWler", "WebWriter", "webRepriter", "webWrite"]}}
{"id1": "17158020", "id2": "8788371", "code1": "    public synchronized String encryptPassword(String passwordString) throws Exception {\n        MessageDigest digest = null;\n        digest = MessageDigest.getInstance(\"SHA\");\n        digest.update(passwordString.getBytes(\"UTF-8\"));\n        byte raw[] = digest.digest();\n        String hash = (new BASE64Encoder()).encode(raw);\n        return hash;\n    }\n", "code2": "    private void tail(String[] cmd, int pos) throws IOException {\n        CommandFormat c = new CommandFormat(\"tail\", 1, 1, \"f\");\n        String src = null;\n        Path path = null;\n        try {\n            List<String> parameters = c.parse(cmd, pos);\n            src = parameters.get(0);\n        } catch (IllegalArgumentException iae) {\n            System.err.println(\"Usage: java FsShell \" + TAIL_USAGE);\n            throw iae;\n        }\n        boolean foption = c.getOpt(\"f\") ? true : false;\n        path = new Path(src);\n        FileSystem srcFs = path.getFileSystem(getConf());\n        if (srcFs.isDirectory(path)) {\n            throw new IOException(\"Source must be a file.\");\n        }\n        long fileSize = srcFs.getFileStatus(path).getLen();\n        long offset = (fileSize > 1024) ? fileSize - 1024 : 0;\n        while (true) {\n            FSDataInputStream in = srcFs.open(path);\n            in.seek(offset);\n            IOUtils.copyBytes(in, System.out, 1024, false);\n            offset = in.getPos();\n            in.close();\n            if (!foption) {\n                break;\n            }\n            fileSize = srcFs.getFileStatus(path).getLen();\n            offset = (fileSize > offset) ? offset : fileSize;\n            try {\n                Thread.sleep(5000);\n            } catch (InterruptedException e) {\n                break;\n            }\n        }\n    }\n", "label": 0, "substitutes": {"encryptPassword": [" encryptedPass", "enccryptPass", "encryptedRequest", "encryptpassword", "encryptedpassword", "enccryptPassword", "encipherPassword", "encryptRequest", "encryptedPassword", " encryptpassword", "encipherRequest", "encryptedPass", "enccryptRequest", " encryptRequest", "encipherpassword", " encryptedPassword", " encryptedpassword", " encryptedRequest", " encryptPass", "encryptPass", "enccryptpassword", "encipherPass"], "passwordString": ["PasswordStr", "passPassword", "passwordstring", "databaseStr", "passwordUTF", "passString", "passText", "PasswordPassword", "databasePassword", "phraseText", "passwordText", " passwordstring", "passUTF", "databasestring", " passwordText", "databaseString", "phrasePassword", "phraseUTF", " passwordUTF", "passwordPassword", " passwordStr", " passwordPassword", "phraseString", "PasswordString", "passwordStr", "Passwordstring"], "digest": ["dested", "dester", "redist", "mingest", "dgest", "redester", " digse", "digist", "decest", "diggest", "dest", "hashester", "Digate", "digate", "minse", "decate", "digse", "diffested", "Digester", "minested", "diffest", "diffgest", "Digse", "digEST", "Diggest", "decEST", " digist", "hashse", "Digist", "diffester", "redest", "hashested", " digester", "Digested", "hashest", "decested", "minest", " digate", "dse", " digEST", "digested", "redEST", "digester", "DigEST", " digested", "Digest"], "raw": ["all", "buf", "json", "random", "known", "serial", "custom", "clean", "box", "mem", "buffer", "message", "result", "available", "unsigned", "sh", "input", "out", "valid", "des", "was", "hex", " Raw", "aw", "hook", "RAW", " RAW", "bar", "full", "local", "row", "core", "n", "Raw", "password", "bytes", "bare", "w"], "hash": ["ashes", "ashed", "handle", "mask", "json", "tr", "ash", "Hash", "serial", "h", "bh", "sum", "tag", "sha", "shadow", "ASH", "cert", "message", "sh", "name", "hed", "hidden", "token", "has", "total", "sign", "hex", "search", "height", "proof", "href", "key", "html", "mac", "ssh", "password", "check", "id", "user", "print"]}}
{"id1": "6341264", "id2": "9347451", "code1": "    public static byte[] getJarEntry(String jarName, String entry, int port) {\n        byte[] b = null;\n        try {\n            String codebase = System.getProperty(\"java.rmi.server.codebase\", InetAddress.getLocalHost().getHostName());\n            String protocol = \"http://\";\n            int x = codebase.indexOf(protocol) + protocol.length();\n            String s2 = codebase.substring(x);\n            int x2 = s2.indexOf('/');\n            String downloadHost = s2.substring(0, x2);\n            if (downloadHost.indexOf(':') == -1) {\n                downloadHost += \":\" + port;\n            }\n            URL url = new URL(\"jar:http://\" + downloadHost + \"/\" + jarName + \"!/\" + entry);\n            JarURLConnection jurl = (JarURLConnection) url.openConnection();\n            JarEntry je = jurl.getJarEntry();\n            InputStream is = jurl.getInputStream();\n            BufferedInputStream bis = new BufferedInputStream(is);\n            int size = (int) je.getSize();\n            b = new byte[size];\n            int rb = 0;\n            int chunk = 0;\n            while ((size - rb) > 0) {\n                chunk = bis.read(b, rb, size - rb);\n                if (chunk == -1) {\n                    break;\n                }\n                rb += chunk;\n            }\n            bis.close();\n            is.close();\n            bis = null;\n            is = null;\n            url = null;\n            jurl = null;\n        } catch (UnknownHostException e) {\n            e.printStackTrace();\n            return null;\n        } catch (IOException e) {\n            e.printStackTrace();\n            return null;\n        }\n        return b;\n    }\n", "code2": "    public void writeData(String name, int items, int mzmin, int mzmax, long tstart, long tdelta, int[] peaks) {\n        PrintWriter file = getWriter(name + \".txt\");\n        file.print(\"Filename\\t\");\n        file.print(\"Date\\t\");\n        file.print(\"Acquisition #\\t\");\n        file.print(\"\ufffdm Diameter\\t\");\n        for (int i = mzmin; i <= mzmax; i++) file.print(i + \"\\t\");\n        file.println();\n        int nothing = 0;\n        String fileLoc = \"C:/abcd/\" + name + \".txt\\t\";\n        Date tempDate;\n        for (int i = 0; i < items; i++) {\n            tempDate = new Date(tstart);\n            tstart += tdelta;\n            file.print(fileLoc);\n            file.print(dateFormat.format(tempDate) + \"\\t\");\n            file.print(i + 1 + \"\\t\");\n            double t = (double) (i) / 10;\n            file.print(t + \"\\t\");\n            boolean peaked = false;\n            for (int k = mzmin; k <= mzmax; k++) {\n                for (int j = 0; j < peaks.length && !peaked; j++) {\n                    if (k == peaks[j]) {\n                        file.print(peakVals[j % peakVals.length] + \"\\t\");\n                        peaked = true;\n                    }\n                }\n                if (!peaked) {\n                    if (k == mzmax) file.print(nothing); else file.print(nothing + \"\\t\");\n                }\n                peaked = false;\n            }\n            file.println();\n        }\n        try {\n            Scanner test = new Scanner(f);\n            while (test.hasNext()) {\n                System.out.println(test.nextLine());\n            }\n            System.out.println(\"test\");\n        } catch (Exception e) {\n        }\n        file.close();\n    }\n", "label": 0, "substitutes": {"getJarEntry": ["getJavaEntry", "getServerInfo", "getFileInfo", "getModuleItem", " getJarResource", "getJarInfo", " getJarItem", "getZipFile", "getJavaItem", " getZipItem", "getJarResource", " getJarInfo", " getJarFile", "getJavaFile", "getFileItem", "getJarFile", "getZipEntry", " getJarEnt", "getServerResource", "getModuleEntry", "getJavaEnt", "getResourceItem", "getModuleFile", " getFileEntry", " getFileResource", "getJarItem", "getJarEnt", " getFileInfo", "getResourceEntry", "getZipItem", " getZipEnt", "getServerItem", " getFileItem", "getServerEntry", " getZipEntry", " getZipFile", "getResourceInfo", "getFileEntry", "getModuleEnt", "getZipEnt", "getResourceResource", "getFileResource"], "jarName": [" jarKey", "JarLocal", "JarN", "jobName", "jobN", "jarN", "jarLocal", " jarLocal", "binaryName", "jarname", " jarN", "JarName", "jarKey", "sessionKey", "Jarname", " jarname", "jobLocal", "jobname", "binaryKey", "sessionname", "binaryname", "sessionName"], "entry": ["address", "text", "element", "ie", "comment", "word", "resource", "description", "command", "log", "jar", "cell", "xml", "e", "uri", "name", "archive", "input", "ent", "ry", "query", "data", "search", "path", "enter", "zip", "Entry", "key", "row", "string", "er", "field", "server", "file", "quit", "index", "print", "delete"], "port": ["type", "export", "Port", "address", "value", "page", "limit", "connection", "priority", "format", "pc", "position", "pt", "localhost", "pos", "age", "it", "offset", "project", "path", "point", "PORT", "length", "ports", "ip", "count", "row", "key", "string", "ort", "socket", "remote", "width", "eport", "start", "server", "version", "index", "p", "host"], "b": ["u", "f", "buf", "bt", "sb", "pb", "B", "j", "p", "bf", "br", "y", "bl", "buff", "bit", "cb", "d", "ob", "h", "bs", "wb", "base", "bas", "be", "buffer", "bi", "bits", "c", "bb", "db", "emb", "v", "i", "e", "bin", "nb", "bp", "ba", "l", "eb", "s", "mb", "r", "xb", "fb", "gb", "ib", "a", "ab"], "codebase": ["Codebas", "corefile", " codebased", "linkBase", "Codespace", "Codefile", "cebase", "Codease", "cebased", "corebase", "codefile", "Codebased", "CodeBase", "chebase", "codeBase", "codease", "linkbas", "codebased", "chespace", "linkbase", "cease", "corespace", " codeBase", " codebas", "Codebase", "ceBase", "cheBase", "codebas", "coreBase", "codespace", "chefile", " codease"], "protocol": ["phyication", "protication", "proos", "pronocol", "pertocol", "cryptos", "patocol", "protol", "patol", "proocol", "cryptility", "proavior", "pronavior", "cryptix", "cryptotype", "scheication", "pronotype", "protos", "proicle", "scheix", "cryptication", "prootype", "pertavior", "scheocol", "cryptol", "phyocol", "pertotype", "proticle", "phyix", "pronicle", "prototype", "scheility", "cryptocol", "prool", "phyility", "patos", "perticle", "protavior", "protix", "protility", "patotype"], "x": ["xs", "xa", "z", "y", "X", "tx", "ax", "ux", "inx", "w", "nex", "mx", "t", "wx", "xy", "max", "xx", "i", "xc", "ox", "xxxxxxxx", " cx", "xi", "rx", "xes", "dx", "n", "xp", "xd", "index", "px", "p", "xf", "ix", "ex"], "s2": ["ps1", "es2", " s1", "s02", "ts4", "estwo", "ts3", "es1", "ps02", "sv02", "slt", "svtwo", "x1", "ts02", "ss4", "ss02", "s1", "pslt", " slt", "ts2", " stwo", "x02", "s4", "ss3", " s02", "s3", "ps2", "ss2", "xlt", "sv2", "es02", "stwo", "sv1"], "x2": [" x02", "rx02", "ix02", "ax3", "rx2", "x1", " x1", "ex02", "x02", "ax02", "x3", "ix1", "rx1", "ex3", "ex2", "ix2", "ex1", "ax1", "ax2", " x3"], "downloadHost": ["transferhost", "DownloadDomain", "dumphost", "dumpUrl", "DownloadPort", "downloadUrl", "transferHost", "archiveHead", " downloadhost", "DownloadPath", "dumpNode", " downloadNode", " downloadDomain", "downloadHead", "transferPort", "downloadPort", "dumpDomain", "DownloadHead", " downloadPath", "downloadNode", " downloadUrl", " downloadPort", "archiveUrl", "DownloadHost", "dumpHost", "DownloadNode", "archiveHost", "transferUrl", "downloadDomain", "archivehost", "downloadPath", "DownloadUrl", " downloadHead", "downloadhost", "dumpPath", "Downloadhost"], "url": ["browser", "hl", "gl", "sb", "ref", "json", "dl", "ob", "obj", "lb", "www", "bel", "ls", "web", "ll", "base", "link", "pl", "build", "sl", "open", "log", "call", "lr", "jar", "rel", "ur", "mount", "uri", "URL", "serv", "name", "str", "rl", "l", "nl", "ul", "mail", "ssl", "el", "ret", "zip", "http", "arl", "download", "atl", "mil", "file", "loc", "il", "Url", "ml"], "jurl": ["zgl", " jll", "jcname", "jarkl", " jgl", "jcUrl", "jjurl", "jll", "jURL", "jarurl", "jpUrl", "jckl", "jarname", "zll", " jUrl", "jssl", "JUrl", "jUrl", "jsUrl", " jsl", "jpsl", "jjob", "jsjob", "jjjob", "Jurl", "jpgl", "jsURL", "Jkl", " jjob", "jjUrl", "jsl", "jname", " jURL", "jpurl", "jjURL", "jcurl", "jsurl", "jsll", "zurl", "zUrl", "jarUrl", "Jname", "jkl", "jgl", "jsgl"], "je": ["ze", "pet", "dj", "j", "ie", "oe", "ee", "js", "se", "ei", " Je", "zy", "jl", "jet", "nex", "ae", "ve", "jj", "exe", "ffe", "vre", "zo", "bj", "e", "ja", "sec", "jo", "jen", "ele", "ge", "ese", "zip", "te", "jp", "elt", "ne", "pe"], "is": ["mi", "sb", "ois", "ist", "ins", "Is", "im", "js", "ri", "nis", "fs", "bs", "isa", "ais", "in", "tis", "bi", "bits", "ai", "ires", "i", "its", "ris", "os", "IS", "atis", "isc", "ir", "isl", "si", "lis", "obs", "s", "ists", "ii", "isi", "ios", "\u00eds", "isin", "iso", "iss", "il", "ib", "es", "sis"], "bis": ["sb", "ses", "buff", "res", "oss", "cb", "ins", "ob", "nis", "ri", "bps", "bh", "fr", "fs", "bs", "rison", "sbm", "ls", "ais", "conv", "ns", "tis", "bi", "bits", "pins", "xy", "bb", "its", "abin", "serv", "ris", "rs", "os", "bos", "bes", "ibe", "gs", "obs", "lis", "binary", "aos", "rots", "ubis", "onis", "vs", "uds", "bil", "isin", "oi", "isi", "ios", "es", "bytes", "uffy"], "size": ["ze", "type", "empty", "year", "iz", "notice", "settings", "small", "sample", "time", "capacity", "score", "storage", "area", "se", "sum", "status", "sex", "range", "ose", "shape", "message", "max", "re", "mode", "number", "sv", "scroll", "name", "now", "zie", "pi", "SIZE", "len", "length", "space", "si", "news", "sn", "num", "sy", "use", "nr", "count", "n", "scale", "Size", "send", "body", "index", "ize", "unit"], "rb": ["buf", "buster", "rc", "bone", "rar", "rss", "sb", "br", "RB", "pb", "ord", "ref", "rt", "rab", "mr", "rg", "cb", "ob", "rw", "cr", "ri", "lb", "umb", "ro", "ring", "wb", "err", "ctr", "bb", "lr", "db", "rm", "bp", "rd", "ptr", "nb", "rf", "kb", "rs", "ru", "rid", "eb", "rod", "num", "r", "nr", "rex", "erb", "rob", "xb", "ruby", "fb", "gb"], "chunk": ["tchunk", "cpork", "echunk", "Chunks", "chunks", "cpow", "Chunk", "cunk", "chbyte", "charord", "echbyte", "tchunks", "echord", "chedunk", "cow", "ichunks", "cpunks", "chulk", " chunks", "echunks", "chork", " choint", " chord", " chbyte", "cpunk", "charbyte", "charoint", "ichunk", "tchork", "chow", "chedump", "ichulk", " chulk", "charunk", "charunks", "chedoint", "Chulk", "choint", "cork", "chedunks", " chump", "charump", "chump", "chord", "cunks", "tchow"]}}
{"id1": "6906419", "id2": "3187685", "code1": "    public static String encryptPassword(String password) {\n        try {\n            MessageDigest digest = java.security.MessageDigest.getInstance(\"SHA1\");\n            digest.update(password.getBytes(\"UTF-8\"));\n            byte[] hash = digest.digest();\n            StringBuffer buf = new StringBuffer();\n            for (int i = 0; i < hash.length; i++) {\n                int halfbyte = (hash[i] >>> 4) & 0x0F;\n                int two_halfs = 0;\n                do {\n                    if ((0 <= halfbyte) && (halfbyte <= 9)) {\n                        buf.append((char) ('0' + halfbyte));\n                    } else {\n                        buf.append((char) ('a' + (halfbyte - 10)));\n                    }\n                    halfbyte = hash[i] & 0x0F;\n                } while (two_halfs++ < 1);\n            }\n            return buf.toString();\n        } catch (Exception e) {\n        }\n        return null;\n    }\n", "code2": "    private void copyJar(File src, File dst) throws IOException {\n        FileChannel srcChannel = null;\n        FileChannel dstChannel = null;\n        try {\n            srcChannel = new FileInputStream(src).getChannel();\n            dstChannel = new FileOutputStream(dst).getChannel();\n            dstChannel.transferFrom(srcChannel, 0, srcChannel.size());\n        } catch (IOException e) {\n            fLog.log(Level.SEVERE, e.getMessage(), e);\n        } finally {\n            srcChannel.close();\n            dstChannel.close();\n        }\n    }\n", "label": 0, "substitutes": {"encryptPassword": ["decryptPass", "encryptString", "encryptionString", "decryptString", "enccryptPass", "encryptpassword", "encryptedpassword", "decryptedPassword", "enccryptPassword", "decryptpassword", "decryptedString", "encryptionPassword", "encryptedPassword", "encryptionPass", "decryptedpassword", "encryptedPass", "encryptedString", "encryptionpassword", "enccryptString", "decryptedPass", "encryptPass", "enccryptpassword", "decryptPassword"], "password": ["phrase", "address", "value", "text", "default", "reset", "email", "hello", "word", "description", "secret", "shadow", "command", "attribute", "Password", "message", "wd", "wordpress", "name", "token", "input", "login", "auth", "sword", "database", "pattern", "padding", "key", "string", "user", "username", "print", "data", "prefix", "pass"], "digest": ["persester", "dested", " digse", "decest", "digist", "persest", "dest", "hashester", "hashEST", "decester", "digse", "Digester", "minested", "Digse", "digEST", "persested", "hashse", "Digist", "decested", "persist", " digester", "Digested", "hashest", "minester", "minest", "decse", "minist", "dse", " digEST", "digested", "digester", "dester", "DigEST", " digested", "Digest"], "hash": ["ashes", "ah", "report", "all", "handle", "hist", "mask", "address", "block", "stock", "ash", "her", "Hash", "match", "shift", "test", "h", "score", "share", "sum", "table", "esh", "here", "sha", "attribute", "hz", "have", "array", "cache", "sh", "alt", "hed", "square", "has", "total", "hex", "query", "history", "search", "height", "dig", "filter", "html", "oh", "rh", "where", "mac", "memory", "check", "map", "print", "host"], "buf": ["window", "txt", "cv", "usr", "block", "pb", "buff", "br", "img", "var", "bg", "func", "cb", "ob", "bo", "bh", "foo", "tmp", "bc", "agg", "conv", "box", "buffer", "pkg", "bag", "b", "printf", "fam", "db", "font", "off", "Buffer", "nb", "rb", "uf", "hung", "alph", "bu", "mu", "cmd", "np", "queue", "mb", "batch", "etc", "bar", "Buff", "forge", "msg", "cf", "cap", "pool", "fb", "vec"], "i": ["exp", "f", "mi", "major", "json", "u", "ini", "j", "ski", "y", "cli", "ie", "I", "qi", "di", "im", "ri", "ei", "slice", "m", "iq", "conv", "init", "x", "in", "t", "iu", "hi", "q", "ti", "bi", "c", "print", "b", "ic", "go", "ci", "multi", "ai", "sim", "to", "gi", "v", "ui", "e", "uri", "pi", "get", "it", "phi", "ji", "li", "xi", "\u0438", "my", "si", "point", "g", "ind", "ip", "zi", "info", "n", "key", "me", "io", "ii", "is", "oi", "index", "id", "a", "ix", "ex"], "halfbyte": ["halfpiece", " halfbuffer", "Halfpage", "halfpixel", "phypair", "phypiece", "Halfbytes", " halfletter", " halfcoin", " halfpixel", "phybytes", "Halfletter", "quarterchar", " halfnode", "Halfpiece", "halfletter", " halfpage", " halfpair", "quarterword", "halfnode", "quarterpair", "phychar", "halfbytes", "halfchar", "halfword", "phylen", "Halfbyte", "Halfnode", " halfchar", "Halfchannel", " halflen", "halfchannel", "halfpair", " halfchannel", "phypixel", "Halfword", " halfbytes", "quarterbyte", " halfword", "quarterletter", "halfcoin", "Halfpixel", "quarterpixel", "leftnode", "leftchar", "quarterchannel", "Halfcoin", "quartercoin", "halfpage", "quarterpage", "halflen", "leftbuffer", "halfbuffer", "Halfbuffer", " halfpiece", "Halfchar", "quarterlen", "leftbyte", "phybyte"], "two_halfs": ["two_roundls", "two_enthalsets", "two_shakes", "two_turnls", "two_leds", "two_enthalss", "two_enthalisters", "two_ledsets", "two_roundi", "two_halfls", "two_parenls", "two_ledss", "two_halfups", "two_turns", "two_turnups", "two_parenups", "two_rounds", "two_halfss", "two_halfsets", "two_shakeisters", "two_shakesets", "two_halfisters", "two_shakess", "two_roundups", "two_enthals", "two_halfi", "two_pareni", "two_parens", "two_turni", "two_ledisters"]}}
{"id1": "3683344", "id2": "12106167", "code1": "    private static String genRandomGUID(boolean secure) {\n        String valueBeforeMD5 = \"\";\n        String valueAfterMD5 = \"\";\n        MessageDigest md5 = null;\n        StringBuffer sbValueBeforeMD5 = new StringBuffer();\n        try {\n            md5 = MessageDigest.getInstance(\"MD5\");\n        } catch (NoSuchAlgorithmException e) {\n            System.out.println(\"Error: \" + e);\n            return valueBeforeMD5;\n        }\n        long time = System.currentTimeMillis();\n        long rand = 0;\n        if (secure) {\n            rand = mySecureRand.nextLong();\n        } else {\n            rand = myRand.nextLong();\n        }\n        sbValueBeforeMD5.append(s_id);\n        sbValueBeforeMD5.append(\":\");\n        sbValueBeforeMD5.append(Long.toString(time));\n        sbValueBeforeMD5.append(\":\");\n        sbValueBeforeMD5.append(Long.toString(rand));\n        valueBeforeMD5 = sbValueBeforeMD5.toString();\n        md5.update(valueBeforeMD5.getBytes());\n        byte[] array = md5.digest();\n        String strTemp = \"\";\n        for (int i = 0; i < array.length; i++) {\n            strTemp = (Integer.toHexString(array[i] & 0XFF));\n            if (strTemp.length() == 1) {\n                valueAfterMD5 = valueAfterMD5 + \"0\" + strTemp;\n            } else {\n                valueAfterMD5 = valueAfterMD5 + strTemp;\n            }\n        }\n        return valueAfterMD5.toUpperCase();\n    }\n", "code2": "    public static void init(Locale lng) {\n        try {\n            Locale toLoad = lng != null ? lng : DEFAULT_LOCALE;\n            URL url = ClassLoader.getSystemResource(\"locales/\" + toLoad.getISO3Language() + \".properties\");\n            if (url == null) {\n                url = ClassLoader.getSystemResource(\"locales/\" + DEFAULT_LOCALE.getISO3Language() + \".properties\");\n            }\n            PROPS.clear();\n            PROPS.load(url.openStream());\n        } catch (IOException ioe) {\n            try {\n                URL url = ClassLoader.getSystemResource(\"locales/\" + DEFAULT_LOCALE.getISO3Language() + \".properties\");\n                PROPS.clear();\n                PROPS.load(url.openStream());\n            } catch (Exception e) {\n                e.printStackTrace();\n                System.exit(99);\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n            System.exit(99);\n        }\n    }\n", "label": 0, "substitutes": {"genRandomGUID": [" genRandomUUID", " genRandUU", " genRandomRandomU", " genRandomSID", " genRandomGU", " genRandGU", " genRandUUID", " genRandomUU", " genRandGUID", " genRandomRandomuid", " genRandomRandomUID", " genRandomSuid", " genRandomGuid", " genRandUuid", " genRandGID", " genRandUID", " genRandomSU", " genRandomRandomID", " genRandomSUID", " genRandomUuid", " genRandomUID", " genRandGuid", " genRandomGID"], "secure": ["active", "protect", " Secure", "google", "sync", "ie", "deep", "free", "strong", "speed", "force", "sys", "https", "client", "status", "clear", "stable", " insecure", "nice", "sr", "close", "safe", "sec", "trust", "weak", " securely", "encrypted", "security", "confirmed", "quiet", "ssl", "domain", "Secure", "prime", "check", "id", "sensitive", "pretty", "server"], "valueBeforeMD5": ["valueUnderMM0", "valueBeforeMOD0", "valueBeforeMM25", "valueBeforeMDInvalid", "valueUnderMD25", "valueBeforeMD2", "valueBeforeRD5", "valueAfterMD523", "valueBeforeND2", "valueBeforeMOD2", "valueAfterMD0", "valueBeforeSHA5", "valueBeforeID5", "valueBeforeMOD5", "valueBeforeDER2", "valueAfterND3", "valueBeforeMT25", "valueBeforeRDInvalid", "valueBeforeDERFive", "valueBeforeID3", "valueBeforeMD3", "valueBeforeRD2", "valueBeforeSHA523", "valueUnderMM5", "valueBeforeID4", "valueAfterND4", "valueBeforeSHA2", "valueBeforeMT2", "valueAfterDER0", "valueAfterMDFive", "valueBeforeDER0", "valueBeforeRD523", "valueAfterDER2", "valueAfterDER5", "valueBeforeMD4", "valueBeforeMD523", "valueUnderMM25", "valueAfterMD3", "valueAfterDERFive", "valueBeforeMT0", "valueAfterND5", "valueBeforeMM0", "valueAfterMDInvalid", "valueBeforeND4", "valueAfterND2", "valueBeforeMD0", "valueBeforeMDFive", "valueAfterMD2", "valueAfterMD4", "valueBeforeMM5", "valueBeforeMT5", "valueBeforeID2", "valueBeforeMTFive", "valueBeforeND3", "valueBeforeMODFive", "valueBeforeDER5", "valueUnderMD0", "valueBeforeMD25", "valueUnderMD5", "valueBeforeND5", "valueBeforeND0", "valueBeforeSHAInvalid", "valueBeforeND25"], "valueAfterMD5": ["valueBeforeMC5", "valueWithoutMD5", "valueAfterMC8", "valueAfterSDRL", "valueWithoutmd2", "valueBeforeMM2", "valueAfterMM3", "valueAfterMD55", "valueAfterUD5", "valueBeforeMD2", "valueAfterMI2", "valueWithoutMDOK", "valueafterMDLeft", "valueBeforeMM3", "valueAftermdOK", "valueAfterMM2", "valueAfterMI5", "valueAftermdPE", "valueAfterEM55", "valueAfterUDRL", "valueAfterMTLeft", "valueAfterCDdown", "valueAfterMT2", "valueAfterSD5", "valueAfterMT8", "valueafterEM55", "valueAfterMC3", "valueAfterMT3", "valueBeforeMD3", "valueAfterMDOK", "valueBeforeMDdown", "valueBeforeMC2", "valueafterMD2", "valueAfterMM5", "valueAfterMDLeft", "valueAftermd2", "valueAfterMC4", "valueAfterMT5", "valueBeforeMM4", "valueAfterMDPE", "valueBeforeMD4", "valueAfterMIPE", "valueafterEMLeft", "valueWithoutmdPE", "valueAfterMCdown", "valueAfterMD3", "valueWithoutMDPE", "valueAfterMTdown", "valueAfterUDODY", "valueAfterCD5", "valueAfterEMLeft", "valueAfterEM2", "valueAfterMIOK", "valueWithoutmd5", "valueWithoutMD2", "valueWithoutmdOK", "valueAfterMD2", "valueAfterMD4", "valueBeforeMM5", "valueAfterUD3", "valueafterMD5", "valueBeforeMDODY", "valueafterMD55", "valueBeforeMCdown", "valueAfterSDODY", "valueAfterMT55", "valueAfterMC5", "valueBeforeMD8", "valueAfterMD8", "valueafterEM2", "valueAfterEM5", "valueAfterMDRL", "valueAfterMC2", "valueAfterSD3", "valueAfterMM4", "valueAftermd5", "valueBeforeMDRL", "valueAfterCD2", "valueAfterMDODY", "valueAfterMDdown", "valueafterEM5"], "md5": ["MD25", " md25", " MD2", "MD7", "MD2", "MD5", "MD3", " md3", "dig5", " md2", " MD3", "metadata5", "md7", " md7", "dig3", "metadata25", "md25", "metadata2", " MD7", "dig2", "md3", "md2", "metadata3", " MD5"], "sbValueBeforeMD5": ["sbValueBeforeMDNot", "sbValueAfterMD25", "sbValueBeforeMDFive", "sbValueDefmd5", "sbValueBeforeMON305", "sbValueAfterMDNot", "sbValueBeforePD5", "sbValueInsideAMD512", "sbValueInsideMD305", "sbValueAfterMD2", "sbValueBeforeMD3", "sbValueBeforeLM5", "sbValueBeforemd5", "sbValueBeforemdLE", "sbValueBeforeLM65", "sbValueBeforeMD05", "sbValueInsideAMD2", "sbValueBeforeAND2", "sbValueBeforeMT65", "sbValueDefMD45", "sbValueBeforeANDFive", "sbValueBeforeND2", "sbValueBeforeMOD3", "sbValueFrontLM5", "sbValueBeforeMD20", "sbValueBeforePDLE", "sbValueFrontLM2", "sbValueInsideMD2", "sbValueBeforeMED25", "sbValueAfterMD5", "sbValueFrontMD20", "sbValueDefMD2", "sbValueBeforeMED2", "sbValueBeforeMT20", "sbValueBeforeMDOK", "sbValueBeforeMD512", "sbValueInsideAMD305", "sbValueBeforeMON2", "sbValueAfterMD05", "sbValueAfterMD3", "sbValueDefmd45", "sbValueBeforeMOD5", "sbValueBeforemd45", "sbValueBeforeMDLE", "sbValueBeforePDOK", "sbValueBeforeMS3", "sbValueBeforeSD2", "sbValueBeforeSDNot", "sbValueBeforeMT05", "sbValueBeforeMT2", "sbValueBeforeAMD5", "sbValueInsideAMD5", "sbValueBeforeMD305", "sbValueBeforeMON5", "sbValueBeforeMD2", "sbValueAfterMDOK", "sbValueBeforeMED45", "sbValueBeforeAND5", "sbValueBeforeMTFive", "sbValueAfterMDFive", "sbValueBeforeMT5", "sbValueFrontMD65", "sbValueBeforemdOK", "sbValueBeforePD2", "sbValueAfterMDLE", "sbValueBeforeMED5", "sbValueBeforemd2", "sbValueBeforeMOD45", "sbValueBeforeSD5", "sbValueBeforeLM2", "sbValueFrontLM65", "sbValueBeforeND5", "sbValueBeforeAND05", "sbValueFrontLM20", "sbValueAfterMS5", "sbValueBeforeMS25", "sbValueAfterMD45", "sbValueBeforeMD25", "sbValueDefMD5", "sbValueBeforeMOD25", "sbValueFrontMD2", "sbValueAfterMS25", "sbValueBeforeMD65", "sbValueBeforeAMD305", "sbValueBeforeAMD512", "sbValueAfterMS3", "sbValueBeforeMED3", "sbValueInsideMD5", "sbValueBeforeMD45", "sbValueBeforeLM20", "sbValueBeforeMS45", "sbValueBeforeND45", "sbValueInsideMD512", "sbValueAfterMS45", "sbValueDefmd2", "sbValueFrontMD5", "sbValueBeforeAMD2", "sbValueBeforeMS5", "sbValueBeforeMON512", "sbValueBeforeMEDNot"], "time": ["event", "times", "ime", "window", "year", "value", "lock", "runtime", "frame", "Time", "hour", "sequence", "TIME", "t", "port", "date", "ts", "timer", "system", "counter", "name", "now", "race", "total", "etime", "age", "ty", "order", "rate", "length", "estamp", "clock", "tc", "tim", "start", "size", "timeout", "user", "id", "duration"], "rand": ["rc", "nt", "rss", "gz", "roll", "and", "z", "res", "sample", "random", "rt", "ng", "pid", "cr", "sys", "init", "rank", "sid", "range", "rest", "round", "md", "mid", "max", "dr", "reg", "rd", "kick", "pick", "ripp", "trust", "hash", "std", "rid", "rot", "gt", "rate", "Rand", "seed", "uid", "r", "grad", "inv", "did", "fine", "dist", "with", "rh", "id", "frac", "nd"], "array": ["ashes", "value", " Array", "var", "vector", "ash", "assets", "random", "rays", "storage", "area", "share", "ami", "app", "aster", "range", "stack", "list", "v", "number", "angular", "archive", "external", "hash", "ary", "stage", "upper", "audio", "length", "aw", "at", "binary", "amount", "batch", "instance", "ray", "collection", "Array", "atomic", "row", "string", "RAY", "our", "save", "arr", "arrow", "map", "angle", "data"], "strTemp": ["strMods", "strNew", "strTem", "arrPtr", "STRtemp", "stringPtr", "drPtr", "frPtr", " strTr", "stringTest", "strCmd", "strUnt", "brTemplate", "hexTem", "frTem", "drTemp", "hexTemp", "arrNew", "strTr", "STRTemp", "txtTem", "stringTem", "STRNew", " strNew", "drMods", "frTemp", "arrTem", "strTest", " strtemp", "arrUnt", " strTem", "brTem", "stringUnt", " strCmd", "stringMods", " strUnt", "arrTemp", "drTem", "frTemplate", "strTemplate", "brTemp", "strtemp", " strTemplate", "arrTest", "stringTemp", "hexTr", "arrtemp", " strTest", "STRTem", "txtTemp", "strPtr", "txtCmd", "hexCmd", "txtTr", "brPtr", " strPtr", "arrMods"], "i": ["mi", "u", "j", "ini", "us", "y", "ogi", "I", "qi", "di", "im", "ei", "m", "iq", "ki", "yi", "init", "x", "in", "hi", "ti", "chain", "q", "bi", "c", "b", "ic", "cli", "ci", "multi", "ai", "sim", "gi", "v", "ui", "uri", "name", "pi", "ix", "it", "ji", "li", "xi", "\u0438", "si", "ind", "num", "info", "gu", "ii", "index", "id", "a", "phi"]}}
{"id1": "16511008", "id2": "9109613", "code1": "    public ProgramProfilingMessageSymbol createNewProfilingMessageSymbol(int configID, int programMessageSymbolID) throws AdaptationException {\n        ProgramProfilingMessageSymbol profilingMessageSymbol = null;\n        Connection connection = null;\n        Statement statement = null;\n        ResultSet resultSet = null;\n        try {\n            String query = \"INSERT INTO ProgramProfilingMessageSymbols\" + \"(projectDeploymentConfigurationID, programMessageSymbolID)\" + \" VALUES (\" + configID + \", \" + programMessageSymbolID + \")\";\n            connection = DriverManager.getConnection(CONN_STR);\n            statement = connection.createStatement();\n            statement.executeUpdate(query);\n            query = \"SELECT * FROM ProgramProfilingMessageSymbols WHERE \" + \"projectDeploymentConfigurationID = \" + configID + \" AND \" + \"programMessageSymbolID           = \" + programMessageSymbolID;\n            resultSet = statement.executeQuery(query);\n            if (!resultSet.next()) {\n                connection.rollback();\n                String msg = \"Attempt to create program profiling message \" + \"symbol failed.\";\n                log.error(msg);\n                throw new AdaptationException(msg);\n            }\n            profilingMessageSymbol = getProfilingMessageSymbol(resultSet);\n            connection.commit();\n        } catch (SQLException ex) {\n            try {\n                connection.rollback();\n            } catch (Exception e) {\n            }\n            String msg = \"SQLException in createNewProfilingMessageSymbol\";\n            log.error(msg, ex);\n            throw new AdaptationException(msg, ex);\n        } finally {\n            try {\n                resultSet.close();\n            } catch (Exception ex) {\n            }\n            try {\n                statement.close();\n            } catch (Exception ex) {\n            }\n            try {\n                connection.close();\n            } catch (Exception ex) {\n            }\n        }\n        return profilingMessageSymbol;\n    }\n", "code2": "    public static void fileCopy(String from_name, String to_name) throws IOException {\n        File fromFile = new File(from_name);\n        File toFile = new File(to_name);\n        if (fromFile.equals(toFile)) abort(\"cannot copy on itself: \" + from_name);\n        if (!fromFile.exists()) abort(\"no such currentSourcepartName file: \" + from_name);\n        if (!fromFile.isFile()) abort(\"can't copy directory: \" + from_name);\n        if (!fromFile.canRead()) abort(\"currentSourcepartName file is unreadable: \" + from_name);\n        if (toFile.isDirectory()) toFile = new File(toFile, fromFile.getName());\n        if (toFile.exists()) {\n            if (!toFile.canWrite()) abort(\"destination file is unwriteable: \" + to_name);\n        } else {\n            String parent = toFile.getParent();\n            if (parent == null) abort(\"destination directory doesn't exist: \" + parent);\n            File dir = new File(parent);\n            if (!dir.exists()) abort(\"destination directory doesn't exist: \" + parent);\n            if (dir.isFile()) abort(\"destination is not a directory: \" + parent);\n            if (!dir.canWrite()) abort(\"destination directory is unwriteable: \" + parent);\n        }\n        FileInputStream from = null;\n        FileOutputStream to = null;\n        try {\n            from = new FileInputStream(fromFile);\n            to = new FileOutputStream(toFile);\n            byte[] buffer = new byte[4096];\n            int bytes_read;\n            while ((bytes_read = from.read(buffer)) != -1) to.write(buffer, 0, bytes_read);\n        } finally {\n            if (from != null) try {\n                from.close();\n            } catch (IOException e) {\n                ;\n            }\n            if (to != null) try {\n                to.close();\n            } catch (IOException e) {\n                ;\n            }\n        }\n    }\n", "label": 0, "substitutes": {"createNewProfilingMessageSymbol": ["createNewProfilingMsgSchembol", "createNewProfilingMessageSchentax", "createNewProfilingMessageCymbol", "createNewProfilingMsgSymbol", "createNewProfilingMessageSyntax", "createNewProfilingMessagesymbol", "createNewProfilingMessagesyntax", "createNewProfilingMessageCyntax", "createNewProfilingMessageSchembol", "createNewProfilingMsgSyntax", "createNewProfilingMsgSchentax"], "configID": ["configURI", "componentId", "confId", "ConfigML", " configPK", "configIDs", "caseID", "confIDs", "configOR", " configURI", "componentOR", "caseML", "ConfigURL", " configOR", "caseURL", " configURL", "confID", " configid", "configURL", "confPK", " configIDs", "componentPK", "componentID", "Configid", "cfgID", " configML", "ConfigID", "configid", "configPK", "cfgId", "cfgURI", "configId", " configId", "cfgIDs", "caseid", "configML", "confOR", "confURI"], "programMessageSymbolID": ["programMessageSymbolValue", "programMessageSyptionid", "programMessageSyElementID", "programMessageSyTypeName", "programMessageSyTypeId", "programMessageSyElementName", "programMessageSyptionName", "programMessageSyptionId", "programMessageSymbolN", "programMessageSyrorID", "programMessageSymbId", "programMessageSymmbolN", "programMessageSyElementValue", "programMessageSySyID", "programMessageSymmbolId", "programMessageSymbolId", "programMessageSymbolIDs", "programMessageSyTypeID", "programMessageSyptionID", "programMessageSyrorIDs", "programMessageSymbolName", "programMessageSyrorN", "programMessageSymbN", "programMessageSyrorId", "programMessageSySyId", "programMessageSymbolid", "programMessageSymmbolName", "programMessageSymmbolValue", "programMessageSyTypeValue", "programMessageSySyid", "programMessageSymmbolIDs", "programMessageSyElementId", "programMessageSySyName", "programMessageSymbID", "programMessageSymmbolid", "programMessageSymmbolID", "programMessageSymbIDs"], "profilingMessageSymbol": ["profilingMessageSyntax", "profilingMessageSysols", "profilingMessageSymols", "profilingMessageCyavior", "profilingMessageSymmb", "profilingMsgSymbol", "profilingMessageSysmb", "profilingMessageSYmb", "profilingMessageSyse", "profilingMessageSymavior", "profilingMessageSymmbol", "profilingMessageSymb", "profilingMessageSyavior", "profilingMsgSyavior", "profilingMsgSymmbol", "profilingMessagePyntax", "profilingMessageSyols", "profilingMessageCymbol", "profilingMessagesyols", "profilingMessageSymntax", "profilingMessageSymse", "profilingMsgSyntax", "profilingMsgSymntax", "profilingMessagePyavior", "profilingMessagesyse", "profilingMessagesymb", "profilingMessageSYmbol", "profilingMessageCyntax", "profilingMsgSymavior", "profilingMessageSysmbol", "profilingMessagesymbol", "profilingMessageSYse", "profilingMessagePymbol"], "connection": ["ion", "generation", "response", "reference", "subject", "settings", "con", "connected", "entry", "operation", "character", "city", "engine", "bo", "resource", "application", "client", "sequence", "table", "context", "library", "module", "directory", "ce", "link", "command", "we", "associated", "open", "function", "device", "document", "current", "system", "db", "close", "information", "condition", "position", "writer", "Connection", "initial", "cone", "note", "handler", "conn", "created", "network", "line", "collection", "connect", "database", "relation", "channel", "volume", "usage", "config", "socket", "communication", "server", "session", "established"], "statement": ["phrase", "rule", "report", "resource", "linger", "response", "reference", "subject", " Statement", "policy", "sp", "comment", "mt", "execute", "storage", "stan", "se", "application", "sequence", "processor", "description", "set", "t", "library", "template", "directory", "ment", "command", "chain", "function", "management", "document", "message", "journal", "EMENT", "list", "state", "condition", "position", "bind", "stat", "sql", "note", "parse", "language", "network", "instance", "Statement", "database", "relation", "session", "activity", "volume", "usage", "shell", "memory", "print", "expression"], "resultSet": ["traceset", "ResultScan", " resultList", "resultScan", "resultset", "recordset", " resultset", "resultS", "recordSet", "eventList", "resultPath", "resultRow", "ResultS", " resultRow", "ResultPath", "traceList", "ResultHandle", "ResultSource", "ResultList", " resultSource", "eventSet", "rowList", " resultS", "recordList", "resultList", "rowSet", "rowRow", "traceSource", "resultHandle", "rowset", "ResultSet", " resultScan", "rowHandle", "recordHandle", "traceSet", " resultPath", "eventPath", "resultSource", "rowScan", "rowS", "ResultRow", "eventset", "Resultset"], "query": ["ion", "transform", "scan", "lock", "find", "select", "test", "QU", "comment", "request", "execute", "sequence", "create", "sum", "quest", "table", "how", "gate", "init", "script", "sq", "menu", "q", "command", "print", "spec", "scope", "code", "message", "call", "join", "eries", "content", "read", "Query", "condition", "get", "ql", "commit", "sql", "note", "search", "parse", "show", "question", "qu", "volume", "string", "quote", "key", "where", "password", "send", "check", "update", "ERY", "expression", "title"], "msg": ["txt", "nm", "sm", "text", "notice", "cmp", "bg", "comm", "mt", "m", "doc", "sum", "reason", "mess", "mun", "mem", "char", "sg", "mg", "md", "log", "pkg", "err", "man", "em", "message", "rup", "ged", "kg", "ung", "Msg", "req", "e", "ext", "mag", "name", "str", "error", "meg", "gm", "cmd", "sql", "note", "mail", "gs", "mu", "term", "nom", "mb", "g", "og", "cfg", "warn", "mn", "gr", "html", "gem", "med", "gen", "title", "ex"]}}
{"id1": "2676365", "id2": "7468819", "code1": "    public void reset(int currentPilot) {\n        try {\n            PreparedStatement psta = jdbc.prepareStatement(\"DELETE FROM component_prop \" + \"WHERE pilot_id = ? \");\n            psta.setInt(1, currentPilot);\n            psta.executeUpdate();\n            jdbc.commit();\n        } catch (SQLException e) {\n            jdbc.rollback();\n            log.debug(e);\n        }\n    }\n", "code2": "        public void run() {\n            try {\n                HttpURLConnection con = (HttpURLConnection) url.openConnection();\n                con.setRequestMethod(\"GET\");\n                con.setDoInput(true);\n                byte[] encodedPassword = (username + \":\" + password).getBytes();\n                BASE64Encoder encoder = new BASE64Encoder();\n                con.setRequestProperty(\"Authorization\", \"Basic \" + encoder.encode(encodedPassword));\n                InputStream is = con.getInputStream();\n                BufferedReader rd = new BufferedReader(new InputStreamReader(is));\n                String line;\n                StringBuffer response = new StringBuffer();\n                while ((line = rd.readLine()) != null) {\n                    response.append(line);\n                    response.append('\\n');\n                    lastIteraction = System.currentTimeMillis();\n                }\n                rd.close();\n                is.close();\n                con.disconnect();\n                result = response.toString();\n                finish = true;\n            } catch (Throwable e) {\n                this.e = e;\n            }\n        }\n", "label": 0, "substitutes": {"reset": ["report", "flush", "release", "stop", "request", "remove", "clean", "set", "kill", "clear", "init", "command", "write", "replace", "ping", "alert", "close", "touch", "kick", "state", "exit", "destroy", "register", "config", "save", "quit", "update", "delete", "setup"], "currentPilot": ["currentpolly", "currentCane", " currentPane", "currentClan", "currentpolt", " currentPortane", "currentCail", "currentPane", " currentPortail", "currentPortane", "currentNlan", " currentPolly", " currentPortolly", "currentPortolly", "currentNane", "currentPortlan", "currentpail", "currentPortolt", "currentNail", " currentPolt", "currentPolt", " currentPortilot", " currentPlan", " currentPail", " currentPortlan", " currentPortolt", "currentCilot", "currentPail", "currentPolly", "currentPlan", "currentPortilot", "currentpilot", "currentPortail", "currentNilot"], "psta": ["Psa", "ppstan", "apstan", "pesta", "ppsa", "Pstan", "Pesta", "apsta", "pstan", "apsa", "psa", "ppsta", " psha", "apesta", "psha", "ppesta", " psa", "apsha", " pstan", "Psta", "Psha", " pesta"]}}
{"id1": "9275622", "id2": "22264586", "code1": "    private boolean copyFile(File _file1, File _file2) {\n        FileInputStream fis;\n        FileOutputStream fos;\n        try {\n            fis = new FileInputStream(_file1);\n            fos = new FileOutputStream(_file2);\n            FileChannel canalFuente = fis.getChannel();\n            canalFuente.transferTo(0, canalFuente.size(), fos.getChannel());\n            fis.close();\n            fos.close();\n            return true;\n        } catch (FileNotFoundException e) {\n        } catch (IOException e) {\n        }\n        return false;\n    }\n", "code2": "    private static void copyFiles(String strPath, String dstPath) throws Exception {\n        File src = new File(strPath);\n        File dest = new File(dstPath);\n        if (src.isDirectory()) {\n            dest.mkdirs();\n            String list[] = src.list();\n            for (int i = 0; i < list.length; i++) {\n                String dest1 = dest.getAbsolutePath() + \"\\\\\" + list[i];\n                String src1 = src.getAbsolutePath() + \"\\\\\" + list[i];\n                copyFiles(src1, dest1);\n            }\n        } else {\n            FileChannel sourceChannel = new FileInputStream(src).getChannel();\n            FileChannel targetChannel = new FileOutputStream(dest).getChannel();\n            sourceChannel.transferTo(0, sourceChannel.size(), targetChannel);\n            sourceChannel.close();\n            targetChannel.close();\n        }\n    }\n", "label": 1, "substitutes": {"copyFile": [" cpfile", "copyFiles", " copyfile", " copyStream", " duplicatefile", " duplicateFiles", " cpFile", " duplicateFile", "copyStream", "copyfile", " copyFiles", " cpFiles", " cpStream", " duplicateStream"], "_file1": ["_FileInit", "_files1", "_ileOne", "_fileOne", "_linkInit", "_link2", "_fileInit", "_files2", "_link1", "_ile2", "_ileInit", "_File2", "_ile1", "_FileFirst", "_linkOne", "_File1", "_ileFirst", "_FileOne", "_filesOne", "_fileFirst", "_filesFirst"], "_file2": [" _file02", "_FILEb", "_FILE1", "_File02", "_file02", "_Fileb", "_image1", "_link2", "_linkTwo", "_link1", " _fileb", "_File2", " _File1", "_fileb", " _fileTwo", "_FILE2", " _FILEb", "_linktwo", "_fileTwo", "_image2", "_image02", "_Filetwo", "_FILE02", " _FileTwo", "_File1", " _File2", "_imageb", " _FILE2", " _filetwo", " _FILE02", " _Filetwo", "_filetwo", " _FILE1", "_FileTwo"], "fis": ["flis", "fais", "kis", "fi", "Fis", "ufi", "cfis", "qiss", "cos", "fris", " fris", "ufis", "Fris", "ufiss", "cfois", "cis", " fi", "ufios", "Fiss", "qis", "qios", "Fios", "cfiss", " fais", " fois", "kios", "fliss", "fli", "fiss", "Fos", "flios", "cios", "cais", "Fois", " fios", "fios", "qos", "fois", "kos", "cfris", " fiss", "kais"], "fos": ["flis", "ffos", "foes", "woes", "hose", "mos", "foss", "fose", "flos", " faos", " fows", "wis", "floss", "sfoss", "mows", "faos", " foes", "fows", "wos", "moes", "ffis", "hos", "wows", " fose", "hoes", "sfos", "floes", "ffoss", "woss", "sfoes", "maos", " foss", "sfose", "hoss", "ffoes", "waos"], "canalFuente": ["canalFalperor", "canallfuestro", "canallfuenza", "canalUteree", "canalTenente", "canalKuperor", "canalFalje", "canalfuent", "canalUtestro", "canallFuperor", "canalFuje", "canalFalestro", "canalUtente", "canalFiente", "canallFuent", "canalFueree", "canallfuperor", "canalfuenza", "canalKuje", "canallfuje", "canallFuestro", "canalTenent", "canalFuestro", "canalTenperor", "canalFient", "canalFalente", "canallFuenza", "canallFuje", "canallFueree", "canallFuente", "canallfuent", "canalFienza", "canalfuperor", "canalFuenza", "canalFalent", "canalfuente", "canallfuente", "canalfuje", "canalfuestro", "canalTenenza", "canalFiperor", "canalKuent", "canalFuperor", "canalKuente", "canalFuent", "canalFaleree", "canalUtent", "canallfueree", "canalfueree"]}}
{"id1": "19147279", "id2": "2198730", "code1": "    public boolean actualizarDatosFinal(int idJugadorDiv, int idRonda, jugadorxDivxRonda unjxdxr) {\n        int intResult = 0;\n        String sql = \"UPDATE jugadorxdivxronda \" + \" SET resultado = ?, puntajeRonda = ? \" + \" WHERE jugadorxDivision_idJugadorxDivision = \" + idJugadorDiv + \" AND ronda_numeroRonda = \" + idRonda;\n        try {\n            connection = conexionBD.getConnection();\n            connection.setAutoCommit(false);\n            ps = connection.prepareStatement(sql);\n            populatePreparedStatementActFinal(unjxdxr);\n            intResult = ps.executeUpdate();\n            connection.commit();\n        } catch (SQLException ex) {\n            ex.printStackTrace();\n            try {\n                connection.rollback();\n            } catch (SQLException exe) {\n                exe.printStackTrace();\n            }\n        } finally {\n            conexionBD.close(ps);\n            conexionBD.close(connection);\n        }\n        return (intResult > 0);\n    }\n", "code2": "    public void importCSV(InputStream csvfile) throws Exception {\n        try {\n            String[] qmarks = new String[columns.length];\n            for (int i = 0; i < qmarks.length; i++) {\n                qmarks[i] = \"?\";\n            }\n            if (cleartable) {\n                String delsql = \"delete from \" + table;\n                Statement delstm = conn.createStatement();\n                delstm.executeUpdate(delsql);\n            }\n            String sql = \"insert into \" + table + \" (\" + StringUtils.join(columns, \", \") + \") values (\" + StringUtils.join(qmarks, \", \") + \")\";\n            log.debug(\"SQL: \" + sql);\n            PreparedStatement stm = conn.prepareStatement(sql);\n            int datatypes[] = new int[columns.length];\n            for (int i = 0; i < columns.length; i++) {\n                Table tbl = project.getTableByName(table);\n                if (tbl == null) throw new OntopiaRuntimeException(\"Unknown table: \" + table);\n                Column col = tbl.getColumnByName(columns[i]);\n                if (col == null) throw new OntopiaRuntimeException(\"Unknown table column: \" + columns[i]);\n                if (col.getType() == null) throw new OntopiaRuntimeException(\"Column type is null: \" + col.getType());\n                DataType datatype = project.getDataTypeByName(col.getType(), \"generic\");\n                if (datatype == null) throw new OntopiaRuntimeException(\"Unknown column type: \" + col.getType());\n                String dtype = datatype.getType();\n                if (\"varchar\".equals(dtype)) datatypes[i] = Types.VARCHAR; else if (\"integer\".equals(dtype)) datatypes[i] = Types.INTEGER; else throw new OntopiaRuntimeException(\"Unknown datatype: \" + dtype);\n            }\n            LineNumberReader reader = new LineNumberReader(new InputStreamReader(csvfile));\n            for (int i = 0; i < ignorelines; i++) {\n                String line = reader.readLine();\n                if (line == null) break;\n            }\n            log.debug(\"[\" + StringUtils.join(columns, \", \") + \"]\");\n            int lineno = 0;\n            while (true) {\n                lineno++;\n                String line = reader.readLine();\n                if (line == null) break;\n                try {\n                    String[] cols = StringUtils.split(line, separator);\n                    if (cols.length > columns.length && !ignorecolumns) log.debug(\"Ignoring columns: \" + (columns.length + 1) + \"-\" + cols.length + \" '\" + line + \"'\");\n                    log.debug(\"CVALUES: \" + (columns.length + 1) + \"-\" + cols.length + \" '\" + line + \"'\");\n                    String dmesg = \"(\";\n                    for (int i = 0; i < columns.length; i++) {\n                        String col = cols[i];\n                        if (stripquotes) {\n                            int len = col.length();\n                            if (len > 1 && ((col.charAt(0) == '\"' && col.charAt(len - 1) == '\"') || (col.charAt(0) == '\\'' && col.charAt(len - 1) == '\\''))) col = col.substring(1, len - 1);\n                        }\n                        if (col != null && col.equals(\"\")) col = null;\n                        dmesg = dmesg + col;\n                        if (i < columns.length - 1) dmesg = dmesg + \", \";\n                        stm.setObject(i + 1, col, datatypes[i]);\n                    }\n                    dmesg = dmesg + \")\";\n                    log.debug(dmesg);\n                    stm.execute();\n                } catch (Exception e) {\n                    conn.rollback();\n                    throw new OntopiaRuntimeException(\"Cannot read line \" + lineno + \": '\" + line + \"'\", e);\n                }\n            }\n            conn.commit();\n        } finally {\n            if (conn != null) conn.close();\n        }\n    }\n", "label": 1, "substitutes": {"actualizarDatosFinal": [" actualizarDataosfinal", " actualizarDatoFinancial", " actualizarDatoFinal", " actualizarDataasfinal", " actualizarDataosFinal", " actualizarDataosFinancial", " actualizarDataasFinal", " actualizarDatrosfinal", " actualizarDatofinal", " actualizarDatrosBasic", " actualizarDatosBasic", " actualizarDatrosFinancial", " actualizarDatasFinancial", " actualizarDataasBasic", " actualizarDatasFinal", " actualizarDatasBasic", " actualizarDatosFinancial", " actualizarDatoBasic", " actualizarDataosBasic", " actualizarDatasfinal", " actualizarDatrosFinal", " actualizarDatosfinal", " actualizarDataasFinancial"], "idJugadorDiv": ["idJugadorApp", "idJuggadoDef", "idJugadoApp", "idJogadorDiv", "idJuggadorDef", "idJugadeDev", "idJuggadoDiv", "idJugadoDev", "idJugadierDev", "idJugadierDef", "idJugadorDec", "idJogadeDec", "idJugadierApp", "idJogadorDev", "idJugordDef", "idJuggadorDiv", "idJuggadorDev", "idJugordApp", "idJogadorDec", "idJogadeDev", "idJugadeDec", "idJuggadoDev", "idJugadorDev", "idJuggadoApp", "idJogadorDef", "idJugadoDef", "idJugordDec", "idJogadeDiv", "idJugordDev", "idJugadeDef", "idJugadierDiv", "idJugadoDiv", "idJogadeDef", "idJuggadorApp", "idJugordDiv", "idJugadoDec", "idJugadorDef", "idJugadeDiv"], "idRonda": ["idDonda", "idRondo", "idRosa", "IDRonda", "IdRondo", "IDRosa", "idToda", "IDDonda", "idCorata", "idCorondo", "idRunnerata", "idTonda", "idTona", "idConda", "IdRata", "idRunnerondo", "idCoronda", "IdRora", "idTosa", "IDDosa", "idDoda", "idRona", "IdRonda", "idDona", "IDRona", "idRunnerora", "idCorora", "idRunneronda", "idCona", "IDRoda", "IDDoda", "IDDona", "idRora", "idCosa", "idRoda", "idRata", "idCoda", "idDosa"], "unjxdxr": ["unjxdxR", "unjxdxhr", "unjdxxtr", "unjdxxe", "unjxdxtrs", "unjxdxer", "unjdxtxR", "unjxdtxR", "unjxdxtr", "unjxdexe", "unjdxxer", "unjxdexr", "unjxdxde", "unjxdtxer", "unjdxxtrs", "unjxdxrs", "unjxddxhr", "unjxdexrs", "unjxdxtR", "unjxddxR", "unjdxtxer", "unjdxtxr", "unjxdXhr", "unjxdxdr", "unjxdxdrs", "unjxddxr", "unjxdxe", "unjxdexR", "unjxdtxr", "unjxdXer", "unjxddxer", "unjxdtxhr", "unjxdxte", "unjdxxrs", "unjxdxdR", "unjdxxtR", "unjdxxte", "unjdxxhr", "unjdxxr", "unjdxtxhr", "unjxdXR", "unjdxxR", "unjxdXr"], "intResult": [" intSuccess", "intSuccess", "INTSuccess", " intresult", "interResult", "IntReturn", "strResult", "intRes", "strresult", "intResults", "interReturn", "INTresult", "intReturn", "strReturn", "strResults", "IntRes", "IntResult", "IntResults", " intRes", "interResults", " intReturn", "INTResults", "INTReturn", " intResults", "IntSuccess", "INTResult", "intresult", "interRes", "INTRes"], "sql": ["csv", "sb", "settings", "dl", "select", "params", "sp", "description", "qs", "status", "ls", "what", "script", "sq", "template", "q", "command", "log", "db", "xml", "cp", "url", "sv", "condition", "serv", "statement", "ql", "query", "SQL", "sol", "cmd", "seed", "s", "pel", "string", "spr", "fn", "scl", "pr", "setup", "expression"], "connection": ["ion", "computer", "response", "creator", "reference", "subject", "con", "connected", "pointer", "platform", "engine", "city", "bo", "resource", "application", "description", "client", "table", "context", "library", "port", "directory", "link", "command", "c", "associated", "open", "function", "document", "current", "db", "close", "number", "condition", "position", "writer", "statement", "external", "Connection", "conn", "created", "network", "collection", "connect", "database", "relation", "channel", "nc", "socket", "communication", "pool", "server", "session", "character", " Connection"], "ps": ["proxy", "pa", "process", "pd", "PS", "gres", "prep", "tp", "res", "sp", "pse", "Ps", "pp", "processor", "fp", "script", "po", "mp", "pg", "ping", "aps", "cp", "ptr", "fps", "pt", "rs", "pps", "statement", "pos", "eps", "proc", "ds", "pers", "conn", "s", "ports", "jp", "pm", "socket", "posts", "pr", "p", "cs"]}}
{"id1": "9796161", "id2": "4798332", "code1": "    public static String getMD5(String s) {\n        try {\n            MessageDigest m = MessageDigest.getInstance(\"MD5\");\n            m.update(s.getBytes(), 0, s.length());\n            return \"\" + new BigInteger(1, m.digest()).toString(16);\n        } catch (NoSuchAlgorithmException e) {\n            logger.error(\"MD5 is not supported !!!\");\n        }\n        return s;\n    }\n", "code2": "    public static String SHA(String source) {\n        logger.info(source);\n        String result = null;\n        try {\n            MessageDigest digest = MessageDigest.getInstance(\"SHA\");\n            digest.update(source.getBytes());\n            byte[] bytes = digest.digest();\n            result = EncodeUtils.hexEncode(bytes);\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        }\n        logger.info(result);\n        return result;\n    }\n", "label": 1, "substitutes": {"getMD5": ["getMD7", "toSHA4", "toSHA7", "getMD4", "toSHA5", "toMD5", "getmd2", "getmd7", "getMD2", "toMD4", "toMD2", "getSHA2", "getmd5", "toMD7", "toSHA2", "getmd4", "getSHA4", "getSHA5", "getSHA7"], "s": ["f", "xs", "ss", "sb", "ses", "text", "ms", "y", " gets", "ends", "strings", "ins", "h", "js", "ws", "fs", "bs", "ls", "t", "ns", "sq", "c", "b", "ps", "ts", "S", "src", "v", "i", "its", "aws", "sv", "ats", "str", "rs", "os", "l", "data", "sql", "gs", "space", "g", "n", "sts", "string", "gets", "is", "source", "p", "es", "bytes", "ies", "abs"], "m": ["mi", "nm", "mask", "sm", "ms", "om", "y", "mr", "hm", "h", "mt", "managed", "fm", "mo", "mod", "mut", "me", "md", "em", "man", "perm", "rem", "rm", "made", "v", "dm", "e", "bm", "cm", "M", "l", "gm", "am", "mu", "g", "mc", "mm", "manager", "pm", "mk", "vm", "mac", "tm"]}}
{"id1": "12236729", "id2": "11562173", "code1": "        private void copy(File inputFile, File outputFile) throws Exception {\n            FileReader in = new FileReader(inputFile);\n            FileWriter out = new FileWriter(outputFile);\n            int c;\n            while ((c = in.read()) != -1) out.write(c);\n            in.close();\n            out.close();\n        }\n", "code2": "    private void checkInputStream(InputStream in, byte[] cmp, boolean all) throws IOException {\n        ByteArrayOutputStream stream = new ByteArrayOutputStream();\n        IOUtils.copy(in, stream);\n        byte[] out = stream.toByteArray();\n        if (all) assertEquals(cmp.length, out.length);\n        for (int i = 0; i < cmp.length; i++) assertEquals(cmp[i], out[i]);\n    }\n", "label": 1, "substitutes": {"copy": [" replicate", " combine", " operate", " recover", " merge", " transfer", " Copy", "transfer", "Copy", " restore", " seek", " upload", "cp", "read", " copying", " move", "paste", " append", " join", " parallel", " duplicate", " paste", " delete", " clone", " dup", " download", " cp", " cat"], "inputFile": [" inputfile", "outputDir", "outputPath", "configPost", "argumentfile", "inputPost", "argumentPath", "inile", "inputDir", " inputPost", " inputile", "inPath", "argumentFile", " inputPath", " inputDir", "inFile", "configfile", "configPath", "inputfile", "argumentPost", "outputile", "configFile", "inputPath", "inputile", "inDir"], "outputFile": ["outputDir", "outputPath", "outputPlace", " outputFilename", "outputfile", "outFile", "targetFile", "inputDir", "outputFilename", "writeFilename", "outfile", "targetDir", "writeDir", "outFilename", "targetfile", "targetPath", "writeFile", " outputPlace", "writePlace", "inputfile", "outPath", "inputPath", " outputDir", "outPlace", "outDir"], "in": ["ze", "all", "rin", "en", "inn", "ini", "min", "gin", "con", "IN", "ins", "ri", "reader", "on", "al", "In", "init", "inner", "inside", "old", "ic", "ai", "up", "i", "read", "bin", "inc", "input", "sin", "iter", "it", "per", " din", "ir", "ind", "info", "din", "inf", "is", "isin", "cin", "from"], "out": ["co", "en", "nt", "flush", "by", "con", "output", "res", "cos", "cn", "obj", "on", "client", "sys", "dis", "one", "net", "write", "print", "to", "end", "log", "ot", "v", "cache", "writer", "os", "outer", "it", "null", "ou", "at", "outs", "aos", "o", "g", "auto", "n", "io", "Out", "user", "check", "OUT", "can", "ne", "ex"], "c": ["f", "rc", "u", "z", "con", "cos", "character", "cb", "d", "cont", "cr", "C", "bc", "t", "x", "ce", "char", "code", "k", "cc", "chain", "cu", "current", "v", "i", "conf", "cp", "ct", "ac", "gc", "pc", "cache", "cm", "l", "ec", "cod", "ch", "lc", "cd", "unc", "r", "nc", "count", "n", "uc", "arc", "mc", "cap", "cf", "cs", "cl"]}}
{"id1": "14783950", "id2": "22046596", "code1": "    public static void compressWithZip(Vector fileList, String zipFileName) throws IOException {\n        if (fileList == null || fileList.size() == 0) return;\n        FileOutputStream fos = new FileOutputStream(zipFileName);\n        ZipOutputStream zos = new ZipOutputStream(fos);\n        Iterator iter = fileList.iterator();\n        while (iter.hasNext()) {\n            String fileName = (String) iter.next();\n            int ind = Math.max(fileName.lastIndexOf('/'), fileName.lastIndexOf('\\\\'));\n            String shortName = \"unknown\";\n            if (ind < fileName.length() - 1) shortName = fileName.substring(ind + 1);\n            zos.putNextEntry(new ZipEntry(shortName));\n            FileInputStream fis = new FileInputStream(fileName);\n            byte[] buf = new byte[10000];\n            int bytesRead;\n            while ((bytesRead = fis.read(buf)) > 0) zos.write(buf, 0, bytesRead);\n            fis.close();\n            zos.closeEntry();\n        }\n        zos.close();\n    }\n", "code2": "        public void copy(File s, File t) throws IOException {\n            FileChannel in = (new FileInputStream(s)).getChannel();\n            FileChannel out = (new FileOutputStream(t)).getChannel();\n            in.transferTo(0, s.length(), out);\n            in.close();\n            out.close();\n        }\n", "label": 1, "substitutes": {"compressWithZip": ["compressByFiles", "composeWithoutExt", "compresswithZip", "composeWithoutzip", "composeWithFiles", "compresswithExt", "compressWithoutExt", "compressWithoutFiles", "composeWithzip", "composeWithZip", "compresswithzip", "compressWithFiles", "compressWithExt", "compresswithFiles", "compressByExt", "composeWithoutZip", "compressWithoutZip", "compressByZip", "compressWithoutzip", "composeWithExt", "compressByzip", "compressWithzip", "composeWithoutFiles"], "fileList": [" fileL", "resourceList", "tileIterator", "wordIterator", "fileLock", "fileCode", "pageList", "fileIterator", " fileIterator", "resourceNames", "itemLock", "pageL", "resourceLock", " fileLIST", "fileSet", "ileL", "ileList", "fileLIST", "filelist", "tileSet", "pagelist", "tileList", "wordList", "wordLIST", " FileCode", " fileSet", " FileLIST", "pageCode", "tileLIST", " filelist", "wordSet", " fileLock", "fileNames", " FileSet", " fileNames", "ilelist", " fileCode", "pageLIST", "fileL", "pageSet", " FileList", "ileLIST", "itemNames", "itemList"], "zipFileName": ["zipFilenamename", "zFileFilename", "zFilename", "zipDirNames", "zipileName", " zipFilePath", " zipfileFilename", "zipfilePath", " zipFileFilename", "zFilenamename", "zipFilenameName", "zFilenamePath", "zFilenameFilename", "zipFilenameNames", " zipfileName", " zipFileNames", "zipDirName", "zipfileNames", "zFilePath", "zipDirFilename", "zipileFilename", "zipFilenamePath", "zipFilename", "zipFileNames", "zipfileName", " zipfileNames", "zipfileFilename", "zipDirPath", "zipfilename", "zFileName", "zipFileFilename", "zFilenameName", "zipFilePath", " zipfilePath", "zipilename", "zipFilenameFilename", "zipilePath"], "fos": ["flis", "Foss", "foss", "loos", "flos", "foos", "los", "loss", "wOS", "wos", " foos", "fOS", "lfis", "Fos", "lOS", "lfoos", "floos", "woss", " fOS", "Foos", "lfOS", "FOS", "lfos", "flOS", "woos"], "zos": ["ze", "zag", "Sax", "ss", "nz", "ses", "zon", "z", "rys", "webkit", "zin", "oss", "js", "zb", "jas", "ws", "sbm", "zen", "ess", "zh", "hz", "los", "iaz", "ps", "zo", "ossus", "less", "enos", "zes", "han", "os", "ez", "za", "enz", "iners", "bes", "cz", "zan", "css", "zu", "eros", "zzle", "zip", "zers", "zar", "rez", "ippers", "hess", "zik", "zer", "zero", "zi", "es", "sis"], "iter": ["exp", "ser", "oper", "tr", "ee", "izer", "reader", "Iter", "inter", "here", "inner", "maker", "liter", "orient", "vis", "train", "Iterator", "list", "re", "i", "its", "ptr", "ator", "coll", "ait", "outer", "valid", "it", "former", "walker", "ver", "li", "order", "iver", "ir", "gener", "iv", "iner", "ip", "fer", "iterator", "el", "ger", "ner", "er", "is", "where", "loc", "cer", "user", "loop", "loader", "ter", "kit", "ipper"], "fileName": ["ilePath", "ileSet", " filename", " fileNumber", "getStore", "tableSet", "shortStore", "fileNAME", "shortname", "getSource", "FileName", "FileCurrent", " filePath", "fSource", "getName", " fileSource", "localList", "FileNames", "localName", "ileString", "fieldname", " fileCurrent", "fileSet", "ileList", "fieldNAME", "FileString", "shortSource", " fileString", "ileBody", "ileNumber", "tablePath", "fileStore", "fieldName", "fileCurrent", "filename", "ilename", "fName", " fileSet", "tableName", "localname", "ileNAME", " fileStore", "fString", "fBody", "fname", "fileBody", "localNAME", "Filename", "filePath", "fileNames", "ileCurrent", "ileName", "fNames", "fNumber", " fileNames", "FilePath", "ileSource", " fileBody", "getname", "fileSource", "fileString", "fileNumber", "fieldList"], "ind": ["pred", "div", "dj", "find", "j", "dial", "inn", "roll", "d", "draw", "IND", "mod", "md", "red", "pl", "Ind", "mind", "stick", "butt", "wind", "i", "req", "ded", "ptr", "td", "inc", "bind", "pos", "cand", "cond", "sign", "ent", "cod", "seed", "cd", "hend", "num", "kind", "typ", "count", "n", "att", "ld", "loc", "index", "inder", "med", "nd"], "shortName": [" shortname", "fullString", "recentname", "shortname", "shortFilename", "recentCode", "smallname", "smallName", "recentName", "Shortname", "ShortKey", "ShortType", "recentFilename", "quickName", " shortKey", "quickString", "ShortString", "ShortName", "fullName", " shortString", "quickKey", "smallFilename", "shortCode", "fullname", " shortType", "shortKey", "shortString", "smallCode", "fullType", "ShortFilename", "ShortCode", "quickname", "shortType"], "fis": ["fi", "Fis", "ufi", "cfis", "fris", " fris", "ufis", "sfi", "his", "Fris", "wis", "cfois", "hi", " fIs", "sfis", "ufois", "wois", "pi", "ufris", "sfIs", "wIs", "wi", "pris", "FIs", "fois", "sfois", "fIs", "pis", "pois", "hris", "hois", "cfris", "ufIs", "cfi"], "buf": ["seq", "cv", "tr", "block", "br", "buff", "var", "img", "cat", "ref", "orig", "bl", "cb", "bed", "bc", "conv", "box", "mem", "bus", "wb", "buffer", "pkg", "bag", "b", "fam", "cur", "db", "aka", "fg", "bin", "Buffer", "uf", "rb", "tab", "cmd", "mu", "batch", "bar", "Buff", "cap", "msg", "temp", "arr", "fb", "vec", "bytes"], "bytesRead": ["postsFind", "blocksRead", "secondsWritten", "blocksWrite", "bytesLength", "usersLoad", "secondsWrite", "linesNeed", "secondsLoad", "flowsFind", "usersFind", "flowsLoad", "blocksWritten", "secondsRead", " bytesLoad", "bytesLoad", "bytesFind", " bytesWritten", "flowsReady", "flowsRead", "bytesWritten", "BytesRead", "postsRead", " bytesWrite", "linesLength", "BytesLength", "usersRead", "linesWritten", " bytesLength", "bytesReady", "postsReady", "BytesWritten", "bytesNeed", "blocksLoad", " bytesNeed", "postsLoad", "bytesWrite", "BytesNeed", "linesRead", "usersReady"]}}
{"id1": "12066447", "id2": "8150996", "code1": "    protected void truncate(final File file) {\n        LogLog.debug(\"Compression of file: \" + file.getAbsolutePath() + \" started.\");\n        if (FileUtils.isFileOlder(file, ManagementFactory.getRuntimeMXBean().getStartTime())) {\n            final File backupRoot = new File(this.getBackupDir());\n            if (!backupRoot.exists() && !backupRoot.mkdirs()) {\n                throw new AppenderInitializationError(\"Can't create backup dir for backup storage\");\n            }\n            SimpleDateFormat df;\n            try {\n                df = new SimpleDateFormat(this.getBackupDateFormat());\n            } catch (final Exception e) {\n                throw new AppenderInitializationError(\"Invalid date formate for backup files: \" + this.getBackupDateFormat(), e);\n            }\n            final String date = df.format(new Date(file.lastModified()));\n            final File zipFile = new File(backupRoot, file.getName() + \".\" + date + \".zip\");\n            ZipOutputStream zos = null;\n            FileInputStream fis = null;\n            try {\n                zos = new ZipOutputStream(new FileOutputStream(zipFile));\n                final ZipEntry entry = new ZipEntry(file.getName());\n                entry.setMethod(ZipEntry.DEFLATED);\n                entry.setCrc(FileUtils.checksumCRC32(file));\n                zos.putNextEntry(entry);\n                fis = FileUtils.openInputStream(file);\n                final byte[] buffer = new byte[1024];\n                int readed;\n                while ((readed = fis.read(buffer)) != -1) {\n                    zos.write(buffer, 0, readed);\n                }\n            } catch (final Exception e) {\n                throw new AppenderInitializationError(\"Can't create zip file\", e);\n            } finally {\n                if (zos != null) {\n                    try {\n                        zos.close();\n                    } catch (final IOException e) {\n                        LogLog.warn(\"Can't close zip file\", e);\n                    }\n                }\n                if (fis != null) {\n                    try {\n                        fis.close();\n                    } catch (final IOException e) {\n                        LogLog.warn(\"Can't close zipped file\", e);\n                    }\n                }\n            }\n            if (!file.delete()) {\n                throw new AppenderInitializationError(\"Can't delete old log file \" + file.getAbsolutePath());\n            }\n        }\n    }\n", "code2": "    private static boolean copyFile(File in, File out) {\n        boolean ok = true;\n        InputStream is = null;\n        OutputStream os = null;\n        try {\n            is = new FileInputStream(in);\n            os = new FileOutputStream(out);\n            byte[] buffer = new byte[0xFFFF];\n            for (int len; (len = is.read(buffer)) != -1; ) os.write(buffer, 0, len);\n        } catch (IOException e) {\n            System.err.println(e);\n            ok = false;\n        } finally {\n            if (is != null) {\n                try {\n                    is.close();\n                } catch (IOException e) {\n                    System.err.println(e);\n                }\n            }\n            if (os != null) {\n                try {\n                    os.close();\n                } catch (IOException e) {\n                    System.err.println(e);\n                }\n            }\n        }\n        return ok;\n    }\n", "label": 1, "substitutes": {"truncate": ["trvalidize", "trculicate", "trvalidate", "trunicate", "extuncicate", "extuncation", "trunate", "trvalidation", "truncation", "extuncize", "extvalidation", "trunation", "extvalidate", "trvalidicate", "trculate", "extvalidize", "truncicate", "extuncate", "trunize", "trculation", "trculize", "truncize", "extvalidicate"], "file": ["event", "f", "type", "report", "handle", "image", "block", "lock", "File", "time", "FILE", "word", "frame", "resource", "foo", "fp", "create", "page", "table", "run", "port", "base", "work", "module", "spec", "be", "range", "log", "link", "attribute", "to", "template", "message", "current", "filename", "ile", "format", "e", "name", "le", "get", "out", "or", "tree", "this", "parent", "object", "path", "null", "dir", "line", "model", "use", "channel", "full", "local", "info", "zip", "io", "files", "class", "source", "user", "size", "from", "data"], "backupRoot": ["backuproot", "workupidBoot", "backureBoot", "backupsDir", " backupidDir", "backflowRoot", " backupDir", "backuperroot", "backupBoot", "BackupFolder", "backureDir", " backupidroot", "backupidroot", "backureRoot", " backupBox", "backupidBox", " backupidRoot", "backdownFolder", " backupidBox", "backumpBox", "backflowDir", "backupsRoot", "backuperRoot", "backmpRoot", "backupDir", "backupBox", "workupBoot", "backupHome", "backupidFolder", "backmpDir", "workupRoot", "backuperHome", "backupidBoot", " backuproot", "backumpRoot", "backdownDir", "workupidRoot", "backumproot", "backuperDir", "workupidHome", "workupidroot", "backmproot", "backupidHome", "backureHome", "backupidRoot", "BackupidRoot", "BackupidDir", "backupFolder", "workupDir", "backmpBoot", "workuproot", "backflowFolder", "backupidDir", "backdownRoot", "BackupidFolder", "backupsBox", "BackupRoot", "backupsroot", "BackupDir", "backumpDir", "workupHome", "backureroot", "workupidDir"], "df": ["f", "dp", "bf", "pd", "dl", "raf", "di", "d", "Def", "gd", "deb", "lf", "md", "dc", "fd", "dr", "db", "DF", "dm", "format", "def", "dim", "NF", "sd", "tf", "sf", "uf", "ds", "fun", " pdf", "dt", "dd", "dx", "cd", "hd", "mm", "cf", "dep", "tif", "pdf", "du"], "date": ["event", "year", "zone", "dates", "value", "today", "default", "output", "match", "future", "time", "frame", "resource", "daily", "dated", "create", "sum", "standard", "tag", "run", "day", "module", "range", "ate", "message", "content", "format", "number", "when", "name", "now", "down", "Date", "get", "days", "grade", "age", "dt", "note", "cal", "month", "dat", " day", "late", "string", "save", " Date", "start", "due", "version", "update", "data", "duration"], "zipFile": ["jsonfile", "pdffile", "zFilename", "logPath", "logfile", "ZipPath", "pdfFile", "zipfile", "ZipFile", "jsonFilename", "jsonStore", "zipFilename", "zipStream", "zStore", "logStore", "pdfPath", "zFile", "Zipfile", "jsonFile", "ZipStream", "logFile", "zipPath", "logFilename", "zfile", "zipStore", "logStream", "pdfStream"], "zos": ["ze", "Sax", "zag", "tz", "ss", "nz", "ses", "zon", "z", "ozo", "cos", "webkit", "zin", "oss", "js", "south", "zb", "jas", "oses", "ros", "bs", "sbm", "zen", "hs", "zona", "hz", "los", "asar", "esm", "zo", "stice", "enos", "zes", "os", "ez", "za", "shed", "enz", "bes", " sands", "sol", "cz", "zan", "sch", "ones", "css", "estro", "eros", "asio", "zzle", "zers", "rez", "zar", "hess", "zik", "zer", "zi", "sis"], "fis": ["lIs", "fi", "Fis", "dfIs", "fiis", "fiib", "foIs", "fisc", "if\u00eds", "cfis", "cfisc", "efisc", "dfis", "fiiss", "foia", "ofois", "sfits", "fier", "fib", " fiss", "Fisc", "ofisc", "fits", "ifIs", "f\u00eds", "cfiss", "Fiss", "dfiss", "sfis", "foi", " fois", "ifis", "sfisc", "fiss", "efis", "cfits", "Fia", "sfIs", "ofis", "Fier", "fia", "dfier", "li", "Fi", "fiois", "ef\u00eds", "lis", "sfier", " fib", "sfiss", "FIs", "F\u00eds", "fois", "lia", "efIs", "fIs", "ofib", "ofits", "ofiss", "ifisc"], "entry": ["event", "ion", "rance", "insert", "element", "and", "ie", "deep", "internal", "comment", "word", "resource", "office", "obj", "se", "option", "description", "set", "connection", "ce", "char", "ment", "command", "attribute", "delete", "zo", "cell", "tex", "xml", "e", "def", "ace", "entity", "section", "or", "ary", "ent", "ry", "object", "search", "record", "sheet", "add", "zip", "member", "Entry", "row", "key", "de", "data", "cue", "escape"], "buffer": ["phrase", "buf", "window", "block", "buff", "sample", "frame", "comment", "word", "view", "sequence", "page", "table", "category", "append", "library", "base", "template", "char", "code", "command", "attribute", "document", "message", "available", "stack", "letter", "cache", "variable", "Buffer", "iter", "length", "queue", "paste", "binary", "batch", "bar", "screen", "padding", "volume", "temp", "button", "memory", "zero", "header"], "readed": ["rededed", " readED", "READer", "READED", "readented", "redented", "readED", "findED", "reader", "READed", "readared", "indexED", "findared", "readableied", "readableared", "readableED", "Reader", "countd", "Readd", "reded", "counter", "indexented", " readented", "Readied", "indexeded", "Readared", "ReadED", "countED", "readied", "indexed", "READd", "readeded", "findied", "Readed", "redED", "finded", " readeded", "counted", "readableed", "readd"]}}
{"id1": "18891988", "id2": "7425022", "code1": "    public static String getFile(String serviceName, String wsdlLocation, String endpoint) throws AxisFault {\n        mLog.debug(\"Downloading WSDL file from: \" + wsdlLocation);\n        mLog.debug(\"Received endpoint: \" + endpoint);\n        String fileLocation = null;\n        try {\n            String tempDir = System.getProperty(\"java.io.tmpdir\");\n            URL url = new URL(wsdlLocation);\n            String WSDLFile = tempDir + File.separator + serviceName + \".wsdl\";\n            String tmpWSDLFile = WSDLFile + \".tmp\";\n            File inputFile = new File(WSDLFile);\n            File tmpFile = new File(tmpWSDLFile);\n            if (!inputFile.exists() || inputFile.length() == 0) {\n                mLog.debug(\"Downloading the WSDL\");\n                inputFile.createNewFile();\n                InputStream in = url.openStream();\n                FileOutputStream out = new FileOutputStream(inputFile);\n                URLConnection con = url.openConnection();\n                int fileLength = con.getContentLength();\n                ReadableByteChannel channelIn = Channels.newChannel(in);\n                FileChannel channelOut = out.getChannel();\n                channelOut.transferFrom(channelIn, 0, fileLength);\n                channelIn.close();\n                channelOut.close();\n                out.flush();\n                out.close();\n                in.close();\n                Document tmpDocument = XMLUtils.newDocument(new FileInputStream(inputFile));\n                NodeList nl1 = tmpDocument.getElementsByTagName(\"wsdlsoap:address\");\n                for (int i = 0; i < nl1.getLength(); i++) {\n                    Node node1 = nl1.item(i);\n                    if (node1.getNodeName().equals(\"wsdlsoap:address\")) {\n                        ((Element) node1).setAttribute(\"location\", endpoint);\n                    }\n                }\n                FileOutputStream tmpOut = new FileOutputStream(tmpFile);\n                XMLUtils.DocumentToStream(tmpDocument, tmpOut);\n                tmpOut.flush();\n                tmpOut.close();\n                boolean retVal = inputFile.delete();\n                if (retVal) {\n                    retVal = tmpFile.renameTo(new File(WSDLFile));\n                }\n                mLog.debug(\"Return Value: \" + retVal);\n            } else {\n                mLog.debug(\"The WSDL is already at the ServiceProvider\");\n            }\n            fileLocation = WSDLFile;\n        } catch (MalformedURLException mx) {\n            mLog.error(\"MalformedURLException: \" + mx.getMessage() + \", cause: \" + mx.getCause().getMessage());\n            throw new AxisFault(mx.getMessage(), mx.getCause());\n        } catch (IOException ix) {\n            mLog.error(\"IOException: \" + ix.getMessage() + \", cause: \" + ix.getCause().getMessage());\n            throw new AxisFault(ix.getMessage(), ix.getCause());\n        } catch (ParserConfigurationException px) {\n            mLog.error(\"ParserConfigurationException: \" + px.getMessage() + \", cause: \" + px.getCause().getMessage());\n            throw new AxisFault(px.getMessage(), px.getCause());\n        } catch (SAXException sx) {\n            mLog.error(\"SAXException: \" + sx.getMessage() + \", cause: \" + sx.getCause().getMessage());\n            throw new AxisFault(sx.getMessage(), sx.getCause());\n        }\n        return fileLocation;\n    }\n", "code2": "    private String transferWSDL(String wsdlURL, String userPassword) throws WiseConnectionException {\n        String filePath = null;\n        try {\n            URL endpoint = new URL(wsdlURL);\n            HttpURLConnection conn = (HttpURLConnection) endpoint.openConnection();\n            conn.setDoOutput(false);\n            conn.setDoInput(true);\n            conn.setUseCaches(false);\n            conn.setRequestMethod(\"GET\");\n            conn.setRequestProperty(\"Accept\", \"text/xml,application/xml,application/xhtml+xml,text/html;q=0.9,text/plain;q=0.8,image/png,*/*;q=0.5\");\n            conn.setRequestProperty(\"Connection\", \"close\");\n            if (userPassword != null) {\n                conn.setRequestProperty(\"Authorization\", \"Basic \" + (new BASE64Encoder()).encode(userPassword.getBytes()));\n            }\n            InputStream is = null;\n            if (conn.getResponseCode() == 200) {\n                is = conn.getInputStream();\n            } else {\n                is = conn.getErrorStream();\n                InputStreamReader isr = new InputStreamReader(is);\n                StringWriter sw = new StringWriter();\n                char[] buf = new char[200];\n                int read = 0;\n                while (read != -1) {\n                    read = isr.read(buf);\n                    sw.write(buf);\n                }\n                throw new WiseConnectionException(\"Remote server's response is an error: \" + sw.toString());\n            }\n            File outputDir = new File(wiseProperties.getProperty(\"wise.tmpDir\"));\n            if (!outputDir.exists()) {\n                outputDir.mkdir();\n                wiseProperties.setProperty(\"wise.forceImportObject\", \"true\");\n            }\n            File file = new File(wiseProperties.getProperty(\"wise.tmpDir\"), new StringBuffer(\"Wise\").append(IDGenerator.nextVal()).append(\".xml\").toString());\n            OutputStream fos = new BufferedOutputStream(new FileOutputStream(file));\n            IOUtils.copyStream(fos, is);\n            fos.close();\n            is.close();\n            filePath = file.getPath();\n        } catch (WiseConnectionException wce) {\n            throw wce;\n        } catch (Exception e) {\n            throw new WiseConnectionException(\"Wsdl download failed!\", e);\n        }\n        return filePath;\n    }\n", "label": 1, "substitutes": {"getFile": ["createfile", "getString", "GetFile", "selectFile", "getfile", "selectFilename", "createString", "selectString", "GetFilename", "getFilename", "createFilename", "GetString", "Getfile", "selectfile", "createFile"], "serviceName": ["serviceNames", "serviceFamily", "serviceType", "serverCode", "serviceCode", "libraryName", "libraryFamily", "ServiceNames", "ServiceCode", "ServiceName", "serverName", "libraryNames", " serviceNames", "ServiceType", " serviceFamily", " serviceCode", "serverType", " serviceType", "libraryType", "ServiceFamily"], "wsdlLocation": ["awsdlocation", "wssdlocation", "wlLocation", "wlPath", "wslLoc", "wsdURL", "wsDLlocation", "wslPath", "wssdLoc", "wlFolder", "wsdlLoc", "wdlLoc", "awsdlLocation", "wsollocation", "wssdURL", "awsolURL", "wsdLoc", "wsDLURL", "awsdlLoc", "awsdURL", "wssdFolder", "wslFolder", "wsolURL", "awsolLoc", "awsolLocation", "awsdLocation", "wsdlFolder", "wsolLocation", "wsDLLoc", "wssdPath", "wslLocation", "wsdlocation", "wlLoc", "awsollocation", "wssdLocation", "wsDLLocation", "wsdllocation", "wsDLPath", "wdlPath", "wdlLocation", "wsdlPath", "awsdlURL", "wdlFolder", "wsolLoc", "wsdlURL", "awsdLoc", "wsDLFolder", "awsdllocation", "wsdLocation"], "endpoint": ["beginPoint", "Endport", "bindpoints", "idpoint", " endpoints", "Endword", "idpoints", " endline", "bindpoint", "bindport", "endpoints", "beginpoints", " endport", "startline", "Endpoint", "beginpoint", "idline", "endport", "startword", "startpoint", "beginword", "endword", "endPoint", "EndPoint", "endline", "bindPoint", " endPoint", "startPoint", "idPoint", "Endpoints", "startpoints"], "fileLocation": ["FileLocation", "fileLoc", "documentPosition", "FilePosition", "documentLoc", " filelocation", "Filelocation", " filePosition", "filelocation", " fileLoc", "FileLoc", "documentlocation", "documentLocation", "filePosition"], "tempDir": [" tempFolder", "TempPath", "TempUrl", "TempFolder", "TempDirectory", "tempDirectory", "tempPath", "Tempdir", " tempUrl", "tmpDir", "tempdir", " tempDirectory", "tempFolder", "tmpDirectory", "tmpFolder", " tempPath", "TempDir", "tmpdir", "tmpUrl", "tmpPath", "tempUrl", " tempdir"], "url": ["f", "browser", "window", "gl", "dl", "service", "cr", "sur", "m", "https", "bel", "web", "ls", "ll", "base", "char", "link", "pl", "build", "sl", "open", "cert", "rel", "up", "ur", "mount", "re", "cp", "un", "uri", "URL", "str", "l", "nl", "ul", "mail", "li", "conn", "ctrl", "github", "r", "ssl", "ret", "http", "location", "socket", "job", "loc", "il", "Url"], "WSDLFile": ["WSDDLFILE", "WSDELfile", "WSDDLString", "WSDLLFilename", "WSDLLFILE", "WHDLFile", "WSDLSfile", "WSDLFilename", "WNDDLFILE", "WHDLfile", "WSDELFile", "WSDMLFile", "WNDDLFilename", "WNDLFilename", "WSDDLType", "WSDMLfile", "WNDLFile", "WSDQLFILE", "WSDLSString", "WIDLFile", "WSDLLType", "WIDDLType", "WSDELFilename", "WNDLFILE", "WSDDLfile", "WSDQLFile", "WSDLType", "WSDELFILE", "WSDMLFILE", "WNDDLFile", "WIDDLString", "WSDLLFile", "WIDDLfile", "WSDLString", "WSDLfile", "WSDDLFilename", "WHDDLfile", "WSDDLFile", "WSDLSType", "WIDLString", "WNDDLfile", "WSDLLString", "WIDDLFile", "WSDLLfile", "WSDQLfile", "WHDDLFile", "WIDLType", "WSDLSFile", "WSDLFILE", "WHDLFILE", "WHDDLFILE", "WNDLfile", "WIDLfile"], "tmpWSDLFile": ["tmpWSDLFilename", "tmpWIDDLFilename", "tmpWSDLFILE", "tmpWIDLFilename", "tmpWIDLFile", "tmpWSDLfile", "tmpWSDlfile", "tmpWSDDLFILE", "tmpWSDDLFilename", "tmpWSDLDFile", "tmpWSDLLFiles", "tmpWSDLLFilename", "tmpWSDLFiles", "tmpWNDLfile", "tmpWIDLFILE", "tmpWIDDLfile", "tmpWNDDLFilename", "tmpWNDLFile", "tmpWSDLLfile", "tmpWSDDLfile", "tmpWIDDLFile", "tmpWSDLDfile", "tmpWSDDLFiles", "tmpWNDLFilename", "tmpWSDDLFile", "tmpWIDLfile", "tmpWIDDLFILE", "tmpWSDLDFilename", "tmpWSDLDFILE", "tmpWNDDLFile", "tmpWSDlFilename", "tmpWNDDLFiles", "tmpWSDLLFILE", "tmpWSDlFiles", "tmpWNDLFiles", "tmpWSDlFile", "tmpWNDDLfile", "tmpWSDLLFile"], "inputFile": ["tmpSourceFile", "tmpStream", " inputSourceFile", " inputfile", "InputStream", "inputStream", "interfacefile", "clientFile", "indexStream", "tmpFILE", " inputDo", "clientFiles", "outputfile", "errorfile", "tmpfile", "inputDo", "indexfile", "InputFiles", "outputFile", "errorStream", "indexFile", "InputDo", " inputPlace", "inputFILE", "intFiles", "inPath", " inputFiles", "inputFiles", "Inputfile", "outputFILE", " inputPath", "outputStream", "InputFile", "inputPlace", "inFile", "interfaceSourceFile", " inputFILE", "InputPath", "intFILE", "inputSourceFile", "indexFILE", "inputfile", "intFile", "clientFILE", "InputFILE", "clientPath", "inDo", "inputPath", "errorFILE", "interfacePlace", "errorFile", "tmpPlace", "interfaceFile", "infile", "intfile"], "tmpFile": ["inputFilename", "mpfile", " tmpfile", "tmpFILE", "tmpfile", "empFilename", "tempPath", "tempFilename", "empFile", "mpFile", "tmpFiles", "inputFILE", "mpFiles", "mpPath", "empFILE", "tempfile", "tempFILE", " tmpPath", " tmpFiles", "inputfile", "empfile", "tempFiles", "tempFile", "tmpPath", "tmpFilename"], "in": ["mi", "rin", "en", "inn", "ini", "IN", "ins", "cont", "ar", "ri", "ln", "client", "stream", "In", "t", "inner", "init", "c", "ic", "ai", "bin", "inc", "input", "sin", "it", "ch", "conn", "ain", "ind", "o", "r", "inv", "n", "io", "din", "inf", "is", "isin", "source", "file", "cin", "id", "from"], "out": ["all", "co", "en", "lock", "by", "output", "ao", "oss", "obj", "client", "on", "sys", "tmp", "conv", "t", "connection", "net", "we", "write", "c", "to", "log", "buffer", "conf", "cache", "writer", "os", "cm", "outer", "OU", "ch", "this", "conn", "null", "ou", "group", "outs", "at", "o", "aos", "inv", "auto", "ex", "n", "io", "Out", "file", "pool", "OUT", "can", "ne", "w"], "con": ["co", "acon", "win", "cos", "func", "cn", "ln", "ws", "conv", "connection", "cons", "CON", "c", "fc", "soc", "cur", "re", "un", "conf", "com", "cp", "ran", "sec", "Conn", "cm", "const", "login", "ch", "cone", "cal", "conn", "ain", "exc", "tc", "num", "connect", "nc", "mc", "cf", "fn", "cin", "can", "Con"], "fileLength": ["FILELen", "fileFontSize", "objectLength", "fileSize", "ileLen", "FILELength", "fileLen", "objectSize", "ileLength", "fileDuration", " fileLen", "channelSize", "channelFontSize", " fileDuration", " fileSize", "channelLength", "ileDuration", "objectFontSize", "channelDuration", " fileFontSize", "objectDuration", "FILEDuration", "FILESize", "ileSize"], "channelIn": ["Channelin", "ChannelIN", "chanIN", "channelIN", "ChanneledIn", "channelSet", "consoleIN", " channelIN", "channelin", " channeledIn", "clientIn", "channeledIn", "consoleOut", "chanOut", "chanSet", "ChannelSet", "clientSet", "clientin", " channelin", "clientIN", "chanIn", "clientOut", "consoleIn", "consoleedIn", "ChannelOut", "ChannelIn"], "channelOut": ["chanConn", "Channelout", "consoleout", "ChannelConn", " channelout", " channelConn", "ChannelOUT", "courseout", "consoleOut", "chanOut", "consoleOUT", "channelConn", " channelOUT", "channelout", "courseOUT", "chanIn", "courseOut", "courseIn", "consoleIn", "chanout", "channelOUT", "ChannelOut", "ChannelIn"], "tmpDocument": ["mkdocument", "cpdocument", "tmDocument", " tmpMedia", "mpdocument", "npMedia", "tmdocument", "mkDocument", "tmpDoc", "tmDoc", " tmpDocuments", "tpDocument", "npFile", "tmpDocuments", "mpDocument", "tempdocument", " tmpdocument", "tmpdocument", "tpMedia", " tmpDoc", "tmpMedia", "mkDoc", "tpDocuments", "tpFile", "npDocument", "cpDocument", "npDocuments", "tempDoc", "cpDoc", "tempDocument", "mpDoc"], "nl1": ["ln0", "sol9", "rn6", "nr1", "lnOne", "NL2", "nel1", "nrOne", "rn1", "nr01", "nel3", "pelOne", "ln3", "pel1", "nl6", "pel01", "rnOne", "nelOne", "sol0", "nl2", "NL0", "ln6", "NL1", "ln1", "ln9", "nl0", "ln01", "nl01", "rn3", "nl9", "nel6", "nlOne", "sol2", "NL9", "ln2", "nl3", "sol1"], "i": ["mi", "span", "u", "j", "ini", "us", "y", "ms", "I", "ie", "qi", "di", "ri", "m", "ami", "init", "x", "hi", "me", "ti", "k", "bi", "cli", "ic", "multi", "ci", "ai", "sim", "gi", "ui", "v", "pi", "ij", "it", "ji", "li", "xi", "mu", "ims", "si", "\u0438", "ori", "o", "ip", "info", "n", "key", "io", "ii", "is", "index", "id", "a", "ix"], "node1": ["Node2", "n0", "node91", "Node1", " node0", "node2", "nOne", "Node001", "nodeOne", "node0", "Node0", "layer91", " node2", "n1", "componentOne", "layer1", " nodeOne", "ode0", "n91", "ode1", "ode2", "ode001", "layer0", "layerOne", "component0", "NodeOne", "component2", "node001", " node91", " node001", "component1"], "tmpOut": ["tmpObj", "tmpIn", "mpIn", "npIn", "TempOut", "empout", "mpObj", "tempIs", " tmpIs", " tmpObj", "tmpOUT", "npOut", "tmpIs", "mpOut", "tempout", "TempObj", "cmpIn", "TempOUT", "cmpOut", "empIs", "npObj", "tempOUT", "empOut", "tmpout", " tmpIn", "mpout", " tmpOUT", "TempIn", "cmpout", "tempObj", " tmpout", "tempIn", "npout", "tempOut"], "retVal": ["RetTrue", "RetVal", " retValue", "returnTrue", "RetValue", "retValue", "retval", " retTrue", "returnval", "retTrue", "returnValue", "returnVal", "Retval", " retval"]}}
{"id1": "21488518", "id2": "9846843", "code1": "    @Override\n    public Resource createNew(String name, InputStream in, Long length, String contentType) throws IOException {\n        File dest = new File(this.realFile, name);\n        if (allowedClient) {\n            if (\".request\".equals(name) || \".tokens\".equals(name)) {\n                FileOutputStream out = null;\n                try {\n                    out = new FileOutputStream(dest);\n                    IOUtils.copy(in, out);\n                } finally {\n                    IOUtils.closeQuietly(out);\n                }\n                if (\".request\".equals(name)) {\n                    File request = new File(realFile.getAbsolutePath() + \"/\" + name);\n                    RequestManager.manageRequest(request, null, true);\n                    return new OverEncryptedFriendsFile(factory, folderPath + \"/.response\", allowedClient);\n                }\n                return new OverEncryptedFriendsFile(factory, folderPath + \"/\" + name, allowedClient);\n            } else {\n                return null;\n            }\n        } else {\n            LOGGER.error(\"User isn't owner of this folder\");\n            return null;\n        }\n    }\n", "code2": "    public byte[] getResponse() {\n        final ByteArrayInputStream bais = new ByteArrayInputStream(request);\n        final ByteArrayOutputStream baos = new ByteArrayOutputStream();\n        List<String> lines = Collections.emptyList();\n        try {\n            @SuppressWarnings(\"unchecked\") List<String> dl = IOUtils.readLines(bais);\n            lines = dl;\n        } catch (IOException ioex) {\n            throw new AssertionError(ioex);\n        }\n        String resource = null;\n        for (String line : lines) {\n            if (line.startsWith(\"GET \")) {\n                int endIndex = line.lastIndexOf(' ');\n                resource = line.substring(4, endIndex);\n            }\n        }\n        final PrintStream printStream = new PrintStream(baos);\n        if (resource == null) {\n            printStream.println(\"HTTP/1.1 400 Bad Request\");\n        } else {\n            final InputStream inputStream = getClass().getResourceAsStream(resource);\n            if (inputStream == null) {\n                printStream.println(\"HTTP/1.1 404 Not Found\");\n                printStream.println();\n            } else {\n                printStream.println(\"HTTP/1.1 200 OK\");\n                printStream.println();\n                try {\n                    IOUtils.copy(inputStream, printStream);\n                } catch (IOException ioex) {\n                    throw new AssertionError(ioex);\n                }\n            }\n        }\n        printStream.flush();\n        printStream.close();\n        return baos.toByteArray();\n    }\n", "label": 1, "substitutes": {"createNew": ["createFresh", "dataResource", "createNext", "getFresh", "CreateNext", "getNext", "CreateNew", "getResource", "CreateFresh", "getNew", "dataNext", "dataFresh", "dataNew", "CreateResource", "createResource"], "name": ["type", "event", "handle", "nm", "address", "value", "named", "alias", "time", "part", "word", "resource", "description", "client", "create", "names", "base", "template", "one", "code", "action", "old", "only", "end", "current", "ename", "missing", "filename", "format", "none", "now", "NAME", "common", "path", "null", "normal", "ame", "use", "lat", "local", "n", "key", "string", "no", "file", "size", "password", "body", "version", "index", "id", "source", "Name", "data", "prefix", "title"], "in": ["rin", "en", "inn", "gin", "con", "IN", "vin", "ins", "reader", "al", "In", "t", "inner", "err", "c", "b", "asin", "xml", "i", "bin", "mat", "get", "input", "it", "s", "ind", "r", "ma", "mc", "mm", "din", "is", "file", "isin", "source", "body", "cin", "p", "from", "data"], "length": ["value", "text", "Length", "enc", "description", "sequence", "stream", "buffer", "shape", "message", "max", "content", "read", "position", "total", "input", "bytes", "len", "path", "height", "amount", "padding", "count", "size", "password", "body", "data", "duration"], "contentType": ["mediaTypes", " contentLength", "contentLength", "contenttype", "ContentTypes", "ContentType", "ContentLength", "mediatype", "mediaType", "Contenttype", "contentTypes", " contentTypes", "mediaLength", " contenttype"], "dest": ["origin", "coord", "comb", "home", "prop", "cat", "orig", "oe", "d", "cont", "disk", "obj", "trans", "tmp", "table", "wb", "mem", "rest", "resp", " Dest", "lit", "src", "result", " dst", "copy", "target", " destination", "iter", "this", "parent", "path", "dat", "dir", "nom", "self", "Dest", "there", "temp", "source", "loc", "folder"], "out": ["ion", "co", "en", "con", "output", "cos", "res", "oss", "op", "obj", "client", "sys", "w", "set", "col", "conv", "t", "port", "po", "net", "write", "log", "go", "to", "up", "off", "copy", "serv", "os", "external", "outer", "ent", "OU", "it", "conn", "null", "ou", "s", "aos", "outs", "o", "n", "io", "Out", "file", "OUT", "can", "end", "ex"], "request": ["report", "claim", "response", "pair", "reference", "select", "reset", "params", "forward", "requ", "remove", "create", "quest", "library", "require", "open", "message", "current", "Request", "result", "re", "req", "url", "child", "ask", "input", "query", "search", "enter", "begin", "relative", "QUEST", "user", "ire", "move", "push"]}}
{"id1": "13233761", "id2": "23531898", "code1": "    public void executeUpdateTransaction(List queries) throws SQLException {\n        assert connection != null;\n        boolean autoCommit = connection.getAutoCommit();\n        connection.setAutoCommit(false);\n        try {\n            Iterator iterator = queries.iterator();\n            while (iterator.hasNext()) {\n                String query = (String) iterator.next();\n                Statement statement = connection.createStatement();\n                statement.executeUpdate(query);\n            }\n            connection.commit();\n            connection.setAutoCommit(autoCommit);\n        } catch (SQLException e) {\n            connection.rollback();\n            throw new SQLException(e.getMessage());\n        }\n    }\n", "code2": "    public void doUpdateByLoginID() throws Exception {\n        if (!isValidate()) {\n            throw new CesSystemException(\"User_session.doUpdateByLoginID(): Illegal data values for update\");\n        }\n        Connection con = null;\n        PreparedStatement ps = null;\n        String strQuery = \"UPDATE \" + Common.USER_SESSION_TABLE + \" SET \" + \"session_id = ?, user_id = ?, begin_date = ? , \" + \"ip_address = ?, mac_no = ? \" + \"WHERE  login_id= ?\";\n        DBOperation dbo = factory.createDBOperation(POOL_NAME);\n        try {\n            con = dbo.getConnection();\n            con.setAutoCommit(false);\n            ps = con.prepareStatement(strQuery);\n            ps.setString(1, this.sessionID);\n            ps.setInt(2, this.user.getUserID());\n            ps.setTimestamp(3, this.beginDate);\n            ps.setString(4, this.ipAddress);\n            ps.setString(5, this.macNO);\n            ps.setString(6, this.loginID);\n            int resultCount = ps.executeUpdate();\n            if (resultCount != 1) {\n                con.rollback();\n                throw new CesSystemException(\"User_session.doUpdateByLoginID(): ERROR updating data in T_SYS_USER_SESSION!! \" + \"resultCount = \" + resultCount);\n            }\n            con.commit();\n        } catch (SQLException se) {\n            if (con != null) {\n                con.rollback();\n            }\n            throw new CesSystemException(\"User_session.doUpdateByLoginID(): SQLException while updating user_session; \" + \"session_id = \" + this.sessionID + \" :\\n\\t\" + se);\n        } finally {\n            con.setAutoCommit(true);\n            closePreparedStatement(ps);\n            closeConnection(dbo);\n        }\n    }\n", "label": 1, "substitutes": {"executeUpdateTransaction": ["executeUpdateTask", "executeWriteTask", "startQueryStatement", "executeQueryTransaction", "startQueryTransaction", "startUpdateTransaction", "executeInsertStatement", "startUpdateStatement", "executeWriteStatement", "executeUpdateStatement", "executeQueryTx", "startUpdateTask", "startQueryTask", "executeInsertTransaction", "executeWriteTx", "startUpdateTx", "startQueryTx", "executeInsertTx", "executeUpdateTx", "executeQueryStatement", "executeQueryTask", "executeInsertTask", "executeWriteTransaction"], "queries": ["quenges", "galleries", "queues", "Quarks", " Quues", "qualeries", "qualenges", "gallands", "aqueries", "aquands", "qualands", " Queries", "quands", "quues", "aquenges", "gallenges", "qualiries", "aquiries", " Quarks", "queands", "Quands", "queeries", "quarks", "quiries", " Quands", "galliries", "Quues", "quearks", "Queries"], "autoCommit": ["AutoCommits", "autoCommcommit", "autoAbsate", "autoCompate", "automaticCommit", "AutoCommit", "autoCommmit", "autoCompcommit", "autoAbsist", "autoAbscommit", "automaticCommist", "autoCommport", "autoAmport", "autoCompit", "automaticCompit", "AutoClmit", "autoAbsit", "AutoCommport", "autoCommist", "autoCommate", "autoAmits", "AutoCommmit", "autoAmmit", "autoClits", "autoClport", "autoDebist", "autoAmit", "autoBeits", "autoCommits", "autoClit", "autoClmit", "autoDebate", "autoDebit", "AutoClits", "AutoClit", "automaticCompate", "autoBemit", "automaticCommate", "autoCompist", "autoBeit", "autoDebcommit", "AutoClport", "automaticCommcommit", "automaticCompcommit", "autoBeport", "automaticCompist"], "iterator": ["runner", "series", "video", "interstitial", "creator", "vector", "ski", "sample", "rows", "next", "storage", "internet", "reader", "seconds", "giving", "sequence", "processor", "river", "set", "stream", "page", "finder", "trace", "inner", "menu", "directory", "issues", "starter", "integer", "current", "Iterator", "immigrant", "list", "number", "information", "udder", "started", "ator", "liner", "writer", "operator", "outer", "iter", "former", "walker", "encer", "upper", "members", "pler", "gener", "taker", "continue", "pour", "instance", "bis", "collection", "ner", "pee", "values", "size", "folder", "oser", "rounder", "zero", "loop", "loader", "ter", "pie"], "query": ["series", "lock", "subject", "test", "task", "comment", "request", "execute", "description", "resource", "sequence", "quest", "table", "script", "sq", "menu", "q", "command", "code", "message", "join", "result", "family", "escape", "Query", "name", "condition", "sql", "parse", "term", "question", "qu", "key", "string", "row", "quote", "password", "version", "check", "update", "prefix", "title"], "statement": ["phrase", "rule", "block", "task", "comment", "mt", "resource", "execute", "word", "description", "sequence", "set", "status", "table", "fire", "connection", "template", "ment", "command", "message", "call", "system", "minute", "state", "condition", "expression", "sql", "parse", "continue", "binary", "confirmed", "batch", "group", "line", "Statement", "slot", "quote", "usage", "shell", "print", "session"]}}
{"id1": "12146394", "id2": "8164056", "code1": "    public static String md5Crypt(final byte[] key, final byte[] salt) throws NoSuchAlgorithmException {\n        if (key == null || key.length == 0) {\n            throw new IllegalArgumentException(\"Argument 'key' cannot be null or an empty array.\");\n        }\n        if (salt == null || salt.length == 0) {\n            throw new IllegalArgumentException(\"Argument 'salt' cannot be null or an empty array.\");\n        }\n        final MessageDigest _md = MessageDigest.getInstance(\"MD5\");\n        _md.update(key);\n        _md.update(MAGIC.getBytes());\n        _md.update(salt);\n        final MessageDigest md2 = MessageDigest.getInstance(\"MD5\");\n        md2.update(key);\n        md2.update(salt);\n        md2.update(key);\n        byte[] abyFinal = md2.digest();\n        for (int n = key.length; n > 0; n -= 16) {\n            _md.update(abyFinal, 0, n > 16 ? 16 : n);\n        }\n        abyFinal = new byte[] { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };\n        for (int j = 0, i = key.length; i != 0; i >>>= 1) {\n            if ((i & 1) == 1) _md.update(abyFinal, j, 1); else _md.update(key, j, 1);\n        }\n        final StringBuilder sbPasswd = new StringBuilder();\n        sbPasswd.append(MAGIC);\n        sbPasswd.append(new String(salt));\n        sbPasswd.append('$');\n        abyFinal = _md.digest();\n        for (int n = 0; n < 1000; n++) {\n            final MessageDigest md3 = MessageDigest.getInstance(\"MD5\");\n            if ((n & 1) != 0) {\n                md3.update(key);\n            } else {\n                md3.update(abyFinal);\n            }\n            if ((n % 3) != 0) {\n                md3.update(salt);\n            }\n            if ((n % 7) != 0) {\n                md3.update(key);\n            }\n            if ((n & 1) != 0) {\n                md3.update(abyFinal);\n            } else {\n                md3.update(key);\n            }\n            abyFinal = md3.digest();\n        }\n        int[] anFinal = new int[] { (abyFinal[0] & 0x7f) | (abyFinal[0] & 0x80), (abyFinal[1] & 0x7f) | (abyFinal[1] & 0x80), (abyFinal[2] & 0x7f) | (abyFinal[2] & 0x80), (abyFinal[3] & 0x7f) | (abyFinal[3] & 0x80), (abyFinal[4] & 0x7f) | (abyFinal[4] & 0x80), (abyFinal[5] & 0x7f) | (abyFinal[5] & 0x80), (abyFinal[6] & 0x7f) | (abyFinal[6] & 0x80), (abyFinal[7] & 0x7f) | (abyFinal[7] & 0x80), (abyFinal[8] & 0x7f) | (abyFinal[8] & 0x80), (abyFinal[9] & 0x7f) | (abyFinal[9] & 0x80), (abyFinal[10] & 0x7f) | (abyFinal[10] & 0x80), (abyFinal[11] & 0x7f) | (abyFinal[11] & 0x80), (abyFinal[12] & 0x7f) | (abyFinal[12] & 0x80), (abyFinal[13] & 0x7f) | (abyFinal[13] & 0x80), (abyFinal[14] & 0x7f) | (abyFinal[14] & 0x80), (abyFinal[15] & 0x7f) | (abyFinal[15] & 0x80) };\n        to64(sbPasswd, anFinal[0] << 16 | anFinal[6] << 8 | anFinal[12], 4);\n        to64(sbPasswd, anFinal[1] << 16 | anFinal[7] << 8 | anFinal[13], 4);\n        to64(sbPasswd, anFinal[2] << 16 | anFinal[8] << 8 | anFinal[14], 4);\n        to64(sbPasswd, anFinal[3] << 16 | anFinal[9] << 8 | anFinal[15], 4);\n        to64(sbPasswd, anFinal[4] << 16 | anFinal[10] << 8 | anFinal[5], 4);\n        to64(sbPasswd, anFinal[11], 2);\n        return sbPasswd.toString();\n    }\n", "code2": "    private String encode(String str) {\n        StringBuffer buf = new StringBuffer();\n        try {\n            MessageDigest md5 = MessageDigest.getInstance(\"MD5\");\n            md5.update(str.getBytes());\n            byte bytes[] = md5.digest();\n            for (int i = 0; i < bytes.length; i++) {\n                String s = Integer.toHexString(bytes[i] & 0xff);\n                if (s.length() == 1) {\n                    buf.append(\"0\");\n                }\n                buf.append(s);\n            }\n        } catch (Exception ex) {\n        }\n        return buf.toString();\n    }\n", "label": 1, "substitutes": {"md5Crypt": ["md3Enc", " Md5crypt", " Md5Crypt", "md5crypt", " Md3Dec", "md4crypt", " Md3Enc", "md3Crypt", "md5Dec", "md2crypt", "md2Enc", " Md3crypt", "md4Crypt", "md5Enc", " Md5Enc", "md3Dec", " Md3Crypt", "md2Dec", "md3crypt", "md2Crypt", "md4Enc", " Md5Dec", "md4Dec"], "key": ["event", "window", "pair", "value", "y", "test", "policy", "air", "base", "to", "poly", "ice", "state", "form", "ip", "er", "start", "index", "type", "phrase", "address", "sum", "x", "ce", "char", "link", "net", "list", "act", "name", "hash", "note", "change", "iv", "file", "mac", "password", "version", "check", "id", "ion", "block", "text", "item", "entry", "piece", "table", "box", "Key", "chain", "k", "code", "cert", "ey", "none", "str", "input", "query", "seed", "length", "blow", "icon", "root", "user", "gem", "host", "data", "prefix", "KEY", "image", "json", "by", "default", "word", "keys", "client", "ca", "message", "ace", "token", "null", "any", "ek", "string", "no", "source", "prime", "p", "ke", "ex"], "salt": ["sil", "psALT", "sealt", "seash", "unsALT", "sass", " sass", "unsalted", "sash", "cig", "Sint", "Save", "unsalt", "Salt", "psave", "Sil", "slALT", "sert", "piv", "salted", "Siv", "halt", " sert", "Sol", "psalt", "palt", "tsave", "hig", "tsol", "pig", "slil", "SALT", "siv", "cass", "Sash", "hALT", "unsig", "sig", " sig", "seil", "calt", "shet", "Salted", "sol", "slash", "sint", "Sass", "tsalt", "psass", " save", "seALT", " sALT", "sALT", " sint", "chet", "pALT", " salted", "hiv", " shet", "slalt", "Sert", "save", " sol", "Sig", "tsALT"], "_md": [" _mn", " _dm", "_____md", " _df", "_mn", "_____mb", "_mk", "_____mp", " _mand", "_mb", "_sd", "___md", "_MD", "_____mg", "_mand", " _MD", "_df", " _sd", "_mg", " _cmd", "_____dm", "___dm", "_mp", "_cmd", "_____mn", "_dm", "___MD", "___mn"], "md2": [" md1", "dd2", "cmdtwo", "modetwo", "cmdto", "sd1", "dd5", "mode4", "mdTwo", "mb2", "cmd52", "mb52", " md52", "sdTwo", "mode5", "rm6", " md6", "md5", "mb4", "mandto", "cmd5", "mode2", "mdto", "mand2", "rm2", "cmd2", "rm5", "sd2", " mdto", "md4", "md52", "mand5", "rm4", "md6", " md4", "cmd6", "sd5", "dd4", "mand4", "md1", "ddTwo", "cmd4", "dd1", "mb5", "ddtwo", "mdtwo", " md5", " mdTwo"], "abyFinal": ["BabyFin", "uffyFinal", "boatFull", "sayUpdated", "boatInitial", "BabyLast", "agusFinal", "inessFinal", "abyLast", "boatDual", "uyTotal", "alyAll", "washingFixed", "abyFixed", "seatInitial", "BabyZero", "inessReal", "andyComplete", "agusTotal", "abyUpdated", "aberFinal", "washingFin", "sayFinal", "uyInitial", "seatTotal", "andyAll", "seatFin", "sayReal", "uffyUpdated", "seatFinal", "inessFixed", "abyReal", "washingDual", "sayTotal", "alyComplete", "washingComplete", "agusUpdated", "alyFinal", "abyZero", "uffyTotal", "andyFixed", "BabyFinal", "phiReal", "boatReal", "aberInitial", "uyFin", "abyFull", "abyInitial", "abyDual", "washingAll", "boatFinal", "aberFin", "abyFin", "phiDual", "phiFull", "andyFinal", "washingZero", "sayInitial", "abyTotal", "aberTotal", "satLast", "phiFinal", "abyComplete", "alyFixed", "washingLast", "washingReal", "washingFinal", "satZero", "agusFixed", "uffyFixed", "boatFixed", "satFinal", "abyAll", "satFin", "inessInitial", "washingFull", "uyFinal", "sayFixed"], "n": ["all", "na", "en", "nt", "nm", "z", "gn", "nan", "N", "y", "con", "ng", "d", "cn", "nn", "yn", "ln", "m", "dn", "t", "names", "ns", "k", "c", "net", "nor", "un", "v", "number", "nb", "name", "pn", "nu", "non", "l", "out", "ni", "note", "nl", "np", "ul", "len", " N", "norm", "sn", "g", "network", "o", "syn", "num", "ren", "nr", "mn", "nc", "el", "count", "nw", "no", "size", "an", "p", "ne", "w"], "j": ["json", "br", "dj", "z", "y", "I", "uj", "im", "js", "obj", "jit", "ia", "jl", "x", "k", "jj", "q", "bi", "b", "bj", "aj", "v", "jc", "ja", "ij", "out", "kj", "ji", "it", "jump", "si", "at", "g", "oj", "J", "jp", "index", "p", "ix"], "i": ["mi", "u", "ini", "y", "I", "qi", "di", "ri", "ei", "m", "ki", "ia", "ami", "ti", "iu", "init", "hi", "k", "c", "bi", "cli", "ic", "ci", "multi", "ai", "gi", "v", "ij", "pi", "l", "ix", "ji", "it", "ni", "li", "xi", "si", "ip", "info", "ii", "gu", "p", "phi"], "sbPasswd": ["cbPassWD", "sbChainWD", "sbPASSwd", "sbAssword", "sbGuWD", "sbPushwd", "sbPassgrad", "sbpasswd", "ebChainweight", "sbDefwd", "sbGuenc", "sbAsswd", "sbMassWD", "cbpassw", "sbDefw", "sbWorkw", "sbChainwd", "sbPushw", "sbPassword", "zbDefwd", "zbPasssword", "sbpassrc", "sbWorkwd", "cbPassess", "ebChainword", "sbPassess", "sbPASSgrad", "ebPasswd", "sbPushWD", "sbMassenc", "zbDefw", "sbChainweight", "sbpasssword", "sbAssWD", "sbGuwd", "cbpassrc", "sbPASSrc", "zbDefsword", "cbMassess", "zbPassweight", "zbDefweight", "sbPassweight", "ebChainWD", "sbpassweight", "sbpassgrad", "sbPassWD", "sbPasssword", "sbPassenc", "ebPassword", "sbWorkweight", "cbMasswd", "cbPassrc", "cbPassgrad", "sbPassw", "cbPassw", "sbPushenc", "sbPushrc", "cbPasswd", "sbMasswd", "sbChainword", "sbGuess", "sbPASSw", "cbMassWD", "ebPassweight", "sbPushess", "ebChainwd", "cbpasswd", "cbpassgrad", "sbDefsword", "sbMassess", "sbPushgrad", "cbPassenc", "zbPassw", "cbMassenc", "sbAssweight", "sbDefweight", "ebPassWD", "sbPassrc", "sbpassw", "zbPasswd", "sbWorksword"], "md3": ["md33", "cmd3", "cmd33", "mt30", "MD2", "cmdThree", "MD5", "m43", "rm3", "MD3", "mt5", "MD43", "cmd43", "dm03", "mdThree", "mb4", "md5", "cmd5", " md43", "md03", "mt2", "md43", "mb3", "rm5", "dm5", "cmd03", "cmd2", "md4", "m5", "mt03", "m3", "rm30", "rmThree", "mt33", " md4", "mt43", "mb5", "md30", "mt3", " md5", "dm33", "dm3", "m4", "mtThree", "cmd30", "mb43"]}}
{"id1": "18504192", "id2": "15797402", "code1": "    static void copyFile(File in, File out) throws IOException {\n        FileChannel source = new FileInputStream(in).getChannel();\n        FileChannel destination = new FileOutputStream(out).getChannel();\n        source.transferTo(0, source.size(), destination);\n        source.close();\n        destination.close();\n    }\n", "code2": "    public void parse(InputStream stream, ContentHandler handler, Metadata metadata, ParseContext context) throws IOException, SAXException, TikaException {\n        String name = metadata.get(Metadata.RESOURCE_NAME_KEY);\n        if (name != null && wanted.containsKey(name)) {\n            FileOutputStream out = new FileOutputStream(wanted.get(name));\n            IOUtils.copy(stream, out);\n            out.close();\n        } else {\n            if (downstreamParser != null) {\n                downstreamParser.parse(stream, handler, metadata, context);\n            }\n        }\n    }\n", "label": 1, "substitutes": {"copyFile": ["CopyFiles", " transferFile", "copyFiles", "CopyStream", " transferFiles", " CopyStream", "copyStream", "copyfile", " Copyfile", " CopyFiles", "CopyFile", " transferStream", " CopyFile", "Copyfile", " transferfile"], "in": ["rin", "en", "inn", "gin", "IN", "vin", "ins", "on", "In", "old", "b", "ic", "edIn", "up", "i", "inc", "l", "input", "or", "it", "ind", "o", "el", "mm", "n", "din", "inf", "is", "isin", "as", "cin", "id", "from"], "out": ["nt", "output", "oss", "help", "t", "po", "k", "net", "log", "err", "b", "to", "ot", "v", "i", "serv", "os", "l", "it", "gt", "ou", "at", "outs", "g", "o", "s", "ex", "n", "io", "Out", "OUT", "ne", "w"], "source": ["origin", "back", "scan", "style", "access", "subject", "match", "sample", "ie", "service", "pse", "resource", "se", "reader", "comment", "sequence", "secret", "create", "force", "before", "init", "inner", "template", "me", "store", "inside", "spec", "scope", "open", "system", "src", "Source", "copy", "position", "SOURCE", "input", "sin", "query", "parse", "search", "seed", "ource", "space", "instance", "use", "iterator", "local", "info", "volume", "ources", "start", "file", "shell", "from"], "destination": ["Destation", "restinated", " destregation", " destation", "coordregation", " destification", "comification", "restinator", "destregation", " destension", "restation", "destension", "comato", "seeinator", "coordification", "destation", "comregation", "Destinated", " destinator", "Destinator", "coordato", " destato", "coordination", " destinated", "seeination", "seeension", "destification", "destinated", "seeinated", "destato", "Destination", "Destension", "destinator", "restination", "comination"]}}
{"id1": "7351534", "id2": "8770016", "code1": "    public static InputStream getStreamFromSystemIdentifier(String systemId, EntityResolver resolver) throws Exception {\n        InputSource source = null;\n        InputStream stream = null;\n        if (resolver != null) {\n            try {\n                source = resolver.resolveEntity(null, systemId);\n            } catch (Exception e) {\n                LogService.instance().log(LogService.ERROR, \"DocumentFactory: Unable to resolve '\" + systemId + \"'\");\n                LogService.instance().log(LogService.ERROR, e);\n            }\n        }\n        if (source != null) {\n            try {\n                stream = source.getByteStream();\n            } catch (Exception e) {\n                LogService.instance().log(LogService.ERROR, \"DocumentFactory: Unable to get bytestream from '\" + source.getSystemId() + \"'\");\n                LogService.instance().log(LogService.ERROR, e);\n            }\n        }\n        if (stream == null) {\n            URL url = new URL(systemId);\n            stream = url.openStream();\n        }\n        return stream;\n    }\n", "code2": "    public InputStream loadResource(String location) throws GenericConfigException {\n        URL url = getURL(location);\n        try {\n            return url.openStream();\n        } catch (java.io.IOException e) {\n            throw new GenericConfigException(\"Error opening URL resource at location [\" + url.toExternalForm() + \"]\", e);\n        }\n    }\n", "label": 0, "substitutes": {"getStreamFromSystemIdentifier": ["getStreamFromSysIdentifier", "getStreamFromSysidentifier", "getStreamFromSystemIdifiers", "getStreamFromSystemidentifer", "getStreamFromSysIdentification", "getStreamFromSystemIdification", "getStreamFromSystemIdentifer", "getStreamFromSysidentifer", "getStreamFromSystemidentifier", "getStreamFromSysIdentifer", "getStreamFromSysidentification", "getStreamFromSystemidentification", "getStreamFromSysIdentifiers", "getStreamFromSysidentifiers", "getStreamFromSystemIdifer", "getStreamFromSystemidentifiers", "getStreamFromSystemIdentification", "getStreamFromSystemIdentifiers", "getStreamFromSystemIdifier"], "systemId": ["systemDoes", "ystemIs", "ystemMid", "localhostMid", "humanById", "cmsId", "systemIn", "humanId", "sysID", "humanStart", "systemid", "publicIn", "cmsDoes", "publicId", "ystemid", "sysById", "systemById", "localhostId", "cmsStart", "systemMid", "publicById", "ystemIn", "publicName", "ystemName", "localhostStart", "systemStart", "ystemById", "systemIs", "publicMid", "humanIs", "humanDoes", "systemName", " systemName", "systemID", "serverId", "cmsMid", "publicid", "sysIs", "ystemID", "sysId", "serverById", "serverid", "humanMid", "ystemId", "localhostDoes", " systemById", "humanID", "serverIn", " systemMid"], "resolver": [" resanger", "resolutionolution", "reanger", "resolutionolving", "persolution", "reolving", " reserver", "resolving", "persolver", "relove", "rserver", "perslove", "reserver", " resolved", "persolving", "resolutionlove", "reolver", "resolution", "resanger", "resolutionolver", " resolution", "reolved", "reerver", "reslove", " resolve", "rsanger", "rsolver", "persolve", "reolution", "reolve", "persolved", "resolve", "resolved", "rsolution"], "source": ["proxy", "origin", "ser", "series", "via", "style", "rule", "response", "image", "subject", "sample", "supp", "console", "sp", "service", "storage", "resource", "reader", "se", "sequence", "force", "create", "raw", "site", "table", "status", "context", "init", "inner", "ce", "template", "spec", "store", "base", "attribute", "scope", "system", "src", "missing", "result", "Source", "node", "uri", "copy", "get", "target", "SOURCE", "input", "sql", "parent", "object", "component", "ource", "null", "seed", "instance", "relation", "iterator", "channel", "local", "remote", "string", "file", "shell", "unit", "cause", "from", "peer"], "stream": ["window", "output", "sample", "test", "next", "pipe", "port", "mount", "out", "form", "present", "channel", "row", "our", "control", "loop", "REAM", "response", "cont", "resource", "reader", "pod", "buffer", "log", "shape", "ream", "cache", "progress", "upload", "encrypted", "batch", "ssl", "http", "temp", "file", "poll", "clean", "Stream", "feed", "chain", "open", "hold", "read", "complete", "input", "proc", "object", "length", "instance", "download", "pool", "body", "wrapper", "data", "peer", "export", "sync", "console", "trans", "sequence", "load", "message", "impl", "result", "stack", "content", "valid", "sw", "null", "iterator", "zip", "socket"], "url": ["browser", "f", "back", "window", "hl", "gl", "address", "ref", "dl", "service", "resource", "bel", "ls", "web", "ll", "char", "link", "build", "sl", "b", "system", "rel", "ur", "mount", "uri", "URL", "rl", "external", "l", "nl", "ul", "mail", "term", "null", "r", "ssl", "ret", "key", "http", "location", "job", "Url"]}}
{"id1": "350482", "id2": "742465", "code1": "    public static void doVersionCheck(View view) {\n        view.showWaitCursor();\n        try {\n            URL url = new URL(jEdit.getProperty(\"version-check.url\"));\n            InputStream in = url.openStream();\n            BufferedReader bin = new BufferedReader(new InputStreamReader(in));\n            String line;\n            String develBuild = null;\n            String stableBuild = null;\n            while ((line = bin.readLine()) != null) {\n                if (line.startsWith(\".build\")) develBuild = line.substring(6).trim(); else if (line.startsWith(\".stablebuild\")) stableBuild = line.substring(12).trim();\n            }\n            bin.close();\n            if (develBuild != null && stableBuild != null) {\n                doVersionCheck(view, stableBuild, develBuild);\n            }\n        } catch (IOException e) {\n            String[] args = { jEdit.getProperty(\"version-check.url\"), e.toString() };\n            GUIUtilities.error(view, \"read-error\", args);\n        }\n        view.hideWaitCursor();\n    }\n", "code2": "    public static void doVersionCheck(View view) {\n        view.showWaitCursor();\n        try {\n            URL url = new URL(jEdit.getProperty(\"version-check.url\"));\n            InputStream in = url.openStream();\n            BufferedReader bin = new BufferedReader(new InputStreamReader(in));\n            String line;\n            String version = null;\n            String build = null;\n            while ((line = bin.readLine()) != null) {\n                if (line.startsWith(\".version\")) version = line.substring(8).trim(); else if (line.startsWith(\".build\")) build = line.substring(6).trim();\n            }\n            bin.close();\n            if (version != null && build != null) {\n                if (jEdit.getBuild().compareTo(build) < 0) newVersionAvailable(view, version, url); else {\n                    GUIUtilities.message(view, \"version-check\" + \".up-to-date\", new String[0]);\n                }\n            }\n        } catch (IOException e) {\n            String[] args = { jEdit.getProperty(\"version-check.url\"), e.toString() };\n            GUIUtilities.error(view, \"read-error\", args);\n        }\n        view.hideWaitCursor();\n    }\n", "label": 1, "substitutes": {"doVersionCheck": ["doVersionsCheck", " doVersionsCheck", "doBuildcheck", "doBuildTest", "doImageTest", "doVersionInfo", " doVersionUpdate", " doVersioncheck", "doFeatureTest", "doImageCheck", " doVersionsTest", "doApplicationTest", "doImageInfo", " doVersionTest", "doVersionsUpdate", " doVersionQuery", "doApplicationInfo", " doVersionscheck", "doFeatureQuery", "doVersionUpdate", "doFeatureUpdate", "doApplicationCheck", "doApplicationQuery", "doBuildUpdate", "doVersionTest", "doVersionsTest", " doApplicationTest", "doVersionQuery", " doVersionInfo", " doApplicationInfo", " doApplicationQuery", "doVersionscheck", " doVersionsUpdate", "doBuildCheck", "doVersioncheck", "doImageQuery", "doFeatureCheck", "doFeatureInfo", " doApplicationCheck", "doFeaturecheck"], "view": ["browser", "report", "window", "cv", "layout", "image", "virtual", "subject", "block", "lock", "engine", "h", "client", "VIEW", "tv", "views", "page", "update", "context", "box", "port", "q", "buffer", "document", "call", "cell", "v", "widget", "review", "see", "iew", "input", "query", "this", "controller", "tree", "form", "show", "project", "component", "eye", "model", "View", "manager", "self", "row", "http", "html", "file", "vm", "pool", "version", "index", "check", "ml", "print", "server", "display"], "url": ["f", "browser", "hl", "gl", "address", "ref", "dl", "lb", "client", "bel", "ll", "char", "link", "pl", "log", "sl", "build", "b", "rel", "ur", "v", "mount", "uri", "URL", "str", "rl", "get", "l", "oul", "nl", "ul", "mail", "r", "ssl", "domain", "http", "html", "job", "file", "loc", "Url", "host"], "in": ["f", "rin", "inn", "gin", "IN", "vin", "ins", "reader", "ln", "on", "can", "stream", "In", "init", "inner", "asin", "i", "mat", "inc", "l", "input", "out", "sin", " IN", " din", "ain", "mn", "info", "n", "din", "inf", "is", "isin", "source", "body", "cin", "from"], "bin": ["all", "rin", " Bin", "win", "inn", "stock", "buff", "by", "gin", "con", "bl", "bg", "cos", "cb", "ins", "obin", "reader", "bur", "ln", "bed", "conv", "init", "inner", "bi", "spin", "buffer", "b", "mon", "thin", "db", "re", "ran", "nb", " bins", "lib", "abin", "cache", "rb", "out", "sin", "len", " din", "binary", "local", "din", "sam", "jin", "file", "brain", "bn", "body", "cin", "ebin", "session"], "line": ["rule", "LINE", "lo", "style", "zone", "lin", "block", "cat", "eline", "entry", "ine", "sample", "next", " block", "column", "part", "comment", "frame", "lane", "word", "ln", "sequence", "lines", "page", "status", "stream", "port", "base", "trace", "char", "code", "range", "link", "log", "chain", "err", "message", "cell", "ice", "detail", "stay", "le", "liner", "l", "section", "iter", "cmd", "parse", "point", "record", "Line", "channel", "key", "row", "string", "job", "field", "inline", "file", "tile", "print"], "develBuild": ["deeltaLoad", "deployBuilder", "duVELBuild", "duvelBuilt", "develLoad", "desvelLoad", "desVELRelease", "deeltaRelease", "deffBuild", "depoBuilt", "desvelbuild", "devBuilder", "deployBuilt", "duvelBuilder", "duffbuild", "duvelBoot", "DeVELBuilt", "desVELbuild", "devBuilt", "duffBuilt", "desvelBuild", "deeltaBuild", "devLog", "deployRelease", "develbuild", "devBuild", "develBoot", "devBoot", "DevelBuild", "DeVELbuild", "deployBuild", "deVELRelease", "duVELbuild", "deffBuilder", "deVELLog", "DeVELLog", "desVELLoad", "deVELLoad", "deVELBuilt", "deVELbuild", "DevelLog", "deVELBuild", "deployBoot", "duffBuild", "deVELBuilder", "duVELBuilder", "deeltabuild", "duvelBuild", "deffBuilt", "Develbuild", "depoBuild", "depobuild", "desvelRelease", "develLog", "DevelBuilt", "deploybuild", "duffBuilder", "deVELBoot", "develBuilt", "deffbuild", "desVELBuild", "DeVELBuild", "devbuild", "develRelease", "develBuilder", "deployLoad", "duvelbuild", "duVELBoot", "depoLog"], "stableBuild": ["activeBuilder", " unstableBuilder", " stableBuilder", "activeBuild", "securebuild", "confirmedBoot", "confirmedBuild", "stableBoot", "devBuilder", "activebuild", "stableCraft", "confirmedLong", " stableBind", " stableBoot", " unstableBuild", "stablebuild", "devBuild", " stableMake", "devBind", " stableCraft", "stableBind", "secureBuilder", " unstableLong", "secureBuild", "stableBuilder", " unstableBind", "confirmedbuild", " stablebuild", "activeMake", " unstableCraft", " stableLong", " unstablebuild", "devbuild", "devMake", "stableMake", "secureCraft", "stableLong", " unstableBoot"]}}
{"id1": "6271502", "id2": "18613870", "code1": "    @Override\n    public InputStream getResourceByClassName(String className) {\n        URL url = resourceFetcher.getResource(\"/fisce_scripts/\" + className + \".class\");\n        if (url == null) {\n            return null;\n        } else {\n            try {\n                return url.openStream();\n            } catch (IOException e) {\n                return null;\n            }\n        }\n    }\n", "code2": "    private static void copyFile(File src, File dst) throws IOException {\n        FileChannel in = new FileInputStream(src).getChannel();\n        FileChannel out = new FileOutputStream(dst).getChannel();\n        in.transferTo(0, in.size(), out);\n        in.close();\n        out.close();\n    }\n", "label": 0, "substitutes": {"getResourceByClassName": ["getResourcebyclassType", "getResourcebyClassType", "getResourceByFileType", "getResourceByFileNames", "getResourcebyClassPath", "getResourceByPackagePath", "getResourcebyClassName", "getResourceByclassType", "getResourceByPackageName", "getResourceByclassPath", "getResourceByClassNames", "getResourceByPackageType", "getResourceByClassPath", "getResourceByclassName", "getResourceByFileName", "getResourcebyclassName", "getResourcebyclassPath", "getResourceByClassType", "getResourcebyClassNames", "getResourcebyclassNames", "getResourceByFilePath", "getResourceByclassNames", "getResourceByPackageNames"], "className": ["classesNAME", " classFamily", "classNAME", "CLASSNAME", "templateNAME", "classesType", " classType", "classType", " classNames", " classNAME", "classFamily", "ClassName", "templateName", "classesName", "Classname", "classNames", " classname", "templateFamily", "CLASSName", "classname", "ClassNames", "CLASSNames", "CLASSname", "ClassNAME", "templateType", "classesFamily"], "url": ["f", "browser", "gl", "address", "ref", "dl", "entry", "util", "service", "resource", "builder", "raw", "page", "ls", "web", "ll", "char", "abs", "link", "err", "sl", "log", "b", "bb", "impl", "lr", "result", "re", "rel", "mount", "uri", "URL", "name", "str", "rl", "get", "l", "or", "nl", "mail", "path", "rect", "mb", "ssl", "channel", "ret", "http", "location", "job", "button", "file", "loc", "Url", "user", "ml", "cl"]}}
{"id1": "9826240", "id2": "14691829", "code1": "    private boolean checkHashBack(Facade facade, HttpServletRequest req) {\n        String txtTransactionID = req.getParameter(\"txtTransactionID\");\n        String txtOrderTotal = req.getParameter(\"txtOrderTotal\");\n        String txtShopId = facade.getSystemParameter(GlobalParameter.yellowPayMDMasterShopID);\n        String txtArtCurrency = facade.getSystemParameter(GlobalParameter.yellowPayMDCurrency);\n        String txtHashBack = req.getParameter(\"txtHashBack\");\n        String hashSeed = facade.getSystemParameter(GlobalParameter.yellowPayMDHashSeed);\n        String securityValue = txtShopId + txtArtCurrency + txtOrderTotal + hashSeed + txtTransactionID;\n        MessageDigest digest;\n        try {\n            digest = java.security.MessageDigest.getInstance(\"MD5\");\n            digest.update(securityValue.getBytes());\n            byte[] array = digest.digest();\n            StringBuffer sb = new StringBuffer();\n            for (int j = 0; j < array.length; ++j) {\n                int b = array[j] & 0xFF;\n                if (b < 0x10) sb.append('0');\n                sb.append(Integer.toHexString(b));\n            }\n            String hash = sb.toString();\n            System.out.println(\"com.eshop.http.servlets.PaymentController.checkHashBack: \" + hash + \" \" + txtHashBack);\n            if (txtHashBack.equals(hash)) {\n                return true;\n            }\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        }\n        return false;\n    }\n", "code2": "    public static String getMD5Hash(String in) {\n        StringBuffer result = new StringBuffer(32);\n        try {\n            MessageDigest md5 = MessageDigest.getInstance(\"MD5\");\n            md5.update(in.getBytes());\n            Formatter f = new Formatter(result);\n            for (byte b : md5.digest()) {\n                f.format(\"%02x\", b);\n            }\n        } catch (NoSuchAlgorithmException ex) {\n            ex.printStackTrace();\n        }\n        return result.toString();\n    }\n", "label": 1, "substitutes": {"checkHashBack": ["checkClearUp", " checkhashUp", "checkLockBack", "checkClearback", "checkhashDown", "checkHashback", "checkLockUp", "checkClearDown", "checkhashback", " checkhashBack", "checkLockDown", "checkLockback", "checkHashDown", "checkHashUp", " checkHashback", " checkHashDown", "checkhashBack", "checkClearBack", "checkhashUp", " checkHashUp", " checkhashDown", " checkhashback"], "facade": ["glage", "funcage", "funcader", "Facificate", "funcade", "faclegate", "Facaded", "Facage", "formificate", "facader", "latlegate", " facage", "servade", "facificate", "Facacet", "Faclegate", "latader", "famacet", "facades", "famade", "servage", "formace", "funcace", "Facades", "Facade", "Facader", "formacet", "latace", "glader", "servades", "funclegate", "facacet", "servaded", " facades", "famace", "formade", "Facace", "glace", "facace", "glade", "facaded", " facaded", "facage", "famificate", "latade"], "req": ["rec", "attr", "good", "ctx", "res", "tx", "mr", "params", "uj", "request", "requ", "obj", "qs", "quest", "wcs", "work", "Requ", "urg", "sq", "q", "wx", "err", "require", "pkg", "resp", "ctr", "forced", "cur", "Request", "reg", "org", "e", "required", "rb", "qq", "out", "proc", "cmd", "queue", "Resp", "etc", "r", "rpm", "desc", "aux", "gr", "http", "jp", "forge", "msg", "rh", "compl", "body", "qt", "needed", "p", "data"], "txtTransactionID": ["txtOrderName", "txtTransName", "txtOrderID", "textTransactionId", "xtTxName", "txtTxName", "txtTransID", "txtOrderId", "txtTxId", "xtTxKey", "xtTransactionId", "textTxName", "txtTxID", "xtTransactionKey", "txtTXId", "xtTransactionName", "txtTransactionName", "txtTransId", "textTxID", "textTxId", "xtTxID", "txtTXID", "txtTransKey", "textTransactionName", "xtTransactionID", "txtTransactionId", "txtTransactionKey", "txtTxKey", "textTransactionID", "txtOrderKey", "xtTxId", "txtTXName"], "txtOrderTotal": ["txtJobInfo", "txtOrderInfo", "txtArticleTotal", "txtArticleInfo", "xtOrderInfo", "txtOrderId", "txtTransactionTotal", "txtArticleId", "strTransactionTotal", "xtOrdId", "txtOrdId", "txtOrdTotal", "txtJobTotal", "txtTradeBase", "xtOrderTotal", "txtJobSum", "txtTransactionComplete", "strTransactionBase", "xtOrdTotal", "xtOrderId", "txtOrdBase", "txtArticleSum", "txtOrdInfo", "txtOrdComplete", "txtJobId", "strOrderBase", "txtOrderSum", "txtTransactionBase", "txtOrderBase", "xtOrderSum", "strOrderTotal", "xtOrdSum", "txtTradeTotal", "strTransactionComplete", "strOrderComplete", "xtOrdInfo", "txtOrdSum", "txtOrderComplete", "txtTradeComplete"], "txtShopId": ["txtStreetid", "txtSiteID", "txtServerid", "xtSiteAid", "txtStreetById", "textStoreid", "txtServerID", "txtStoreid", "txtSiteId", "textStoreId", "txtForgeID", "txtStoreId", "txtStreetId", "txtStoreID", "xtSiteID", "xtShopAid", "txtShopid", "txtForgeid", "txtServerId", "textShopid", "txtForgeId", "textStoreID", "txtShopAid", "txtSiteAid", "txtSiteid", "txtSiteById", "xtShopid", "txtShopById", "xtShopId", "txtForgeAid", "xtSiteid", "txtStreetID", "txtShopID", "txtServerAid", "textShopById", "textShopID", "xtSiteId", "txtStoreById", "textShopId", "textStoreById", "xtShopID"], "txtArtCurrency": ["txtArtConategories", "txtArticleCoulture", "txtArticleCcurrency", "txtArtConulture", "txtArticleCategories", "txtArticleCourrency", "txtArtCoategories", "txtArtColurrency", "txtArticleCulture", "txtArticleCocurrency", "txtArtConurrencies", "txtArtCurrencies", "txtArticleCurrency", "txtArtColcurrency", "txtArtCocurrency", "txtArtCulture", "txtArtCcurrency", "txtArtCourrencies", "txtArticleCurrencies", "txtArticleConategories", "txtArtConurrency", "txtArtCoulture", "txtArtColategories", "txtArticleConcurrency", "txtArtConcurrency", "txtArtCourrency", "txtArticleCourrencies", "txtArtCategories", "txtArticleConurrency"], "txtHashBack": ["xtHashBack", "txthashBACK", "txthashFront", "txtFilterBack", "texthashValue", "txtHelpBACK", "txthashback", "texthashback", "txthashValue", "txtRawBack", "txtClearback", "txtHelpback", "texthashBack", "txtLockback", "txtLockBack", "textHashBack", "xtHashBACK", "txtFilterFront", "txtLockBACK", "txtHashFront", "xtStockFront", "txtHashback", "xtStockBack", "textHashback", "txtClearFront", "txtStockback", "xtStockback", "txtHelpFront", "txtStockBACK", "txtHashBACK", "txtFilterback", "txtLockFront", "txtFilterBACK", "txtRawback", "txtStockFront", "textHashValue", "texthashBACK", "txtHashValue", "txthashBack", "txtClearBACK", "txtClearBack", "texthashFront", "xtHashFront", "textHashFront", "xtStockBACK", "txtRawBACK", "xtHashback", "textHashBACK", "txtHelpBack", "txtStockBack", "txtRawValue"], "hashSeed": ["hashFetter", "hashAsep", "hashFeed", "hoAseder", "hashSeiper", "hoAsep", "hashSetter", " hashSiper", "hashSeder", "hashSeeeds", "hashFep", " hashSeee", " hashSeeed", "hoAseed", "hashFeder", "hashSeeed", "hashSlee", "hashAseder", "hashSeee", "hashSiper", " hashSeiper", "hashSee", "hashSleed", "hashSep", "hoSeed", "hashSourceeed", " hashSeeds", "hashSourceep", "hoSep", "hashSleeds", "hoAsetter", "hoSetter", "hashSourceeder", "hoSeder", "hashSliper", "hashSourceetter", "hashSeeds", "hashAseed", " hashSee", "hashAsetter", " hashSeeeds"], "securityValue": ["SecurityValue", "secVal", " securityVal", "securityVal", "secValue", "secValues", "securityData", "secData", "securityValues", " securityValues", "SecurityData", "SecurityVal", " securityData", "SecurityValues"], "digest": ["dested", " digse", "equse", "equet", "Diget", "diger", "macester", "diget", "diggest", "dest", "der", "dependest", "equest", "Diger", "digests", "contse", "digse", "Digester", "Digests", " digests", "dEST", "Digse", "digEST", "Diggest", "contest", "contested", "equester", "dependester", " digester", "Digested", "dependested", " diget", "dependgest", "macested", "macest", "dse", " digEST", "digested", " diger", "contests", "digester", "dester", "DigEST", "macgest", " digested", "Digest"], "array": ["ashes", "export", "response", "pair", " Array", "ash", "vector", "rays", "ar", "area", "a", "share", "av", "iq", "view", "raw", "sha", "range", "attribute", "buffer", "shape", "max", "list", "v", "number", "angular", "now", "archive", "stage", "audio", "object", "length", "binary", "batch", "record", "instance", "ray", "collection", "bar", "Array", "row", "string", "RAY", "our", "arr", "arrow", "map", "angle"], "sb": ["bt", "pb", "rub", "bf", "bg", "cb", "ob", "obb", "lb", "zb", "bh", "bps", "bs", "sbm", "ls", "bsp", "wb", "sa", "sq", "sg", "orb", "soc", "bb", "esm", "bj", "SB", "gc", "nb", "sv", "kb", "rb", "sf", "eb", "abb", "obs", "ctrl", "lp", "sn", "bis", "stab", "ssl", "erb", "sam", "rob", "shell", "gob", "gb", "ib", "abs"], "j": ["_", "json", "br", "dj", "z", "uj", "js", "obj", "jit", "jl", "jet", "x", "k", "jj", "q", "bj", "aj", "v", "i", "yy", "ja", "jc", "jo", "state", "ij", "kj", "ji", "it", "jump", "ody", "g", "ind", "el", "oj", "J", "n", "jp", "key", "gr", "msg", "job", "att", "from", "bot", "ix"], "b": ["beta", "bt", "B", "br", "bf", "bit", "bg", "cb", "h", "bound", "bs", "bc", "base", "be", "k", "bi", "bb", "db", "bp", "v", "nb", "BB", "ba", "rb", "eb", "bu", "binary", "mb", "bis", "bar", "fb", "gb", "ib", "bd", "ab"], "hash": ["ashes", "ah", "buster", "report", "handle", "response", "json", "address", "value", "ash", "Hash", "block", "sample", "test", "h", "bh", "sum", "tag", "sha", "flash", "hz", "ASH", "message", "result", "format", "cache", "url", "total", "hex", "search", "height", "filter", "crypt", "ssl", "href", "key", "html", "string", "oh", "uh", "rh", "where", "password", "version", "check", "data", "header", "title"]}}
{"id1": "10385815", "id2": "6403868", "code1": "    public static void copy(String fileFrom, String fileTo) throws IOException {\n        FileInputStream inputStream = null;\n        FileOutputStream outputStream = null;\n        FileChannel inputChannel = null;\n        FileChannel outputChannel = null;\n        try {\n            inputStream = new FileInputStream(fileFrom);\n            outputStream = new FileOutputStream(fileTo);\n            inputChannel = inputStream.getChannel();\n            outputChannel = outputStream.getChannel();\n            inputChannel.transferTo(0, inputChannel.size(), outputChannel);\n        } finally {\n            try {\n                inputChannel.close();\n            } finally {\n                try {\n                    outputChannel.close();\n                } finally {\n                    try {\n                        inputStream.close();\n                    } finally {\n                        outputStream.close();\n                    }\n                }\n            }\n        }\n    }\n", "code2": "    private File extractUninstallFiles(File _destPath, boolean upgrade, String lastVer) {\n        File oldlog = null;\n        try {\n            boolean oldClassCopied = false;\n            File destPath = new File(_destPath, \"vai_\" + VAGlobals.APP_NAME + \"_\" + VAGlobals.APP_VERSION);\n            if (upgrade) {\n                File lastVerPath = new File(_destPath, \"vai_\" + VAGlobals.APP_NAME + \"_\" + lastVer);\n                if (destPath.equals(lastVerPath)) {\n                    File bkdir = new File(destPath.getAbsolutePath() + \".bak\");\n                    if (!destPath.renameTo(bkdir)) {\n                        throw new IOException(VAGlobals.i18n(\"Setup_NotCreateDirectory\") + \" \" + destPath);\n                    }\n                    oldlog = new File(bkdir.getAbsolutePath() + System.getProperty(\"file.separator\") + \"uninstall.vai\");\n                    lastVerPath = bkdir;\n                } else {\n                    oldlog = new File(lastVerPath.getAbsolutePath() + System.getProperty(\"file.separator\") + \"uninstall.vai\");\n                }\n                if ((!destPath.exists()) && (!destPath.mkdirs())) {\n                    throw new IOException(VAGlobals.i18n(\"Setup_NotCreateDirectory\") + \" \" + destPath);\n                }\n                if (uInfo_.module) oldClassCopied = copyOldSetupClass(lastVerPath, destPath);\n            } else {\n                if ((!destPath.exists()) && (!destPath.mkdirs())) {\n                    throw new IOException(VAGlobals.i18n(\"Setup_NotCreateDirectory\") + \" \" + destPath);\n                }\n            }\n            dirty_ = true;\n            File[] ls = destPath.listFiles();\n            for (int i = 0; i < ls.length; i++) {\n                if (!oldClassCopied) ls[i].delete(); else if (!ls[i].getPath().equals(destPath.getAbsolutePath() + File.separator + installClassName_ + \".class\")) ls[i].delete();\n            }\n            byte[] buf = new byte[0];\n            int read = 0;\n            if (!oldClassCopied && (installClassSize_ > 0 || jarOffset_ > 0)) {\n                final File outClassFile = new File(destPath.getAbsolutePath() + File.separator + installClassName_ + \".class\");\n                if (outClassFile.exists() && !outClassFile.delete()) {\n                    ui_.showError(new Exception(VAGlobals.i18n(\"Setup_FileNotCreated\") + \":\\n\" + outClassFile.getName()));\n                }\n                final FileOutputStream out = new FileOutputStream(outClassFile);\n                final FileInputStream in = new FileInputStream(fileWithArchive_);\n                if (installClassOffset_ > 0) {\n                    in.skip(installClassOffset_);\n                }\n                buf = new byte[0];\n                if (installClassSize_ < 0) buf = new byte[(int) jarOffset_]; else buf = new byte[(int) installClassSize_];\n                read = in.read(buf, 0, buf.length);\n                out.write(buf, 0, read);\n                out.close();\n                in.close();\n            }\n            final FileInputStream in = new FileInputStream(fileWithArchive_);\n            if (jarOffset_ > 0) {\n                in.skip(jarOffset_);\n            }\n            JarInputStream jar = new JarInputStream(in);\n            final File outJarFile = new File(destPath.getAbsolutePath() + File.separator + \"install.jar\");\n            if (outJarFile.exists() && !outJarFile.delete()) {\n                ui_.showError(new Exception(VAGlobals.i18n(\"Setup_FileNotCreated\") + \":\\n\" + outJarFile.getName()));\n            }\n            JarOutputStream outJar = new JarOutputStream(new FileOutputStream(outJarFile));\n            ZipEntry entry = jar.getNextEntry();\n            final int bufSize = 32768;\n            buf = new byte[bufSize];\n            while (entry != null) {\n                String entryName = entry.getName();\n                if (entryName.equals(\"com/memoire/vainstall/resources/vainstall.properties\")) {\n                } else if (entryName.equals(installClassName_ + \".class\") && !oldClassCopied) {\n                    FileOutputStream out = null;\n                    try {\n                        out = new FileOutputStream(destPath.getAbsolutePath() + File.separator + installClassName_ + \".class\");\n                        VAGlobals.copyStream(jar, out, buf);\n                    } catch (IOException e) {\n                        throw e;\n                    } finally {\n                        if (out != null) out.close();\n                    }\n                } else if (!entryName.endsWith(\".zip\")) {\n                    if (VAGlobals.DEBUG) VAGlobals.printDebug(\"jar entry name \" + entryName);\n                    ZipEntry outEntry = new ZipEntry(entryName);\n                    CRC32 crc = new CRC32();\n                    outJar.putNextEntry(outEntry);\n                    int size = 0;\n                    while ((read = jar.read(buf, 0, bufSize)) >= 0) {\n                        size += read;\n                        if (read == 0) {\n                            Thread.yield();\n                        } else {\n                            outJar.write(buf, 0, read);\n                            crc.update(buf, 0, read);\n                        }\n                    }\n                    outEntry.setSize(size);\n                    outEntry.setCrc(crc.getValue());\n                    outJar.flush();\n                    outJar.closeEntry();\n                }\n                jar.closeEntry();\n                entry = jar.getNextEntry();\n            }\n            InputStream pin = getClass().getResourceAsStream(\"resources/vainstall.properties\");\n            Properties prop = new Properties();\n            try {\n                prop.load(pin);\n            } catch (IOException exc) {\n            }\n            if (language == null) language = \"default\";\n            prop.setProperty(\"vainstall.destination.language\", language);\n            ZipEntry outEntry = new ZipEntry(\"com/memoire/vainstall/resources/vainstall.properties\");\n            CRC32 crc = new CRC32();\n            outEntry.setCrc(crc.getValue());\n            outEntry.setSize(prop.size());\n            outJar.putNextEntry(outEntry);\n            prop.store(outJar, VAGlobals.NAME + \" \" + VAGlobals.VERSION);\n            outEntry.setCrc(crc.getValue());\n            outJar.closeEntry();\n            jar.close();\n            outJar.close();\n            in.close();\n        } catch (IOException e) {\n            String message = e.getLocalizedMessage();\n            message += \"\\n\" + VAGlobals.i18n(\"Setup_ErrorUninstallScripts\");\n            e.printStackTrace();\n            exitOnError(new IOException(message));\n        }\n        return oldlog;\n    }\n", "label": 1, "substitutes": {"copy": ["csv", "cop", "cat", "sync", "create", "Copy", "transfer", "write", "slice", "load", "replace", "rm", "cp", "read", " copying", "upload", "paste", "opy", "Cop", "download", "save", " duplicate", "file", "clip", "clone", "delete", "move"], "fileFrom": ["inputForm", "projectA", " fileStart", "ileFrom", "sampleFrom", "inputTo", "projectStart", "ileForm", " fileA", "FileFrom", "ileObject", "FileObject", "fileForm", "FileForm", "projectInitial", "projectFrom", "ileTo", "fileA", "fileStart", " fileInitial", "sampleStart", "FileTo", "inputObject", "sampleInitial", "fileInitial", "sampleA", "fileObject", "inputFrom"], "fileTo": ["File2", "fileTarget", "fileDest", "modelDest", "file2", " fileTarget", " fileTO", " fileDest", "modelTarget", "ile2", " file2", "fileTO", "modelTO", "FileTO", "ileTo", "modelTo", "FileTo", "ileTarget", "FileDest", "ileDest", "FileTarget"], "inputStream": ["sourceSteam", "inputStreamer", "InputChannel", "audioSteam", "InputStream", " inputSource", "InputSource", "inputFile", "sourceChannel", "eventStreamer", "InputStreamer", "eventStream", " inputSteam", "inputSteam", "activeSteam", "imageStreamer", "importStream", " inputFile", "eventstream", "eventSteam", "audioStream", "InputFile", "imageStream", "sourceSource", "importSteam", "inputstream", "activeChannel", "imageSteam", "imageChannel", "imagestream", "importChannel", "audiostream", "sourceStream", "InputSteam", "audioStreamer", "inputSource", "activeStream", "importFile", "activeStreamer"], "outputStream": [" outputString", "writeChannel", "resultSteam", "inputSteam", "displayChannel", "Outputstream", "outputFile", "webChannel", "OutputStream", "webStream", "resultChannel", "resultStream", "writeSocket", "displayStream", "displaySteam", "resultSocket", "writeStream", "OutputChannel", "displaystream", "webSteam", "OutputSteam", " outputSteam", "webString", "outputSteam", "OutputFile", "outputstream", " outputSocket", "inputstream", "outputString", "outputSocket", "writeSteam", " outputFile", "webFile", "inputString"], "inputChannel": ["currentChan", "inputCamera", "InputChannel", "outputConnection", "InputStream", "readableChan", "InputConnection", "InputCamera", "createChannel", "operatorConnection", " inputCamera", " inputSteam", "inputSteam", "createStream", "createChan", "inputChain", "operatorChannel", "operatorStream", "readableChannel", "readChan", "readableConnection", "readChannel", "inputConnection", "outputSteam", " inputChain", "inputChan", "currentChain", "localConnection", " inputChan", " inputConnection", "inputCategory", "localChan", "currentChannel", " inputCategory", "InputChan", "currentCategory", "readCategory", "readChain", "localChannel", "createSteam", "operatorCamera", "outputChan"], "outputChannel": ["OutputContext", "outputConnection", "successChannel", " outputChan", "putStream", "writeChannel", "writeChan", "outputchannel", "OutputStream", " outputchannel", "Outputchannel", "writeConnection", "writeContext", "putChannel", "putChan", "successConnection", "putchannel", "OutputChan", "hiddenChannel", " outputConnection", "updatechannel", "hiddenCategory", "OutputCategory", "updateChannel", "OutputConnection", "hiddenchannel", "outputCategory", " outputContext", "hiddenChan", "updateChan", "successStream", "outputContext", "OutputChannel", "updateCategory", "successchannel", "outputChan"]}}
{"id1": "2642914", "id2": "8490297", "code1": "    private static void addFileToTarGz(TarArchiveOutputStream taro, String path, String base) throws IOException {\n        File f = new File(path);\n        String entryName = base + f.getName();\n        FileInputStream goIn = new FileInputStream(f);\n        TarArchiveEntry tarEntry = new TarArchiveEntry(f, entryName);\n        taro.setLongFileMode(TarArchiveOutputStream.LONGFILE_GNU);\n        taro.putArchiveEntry(tarEntry);\n        if (f.isFile()) {\n            IOUtils.copy(goIn, taro);\n            taro.closeArchiveEntry();\n        } else {\n            taro.closeArchiveEntry();\n            File[] children = f.listFiles();\n            if (children != null) {\n                for (File child : children) {\n                    addFileToTarGz(taro, child.getAbsolutePath(), entryName + \"/\");\n                }\n            }\n        }\n        taro.close();\n        goIn.close();\n    }\n", "code2": "    public static void copyFile(File src, File dst) throws IOException {\n        try {\n            InputStream in = new FileInputStream(src);\n            OutputStream out = new FileOutputStream(dst);\n            byte[] buf = new byte[TEMP_FILE_BUFFER_SIZE];\n            int len;\n            while ((len = in.read(buf)) > 0) out.write(buf, 0, len);\n            in.close();\n            out.close();\n        } catch (FileNotFoundException e1) {\n            MLUtil.runtimeError(e1, src.toString());\n        } catch (IOException e2) {\n            MLUtil.runtimeError(e2, src.toString());\n        }\n    }\n", "label": 1, "substitutes": {"addFileToTarGz": ["addFileToTarGsz", "addFileToTarGep", "addFileToTarBzip", "addFileToTarGx", "addFileToTarRz", "addFileToTarGezip", "addFileToTarGw", "addFileToTarJz", "addFileToTarGez", "addFileToTarJw", "addFileToTarGzip", "addFileToTarBt", "addFileToTarGet", "addFileToTarGsp", "addFileToTarGst", "addFileToTarRx", "addFileToTarGszip", "addFileToTarBp", "addFileToTarJzip", "addFileToTarBz", "addFileToTarGt", "addFileToTarJx", "addFileToTarRw", "addFileToTarGp", "addFileToTarBw", "addFileToTarBx", "addFileToTarRzip"], "taro": ["tro", "tosa", "Tolan", "troa", "tory", "tary", "tempamo", "Targo", "thara", "traro", "Tarro", "Tara", "ktaro", "ktara", "stoa", "retara", "starro", " trar", "tharro", "qtro", "wro", "tamo", "trar", "qtolan", " tamo", "stargo", "ktrar", " tara", "Taco", "retaro", "Tory", "tharo", "marro", "mro", " tary", "qtaro", "ttara", "stary", "thrar", "stamo", " tosa", "trro", "margo", "thosa", "warro", "toa", "trary", "tara", "temparo", "wargo", " toa", "retamo", "ttamo", "Taro", "ttaro", "Tro", "ttosa", "Tamo", " tarro", "thamo", " taco", "taco", "ktarro", "tempargo", " targo", " tolan", "targo", "staro", "tempro", "waro", "staco", "tarro", "stro", " tro", " tory", "retaco", "qtory", "tolan", "maro"], "path": ["transform", "ref", "text", "entry", "parts", "h", "m", "clean", "doc", "w", "ath", "chain", "c", "th", "PATH", "mount", "url", "name", "pi", "history", "project", "dir", "Path", "kind", "full", "local", "pattern", "key", "core", "string", "file", "binding", "root", "p", "print", "ex"], "base": ["bad", "extra", "Base", "bf", "default", "reset", "alias", "based", "part", "create", "pad", "shadow", "bas", "template", "build", "buffer", "b", "basic", "absolute", "db", "family", "name", "common", "ase", "parent", "normal", "full", "padding", "relative", "start", "file", "binding", "root", "check", "server", "prefix", "bare"], "f": ["fi", "alf", "fe", "bf", "y", "af", "d", "h", "fs", "fm", "fp", "fr", "fed", "fac", "t", "lf", "c", "fc", "fd", "far", "b", "perm", "v", "i", "e", "fg", "rf", "tf", "sf", "life", "elf", "l", "uf", "fx", "fo", "form", "g", "o", "r", "fab", "fa", "F", "cf", "inf", "file", "ft", "fb", "p", "xf", "df", "fl", "w"], "entryName": ["entryKey", " entryname", "entryPath", "rowType", "entryLetter", " entryLetter", "rowLetter", " entryPath", "rowname", "elementPath", "elementKey", "entryname", "ryName", "Entryname", "ryname", "cuename", "entryType", "rowName", "EntryType", "EntryName", "cueName", "ryType", "cueKey", "elementName", "EntryKey", "EntryPath", " entryType", "ryLetter", " entryKey", "elementname", "cueType"], "goIn": ["geInput", "goin", "GoIN", "moIn", "poIN", "moIN", " goIns", "goInput", " goOut", " goin", "GoIn", "Goin", "poIn", "goIns", " goIN", "poOut", "moIns", "moInput", "geIns", "goIN", "poin", "GoIns", "GoOut", "moin", "gein", "geIn", "goOut", " goInput"], "tarEntry": ["tarCategory", " tarCategory", "rarEnt", "carCategory", " tarEnt", "tarentry", "rarentry", "warItem", "tarItem", "carentry", "rarItem", "tarEnt", "rarEntry", "warEnt", " tarComponent", "rarComponent", "tarComponent", "warEntry", "carEntry", " tarentry", "rarCategory", "warComponent", "carEnt", " tarItem"], "children": ["hawks", "parents", "all", "cloud", "json", "each", "these", "gall", "reports", "users", "items", "keys", "Children", "modules", "fs", "roots", "jobs", "ls", "packages", "ll", "names", "los", "ml", "ps", "cache", "blocks", "they", "many", "wn", "resources", "parent", "members", "ul", "aos", "objects", "batch", "balls", "ports", "stories", "ren", "groups", "pages", "files", "kids", "follow", "cs"], "child": ["handle", "block", "brother", "entry", "comment", "cow", "client", "fr", "page", "col", "ll", "lf", "char", "q", "label", "c", "fd", "cell", "close", "ph", "background", "uncle", "cache", "name", "l", "last", "ch", "parent", "Child", "batch", "zip", "count", "key", "row", "pixel", "job", "file", "shell", "id", "follow", "friend"]}}
{"id1": "22603577", "id2": "18989018", "code1": "    public static String getFileContentFromPlugin(String path) {\n        URL url = getURLFromPlugin(path);\n        StringBuffer sb = new StringBuffer();\n        try {\n            Scanner scanner = new Scanner(url.openStream());\n            while (scanner.hasNextLine()) {\n                String line = scanner.nextLine();\n                sb.append(line + \"\\n\");\n            }\n            scanner.close();\n        } catch (Exception e) {\n            e.printStackTrace();\n            return \"\";\n        }\n        return sb.toString();\n    }\n", "code2": "    protected void doSetInput(IEditorInput input, IProgressMonitor monitor) throws CoreException {\n        IWorkspaceRoot root = ResourcesPlugin.getWorkspace().getRoot();\n        IFileFormat format = null;\n        Object source = null;\n        InputStream in = null;\n        try {\n            IPath path;\n            if (input instanceof IStorageEditorInput) {\n                IStorage s = ((IStorageEditorInput) input).getStorage();\n                in = s.getContents();\n                if (s instanceof IFile) {\n                    IFile file = (IFile) s;\n                    path = file.getRawLocation();\n                    if (root.exists(path)) {\n                        path = root.getLocation().append(path);\n                    }\n                    source = path.toFile();\n                }\n            } else if (input instanceof IPathEditorInput) {\n                path = ((IPathEditorInput) input).getPath();\n                source = path.toFile();\n            } else if (input instanceof IURIEditorInput) {\n                URI uri = ((IURIEditorInput) input).getURI();\n                if (URIUtil.isFileURI(uri)) {\n                    source = URIUtil.toFile(uri);\n                } else {\n                    URL url = URIUtil.toURL(uri);\n                    in = url.openStream();\n                }\n            }\n            if (source == null) {\n                if (!in.markSupported()) {\n                    in = new BufferedInputStream(in);\n                }\n                in.mark(10);\n                source = in;\n            }\n            IContentDescription cd = Platform.getContentTypeManager().getDescriptionFor(in, input.getName(), new QualifiedName[] { ImageCore.VALID_FORMATS });\n            if (in != null) {\n                in.reset();\n            }\n            Collection<?> valid = (Collection<?>) cd.getProperty(ImageCore.VALID_FORMATS);\n            if (valid.isEmpty()) throw new CoreException(new Status(Status.ERROR, ImageUI.PLUGIN_ID, \"Unsupported file format.\"));\n            ImageInputStream stream = ImageIO.createImageInputStream(source);\n            format = (IFileFormat) valid.iterator().next();\n            IDocument document = format.decode(stream, monitor);\n            setDocument(document);\n        } catch (IOException e) {\n            Status status = new Status(Status.ERROR, ImageUI.PLUGIN_ID, \"IO Error\", e);\n            throw new CoreException(status);\n        } finally {\n            if (in != null) {\n                try {\n                    in.close();\n                } catch (IOException e) {\n                }\n            }\n        }\n        super.setInput(input);\n    }\n", "label": 0, "substitutes": {"getFileContentFromPlugin": ["getFileContentfromProvider", "getFileContentFromProvider", "getFileContentsFromPlug", "getFileContentFromPlug", "getFileContentsForUrl", "getFileContentsForPlug", "getFileContentFormPlug", "getFileContentForPlug", "getFileContentsFromPlugin", "getFileContentsFromProvider", "getFileContentfromUrl", "getFileContentForPlugin", "getFileContentFormPlugin", "getFileContentsForProvider", "getFileContentFormUrl", "getFileContentsFromUrl", "getFileContentfromPlug", "getFileContentForProvider", "getFileContentfromPlugin", "getFileContentForUrl", "getFileContentsForPlugin", "getFileContentFromUrl", "getFileContentFormProvider"], "path": ["transform", "image", "text", "alias", "pod", "ath", "module", "directory", "template", "spec", "log", "th", "PATH", "join", "plugin", "filename", "mount", "uri", "name", "input", "project", "dir", "Path", "kind", "pattern", "local", "full", "key", "location", "string", "with", "file", "root", "p", "prefix"], "url": ["browser", "hl", "gl", "address", "ref", "dl", "resource", "client", "bel", "web", "ll", "base", "char", "link", "build", "sl", "impl", "lr", "db", "ur", "org", "mount", "uri", "URL", "name", "l", "nl", "mail", "hub", "r", "ssl", "el", "domain", "http", "html", "job", "file", "loc", "Url", "user", "host"], "sb": ["buf", "bt", "pb", "buff", "bf", "sm", "bg", "sp", "cb", "ob", "zb", "lb", "bh", "bs", "bsp", "wb", "sa", "sq", "sg", "b", "bb", "db", "bp", "SB", "nb", "sv", "kb", "BB", "rb", "sf", " SB", "ub", "eb", "obs", "lp", "mb", "ssl", "erb", "xb", "rob", "bn", "fb", "gb", "ib", "bd"], "scanner": [" Scanner", "scaner", " scaner", "caner", "Scanener", " Scanifier", "searchning", "scanifier", "searchner", " scaninner", "searchter", "searcher", " scanning", "scanning", "canener", "scanener", "Scanifier", "canter", "scaninner", " Scaner", "Scanner", "Scanter", " scanener", "Scaner", "canning", "Scaninner", "canner", "scanter", " Scanter", " scanter", "caninner", " scanifier"], "line": ["LINE", "zone", "lin", "block", "text", "eline", "entry", "ine", "next", "piece", "column", "word", "frame", "comment", "ln", "sequence", "page", "stroke", "day", "chain", "link", "command", "message", "cell", "detail", "le", "liner", "statement", "l", "nl", "lined", "point", "group", "Line", "row", "string", "inline", "file", "source", "user"]}}
{"id1": "7122523", "id2": "8778962", "code1": "    public ActionForward execute(ActionMapping mapping, ActionForm form, HttpServletRequest request, HttpServletResponse response) throws Exception {\n        InstanciaDelegate delegate = RegistroManager.recuperarInstancia(request);\n        if (delegate == null) {\n            ActionErrors errors = new ActionErrors();\n            errors.add(null, new ActionError(\"errors.session\"));\n            saveErrors(request, errors);\n            return mapping.findForward(\"fail\");\n        }\n        AyudaPantalla ayudaPantalla = delegate.obtenerAyudaPantalla();\n        TraAyudaPantalla traAyudaPantalla = (TraAyudaPantalla) ayudaPantalla.getTraduccion();\n        String urlSonido = traAyudaPantalla.getUrlSonido();\n        if (urlSonido == null) {\n            return null;\n        }\n        URL url = new URL(urlSonido);\n        URLConnection urlConnection = url.openConnection();\n        urlConnection.connect();\n        String tipoMime = urlConnection.getContentType();\n        log.debug(\"Tipo Mime: \" + tipoMime);\n        Map audioOptions = new HashMap();\n        if (tipoMime.indexOf(\"audio\") != -1 || tipoMime.indexOf(\"asf\") != -1 || tipoMime.equals(\"unknown/unknown\")) {\n            audioOptions.put(\"id\", \"MediaPlayer\");\n            audioOptions.put(\"codeBase\", \"http://activex.microsoft.com/activex/controls/mplayer/en/nsmp2inf.cab#Version=6,4,7,1112\");\n            audioOptions.put(\"classId\", \"CLSID:22D6F312-B0F6-11D0-94AB-0080C74C7E95\");\n            audioOptions.put(\"mimeType\", \"application/x-mplayer2\");\n            audioOptions.put(\"urlSonido\", urlSonido);\n            audioOptions.put(\"pluginSpage\", \"http://www.microsoft.com/Windows/Downloads/Contents/Products/MediaPlayer/\");\n        } else if (tipoMime.indexOf(\"real\") != -1) {\n            audioOptions.put(\"id\", \"RVOCX\");\n            audioOptions.put(\"codeBase\", \"\");\n            audioOptions.put(\"classId\", \"clsid:CFCDAA03-8BE4-11cf-B84B-0020AFBBCCFA\");\n            audioOptions.put(\"mimeType\", \"audio/x-pn-realaudio-plugin\");\n            audioOptions.put(\"urlSonido\", urlSonido);\n            audioOptions.put(\"pluginSpage\", \"\");\n        }\n        request.setAttribute(\"audioOptions\", audioOptions);\n        log.debug(\"entra success\");\n        return mapping.findForward(\"success\");\n    }\n", "code2": "    public static boolean decodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.DECODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "label": 0, "substitutes": {"execute": ["edit", "transform", "handle", "process", "next", "forward", "view", "run", "WARD", "action", "management", "to", "call", "flow", "route", "invoke", "get", "success", " evaluate", "reflect", "wards", "submit", "\u7684", "check", "index", "ward", " replay"], "mapping": ["Mappings", "smigration", "dapper", "Mapper", "imapper", "dapping", "dappings", "dapped", "Migration", "migration", "mappings", "mapped", "imigration", "mapper", " mappings", "smapped", "smapper", "imapped", "imapping", "Mapped", " mapper", "smapping", "Mapping", " mapped"], "form": ["type", "forms", " forms", "m", "fm", "formed", "flash", "template", "command", "attribute", "fc", "flow", "list", "format", "owner", " FORM", "Form", "input", " Form", "parent", "auth", "channel", "FORM", "config", "field", "apply", "orm", "sam"], "request": ["first", "report", "window", "access", "reference", "reset", "hello", "contact", "forward", "frame", "application", "resource", "view", "client", "page", "web", "quest", "context", "connection", "command", "attribute", "open", "document", "message", "current", "Request", "xml", "req", "input", "initial", "container", "order", "query", "controller", "true", "instance", "model", "framework", "http", "remote", "QUEST", "user", "index", "store", "server", "session"], "response": ["report", "reply", "image", "output", "frame", "application", "view", "Response", "status", "context", "write", "resp", "document", "message", "result", "onse", "xml", "content", "success", "respond", "exit", "http", "file", "print", "session", "render"], "delegate": ["delet", "dellegate", "releg", "desploy", "demlet", "demoder", "demlegate", "deslegates", "deleg", "dellet", "delegates", "relegate", "Deploy", "demleg", "desoder", "desleg", "Delegates", "Deoder", "Delet", "deploy", "deslegate", "demlegates", "dellegates", "Delegate", "Deleg", "deoder", "relegates", "reploy"], "errors": ["terms", "maps", "forms", "tags", "ses", "settings", "reports", "orders", "assets", "rows", "utils", " Errors", "details", "ros", "types", "rors", "lines", "lations", "runs", "err", "rules", "uploads", "uments", "umbles", "rs", "error", "rown", "laws", "images", "fields", "events", "s", "ates", "objects", "ations", "states", "rates", "relations", "values", "rings", "es", "results", "session", "checks"], "ayudaPantalla": ["ayudaPANTalli", "ayudapantalli", "ayudaPantsalla", "ayudaPantallo", "ayudapantsheon", "ayudaPantsheon", "ayudapantalla", "ayudaPantheon", "ayudaPantsagna", "ayudapantsallo", "ayudapantsalla", "ayudaPandagna", "ayudaPandallo", "ayudaPantsalli", "ayudaPANTalla", "ayudapantagna", "ayudaPantalli", "ayudapantallo", "ayudaPANTheon", "ayudaPANTallo", "ayudaPANTagna", "ayudaPantsallo", "ayudaPandheon", "ayudaPantagna", "ayudapantsalli", "ayudaPandalla", "ayudapantsagna", "ayudaPandalli", "ayudapantheon"], "traAyudaPantalla": ["traAyudaNantunta", "traAyudaCantalla", "traAyudaPantsono", "traAyudaNantalla", "traAyudaPantallo", "traAyudaPantalli", "traAyudaNartheon", "traAyudaPANTheon", "traAyudaNartono", "traAyudaCantallion", "traAyudaPartalla", "traAyudaPantryallion", "traAyudaCantryalli", "traAyudaPANTono", "traAyudaPstantallion", "traAyudaCantryalla", "traAyudaNantheon", "traAyudaPantsheon", "traAyudaPantryallo", "traAyudaCantryallo", "traAyudaPandallo", "traAyudaPstantallo", "traAyudaCantalli", "traAyudaPantono", "traAyudaPantallion", "traAyudaPandalli", "traAyudaPANTalla", "traAyudaPantsunta", "traAyudaPstantalli", "traAyudaCantryallion", "traAyudaPantheon", "traAyudaPantryalla", "traAyudaPartheon", "traAyudaPANTunta", "traAyudaPantunta", "traAyudaNartalla", "traAyudaPandalla", "traAyudaPartono", "traAyudaNantono", "traAyudaNartunta", "traAyudaPstantalla", "traAyudaPandallion", "traAyudaPartunta", "traAyudaPantsalla", "traAyudaPantryalli", "traAyudaCantallo"], "urlSonido": [" urlDonido", "urlsonira", "URLSonida", "urlSonuri", "urlSonilo", " urlWanindu", " urlDonuri", " urlWanigo", " urlWanido", "strsonide", "urlWanigo", "urlWan\u00ed", "URLSonido", "urlSunilo", "urlJonilo", "urlSunidable", "urlJonido", "urlSenido", "urlSunide", "urlSonide", "urlSunido", "urlSenid", "strsonilo", "urlWanido", " urlSonira", "urlSonid", "urlsonidable", "urlDonira", "urlsonuri", "strSonide", "strsonido", "URLSunid", "urlSenuri", "URLSunido", "strSonido", "urlSonindu", " urlDonida", "urlSonira", " urlSonindu", "urlDonido", " urlSonigo", "urlSON\u00ed", "urlSONigo", "urlsonide", "strSonida", "urlSenidable", "URLSunidable", "urlDonida", "urlWanindu", " urlSonida", " urlWan\u00ed", " urlSon\u00ed", "urlSonida", "strsonida", "urlSunid", "urlSon\u00ed", "urlSenira", "URLSunida", "urlSONido", "urlsonido", "urlsonida", "urlSunida", "urlJonide", " urlDonira", "urlJonida", "urlSunindu", "urlSenida", " urlSonuri", "urlsonilo", "URLSonid", "urlDonuri", "urlSONindu", "urlSun\u00ed", "urlSonigo", "URLSonidable", "urlsonid", "urlSunigo", "strSonilo", "urlSonidable"], "url": ["browser", "window", "address", "dl", "email", "https", "bel", "raw", "ls", "web", "ll", "char", "link", "build", "log", "sl", "b", "xml", "ur", "mount", "uri", "URL", "name", "get", "str", "l", "nl", "ul", "mail", "parse", "github", "r", "ssl", "key", "http", "location", "string", "html", "loc", "Url", "host"], "urlConnection": ["urlconnection", " urlconnection", "httpResponse", "URLConnection", "UrlConnector", " urlConnect", "strConnection", "Urlconnection", "strconnection", "urlClient", "httpconnection", "URLResponse", " urlConnector", "strClient", "UrlClient", "httpConnector", "httpConnect", "UrlConnect", " urlClient", "httpConnection", "strConnect", "UrlResponse", "UrlConnection", "urlResponse", "urlConnector", "URLConnect", "urlConnect", "httpClient", "URLconnection"], "tipoMime": ["tipologyMIME", "tipoHMime", "tipoManift", "tipoHMIME", "tiposPIME", "tipoEMime", "tipoManime", "tipoMetIME", "tiposNime", "tipoMpe", "tipoAMime", "tipoMocker", "tiposMetIME", "tipoHMift", "tipologyNimer", "tiposPift", "tipoMip", "tipoMile", "tiposNip", "tipologyMime", "tipoMCime", "tipoCMile", "tiposMime", "tiposMIME", "tipoNip", "tiposMimer", "tipoNIME", "tiposMip", "tipoManile", "tipoDMocker", "tipoMimer", "tipoHMimer", "tipoMCocker", "tipotaMisc", "tiposMetime", "tipoNimer", "tipoNocker", "tipoMich", "tipologyNocker", "tipomime", "tipoAMIME", "tipoMift", "tipoMMift", "tipomIME", "tiposNIME", "tipotaManisc", "tipoMMich", "tiposPime", "tiposMpe", "tipotaManile", "tipotaMime", "tipotaMile", "tiposNiso", "tipotaManift", "tipoDMIME", "tipoMiso", "tipoEMiso", "tipoCMift", "tiposMift", "tipologyNIME", "tipologyMimer", "tipoPIME", "tiposMetimer", "tipoCMisc", "tipoDMimer", "tipoMetpe", "tipoMCimer", "tipoAMich", "tipotaMift", "tipologyMocker", "tipomiso", "tipoPime", "tipoMetime", "tipoMMime", "tipoDMime", "tipoNime", "tipomip", "tipoMIME", "tipoHMisc", "tiposMetpe", "tipoMetimer", "tipoNiso", "tipoMMIME", "tiposMiso", "tiposMich", "tipotaManime", "tiposPich", "tipoHMile", "tipoHMpe", "tipoPift", "tipoEMip", "tipoPich", "tipoMCIME", "tipoManisc", "tipoCMime", "tipoAMift", "tipoMisc", "tipologyNime", "tipoEMIME"], "audioOptions": ["voiceFrames", " audioAttributes", "musicSettings", " audioParts", "applicationOptions", " audioDetails", " microphoneSettings", " audioParameters", " audioOption", " microphoneFrames", "musicParameters", "voiceAttributes", "musicoptions", "voiceDetails", " microphoneDetails", "AudioParts", "mediaOptions", "mediaParts", "volumeAttributes", "audioFrames", "audioSettings", "voiceParts", "AudioAttributes", "AudioSettings", "audioParts", "applicationSettings", "voiceParameters", " microphoneoptions", "soundOptions", "applicationParts", " audioFrames", "mediaoptions", " audiooptions", "audioOption", " microphoneOptions", "audioParameters", "AudioOptions", "voiceSettings", "soundoptions", "mediaOption", "applicationoptions", "volumeOptions", "soundSettings", "soundAttributes", " microphoneOption", "voiceOptions", "audioAttributes", "musicParts", "audiooptions", "musicOptions", "audioDetails", " microphoneParts", "volumeParts", "musicAttributes", " audioSettings", "mediaSettings", "volumeoptions"]}}
{"id1": "14820302", "id2": "11968328", "code1": "    protected void innerProcess(ProcessorURI curi) throws InterruptedException {\n        Pattern regexpr = curi.get(this, STRIP_REG_EXPR);\n        ReplayCharSequence cs = null;\n        try {\n            cs = curi.getRecorder().getReplayCharSequence();\n        } catch (Exception e) {\n            curi.getNonFatalFailures().add(e);\n            logger.warning(\"Failed get of replay char sequence \" + curi.toString() + \" \" + e.getMessage() + \" \" + Thread.currentThread().getName());\n            return;\n        }\n        MessageDigest digest = null;\n        try {\n            try {\n                digest = MessageDigest.getInstance(SHA1);\n            } catch (NoSuchAlgorithmException e1) {\n                e1.printStackTrace();\n                return;\n            }\n            digest.reset();\n            String s = null;\n            if (regexpr != null) {\n                s = cs.toString();\n            } else {\n                Matcher m = regexpr.matcher(cs);\n                s = m.replaceAll(\" \");\n            }\n            digest.update(s.getBytes());\n            byte[] newDigestValue = digest.digest();\n            curi.setContentDigest(SHA1, newDigestValue);\n        } finally {\n            if (cs != null) {\n                try {\n                    cs.close();\n                } catch (IOException ioe) {\n                    logger.warning(TextUtils.exceptionToString(\"Failed close of ReplayCharSequence.\", ioe));\n                }\n            }\n        }\n    }\n", "code2": "    public static String getMD5(String _pwd) {\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"MD5\");\n            md.update(_pwd.getBytes());\n            return toHexadecimal(new String(md.digest()).getBytes());\n        } catch (NoSuchAlgorithmException x) {\n            x.printStackTrace();\n            return \"\";\n        }\n    }\n", "label": 1, "substitutes": {"innerProcess": [" doWork", " doHandle", " doRun", "internalWork", " innerWork", " inlineRun", "internalProcess", " doProcess", "internalHandle", " inlineWork", " innerHandle", "internalRun", " inlineHandle", " inlineProcess", " innerRun"], "curi": ["vcuri", "gcumi", "cpurl", "mcri", "contumi", " cURI", "conturi", "Curl", "cpu", "cumi", " citi", "CURI", "cris", " cri", "cpri", "rcumi", "cURI", "lciri", "ccuri", "cpiri", "pcdu", "contdu", "gcui", "rcuri", "mcuri", "ccris", "cdu", "cui", "vcumi", "cri", "lcri", "gcdu", "ccumi", "gcuri", "vcris", "Cri", "rcdu", " ciri", "mciti", "Ciri", "curl", "ctiti", " cui", "vcui", "ctURI", " curl", "Curi", "pcuri", "pcpu", "ctri", "lcuri", "lcURI", " cdu", "citi", "rcui", "contpu", "pcumi", " cris", "cturi", "ciri", "cpuri", " cpu", "mcURI", "ccui", " cumi"], "regexpr": ["cregexpr", "frentaxpr", "revrePr", "reroxpr", "reacepr", "fregexpre", "revelopPR", "revelopexpr", "reactfr", "rentaxexpr", "revrep", "regexp", "cregexexpr", "regexfr", "revreexpr", "fregexPR", "reacep", "regexexpr", "fregexpr", "cregexPr", "frentaxpre", "rentaxpre", "frentaxPR", "Regexp", "reactexpr", "regexpre", "remaexpr", "reveloppr", "rentaxPR", "Regexfr", "reactpr", "Regexexpr", "Regexpr", "remaPR", "reroxfr", "reveloppre", "fregexexpr", "reaceexpr", "reactp", "remapre", "frentaxexpr", "reroxexpr", "regexPr", "regexPR", "reroxp", "reacePr", "cregexp", "rentaxpr", "revrepr", "remapr"], "cs": ["csv", "rc", "ics", "ss", "ms", "ctx", "Cs", "cos", "res", "cks", "cn", "js", "cms", "ws", "fs", "bs", "qs", "cus", "ls", "wcs", "hs", "ns", "cons", "acts", "c", "fc", "cas", "ctr", "ts", "ps", "cp", "gc", "pc", "ats", "rs", "caps", "CS", "acs", "sc", "ces", "ck", "gs", "css", "cd", "tc", "nc", "mc", "vs", "sts", "cf", "cer", "ks", "aches", "cc"], "digest": [" digse", "digist", "diger", "dest", "hashester", "der", " digum", "hashEST", "columnist", "Diger", "signested", "digse", "digum", "Digester", "columnest", "Digum", "displayer", "columnum", "mixse", "signist", "displayester", "Digse", "digEST", "displayest", "displayested", " digist", "displayEST", "hashse", "mixest", "Digist", " digester", "Digested", "hashest", "displayse", "mixist", "dse", "dist", "signse", "digested", " digEST", " diger", "mixested", "signest", "digester", "DigEST", " digested", "Digest"], "s": ["services", "ss", "sb", "prints", "ms", "ins", "h", "js", "ws", "fs", "https", "bs", "qs", "ls", "t", "hs", "ns", "sq", "c", "b", "ps", "S", "ts", "reads", "e", "its", "less", "sv", "ats", "rs", "str", "has", "eps", "ds", "sol", "sql", "ims", "gs", "space", "n", "sts", "gets", "is", "sam", "p", "es", "bytes", "abs"], "m": ["f", "nm", "sm", "ms", "om", "mr", "d", "mt", " M", "managed", "mo", "t", "mem", "met", "me", "md", "em", "esm", "b", "perm", "rm", "v", "i", "dm", "cm", "M", "l", "gm", "mu", "ma", "mc", "mm", "n", "vm", "mac", "p", "tm"], "newDigestValue": ["newdigestV", "newDigseData", "newDigestedData", "newDigestedV", "newdigestValue", "newDigestVal", "newDigestedVal", "newDigestedValues", "newdigistData", "newdigestedValue", "newDigumentValues", "newDigestedValue", "newDigistData", "newDigseValue", "newDigestV", "newDigestData", "newdigestVal", "newDigestValues", "newDigistValue", "newdigestedV", "newdigestValues", "newDigseValues", "newDigumentValue", "newdigistValue", "newdigestData", "newdigestedVal", "newdigestedValues", "newDigumentVal", "newDigseV", "newDigumentV", "newDigseVal", "newdigistVal", "newDigistVal"]}}
{"id1": "13657103", "id2": "5951961", "code1": "    private void forBundle(BundleManipulator manip) {\n        ByteArrayOutputStream bout = null;\n        try {\n            bout = new ByteArrayOutputStream();\n            ZipOutputStream zout = new ZipOutputStream(bout);\n            Bundle bundle = getBundle();\n            Enumeration<URL> files = bundle.findEntries(\"/\", \"*.vm\", false);\n            if (files != null) {\n                while (files.hasMoreElements()) {\n                    URL url = files.nextElement();\n                    String name = url.getFile();\n                    if (name.startsWith(\"/\")) {\n                        name = name.substring(1);\n                    }\n                    if (manip.includeEntry(name)) {\n                        zout.putNextEntry(new ZipEntry(name));\n                        IOUtils.copy(url.openStream(), zout);\n                    }\n                }\n            }\n            manip.finish(bundle, zout);\n            Manifest mf = new Manifest(bundle.getEntry(\"META-INF/MANIFEST.MF\").openStream());\n            zout.putNextEntry(new ZipEntry(\"META-INF/MANIFEST.MF\"));\n            mf.write(zout);\n            zout.close();\n            File tmpFile = File.createTempFile(TEMPLATES_SYMBOLIC_NAME, \".jar\");\n            FileUtils.writeByteArrayToFile(tmpFile, bout.toByteArray());\n            if (pluginAccessor.getPlugin(TEMPLATES_SYMBOLIC_NAME) != null) {\n                pluginController.uninstall(pluginAccessor.getPlugin(TEMPLATES_SYMBOLIC_NAME));\n            } else if (pluginAccessor.getPlugin(TEMPLATES_PLUGIN_KEY) != null) {\n                pluginController.uninstall(pluginAccessor.getPlugin(TEMPLATES_PLUGIN_KEY));\n            }\n            pluginController.installPlugin(new JarPluginArtifact(tmpFile));\n            ServiceReference ref = bundleContext.getServiceReference(PackageAdmin.class.getName());\n            ((PackageAdmin) bundleContext.getService(ref)).refreshPackages(null);\n            tmpFile.delete();\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            IOUtils.closeQuietly(bout);\n        }\n    }\n", "code2": "    public static void main(String[] args) {\n        try {\n            URL url = new URL(args[0]);\n            HttpURLConnection httpCon = (HttpURLConnection) url.openConnection();\n            httpCon.setDoOutput(true);\n            httpCon.setRequestMethod(\"PUT\");\n            OutputStreamWriter out = new OutputStreamWriter(httpCon.getOutputStream());\n            out.write(\"fatal error\");\n            out.close();\n            System.out.println(\"end\");\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n", "label": 0, "substitutes": {"forBundle": [" processPasket", " processEmbundle", " manageBranch", " manageBasket", " processBundle", " processEmbunch", " manageRebranch", " processPunch", " processEmbasket", " processPundle", " manageBunch", " manageBundle", " processRebundle", " processRebasket", " processRebranch", " processBasket", " processBranch", " manageRebunch", " processBunch", " manageRebundle", " manageRebasket", " processRebunch", " processEmbranch", " processPranch"], "manip": ["manup", " ManIP", "MANip", "managerip", "emanip", "ManIP", " Manip", "emaniper", "emanipper", "Manup", " Manips", "Manop", "emanap", "MANap", " Manap", "emanop", "MANIP", "manop", "Manips", "managerup", "manipper", "manap", "MANips", "damip", "manIP", "manips", "damipper", " manipper", "Manap", "managerIP", "emanup", "damap", "damiper", "maniper", "Manip", "emanIP", " manap", " maniper", "managerop"], "bout": ["zio", "zOut", "bbpool", "zoff", "Bin", "wpool", "boff", "zin", "bOut", " bouts", "bbOut", "Bout", "Boff", "wout", " bin", "bpool", "bbop", "bou", "bio", "bbouts", " bOUT", "zOUT", "bOUT", "zouts", " boff", " bop", "bin", "bbout", "bbio", " bOut", " bio", "wOut", "wop", "wou", " bou", "bop", " bpool", "bouts", "BOUT", "zou"], "zout": ["zOut", "zenet", "znet", "ozou", "win", "zein", "zall", "tzOUT", "zpool", "wpool", "zent", " zouts", "zin", "ozall", "zipouts", "azin", "ozos", "zoss", "wout", "zipaos", "zoent", "zend", " zaos", "zipout", "zoneaos", "zouts", "azout", "zOUT", "ezos", "zipnet", "zerout", "zerouts", " zou", " zos", " znet", "zerend", " zin", "zeout", " zpool", " zOUT", "ozOUT", "wOut", "ozout", "zoneout", "azouts", "zaos", "zipOut", "zeOut", " zoss", "tzall", "ezOUT", " zend", " zall", "zoend", "ozoss", "ezout", "ezou", "zoout", "wouts", "zippool", " zent", "zipin", "tzout", " zOut", "zerent", "zoouts", "zos", "zoneouts", "zou", "zoneOut", "azOut", "tzoss"], "bundle": ["pbulk", "mbundle", "brigration", "mbasket", "bigration", "boulk", "abasket", "sbund", "lund", "bund", "abigration", "lound", "sbasket", "bond", "boigration", "bkg", "bound", "lasket", "abundle", "brulk", "masket", "basket", "boasket", " bulk", "rbasket", "mond", "pbundle", "lundle", " bkg", " bond", " basket", "rbundle", "boundle", "brasket", "mundle", "mbond", " bund", "mbund", "pbkg", " bound", "pbasket", "brundle", "rbkg", "mund", "abulk", "sbound", "sbundle", "rbulk", "bulk"], "files": ["times", "forms", "photos", "leases", "reports", "ails", "assets", "links", "rows", "users", "items", "facts", "plates", "keys", "seconds", "fs", "types", "roots", "lines", "les", "ls", "runs", "classes", "names", "organisms", "iles", "rules", "issues", "sites", "stores", "styles", "images", "ids", "ds", "fields", "resources", "actions", "chains", "obs", "fixes", "books", "ions", "objects", "balls", "ports", "headers", "results", "Files", "pages", "groups", "features", "values", "file", "lets", "ures", "bytes", "bees", "faces"], "url": ["f", "browser", "gl", "sb", "dl", "entry", "sp", "ob", "resource", "m", "bel", "ls", "web", "ll", "char", "link", "buffer", "sl", "b", "cert", "rel", "re", "ur", "mount", "uri", "URL", "str", "l", "li", "nl", "mail", "path", "norm", "mb", "r", "el", "key", "http", "location", "html", "file", "loc", "Url", "user", "ml", "fl"], "name": ["type", "f", "event", "all", "nm", "address", "default", "named", "alias", "internal", "part", "word", "comment", "m", "on", "run", "names", "me", "one", "label", "code", "family", "filename", "format", "none", "node", "str", "hash", "NAME", "common", "order", "len", "path", "length", "normal", "term", "ame", "num", "full", "local", "info", "key", "n", "string", "no", "file", "source", "size", "version", "id", "Name", "data", "prefix", "title"], "mf": [" mF", "manff", " Mff", "manf", "mnif", "mnf", " mfo", "MF", "mfy", " Mf", "mF", "mff", " mif", "Mf", "Mif", "Mfo", "Mff", "Mfy", "manF", "mif", "mfo", " MF", "mnF", " Mfy", "manfy", "mnfo"], "tmpFile": ["tempDir", "tmpName", "mpF", "TempF", "mpfile", " tmpfile", "tmpfile", "potFile", "mpFile", "tmpDir", "tmpFiles", "Tempfile", "TempName", "tmpF", "tempName", "mpDir", "TempFile", "tarName", "tarfile", "tempfile", " tmpFiles", "TempCheck", "potfile", "tempF", "potFiles", "tempCheck", "tempFiles", "tempFile", "tarFile", "TempDir", "tarCheck", "tmpPlace", " tmpPlace", "tmpCheck", "tempPlace", "potPlace"], "ref": ["f", " val", "rc", " reg", " refer", "reference", "prop", "br", "rep", " req", "pid", "af", "service", " re", "pro", " id", " references", "mem", "port", "range", "link", "pkg", "resp", "rem", " ret", "re", "rel", " referred", "req", "conf", "Reference", " href", "def", "nav", "tab", "Ref", "eb", "rev", "rm", "r", "href", "ret", "REF", "id", "prefix", " pref"]}}
{"id1": "18504192", "id2": "9033639", "code1": "    static void copyFile(File in, File out) throws IOException {\n        FileChannel source = new FileInputStream(in).getChannel();\n        FileChannel destination = new FileOutputStream(out).getChannel();\n        source.transferTo(0, source.size(), destination);\n        source.close();\n        destination.close();\n    }\n", "code2": "    public void testHttpsConnection() throws Throwable {\n        setUpStoreProperties();\n        try {\n            SSLContext ctx = getContext();\n            ServerSocket ss = ctx.getServerSocketFactory().createServerSocket(0);\n            TestHostnameVerifier hnv = new TestHostnameVerifier();\n            HttpsURLConnection.setDefaultHostnameVerifier(hnv);\n            URL url = new URL(\"https://localhost:\" + ss.getLocalPort());\n            HttpsURLConnection connection = (HttpsURLConnection) url.openConnection();\n            SSLSocket peerSocket = (SSLSocket) doInteraction(connection, ss);\n            checkConnectionStateParameters(connection, peerSocket);\n            connection.connect();\n        } finally {\n            tearDownStoreProperties();\n        }\n    }\n", "label": 0, "substitutes": {"copyFile": ["CopyFiles", " transferFile", "copyFiles", "CopyStream", " transferFiles", " CopyStream", "copyStream", "copyfile", " Copyfile", " CopyFiles", "CopyFile", " transferStream", " CopyFile", "Copyfile", " transferfile"], "in": ["rin", "en", "inn", "gin", "IN", "vin", "ins", "on", "In", "old", "b", "ic", "edIn", "up", "i", "inc", "l", "input", "or", "it", "ind", "o", "el", "mm", "n", "din", "inf", "is", "isin", "as", "cin", "id", "from"], "out": ["nt", "output", "oss", "help", "t", "po", "k", "net", "log", "err", "b", "to", "ot", "v", "i", "serv", "os", "l", "it", "gt", "ou", "at", "outs", "g", "o", "s", "ex", "n", "io", "Out", "OUT", "ne", "w"], "source": ["origin", "back", "scan", "style", "access", "subject", "match", "sample", "ie", "service", "pse", "resource", "se", "reader", "comment", "sequence", "secret", "create", "force", "before", "init", "inner", "template", "me", "store", "inside", "spec", "scope", "open", "system", "src", "Source", "copy", "position", "SOURCE", "input", "sin", "query", "parse", "search", "seed", "ource", "space", "instance", "use", "iterator", "local", "info", "volume", "ources", "start", "file", "shell", "from"], "destination": ["Destation", "restinated", " destregation", " destation", "coordregation", " destification", "comification", "restinator", "destregation", " destension", "restation", "destension", "comato", "seeinator", "coordification", "destation", "comregation", "Destinated", " destinator", "Destinator", "coordato", " destato", "coordination", " destinated", "seeination", "seeension", "destification", "destinated", "seeinated", "destato", "Destination", "Destension", "destinator", "restination", "comination"]}}
{"id1": "364438", "id2": "536614", "code1": "    public void convert(File src, File dest) throws IOException {\n        InputStream in = new BufferedInputStream(new FileInputStream(src));\n        DcmParser p = pfact.newDcmParser(in);\n        Dataset ds = fact.newDataset();\n        p.setDcmHandler(ds.getDcmHandler());\n        try {\n            FileFormat format = p.detectFileFormat();\n            if (format != FileFormat.ACRNEMA_STREAM) {\n                System.out.println(\"\\n\" + src + \": not an ACRNEMA stream!\");\n                return;\n            }\n            p.parseDcmFile(format, Tags.PixelData);\n            if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) {\n                System.out.println(\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n                return;\n            }\n            boolean hasPixelData = p.getReadTag() == Tags.PixelData;\n            boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12;\n            int pxlen = p.getReadLength();\n            if (hasPixelData) {\n                if (inflate) {\n                    ds.putUS(Tags.BitsAllocated, 16);\n                    pxlen = pxlen * 4 / 3;\n                }\n                if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) {\n                    System.out.println(\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                    return;\n                }\n            }\n            ds.putUI(Tags.StudyInstanceUID, uid(studyUID));\n            ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID));\n            ds.putUI(Tags.SOPInstanceUID, uid(instUID));\n            ds.putUI(Tags.SOPClassUID, classUID);\n            if (!ds.contains(Tags.NumberOfSamples)) {\n                ds.putUS(Tags.NumberOfSamples, 1);\n            }\n            if (!ds.contains(Tags.PhotometricInterpretation)) {\n                ds.putCS(Tags.PhotometricInterpretation, \"MONOCHROME2\");\n            }\n            if (fmi) {\n                ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian));\n            }\n            OutputStream out = new BufferedOutputStream(new FileOutputStream(dest));\n            try {\n            } finally {\n                ds.writeFile(out, encodeParam());\n                if (hasPixelData) {\n                    if (!skipGroupLen) {\n                        out.write(PXDATA_GROUPLEN);\n                        int grlen = pxlen + 8;\n                        out.write((byte) grlen);\n                        out.write((byte) (grlen >> 8));\n                        out.write((byte) (grlen >> 16));\n                        out.write((byte) (grlen >> 24));\n                    }\n                    out.write(PXDATA_TAG);\n                    out.write((byte) pxlen);\n                    out.write((byte) (pxlen >> 8));\n                    out.write((byte) (pxlen >> 16));\n                    out.write((byte) (pxlen >> 24));\n                }\n                if (inflate) {\n                    int b2, b3;\n                    for (; pxlen > 0; pxlen -= 3) {\n                        out.write(in.read());\n                        b2 = in.read();\n                        b3 = in.read();\n                        out.write(b2 & 0x0f);\n                        out.write(b2 >> 4 | ((b3 & 0x0f) << 4));\n                        out.write(b3 >> 4);\n                    }\n                } else {\n                    for (; pxlen > 0; --pxlen) {\n                        out.write(in.read());\n                    }\n                }\n                out.close();\n            }\n            System.out.print('.');\n        } finally {\n            in.close();\n        }\n    }\n", "code2": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "label": 1, "substitutes": {"convert": ["Converting", "compvert", "converts", "unverted", "consvert", "Conprocess", "CONversion", "converted", "Conversion", "unprocess", "confer", "unfer", "Confer", "unvert", "unverts", "compverts", "ConVERT", "Converted", "CONvert", "conversion", "conprocess", "CONfer", "Convert", "CONverted", "unversion", "compversion", "compprocess", "consversion", "converting", "CONverting", "consVERT", "consverting", "conVERT", "CONVERT", "Converts"], "src": ["ser", "buster", "rc", "txt", "hl", "scan", "usr", "attr", "img", "orig", "func", "ins", "sit", "cont", "sys", "stream", "SourceFile", "sq", "addr", "rest", "pkg", "cur", "sr", "rel", "filename", "ur", "Source", "its", "req", "url", "uri", "RC", "rs", "str", "SOURCE", "inst", "input", "upload", "sin", "rx", "sc", "st", "path", "ource", "s", "iv", "scene", "href", "http", "config", "dist", "start", "file", "source", "loc", "ipl", "ebin", "from", "host", "cc"], "dest": ["txt", "img", " destinations", "gin", "orig", "test", "disk", "est", "table", "port", "rest", "write", " Dest", "result", " dst", "mat", "target", "foreign", " orig", " destination", "dir", "dat", "Dest", "dist", "temp", " Destination", "source", "tif"], "in": ["en", "rin", "inn", "res", "IN", "ins", "d", "ar", "reader", "m", "stream", "In", "inner", "b", "up", "i", "bin", "serv", "l", "input", "sql", "st", "ind", "r", "el", "ad", "io", "din", "inf", "is", "isin", "source", "as", "file", "cin", "from"], "p": ["f", "php", "pa", "pb", "dp", "j", "pd", "tp", "rep", "vp", "sp", "d", "py", "parser", "part", "h", "op", "pp", "m", "fp", "t", "pl", "c", "pkg", "b", "pg", "ps", "ping", "post", "pro", "i", "cp", "ph", "pc", "pt", "pi", "l", "it", "per", "parse", "P", "pers", "at", "lp", "pre", "g", "r", "jp", "pm", "er", "wp", "prot", "pe", "ap"], "ds": ["dates", "dp", "di", " ads", "scripts", "loads", "yes", "qs", "tests", "ns", "ps", "drivers", "db", "dds", "sd", "ats", "dt", " DS", "ports", "ras", "terms", "ss", "DS", "ws", "bs", "docs", "hs", "workers", "iffs", "lists", "os", "edes", "gs", " dd", "hd", "vs", " d", "uds", "ils", "eds", "xs", "tags", "Ds", "dl", "els", "sets", "gd", "ls", "ts", "ags", "rs", " des", "obs", "s", "outs", "ods", "sts", "posts", "ands", "tes", "cs", "amps", "dos", "ads", "pd", "tp", "mys", "d", "cks", "js", " os", "its", "aws", "ys", "des", "eps", "dd", "ks", "points", "df", "nas", "dh"], "format": ["type", "f", "style", "layout", "settings", "output", "policy", "MAT", "feature", "mt", "fm", "set", "status", "table", "tag", "t", "feat", " Format", "module", "template", "sche", "spec", "fc", "shape", "mode", "Format", "ct", "act", "mat", "name", "ats", "pi", "top", "l", "it", "parse", "form", "path", "at", "filter", "lat", "pattern", "id", "cf", "file", "source", "size", "unit", "version", "pretty", "title"], "hasPixelData": ["HaspixelDATA", "hasixelData", "hasPixelDATA", "Haspixeldata", "hasPixeldata", "HasPixelDATA", "HaspixelData", "hasFrameData", "hasFrameDATA", "haspixelDATA", "hasFramedata", "HasPixeldata", "haspixeldata", " hasPixelDATA", " hasPixeldata", "hasixeldata", "hasixelDATA", "HasPixelData", "haspixelData"], "inflate": ["inFLated", "Inflate", "invalidATE", "inFLat", "inFLocate", "incelate", " invalidicate", "infolat", "Inflat", "invalidate", "inFlicate", "inflATE", "inflated", "incelicate", " inflocate", "incelocate", "Informocate", "Informated", "incelATE", "inFlATE", " inflicate", "inFlate", " invalidate", "informat", "infolated", "Inflocate", "inflicate", "inFlocate", "infolocate", "informocate", "informate", "Informat", "invalidicate", "Inflated", " inflATE", "inflocate", "informated", "Informate", "inFLate", "invalidocate", " invalidATE", "inflat", " invalidocate", "infolate"], "pxlen": ["pxln", "mmlin", "packlen", "pxlength", "cpln", "xplength", "cplength", "phpln", "pixellength", "pxlin", "cpden", "mxlength", "cplen", "packlength", "pexlength", "xylen", "mmlen", "pxdec", "tmpln", "packdec", "phplength", "pexln", "mxdec", "packfun", "pexls", "mxlen", "pxls", "pxfun", "xylin", "xyln", "tmplin", "xpden", "mxln", "tmplen", "pexlen", "pxden", "phplen", "pexfun", "mmlength", "pixelfun", "packls", "xpln", "phpdec", "pixells", "pexden", "tmplength", "xplen", "packln", "mmln", "pixellen", "xylength"], "out": ["output", "res", "obj", "ln", "client", "sys", "sum", "inter", "init", "net", "log", "print", "err", "list", "up", "crit", "name", "writer", "outer", "cmd", "conn", "gov", "ou", "group", "aos", "outs", "dir", "cfg", "inv", "screen", "gr", "io", "msg", "temp", "Out", "OUT", "user", "store", "pretty", "prefix", "ex"]}}
{"id1": "7044153", "id2": "19006212", "code1": "    private static void sendExceptionToServer(String server, Throwable ex, String config, String prob) {\n        try {\n            StringBuilder dataSB = new StringBuilder();\n            dataSB.append(URLEncoder.encode(\"secret\", \"UTF-8\"));\n            dataSB.append('=');\n            dataSB.append(URLEncoder.encode(\"badsecurity\", \"UTF-8\"));\n            dataSB.append('&');\n            dataSB.append(URLEncoder.encode(\"version\", \"UTF-8\"));\n            dataSB.append('=');\n            dataSB.append(URLEncoder.encode(BuildInfo.revisionNumber, \"UTF-8\"));\n            dataSB.append('&');\n            dataSB.append(URLEncoder.encode(\"os\", \"UTF-8\"));\n            dataSB.append('=');\n            dataSB.append(URLEncoder.encode(System.getProperty(\"os.name\") + \" \" + System.getProperty(\"os.version\"), \"UTF-8\"));\n            dataSB.append('&');\n            dataSB.append(URLEncoder.encode(\"user\", \"UTF-8\"));\n            dataSB.append('=');\n            dataSB.append(URLEncoder.encode(System.getProperty(\"user.name\"), \"UTF-8\"));\n            dataSB.append('&');\n            dataSB.append(URLEncoder.encode(\"msg\", \"UTF-8\"));\n            dataSB.append('=');\n            dataSB.append(URLEncoder.encode(ex.getMessage(), \"UTF-8\"));\n            ByteArrayOutputStream trace = new ByteArrayOutputStream();\n            ex.printStackTrace(new PrintStream(trace));\n            dataSB.append('&');\n            dataSB.append(URLEncoder.encode(\"trace\", \"UTF-8\"));\n            dataSB.append('=');\n            dataSB.append(URLEncoder.encode(trace.toString(), \"UTF-8\"));\n            if (config != null) {\n                dataSB.append('&');\n                dataSB.append(URLEncoder.encode(\"config\", \"UTF-8\"));\n                dataSB.append('=');\n                dataSB.append(URLEncoder.encode(config, \"UTF-8\"));\n            }\n            if (prob != null) {\n                dataSB.append('&');\n                dataSB.append(URLEncoder.encode(\"problem\", \"UTF-8\"));\n                dataSB.append('=');\n                dataSB.append(URLEncoder.encode(prob, \"UTF-8\"));\n            }\n            URL url = new URL(errorServerURL);\n            URLConnection conn = url.openConnection();\n            conn.setDoOutput(true);\n            OutputStreamWriter wr = new OutputStreamWriter(conn.getOutputStream());\n            wr.write(dataSB.toString());\n            wr.flush();\n            BufferedReader rd = new BufferedReader(new InputStreamReader(conn.getInputStream()));\n            String response = null;\n            String line = null;\n            while ((line = rd.readLine()) != null) {\n                if (response == null) response = line; else System.out.println(line);\n            }\n            wr.close();\n            rd.close();\n            if (response.equals(\"success\")) System.out.println(\"Exception sent to maRla development team\"); else System.out.println(\"Unable to send exception to development team: \" + response);\n        } catch (IOException ex2) {\n            System.out.println(\"Unable to send exception to development team: \" + ex2.getMessage());\n        }\n    }\n", "code2": "    public void Load(String fname) throws Exception {\n        File f = null;\n        try {\n            if (\"\".equals(fname) || fname == null) throw new Exception();\n            System.out.println(\"Loading mapfile \" + fname);\n        } catch (Exception e) {\n            throw new Exception(\"File not found\");\n        }\n        aType = null;\n        fieldtype.clear();\n        creatures.clear();\n        aElement = new String(\"\");\n        content = null;\n        Ax = -1;\n        Ay = -1;\n        aTemplate = -1;\n        SAXParserFactory factory = SAXParserFactory.newInstance();\n        data_read = 0;\n        URL url = this.game.mainClass.getClassLoader().getResource(fname);\n        if (url == null) {\n            throw new Exception(\"Can't load map from : \" + fname);\n        }\n        try {\n            SAXParser parser = factory.newSAXParser();\n            parser.parse(url.openStream(), this);\n        } catch (Exception e) {\n            System.out.println(\"Can't open XML : \" + e);\n        }\n        for (int i = 0; i < fieldtype.size(); i++) {\n            System.out.println((MapField) fieldtype.get(i));\n        }\n        game.player.setpos(start_x, start_y);\n        System.out.println(\"Player starting position set\");\n        start_x = -1;\n        start_y = -1;\n        System.out.println(\"Map \\\"\" + fname + \"\\\" loaded\");\n    }\n", "label": 0, "substitutes": {"sendExceptionToServer": ["sendErrortoServer", "sendExceptiontoClient", "sendErrortoHost", "sendExceptionTOClient", "sendExceptionTOServer", "sendErrortoClient", "sendExceptiontoServer", "sendErrorToClient", "sendExceptiontoHost", "sendErrorToServer", "sendErrorToHost", "sendExceptionToClient", "sendExceptionTOHost", "sendExceptionToHost"], "server": ["ser", "address", "value", "test", "email", "service", "description", "client", "site", "port", "base", "code", "v", "serv", "Server", "localhost", "env", "null", "channel", "remote", "string", "erver", "password", "version", "ver", "store", "host"], "ex": ["exp", "event", "pex", "tx", "test", "fail", "obj", "exclusive", "nex", "x", "one", "wx", "err", "ception", "exe", "ic", "re", "e", "ext", "xc", "com", "example", "ox", "none", "Exc", "error", "EX", "or", "expl", "lex", "hex", "it", "Ex", "exit", "rx", "ry", "Exception", "exc", "any", "rex", "el", "aux", "eas", "except", "an", "ix"], "config": ["rc", "text", "settings", "params", "service", "context", "debug", "c", "log", "cert", "Config", "conf", "content", "ct", "cache", "param", "input", "fig", "auth", "env", "form", "cfg", "channel", "Configuration", "control", "figure", "password"], "prob": ["prbe", "probe", " prbe", "prbj", "prbes", "Probe", "probj", "prb", "Probj", " prbj", " prbes", " prb", "probes", "Prob", "Probes"], "dataSB": ["dataMB", "imageHB", "relationBu", "defGB", "relationSquare", "joinsb", "dataNB", "datasb", "relationBS", "DATABS", "partialSL", "imageQB", "dataSI", "mapSN", "resourceSB", "contentSR", "dateSB", "dataSF", "ataSA", "divBB", "contentBS", "divSN", " dataMB", " dataSN", "dataHB", "defBB", "relBS", "relSB", "defSB", " dataBS", "ataSF", "dataBB", "cachesb", " dataSw", "resourceSF", "listSI", "ataMB", "contentSN", "joinMB", " dataSA", "ataEB", "partialGB", "relSW", "dataQB", " dataBB", "divBS", "nextSF", "relationMB", " dataRB", "relBB", "valueSB", "relationQB", " dataBP", "imageSL", "listSB", "relationNB", "debugSB", "dateQB", "nextGB", "mapSB", "datWB", "joinSB", "keySB", "dataGB", "ataNB", "keyBS", "relationSL", "mapBS", "ataSN", "imageSF", "cacheBB", "debugRB", "divBW", "atasb", "divSF", "defQB", "jsonSw", " dataSI", "dataWB", "relationBB", "cacheSB", "joinWB", "dataBS", "mapSF", "dataSN", " dataSW", "datMB", "cacheBW", "imageSN", "divSquare", "ataBP", " dataGB", "valueSW", " dataEB", "contentSB", "cacheSM", "cacheSF", "datSB", "dataBW", "ataSW", "datSL", "mapGB", "ataBu", " datasb", "dataSw", "relationSN", "imageSM", "joinSL", "DATASB", "listMB", "mapHB", "partialBB", " dataHB", " dataBW", "ataSL", "ataBB", "dataSW", "reasonSB", "contentNB", "dataSquare", "imageBS", "valueBS", "ataSB", "reasonSF", "cacheSA", "relationRB", "dataSL", "reasonSW", "contentSF", "nextQB", "dataEB", "keyBB", "jsonsb", "dataRB", "debugSF", "windowSF", "jsonSB", "partialSB", "DATASW", " dataSquare", "divNB", "imageSw", "listBB", "DATASF", "imageNB", "nextBB", "windowBS", "imageBP", "dataSA", "imageBB", "dateBu", "windowSN", "imageSB", " dataSF", "listEB", "relationSF", "ataQB", "ataSR", "reasonBS", "ataBS", "dataBP", "imageSR", "windowBB", "dataBu", "jsonSF", "imagesb", "mapSL", "nextSB", "dataSM", "listSF", "windowSB", "valueBB", "cacheBS", "nextBS", " dataSM", " dataSL", "dataSR", "mapBB", "ataWB", "debugBB", "keySL", "listsb", "resourceSI", " dataNB", "dateBS", "divSB", "relationSB", "windowSL", "joinSF", " dataQB", "resourcesb"], "trace": ["report", "transform", "track", "style", "span", "tr", "address", "sample", "test", "time", "feature", "frame", "mt", "se", "comment", "sequence", "create", "stream", "table", "thread", "profile", "chain", "debug", "stable", "buffer", "be", "range", "fake", "th", "log", "message", "stack", "list", "tty", "detail", "ace", "race", "dump", "true", "history", "batch", "network", "role", "te", " Trace", "temp", "tile", "body", "store", "tm", "data"]}}
{"id1": "20375440", "id2": "411595", "code1": "    public static void copyFile(File srcFile, File destFile) throws IOException {\n        InputStream src = new FileInputStream(srcFile);\n        OutputStream dest = new FileOutputStream(destFile);\n        byte buffer[] = new byte[1024];\n        int read = 1;\n        while (read > 0) {\n            read = src.read(buffer);\n            if (read > 0) {\n                dest.write(buffer, 0, read);\n            }\n        }\n        src.close();\n        dest.close();\n    }\n", "code2": "    private void displayDiffResults() throws IOException {\n        File outFile = File.createTempFile(\"diff\", \".htm\");\n        outFile.deleteOnExit();\n        FileOutputStream outStream = new FileOutputStream(outFile);\n        BufferedWriter out = new BufferedWriter(new OutputStreamWriter(outStream));\n        out.write(\"<html><head><title>LOC Differences</title>\\n\" + SCRIPT + \"</head>\\n\" + \"<body bgcolor='#ffffff'>\\n\" + \"<div onMouseOver=\\\"window.defaultStatus='Metrics'\\\">\\n\");\n        if (addedTable.length() > 0) {\n            out.write(\"<table border><tr><th>Files Added:</th>\" + \"<th>Add</th><th>Type</th></tr>\");\n            out.write(addedTable.toString());\n            out.write(\"</table><br><br>\");\n        }\n        if (modifiedTable.length() > 0) {\n            out.write(\"<table border><tr><th>Files Modified:</th>\" + \"<th>Base</th><th>Del</th><th>Mod</th><th>Add</th>\" + \"<th>Total</th><th>Type</th></tr>\");\n            out.write(modifiedTable.toString());\n            out.write(\"</table><br><br>\");\n        }\n        if (deletedTable.length() > 0) {\n            out.write(\"<table border><tr><th>Files Deleted:</th>\" + \"<th>Del</th><th>Type</th></tr>\");\n            out.write(deletedTable.toString());\n            out.write(\"</table><br><br>\");\n        }\n        out.write(\"<table name=METRICS BORDER>\\n\");\n        if (modifiedTable.length() > 0 || deletedTable.length() > 0) {\n            out.write(\"<tr><td>Base:&nbsp;</td><td>\");\n            out.write(Long.toString(base));\n            out.write(\"</td></tr>\\n<tr><td>Deleted:&nbsp;</td><td>\");\n            out.write(Long.toString(deleted));\n            out.write(\"</td></tr>\\n<tr><td>Modified:&nbsp;</td><td>\");\n            out.write(Long.toString(modified));\n            out.write(\"</td></tr>\\n<tr><td>Added:&nbsp;</td><td>\");\n            out.write(Long.toString(added));\n            out.write(\"</td></tr>\\n<tr><td>New & Changed:&nbsp;</td><td>\");\n            out.write(Long.toString(added + modified));\n            out.write(\"</td></tr>\\n\");\n        }\n        out.write(\"<tr><td>Total:&nbsp;</td><td>\");\n        out.write(Long.toString(total));\n        out.write(\"</td></tr>\\n</table></div>\");\n        redlinesOut.close();\n        out.flush();\n        InputStream redlines = new FileInputStream(redlinesTempFile);\n        byte[] buffer = new byte[4096];\n        int bytesRead;\n        while ((bytesRead = redlines.read(buffer)) != -1) outStream.write(buffer, 0, bytesRead);\n        outStream.write(\"</BODY></HTML>\".getBytes());\n        outStream.close();\n        Browser.launch(outFile.toURL().toString());\n    }\n", "label": 1, "substitutes": {"copyFile": ["CopyFiles", "CopyDirectory", " copyfile", "copyFiles", "moveFile", "moveFiles", " copyDirectory", "moveDirectory", "copyfile", " copyFiles", "CopyFile", "copyDirectory", "Copyfile", "movefile"], "srcFile": [" srcWeb", "sourcePath", "sourceFile", "sourcefile", "srcFiles", " srcFiles", "srcPath", "subLine", "srcWeb", "srcLine", "subFile", "subPath", "rcFile", "rcWeb", "sourceFiles", "srcfile", "rcLine", "rcPath", " srcLine", "rcFiles", "subWeb", "rcfile", " srcPath", " srcfile"], "destFile": ["DestPath", "destPath", "DestFiles", "srcMail", "srcFilename", "srcFiles", "potFile", " destDir", "srcPath", "srcDir", "potMail", " destMail", " destFiles", " destFilename", "DestDir", "destDir", "potDir", "destMail", "DestFile", " destPath", "potFilename", "destFilename", "destFiles"], "src": ["ser", "rc", "via", "scan", "usr", "sb", "rt", "sync", "sit", "ins", "reader", "ln", "sys", "inner", "sq", "rest", "sl", "ctr", "cur", "sr", "rel", "req", "sh", "pri", "sel", "rs", "rl", "const", "rb", "sin", "sf", "proc", "comp", "rx", "sc", "st", "iv", "syn", "ssl", "http", "sub", "rob", "source", "loc", "gob", "inst", "sing"], "dest": ["exp", "decl", "coord", "nt", "usr", "comb", "cat", "pub", "output", "pas", "them", "di", "sit", "cont", "trans", "doc", "sum", "est", "gd", "gate", "pipe", "port", "dis", "rest", "pl", "end", "master", "must", "opt", "rel", "result", "bin", "target", "std", "pos", "out", "des", "comp", "st", "priv", "dat", "nom", "news", "inv", "desc", "mm", "self", "Dest", "dist", "temp", "mk", "source", "loc", "dc", "nd"], "buffer": ["event", "phrase", "buf", "window", "block", "value", "buff", "text", "sample", "entry", "frame", "word", "comment", "sequence", "stream", "table", "append", "page", "mem", "base", "limit", "char", "command", "attribute", "document", "message", "shape", "result", "stack", "available", "number", "cache", "Buffer", "variable", "initial", "object", "component", "length", "binary", "batch", "bar", "channel", "row", "button", "password", "memory", "print", "data", "header"], "read": ["play", "each", "shift", "sample", "next", "draw", "wait", "t", "q", "build", "have", "get", "iter", "record", "Read", "n", "config", "start", "send", "size", "index", "pe", "reader", "allow", "char", "shape", "reads", "seek", " Read", "need", "height", "ind", "key", "reading", "check", "text", "fill", " write", "stream", "run", "in", "write", "open", "hold", "str", "tail", "input", "last", "query", "len", "length", "mix", "num", "count", "scale", "READ", "find", "sync", "word", "depth", "old", "readable", "load", "current", "skip", "give", "valid", "parse", "add", "no", "print", "end", "pass"]}}
{"id1": "14794404", "id2": "9081749", "code1": "    private String encryptPassword(String password) throws NoSuchAlgorithmException {\n        StringBuffer encryptedPassword = new StringBuffer();\n        MessageDigest md5 = MessageDigest.getInstance(\"MD5\");\n        md5.reset();\n        md5.update(password.getBytes());\n        byte digest[] = md5.digest();\n        for (int i = 0; i < digest.length; i++) {\n            String hex = Integer.toHexString(0xFF & digest[i]);\n            if (hex.length() == 1) {\n                encryptedPassword.append('0');\n            }\n            encryptedPassword.append(hex);\n        }\n        return encryptedPassword.toString();\n    }\n", "code2": "    private static String encrypt(String password, String encryptType) {\n        try {\n            MessageDigest md = MessageDigest.getInstance(encryptType);\n            md.update(password.getBytes());\n            byte[] hash = md.digest();\n            StringBuffer hexString = new StringBuffer();\n            for (int i = 0; i < hash.length; i++) {\n                if ((0xff & hash[i]) < 0x10) {\n                    hexString.append(\"0\" + Integer.toHexString((0xFF & hash[i])));\n                } else {\n                    hexString.append(Integer.toHexString(0xFF & hash[i]));\n                }\n            }\n            password = hexString.toString();\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        }\n        return password.toUpperCase();\n    }\n", "label": 1, "substitutes": {"encryptPassword": ["decryptPass", "decryptPassword", "encryptionSecret", "decryptSecret", "encryptpassword", "encryptedpassword", "encryptedSecret", "decryptedPassword", "encryptSecret", "decryptpassword", "encipherPassword", "encryptionPassword", "encryptionPass", "decryptedpassword", "encryptedPass", "encryptionpassword", "encipherpassword", "decryptedPass", "decryptedSecret", "encryptPass", "encipherSecret", "encipherPass"], "password": ["phrase", "address", "value", "text", "reset", "entry", "email", "word", "description", "secret", "w", "shadow", "directory", "command", "attribute", "Password", "past", "message", "filename", "content", "wordpress", "number", "name", "token", "hash", "input", "login", "path", "sword", "database", "pattern", "padding", "key", "string", "user", "username", "data", "prefix", "pass"], "encryptedPassword": ["encryptedGuest", "installedAttribute", "updatedGuest", " encryptedGuest", "installedDatabase", "initializedConnection", "encryptedpassword", "finishedPassword", "updatedAttribute", "confirmedDatabase", "updatedpassword", "finishedpassword", "encryptedAttribute", "ryptedpassword", "coloredPassword", "encryptedStatement", "finishedGuest", " encryptedConnection", "encryptedDatabase", "updatedPassword", "updatedDatabase", "initializedDatabase", "encryptedDirectory", "confirmedpassword", " encryptedAttribute", "initializedPassword", "finishedDatabase", "coloredConnection", "initializedStatement", " encryptedDirectory", "confirmedPassword", "encryptedConnection", "updatedDirectory", "ryptedPassword", "ryptedDirectory", "installedDirectory", " encryptedpassword", "ryptedDatabase", "coloredStatement", "coloredDatabase", "installedPassword", "confirmedDirectory", " encryptedStatement", " encryptedDatabase"], "md5": ["MD25", " md25", " MD2", " Mdle", "MD7", "MD2", "MD5", " mdle", "MD3", "mdle", " md3", "dig5", " md2", " MD3", " Md5", "md7", "dig3", " md7", " md512", " MDle", " MD8", "md25", " Md8", "sha512", "sha5", "dig2", "MD512", "md8", " md8", "md3", "md512", "md2", "dig25", " Md3", "sha7", " MD5", "sha2"], "digest": ["mdester", "Digness", " digse", "hexEST", "hashester", "hashEST", "digests", "digse", "digum", "hashum", "Digester", "Digests", "Digum", " digests", "hexest", "mdEST", "hexness", "mdum", "Digse", "digEST", "mdest", "mdness", "hashested", "hashest", "Digested", "mdse", "hexested", "mdested", " digEST", "digested", "digness", "DigEST", "digester", "mdests", "Digest"], "i": ["mi", "major", "span", "u", "j", "z", "ski", "y", "I", "ie", "qi", "di", "im", "ri", "ei", "m", "iq", "yi", "conv", "init", "x", "t", "in", "ti", "hi", "q", "me", "err", "bi", "c", "b", "ic", "multi", "ci", "ai", "sim", "gi", "ui", "uri", "pi", "ij", "ix", "iter", "it", "ji", "li", "\u0438", "xi", "my", "si", "point", "ind", "o", "ip", "zi", "n", "key", "io", "gu", "is", "ii", "index", "id", "a", "phi"], "hex": ["exp", "pex", "hl", "oct", "txt", "solid", "json", "br", " Hex", "alpha", "tx", "serial", "h", "raw", "x", "flash", "sex", "print", "cert", "lit", "tex", "color", "ph", "com", "none", "sv", "sh", "def", "unsigned", "str", "hash", "des", "iter", "dump", "comp", "ch", "cmd", "form", "uint", "term", "mix", "rendered", "rex", "full", "zip", "kw", "html", "cf", "temp", "rh", "percent", "check", "xf", "ne", "ex"]}}
{"id1": "3558512", "id2": "17996547", "code1": "    public void serialize(OutputStream out) throws IOException, BadIMSCPException {\n        ensureParsed();\n        ZipFilePackageParser parser = utils.getIMSCPParserFactory().createParser();\n        parser.setContentPackage(cp);\n        if (on_disk != null) on_disk.delete();\n        on_disk = createTemporaryFile();\n        parser.serialize(on_disk);\n        InputStream in = new FileInputStream(on_disk);\n        IOUtils.copy(in, out);\n    }\n", "code2": "    public static File copyFile(File fileToCopy, File copiedFile) {\n        BufferedInputStream in = null;\n        BufferedOutputStream outWriter = null;\n        if (!copiedFile.exists()) {\n            try {\n                copiedFile.createNewFile();\n            } catch (IOException e1) {\n                e1.printStackTrace();\n                return null;\n            }\n        }\n        try {\n            in = new BufferedInputStream(new FileInputStream(fileToCopy), 4096);\n            outWriter = new BufferedOutputStream(new FileOutputStream(copiedFile), 4096);\n            int c;\n            while ((c = in.read()) != -1) outWriter.write(c);\n            in.close();\n            outWriter.close();\n        } catch (FileNotFoundException e) {\n            e.printStackTrace();\n            return null;\n        } catch (IOException e) {\n            e.printStackTrace();\n            return null;\n        }\n        return copiedFile;\n    }\n", "label": 1, "substitutes": {"serialize": ["erialate", " serialized", "serialization", "finalized", "Serialize", "finalize", "Serialization", "finalization", "initialze", "serializer", "serialate", " serialate", " serializer", "initialization", "finalze", "Serialze", "initialize", "Serialized", "initialized", "serialze", "Serialate", "erializer", "erialize", "serialized", "erialized", "Serializer"], "out": ["f", "report", "output", "res", "d", "sum", "stream", "t", "c", "log", "err", "b", "to", "result", "up", "v", "i", "serv", "os", " OUT", "OU", "ch", "it", "sw", "ou", "outs", "aos", "o", "n", "io", "Out", "file", "pool", "OUT", "p", "a", "w"], "parser": ["style", "worker", "tp", "bank", "layer", "util", "policy", "part", "rer", "builder", "reader", "tar", "processor", "base", "inner", "command", "pkg", "asser", "ker", "xml", "format", "ler", "now", "writer", "arser", "token", "jack", "aser", "proc", "walker", "per", "parse", "tree", "handler", "lp", "language", "instance", "magic", "ger", "manager", "er", "job", "file", "password", "Parser", "plan", "p", "loader", "peer"], "on_disk": ["On2link", "on2link", " on_volume", "on_disc", "On_Disk", "On_cloud", "on2file", "on_dis", " on_file", " on_Disk", " on_download", " on_dis", "On_disk", "On2file", "on2Disk", "on_Disk", "On2disk", "On_file", " on_disc", "On2Disk", "on_download", "on_link", "on2disk", "on_cloud", "on_file", "On_link", "on_volume"], "in": ["mi", "en", "rin", "inn", "and", "gin", "min", "IN", "vin", "ins", "on", "In", "inner", "inside", "i", "bin", "inc", "input", "sin", "it", " IN", " din", "ain", "ind", "r", "ad", "io", "din", "inf", "is", "isin", "body", "cin", "id", "from"]}}
{"id1": "15797402", "id2": "822452", "code1": "    public void parse(InputStream stream, ContentHandler handler, Metadata metadata, ParseContext context) throws IOException, SAXException, TikaException {\n        String name = metadata.get(Metadata.RESOURCE_NAME_KEY);\n        if (name != null && wanted.containsKey(name)) {\n            FileOutputStream out = new FileOutputStream(wanted.get(name));\n            IOUtils.copy(stream, out);\n            out.close();\n        } else {\n            if (downstreamParser != null) {\n                downstreamParser.parse(stream, handler, metadata, context);\n            }\n        }\n    }\n", "code2": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "label": 1, "substitutes": {"parse": ["transform", "php", "handle", "process", "parser", "se", "resource", "execute", "create", "tag", "build", "write", "load", "slice", "interpret", "shape", "ping", "close", "xml", "format", "read", "dump", "split", "filter", "add", "use", "scale", "save", "apply", "patch", "map", "p", "print", "pe", "render"], "stream": ["event", "window", "handle", "response", "image", "output", "sample", "sync", "test", "console", "cont", "resource", "reader", "sequence", "clean", "Stream", "in", "chain", "buffer", "open", "document", "message", "stack", "content", "ream", "read", "url", "archive", "input", "upload", "form", "length", "instance", "iterator", "channel", "zip", "download", "http", "file", "source", "data"], "handler": ["event", "handle", "worker", "address", "ctx", "Handler", "policy", "callback", "parser", "service", "storage", "resource", "application", "reader", "h", "processor", "connection", "management", "function", "shape", "hander", "message", "host", "writer", "controller", "hand", "pool", "password", "wrapper", "loader", "server"], "metadata": ["adata", "handle", "json", "image", "dirty", "google", "ctx", "policy", "parts", "mt", "unknown", "details", "managed", "tar", "m", "general", "module", "mem", "met", "template", "md", "management", "basic", "document", "message", "hold", "xml", "property", "content", "detail", "properties", "td", "definition", "meta", "common", "data", "dd", "material", "java", "MD", "iterator", "manager", "info", "config", "still", "memory", "pdf", "header"], "context": ["event", "Context", "response", "ctx", "options", "dict", "frame", "resource", "sequence", "set", "reason", "module", "environment", "connection", "template", "chain", "ce", "command", "document", "current", "system", "stack", "content", "state", "condition", "sc", "component", "null", "network", "instance", "collection", "local", "location", "config", "usage", "translation", "cc"], "name": ["type", "all", "nm", "image", "value", "default", "named", "alias", "time", "part", "comment", "service", "resource", "description", "client", "on", "create", "reason", "names", "base", "label", "old", "current", "system", "family", "filename", "none", "url", "lower", "l", "NAME", "common", "nl", "len", "path", "term", "null", "ame", "channel", "local", "key", "n", "string", "no", "size", "source", "file", "body", "version", "id", "Name", "data", "prefix", "title", "pass"], "out": ["all", "lay", "co", "flush", "us", "con", "output", "cos", "res", "oss", "cn", "obj", "sys", "sum", "table", "col", "conv", "in", "po", "one", "net", "to", "list", "up", "conf", "v", "url", "serv", "writer", "external", "outer", "OU", "it", "cmd", "null", "ou", "aos", "outs", "o", "auto", "n", "io", "Out", "file", "OUT", "user", "print", "gen", "ex"]}}
{"id1": "13563706", "id2": "17557289", "code1": "    public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String selectedPage = request.getParameter(\"SelectedPage\");\n        Page page = null;\n        PortalRequest portalRequest = PortalRequest.getCurrentRequest();\n        if (selectedPage == null) {\n            try {\n                Property pageProp = Property.getProperty(\"HomePage\");\n                selectedPage = pageProp.getValue();\n            } catch (PersistentModelException e) {\n                myLogger.info(\"Page could not be found due to an exception\");\n                response.sendError(response.SC_NOT_FOUND);\n                return;\n            }\n        }\n        myLogger.info(\"Handling Page Request for Page \" + selectedPage);\n        try {\n            if (page == null) {\n                try {\n                    page = Page.getPage(Long.parseLong(selectedPage));\n                } catch (NumberFormatException e) {\n                    List<Page> possiblePage = Page.findByName(selectedPage);\n                    if (possiblePage.size() > 0) {\n                        page = possiblePage.get(0);\n                    } else {\n                        response.sendError(response.SC_NOT_FOUND);\n                        return;\n                    }\n                }\n            }\n            if (!page.isVisibleTo(portalRequest.getCurrentUser())) {\n                Property pageProp = Property.getProperty(\"HomePage\");\n                selectedPage = pageProp.getValue();\n                page = Page.getPage(Long.parseLong(selectedPage));\n            }\n            try {\n                Property property = Property.getProperty(\"LogPageRequests\");\n                if (property.getValue().toLowerCase().equals(\"true\")) {\n                    String referer = request.getHeader(\"Referer\");\n                    if (referer == null || referer.indexOf(portalRequest.getRequest().getServerName()) > 0) {\n                        referer = \" \";\n                    } else {\n                        if (referer.length() >= 200) {\n                            referer = referer.substring(0, 198);\n                        }\n                    }\n                    PageRequest.createRequest(portalRequest.getCurrentHREF(), page, portalRequest.getCurrentUser(), portalRequest.getRequest().getRemoteAddr(), referer);\n                }\n            } catch (PersistentModelException e) {\n                myLogger.log(Level.WARNING, \"Log Page Requests property was not found.\", e);\n            }\n            if (page.isVisibleTo(portalRequest.getCurrentUser())) {\n                HttpSession session = request.getSession();\n                if (session != null) {\n                    RecentlyViewedManager rvm = (RecentlyViewedManager) session.getAttribute(\"ipoint.RecentlyViewedManager\");\n                    if (rvm == null) {\n                        rvm = new RecentlyViewedManager();\n                    }\n                    rvm.add(page);\n                    session.setAttribute(\"ipoint.RecentlyViewedManager\", rvm);\n                }\n                PageCacheEntry entry = null;\n                if (!portalRequest.isPost() && !page.isEditableBy(portalRequest.getCurrentUser())) {\n                    try {\n                        int pageCacheTime = 60000;\n                        try {\n                            Property pageCacheTimeProperty = Property.getProperty(\"PageCacheTime\");\n                            pageCacheTime = Integer.parseInt(pageCacheTimeProperty.getValue());\n                            pageCacheTime *= 1000;\n                        } catch (PersistentModelException pme) {\n                            myLogger.warning(\"Ignoring Exception when retrieving PageCacheTime property\");\n                        } catch (NumberFormatException nfe) {\n                        }\n                        entry = PageCacheEntry.find(portalRequest.getCurrentHREF(), page, portalRequest.getCurrentUser(), pageCacheTime);\n                    } catch (PersistentModelException e) {\n                        myLogger.log(Level.WARNING, \"An error occurred finding a page cache entry\", e);\n                    }\n                }\n                response.setContentType(\"text/html\");\n                response.setHeader(\"Cache-Control\", \"no-cache\");\n                boolean processed = false;\n                if (entry != null) {\n                    String tempFile = entry.getTempFile();\n                    File file = new File(tempFile);\n                    if (file.exists() && file.isFile() && file.canRead()) {\n                        FileReader reader = new FileReader(file);\n                        BufferedReader br = new BufferedReader(reader);\n                        PrintWriter out = response.getWriter();\n                        out.write(\"<!-- Starting to output cached page in \" + portalRequest.elapsedTime() + \" ms -->\\n\");\n                        while (br.ready()) {\n                            out.write(br.readLine() + \"\\n\");\n                        }\n                        out.write(\"<!-- Cached output produced in \" + portalRequest.elapsedTime() + \" ms -->\\n\");\n                        reader.close();\n                        processed = true;\n                        portalRequest.getMBeans().incrementStatistics(ManagementMBeans.StatisticsType.PageTotal, page.getName() + \"-\" + page.getID(), portalRequest.elapsedTime(), true);\n                    } else {\n                        entry.delete();\n                    }\n                }\n                if (!processed) {\n                    PrintWriter out = response.getWriter();\n                    out.write(\"<!-- Output produced by iPoint Portal -->\\n\");\n                    PageRenderer renderer = new PageRenderer(page);\n                    long startTime = System.currentTimeMillis();\n                    request.setAttribute(ELConstants.IPOINT_USER, portalRequest.getCurrentUser());\n                    request.setAttribute(ELConstants.IPOINT_PAGE, page);\n                    request.setAttribute(ELConstants.IPOINT_TEMPLATE, page.getTemplate());\n                    request.setAttribute(ELConstants.IPOINT_PORTAL_PROPERTIES, Property.getPropertiesMap());\n                    request.setAttribute(ELConstants.IPOINT_USER_PROPERTIES, portalRequest.getCurrentUser().getProperties());\n                    renderer.preProcess();\n                    portalRequest.getMBeans().incrementStatistics(ManagementMBeans.StatisticsType.PagePreProcess, page.getName() + \"-\" + page.getID(), System.currentTimeMillis() - startTime, false);\n                    long renderStart = System.currentTimeMillis();\n                    renderer.render();\n                    portalRequest.getMBeans().incrementStatistics(ManagementMBeans.StatisticsType.PageRender, page.getName() + \"-\" + page.getID(), System.currentTimeMillis() - renderStart, false);\n                    portalRequest.getMBeans().incrementStatistics(ManagementMBeans.StatisticsType.PageTotal, page.getName() + \"-\" + page.getID(), System.currentTimeMillis() - startTime, false);\n                    out.write(\"<!-- output produced in \" + PortalRequest.getCurrentRequest().elapsedTime() + \" ms -->\\n\");\n                    if (!page.isEditableBy(portalRequest.getCurrentUser())) {\n                        if (response instanceof CachingResponseWrapper) {\n                            CachingResponseWrapper crw = (CachingResponseWrapper) response;\n                            crw.flushBuffer();\n                            Property tempProperty = Property.getProperty(\"UploadLocation\");\n                            File tempDirectory = new File(tempProperty.getValue());\n                            if (tempDirectory.exists() && tempDirectory.canWrite()) {\n                                File file = File.createTempFile(\"iPointPage\", \".html\", tempDirectory);\n                                try {\n                                    FileWriter fw = new FileWriter(file);\n                                    fw.write(crw.getOutput());\n                                    fw.flush();\n                                    fw.close();\n                                    PageCacheEntry.create(portalRequest.getCurrentHREF(), page, portalRequest.getCurrentUser(), file.getAbsolutePath());\n                                } catch (IOException e) {\n                                }\n                            } else {\n                                myLogger.warning(\"Can not write to directory \" + tempProperty.getValue());\n                            }\n                        }\n                    }\n                }\n            } else {\n                myLogger.info(\"Current User is Forbidden from seeing this Page\");\n                response.sendError(response.SC_FORBIDDEN);\n            }\n        } catch (PersistentModelException e) {\n            myLogger.log(Level.INFO, \"Unable to find page \" + selectedPage, e);\n            response.sendError(response.SC_NOT_FOUND);\n        } catch (PresentationException pe) {\n            pe.printStackTrace();\n            throw new ServletException(\"Error processing the page\", pe);\n        }\n    }\n", "code2": "    private static void copyFile(File source, File dest) throws IOException {\n        FileChannel srcChannel = new FileInputStream(source).getChannel();\n        FileChannel dstChannel = new FileOutputStream(dest).getChannel();\n        dstChannel.transferFrom(srcChannel, 0, srcChannel.size());\n        srcChannel.close();\n        dstChannel.close();\n    }\n", "label": 1, "substitutes": {"doGet": ["DoPut", "doGET", " doPut", " doGET", "handlePut", "Doget", "handleGET", "doget", " doget", "doPut", "handleget", "handleGet", "DoGET", "DoGet"], "request": ["event", "first", "report", "transform", "address", "reference", "each", "subject", "reset", "hello", "forward", "frame", "resource", "application", "view", "create", "context", "connection", "directory", "command", "attribute", "document", "current", "message", "Request", "call", "re", "xml", "route", "url", "position", "get", "complete", "input", "initial", "order", "query", "parent", "search", "project", "path", "use", "http", "socket", "QUEST", "version", "user", "setup"], "response": ["report", "reply", "image", "json", "block", "default", "output", "res", "next", "console", "service", "frame", "application", "description", "view", "summary", "sequence", "Response", "status", "header", "fire", "connection", "ce", "ve", "write", "resp", "document", "message", "result", "format", "see", "example", "condition", "position", "success", "hash", "respond", "exit", "tree", "search", "answer", "continue", "security", "network", "collection", "relation", "foundation", "http", "display", "zero", "version", "print", "server", "render"], "selectedPage": ["lectedPath", "namedFrame", "specifiedPort", "selectedLine", "namedLine", "selectedDocument", "lectedItem", "selectionToken", "electedPage", " selectedLine", "selectionPort", "selectedToken", "selectedRow", "electionPort", "selectLine", "lectedToken", "matchedFrame", " selectedPath", "selectionFile", "namedPort", "selectFile", "lectedDocument", "singlePage", "specifiedFrame", "electedFrame", "selectionLine", "selectedKey", "selectItem", " selectedRow", " selectedFrame", "namedKey", " selectedFile", "electedPort", "selectedPort", "selectedFrame", "electedpage", "verifiedRow", " selectedpage", "lectedRow", "selectedpage", "matchedpage", "singlepage", "lectedpage", "lectedPort", "lectedFrame", "selectPort", "namedPage", "electionDocument", "verifiedpage", "verifiedFile", "namedToken", "singlePort", "lectedPage", "selectedPath", "matchedPort", "matchedPage", "electionPage", "specifiedDocument", " selectedPort", "selectPath", "lectedLine", "selectionPage", " selectedKey", "electionFrame", "selectPage", "namedpage", "specifiedPage", "selectionItem", "selectedItem", "selectedFile", "lectedFile", "verifiedPage", "lectedKey", "singleFrame"], "page": ["rule", "window", "output", "pointer", "policy", "next", "port", "me", "be", "to", "number", "node", "form", "record", "channel", "row", "pages", "phrase", "address", "resource", "pp", "force", "site", "menu", "associated", "log", "document", "cache", "phone", "position", "successful", "age", "language", "line", "version", "server", "layout", "block", " Page", "frame", "office", "application", "view", "table", "profile", "chain", "url", "complete", "parent", "point", "object", "group", "instance", "network", "pool", "user", "display", "peer", "proxy", "Page", "image", "client", "message", "current", "result", "project", "created", "filter", "collection", "self", "p"], "portalRequest": ["portalQuery", "portalingApply", "portsortalEvent", "portalidFrame", "portralSession", "portalResponse", "portralRequest", "PortaleResponse", " portalCall", "portalidRequest", "PortalQuery", " portaleCall", "PortalResponse", " portalAccess", "portalEvent", "portsalRequest", "portralQuery", "portalApply", "portsalEvent", "portortalResponse", "portalThread", "portaleFrame", "portaleEvent", "PortaleFrame", "portalaCall", "portalidSession", "portaleSession", "PortalThread", "portalerequest", "PortalContext", "portaleThread", "PortaleContext", "portalFrame", "terminalSession", "portalidResponse", "terminalRequest", "portortalRequest", "portalityFrame", "portsortalRequest", "PortaleThread", "portalidQuery", "terminalQuery", "PortalFrame", "portortalEvent", "portalaApply", "terminalidSession", "portalaRequest", "portralContext", "portalityResponse", "portpalRequest", "portortalThread", "portaleRequest", "portalityRequest", "portaleQuery", "portaleAccess", "portualRequest", "PortalRequest", "portsortalrequest", "portalAccess", "terminalidRequest", "portualResponse", "portalCall", " portaleRequest", "portortalrequest", "portaleResponse", "portsalrequest", "portsortalResponse", "portortalContext", " portaleAccess", "portalingAccess", "portalaAccess", "portalidContext", " portalApply", "portualrequest", "portalityContext", "portralResponse", "portpalContext", "portaleCall", "portalContext", "PortaleRequest", "portalingCall", "PortaleQuery", "portpalResponse", "terminalResponse", "terminalidResponse", "portortalQuery", " portaleApply", "portalSession", "portualEvent", "portalingRequest", "portpalThread", "portaleContext", "portsalResponse", "terminalidQuery", "portalrequest", "portaleApply"], "pageProp": ["phraseProp", "officePack", " pagePro", "propertyDef", "pagePr", "agePro", "imagePr", "profileProp", "keyProperty", "keyPr", "sectionPred", "officeProp", "sectionProp", "pagePack", "propertyProp", "agePr", " pagePack", "profilePred", " pageProperty", "phrasePr", "agePred", "propertyPack", "ageProp", "poolPred", " pagePriv", "pageComp", "phraseComp", "imagePred", "sectionPro", "officePriv", "poolZip", "pagePred", " pageComp", "pageDef", "poolProp", "propertyPriv", " pagePr", "pagePro", "keyProp", "keyComp", "pageZip", "profileZip", " pagePred", "pagePriv", "profilePro", " pageDef", "phraseProperty", "pageProperty", "imageProp", "officeDef", "sectionZip", "imagePro", "poolPro"], "possiblePage": [" packedPage", "packedLine", "pablePage", "possiblyCollection", " packedTag", "PossiblyPage", "possibleCollection", "possiblePages", "possiblyChild", "pspecifiedPage", "packedCollection", "Possiblepage", "possiblepage", "possiblyTag", "PossiblePage", " packedCollection", "PossiblyChild", "possiblyPage", " packedLine", "pableLine", "pentialpage", "possibleChild", "possibleLine", "PossiblyUser", "PossibleUser", "packedTag", "possibleUser", "pbablePage", "PossibleChild", "pentialTag", "pentialPages", "PossiblePages", "pbableChild", "PossibleCollection", "pibleUser", "possiblyUser", "packedPage", "pbableUser", "pspecifiedTag", "pableTag", "PossiblyCollection", " possibleLine", "pibleCollection", "pspecifiedPages", "PossibleTag", "pibleChild", "pspecifiedpage", "pableCollection", "pbableCollection", "pentialPage", "possibleTag", "piblePage", " possibleTag", "possiblyLine", " possibleCollection"], "property": ["type", "Property", "rule", "phrase", "behavior", "address", "value", "prop", "policy", "service", "frame", "resource", "description", "feature", "trace", "attribute", "command", "function", "integer", "message", "second", "properties", "variable", "owner", "name", "position", "definition", "operator", "expression", "rue", "metadata", "object", "relation", "domain", "key", "location", "string", "config", "field", "class", "p", "header", "title"], "referer": ["rangeerer", "aferer", "Refrer", "rangerer", "reeree", "refirect", "Referee", "reener", "requerer", "rangeender", "defirect", " refrer", "refere", "diffrer", "rerier", "rorrer", "reonder", "reerential", "rearer", "rorirect", "afrer", "reterer", "refonder", "reportered", "differing", "refering", "rorered", "refrier", "reportarer", "Referer", "relerential", "fener", "printrier", "rederee", "reere", "verrier", "reerer", "ferer", "fering", "relender", "afener", "refarer", "referential", "differer", "relrer", "vererential", "diffonder", "reered", "requering", "defrer", "defered", "vererer", "relerer", "rangeener", "reporterer", "printerer", "redere", "refender", "refrer", "printrer", "frer", "aferential", " refirect", "relener", "deferer", "refener", "Refere", " refered", "refered", "rederer", "retered", "rerer", "redrer", "reportrer", "requonder", "retarer", "referee", "requrer", "printerential", "rorerer", "verrer", "reender", "relering", "retrer", "reering"], "e": ["E", "f", "eeee", "event", "echo", "ie", "oe", "ee", "h", "es", "se", "m", "t", "x", "ae", "me", "err", "ception", "eur", "error", "g", "o", "eg", "r", "ge", "n", "te", "er", "de", "eu", "p", "a"]}}
{"id1": "9371421", "id2": "22752444", "code1": "    public static String eventHash(String eventstr) {\n        try {\n            if (md == null) {\n                md = MessageDigest.getInstance(\"MD5\");\n            }\n            md.update(eventstr.getBytes(\"utf-8\"));\n            byte[] theDigest = md.digest();\n            return new BASE64Encoder().encode(theDigest);\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        } catch (UnsupportedEncodingException e) {\n            e.printStackTrace();\n        }\n        return null;\n    }\n", "code2": "    public synchronized String encrypt(String plainText) {\n        String hash = null;\n        try {\n            MessageDigest md = null;\n            try {\n                md = MessageDigest.getInstance(\"SHA\");\n            } catch (NoSuchAlgorithmException e) {\n                throw new NoSuchAlgorithmException();\n            }\n            try {\n                if (plainText != null) md.update(plainText.getBytes(\"UTF-8\"));\n            } catch (UnsupportedEncodingException e) {\n                throw new UnsupportedEncodingException();\n            }\n            byte raw[] = md.digest();\n            hash = (new BASE64Encoder()).encode(raw);\n        } catch (NoSuchAlgorithmException e) {\n            MessageLog.writeErrorMessage(e, this);\n        } catch (UnsupportedEncodingException e) {\n            MessageLog.writeErrorMessage(e, this);\n        }\n        return Util.stripChars(hash);\n    }\n", "label": 1, "substitutes": {"eventHash": [" eventhash", "textHash", "Eventhash", "textRender", " eventName", "EventRender", " eventRender", "EventHash", "EventName", "eventhash", "eventRender", "texthash", "eventName", "textName"], "eventstr": ["ventstr", "ventenc", "EventStr", "Eventstr", " eventstring", "ventname", "msgStr", " eventenc", " eventname", "Eventstring", "eventStr", "Eventname", "msgname", "Eventenc", "eventstring", "msgstring", "ventStr", "eventname", " eventStr", "eventenc", "msgstr"], "md": ["nt", "ms", "pd", "od", "di", "d", "der", "mt", "m", "mo", "mod", "mem", "met", "mg", "red", "del", "mp", "dr", "rm", "det", "dm", "sd", "td", "down", "dd", "cmd", "mand", "metadata", "dat", "mb", "cd", "hd", "MD", "dig", "ind", "ad", "grad", "mn", "mc", "mm", "bd", "ma", "pm", "mk", "ld", "nd", "df", "dh"], "theDigest": ["THEDigests", "theDFested", "theDest", "THEMDests", " theDested", "theDFest", "theDecests", "theMDest", "THEDigEST", "theDFEST", "theDecest", " theDEST", "theMDEST", "theDigesting", "THEDigest", " theDigested", "theDEST", "theDested", "theDecEST", "thedigesting", "thedigest", "theMDests", "theDests", " theDigEST", "theDesting", "thedigEST", "THEMDEST", "THEMDested", "THEMDest", "theDFesting", " theDigesting", "theDigests", "theDecested", "thedigested", "theDigEST", "theMDested", " theDesting", "theDigested", "THEDigested", " theDest"]}}
{"id1": "18114701", "id2": "5744992", "code1": "    public InputSource resolveEntity(String publicId, String systemId) {\n        String resolved = getResolvedEntity(publicId, systemId);\n        if (resolved != null) {\n            try {\n                InputSource iSource = new InputSource(resolved);\n                iSource.setPublicId(publicId);\n                URL url = new URL(resolved);\n                InputStream iStream = url.openStream();\n                iSource.setByteStream(iStream);\n                return iSource;\n            } catch (Exception e) {\n                catalogManager.debug.message(1, \"Failed to create InputSource (\" + e.toString() + \")\", resolved);\n                return null;\n            }\n        }\n        return null;\n    }\n", "code2": "    public void dorequest(Map<String, String> ps, String method) throws IOException {\n        StringBuffer httpResponse = new StringBuffer();\n        URL ourl = new URL(url);\n        HttpURLConnection httpConnection = (HttpURLConnection) ourl.openConnection();\n        httpConnection.setRequestMethod(method);\n        httpConnection.setDoOutput(true);\n        this.setCookie(httpConnection);\n        OutputStream httpOutputStream = httpConnection.getOutputStream();\n        StringBuffer postParams = new StringBuffer(\"\");\n        for (Entry<String, String> entry : ps.entrySet()) {\n            postParams.append(entry.getKey());\n            postParams.append(\"=\");\n            postParams.append(entry.getValue());\n            postParams.append(\"&\");\n        }\n        httpOutputStream.write(postParams.toString().getBytes());\n        BufferedReader httpBufferedReader = new BufferedReader(new InputStreamReader(httpConnection.getInputStream()));\n        httpResponse.append(this.readBufferedContent(httpBufferedReader));\n        text = httpResponse.toString();\n        this.readCookie(httpConnection);\n    }\n", "label": 0, "substitutes": {"resolveEntity": ["consolvingObject", "consolvingEntity", "resolvingObject", "resolvedInternal", "consolvingEnt", "resolveInternal", "consolveInternal", "resolvedEntity", "consolvingInternal", "resloveEnt", "resolvedEnt", "resolvingEntity", "consolveObject", "resolveObject", "resloveInternal", "resolveEnt", "resolvingInternal", "consolveEntity", "resolvingEnt", "consolveEnt", "resloveEntity", "resolvedObject", "resloveObject"], "publicId": ["primaryTime", "openID", "primaryId", "openAnd", "privateID", "privatePart", "privateAnd", "primaryPart", "fullID", " publicPart", "publicLink", "publicPart", " publicID", "fullInt", "ublicID", "publicID", "openPart", "fullLink", " publicTime", "ublicPart", "ublicTime", "openId", " publicAnd", "ublicId", "privateLink", "publicTime", "primaryID", " publicLink", "publicAnd", "publicInt", "privateInt", "privateId", "fullId", " publicInt"], "systemId": ["userID", "sysName", " systemUrl", "sysID", "systemUrl", " systemID", "sysUrl", "externalName", "externalID", "externalId", "systemName", " systemName", "systemID", "userName", "sysId", "externalUrl", "userId", "userUrl"], "resolved": ["presolution", "preserved", "rolution", "involved", "presolver", "solved", "involution", "remolving", "solve", "rolved", "presolving", "Resolve", "solving", "revolution", "rolve", "resolving", "Resolver", "resultsolution", "rolving", "solves", "resultsolving", " resolver", "served", "revolved", "revolving", "presolved", "reserved", "consolves", "Resolution", "resolves", "solution", " resolving", "resolution", " reserved", " resolution", "consolved", "resolver", "consolution", " resolve", "remolved", "revolver", "remolves", "involving", "resultsolver", "involve", "presolve", "resultsolved", "Resolving", "Resolved", "resolve", "consolving", "remolution"], "iSource": ["iService", "aiSourceFile", "iniResource", "IMember", "qiSources", "aiStream", " iSources", "iniSite", " iService", "qiSource", "qiSOURCE", "iuSource", "iuSourceFile", "iiSource", "liStream", "aiSource", "iSourceFile", " iSourceFile", " iSOURCE", "iSOURCE", "aiService", "liSourceFile", "iiSite", "IResource", "iuSources", "uiSource", "iiResource", "liSources", "iSources", "ISource", "iMember", "ISite", "iiMember", "qiSourceFile", "uiSources", " iSite", "liSource", "liSite", "uiSite", "iuSOURCE", "liService", "iniSource", "iniMember", "uiSourceFile", "iResource", "iSite"], "url": ["f", "browser", "hl", "gl", "address", "u", "ref", "dl", "resource", "bel", "ls", "web", "ll", "char", "link", "build", "log", "sl", "mol", "rel", "re", "ur", "mount", "uri", "URL", "name", "str", "rl", "l", "nl", "ul", "mail", "path", "null", "mb", "r", "ssl", "arl", "http", "location", "html", "Url", "user"], "iStream": ["sourcestream", "sourceSteam", "iRead", "riRead", "riStream", "inputStream", "inputSteam", "iStack", "sourceStreamer", " iSteam", "uStreamer", "uStream", "uSteam", "iStreamer", "riStack", "riSteam", " iStack", "inputStack", "istream", "ipstream", "iSteam", "ipSteam", "inputRead", "ipStream", " iRead", "ustream", "ipStreamer", "sourceStream"]}}
{"id1": "20073619", "id2": "7499186", "code1": "    public static String getPagina(String strurl) {\n        String resp = \"\";\n        Authenticator.setDefault(new Autenticador());\n        try {\n            URL url = new URL(strurl);\n            BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream()));\n            String str;\n            while ((str = in.readLine()) != null) {\n                resp += str;\n            }\n            in.close();\n        } catch (MalformedURLException e) {\n            resp = e.toString();\n        } catch (IOException e) {\n            resp = e.toString();\n        } catch (Exception e) {\n            resp = e.toString();\n        }\n        return resp;\n    }\n", "code2": "    private void bootKernel(String conf) {\n        try {\n            AssetManager am = getResources().getAssets();\n            InputStream is = am.open(conf + \".conf\");\n            Properties props = new Properties();\n            props.load(is);\n            is.close();\n            Log.d(\"bootKernel\", \"Listing sdcard assets...\");\n            String[] sdcardfiles = am.list(\"sdcard\");\n            for (String file : sdcardfiles) {\n                Log.d(\"bootKernel\", \"Copying sdcard asset \" + file + \".\");\n                AssetFileDescriptor afd = am.openFd(\"sdcard/\" + file);\n                FileInputStream fis = afd.createInputStream();\n                FileChannel fic = fis.getChannel();\n                FileOutputStream fos = new FileOutputStream(\"/sdcard/\" + file);\n                FileChannel foc = fos.getChannel();\n                fic.transferTo(0, fic.size(), foc);\n                fic.close();\n                foc.close();\n            }\n            Configuration gconf = new JavaPropertiesConfiguration(props);\n            Configuration bconf = gconf.subset(\"boot\");\n            String kclass_name = bconf.getString(\"kernel\");\n            Log.d(\"bootKernel\", \"Attempting to load kernel from class '\" + kclass_name + \"'...\");\n            Class<? extends Kernel> kclass = Class.forName(kclass_name).asSubclass(Kernel.class);\n            Kernel kernel = kclass.newInstance();\n            Log.d(\"bootKernel\", \"Kernel loaded, proceeding with boot...\");\n            BootContext bctx = new SimpleBootContext(gconf, AndroidBridgeService.class, AndroidBridgeServiceImpl.class);\n            kernel.boot(bctx).get();\n            Log.d(\"bootKernel\", \"Kernel boot complete.\");\n        } catch (Exception e) {\n            Log.e(\"bootKernel\", \"Unable to boot kernel due to exception.\", e);\n            finish();\n        }\n    }\n", "label": 0, "substitutes": {"getPagina": ["getPaginino", "getPageinate", "getPackagarine", "getPackagine", "getPagarino", "getPageina", "getPackagina", "getPaginina", "getPackagarinate", "getPackagino", "getPaginine", "getPagarinate", "getPaginate", "getPackaginate", "getPagine", "getPagarine", "getPackagarina", "getPageino", "getPagino", "getPagininate", "getPageine", "getPagarina", "getPackagarino"], "strurl": ["urlurl", "arrurl", "STRstr", "strssl", " strssl", "sprurl", "strURL", "STRurl", " strrel", " strURL", "sprUrl", "urlstr", "arrrel", "strUrl", "STRUrl", "urlUrl", "sprURL", "arrUrl", " strUrl", "arrURL", "STRssl", "strrel", " strstr", "urlssl", "sprrel", "strstr"], "resp": ["exp", "txt", " respons", "gz", "neg", "par", "output", " req", "comm", "changes", "disc", "rest", "err", "perm", " ret", "re", "rel", "comp", "sol", " enc", "rex", "ret", "jp", "html", "msg", "repl", "good", "response", "cmp", "res", "rep", "pas", "obj", "summary", "fr", "https", "conv", "cli", "soc", "req", " Resp", " response", "cmd", "rev", "conn", "lim", " err", "elt", "respons", "dl", " msg", " rep", "rend", "ja", "serv", "esp", "body", "acc", "pretty", "dem", "csv", " outp", "buff", "Response", "help", " disp", "pkg", " res", "rm", "pos", "respond", "gov", "Resp", "inv", "arr"], "url": ["f", "browser", "gl", "address", "dl", "service", "resource", "client", "ls", "web", "ll", "t", "base", "char", "link", "pl", "build", "sl", "open", "b", "cert", "ur", "mount", "uri", "URL", "get", "l", "nl", "ul", "null", "r", "ssl", "http", "file", "loc", "Url", "id", "host"], "in": ["all", "rin", "inn", "and", "by", "gin", "IN", "ins", "reader", "on", "oin", "sum", "al", "In", "inner", "inside", "ill", "ic", "i", "read", "bin", "serv", "inc", "input", "out", "it", " din", "again", "ind", "r", "el", "mn", "mc", "n", "io", "din", "inf", "er", "is", "isin", "file", "source", "body", "cin", "from"], "str": ["exp", "txt", "tr", "div", "br", "text", "j", "block", "entry", "sp", "comm", "dict", "cont", "comment", "cr", "part", "obj", "m", "fr", "ls", "bc", "t", "ns", "inner", "char", "chain", "del", "err", "Str", "dr", "list", "i", "e", "req", "name", "pt", "coll", "le", "l", "ent", "hex", "ch", "sol", "expr", "st", "s", "syn", "line", "r", "n", "sts", "string", "msg", "STR", "arr", "p", "print"]}}
{"id1": "8788371", "id2": "19134229", "code1": "    private void tail(String[] cmd, int pos) throws IOException {\n        CommandFormat c = new CommandFormat(\"tail\", 1, 1, \"f\");\n        String src = null;\n        Path path = null;\n        try {\n            List<String> parameters = c.parse(cmd, pos);\n            src = parameters.get(0);\n        } catch (IllegalArgumentException iae) {\n            System.err.println(\"Usage: java FsShell \" + TAIL_USAGE);\n            throw iae;\n        }\n        boolean foption = c.getOpt(\"f\") ? true : false;\n        path = new Path(src);\n        FileSystem srcFs = path.getFileSystem(getConf());\n        if (srcFs.isDirectory(path)) {\n            throw new IOException(\"Source must be a file.\");\n        }\n        long fileSize = srcFs.getFileStatus(path).getLen();\n        long offset = (fileSize > 1024) ? fileSize - 1024 : 0;\n        while (true) {\n            FSDataInputStream in = srcFs.open(path);\n            in.seek(offset);\n            IOUtils.copyBytes(in, System.out, 1024, false);\n            offset = in.getPos();\n            in.close();\n            if (!foption) {\n                break;\n            }\n            fileSize = srcFs.getFileStatus(path).getLen();\n            offset = (fileSize > offset) ? offset : fileSize;\n            try {\n                Thread.sleep(5000);\n            } catch (InterruptedException e) {\n                break;\n            }\n        }\n    }\n", "code2": "    private void copyFile(final String sourceFileName, final File path) throws IOException {\n        final File source = new File(sourceFileName);\n        final File destination = new File(path, source.getName());\n        FileChannel srcChannel = null;\n        FileChannel dstChannel = null;\n        try {\n            srcChannel = new FileInputStream(source).getChannel();\n            dstChannel = new FileOutputStream(destination).getChannel();\n            dstChannel.transferFrom(srcChannel, 0, srcChannel.size());\n        } finally {\n            try {\n                if (dstChannel != null) {\n                    dstChannel.close();\n                }\n            } catch (Exception exception) {\n            }\n            try {\n                if (srcChannel != null) {\n                    srcChannel.close();\n                }\n            } catch (Exception exception) {\n            }\n        }\n    }\n", "label": 1, "substitutes": {"tail": ["ctl", "lock", "cat", "execute", "ls", "link", "command", "log", "slice", "load", "println", "list", "copy", "head", "get", "dump", "stat", "ail", "parse", "term", "split", "filter", "download", "file", "shell", "sort", "print"], "cmd": ["nt", "ctl", "cat", "om", "vp", "Cmd", "spread", "force", "help", "init", "command", "md", "pkg", "log", "cli", "Command", "ctr", "call", "mode", "wd", "det", "req", "cp", "ct", "act", "bind", "fx", "dir", "news", "cd", "batch", "kind", "config", "msg", "quit", "check"], "pos": ["ref", "pid", "part", "doc", "port", "po", "POS", "spec", "Position", "pose", "pro", "i", "off", "def", "position", "pt", "os", "top", " position", "len", "point", "length", "o", " POS", "slot", "add", "count", "row", "no", "start", "size", "loc", "pool", "Pos", "index", "id", "p"], "c": ["f", "rc", "co", "u", "cb", "cn", "comm", "cont", "cr", "enc", "m", "C", "t", "ce", "k", "dc", "cs", "fc", "b", "cu", "v", "e", "ct", "cp", "gc", "jc", "format", "ac", "cm", "l", "ec", "comp", "cod", "ctrl", "lc", "tc", "cd", "r", "nc", "mc", "cf", "p", "cc"], "src": ["ser", "attr", "rc", "txt", "scan", "usr", "sb", "subject", "text", "output", "rt", "dest", "cont", "sys", "bs", "raw", "tmp", "template", "sq", "sr", "filename", "Source", "req", "bin", "url", "uri", "sup", "rs", "target", "SOURCE", "str", "input", "sel", "query", "sc", "st", "ource", "search", "sn", "binary", "href", "string", "config", "dist", "source", "loc", "shell", "inst"], "path": ["exp", "value", "pointer", "port", "base", "PATH", "system", "mount", "pt", "pi", "stat", "form", "kind", "core", "type", "handle", "select", "dest", "cont", "resource", "template", "link", "log", "th", "name", "pc", "target", "sc", "history", "key", "temp", "file", "where", "w", "ref", "entry", "sp", "ath", "trace", "chain", "cp", "url", "input", "api", "parent", "point", "length", "dir", "Path", "root", "host", "prefix", "data", "transform", "image", "prop", "m", "context", "po", "spec", "pkg", "format", "route", "this", "project", "opath", "pattern", "self", "physical", "source", "loc", "patch", "p"], "parameters": ["meter", "temuments", "paramParameters", "muments", "paramuments", "initialuments", "temeters", "meters", "configParameters", "initialeter", "initialeters", "temeter", "configeters", "commandeters", "mParameters", "configeter", "commandeter", "temParameters", "commanduments", "configuments", "parameter"], "foption": ["doptions", "FOption", " foperation", "Foptions", "doption", "goperation", "fOption", "foperation", "goptions", "goption", " fOption", "gOption", " foptions", "Foperation", "dOption", "Foption", "foptions"], "srcFs": ["sourceFS", " srcfs", "sourceOs", "rcOs", "rcFram", "rcFs", "srcFram", "sysFram", " srcFS", "srcfs", " srcDir", "srcDir", "viaFram", " srcSys", " srcRs", "srcOs", "sysFS", " srcOs", "viaSys", "rcSys", " srcFram", "srcSys", "rcFS", "sysOs", "sysfs", "rcDir", "srcFS", "sourcefs", "viaFS", "sysDir", "srcRs", "sysFs", "viaFs", "rcRs", "sysRs", "sysSys", "sourceFs"], "fileSize": ["messageNow", "messageLength", "pageSIZE", "byteLength", "ileTime", "fileSIZE", "fileInfo", "messageSIZE", "FileName", " fileCount", "FileSIZE", "ileLine", "relationName", "viewLength", "relationLength", " filesize", "filesize", "ilesize", "ileSIZE", " fileLine", "pageLength", "relationNow", "messageSize", " fileSIZE", "resourceSIZE", "fileCount", "fileLine", "ileLength", "bufferInfo", "bufferLength", " fileName", " fileTime", "bufferSize", "viewSIZE", "timesize", "FileSize", "FileTime", "pageInfo", "byteName", "resourceSize", "pageSize", "resourceLength", "FileLength", "fileTime", "ileCount", "viewName", "relationSize", "resourceNow", "fileName", "FileLine", "fileLength", " fileLength", "fileNow", "timeCount", "timeSize", "bufferSIZE", "byteSize", "byteSIZE", "timeSIZE", "viewSize", " fileInfo", "relationSIZE", "ileSize"], "offset": ["origin", "empty", "window", "address", "image", "item", "reset", "pointer", "shift", "original", "left", "option", "fp", "set", "page", "port", "offer", "base", "attribute", "buffer", "to", "Offset", " seek", "seek", "number", "off", " offsets", "scroll", "owner", "url", "ptr", "position", "os", "error", "OFF", "out", "total", "order", "encrypted", "seed", "point", "length", "amount", " overhead", "o", "line", "slot", "auto", "padding", "count", "row", "volume", "location", "usage", "start", "size", "loc", "floor", "zero", "index", "from", "end", "prefix"], "in": ["mi", "rin", "inn", "ini", "and", "by", "gin", "con", "min", "IN", "vin", "ins", "reader", "m", "on", "client", "oin", "raw", "sum", "In", "init", "inner", "re", "xml", "up", "i", "read", "bin", "get", "inc", "cm", "l", "out", "input", "pi", "it", " din", "ind", "nin", "add", "r", "ma", "mc", "mm", "info", "io", "din", "is", "isin", "source", "body", "cin", "from", "ex"]}}
{"id1": "22046596", "id2": "21348951", "code1": "        public void copy(File s, File t) throws IOException {\n            FileChannel in = (new FileInputStream(s)).getChannel();\n            FileChannel out = (new FileOutputStream(t)).getChannel();\n            in.transferTo(0, s.length(), out);\n            in.close();\n            out.close();\n        }\n", "code2": "        protected void processAddByURLSubmit(URL url, String invalidUrlMsg) {\n            if (!this.hasError()) {\n                try {\n                    StringWriter xmlSourceWriter = new StringWriter();\n                    IOUtils.copy(url.openStream(), xmlSourceWriter);\n                    processSubmittedDoap(xmlSourceWriter.toString());\n                } catch (FileNotFoundException e) {\n                    Session.get().error(invalidUrlMsg);\n                    logger.warn(\"Error processing URL: \" + invalidUrlMsg);\n                } catch (IOException e) {\n                    setResponsePage(new ErrorReportPage(new UserReportableException(\"Unable to add doap using RDF supplied\", DoapFormPage.class, e)));\n                    logger.warn(\"Error processing URL: \" + url + \"; \" + e.getMessage(), e);\n                }\n            }\n        }\n", "label": 1, "substitutes": {"copy": [" replace", " replicate", " Transfer", " extend", "Copy", "transfer", "write", " restore", " seek", "cp", " share", " copying", " swap", "upload", " rename", " move", " mirror", "paste", " insert", " overwrite", " parallel", " populate", " duplicate", " paste", " dup", " cp", " cop"], "s": ["f", "xs", "ss", "sb", "ses", "p", "z", "ms", "ins", "js", "south", "ws", "fs", "qs", "ls", "ns", "sq", "sl", "b", "ps", "S", "ts", "src", "v", "its", "less", "sv", "ats", "rs", "os", "sf", "l", "input", "ys", "ds", "str", "gs", "st", "g", "n", "sts", "string", "gets", "is", "source", "es", "ies", "cs"], "t": ["f", "txt", "nt", "tr", "j", "rt", "test", "h", "mt", "unt", "kt", "w", "tt", "template", "k", "ts", "v", "i", "ct", "pt", "l", "ent", "it", "gt", "wt", "st", "at", "tc", "g", "o", "ret", "te", "n", "ht", "T", "p", "title", "ot"], "in": ["mi", "rin", "en", "inn", "and", "gin", "con", "ie", "IN", "ins", "im", "ar", "oin", "In", "init", "inside", "inner", "ic", "ai", "up", "i", "bin", "inc", "input", "sin", "iter", "it", " din", "ir", "ind", "info", "io", "din", "inf", "is", "isin", "source", "cin", "user", "from"], "out": ["co", "en", "nt", "j", "by", "con", "output", "res", "cn", "client", "sys", "k", "net", "c", "b", "to", "result", "ot", "up", "v", "i", "ac", "l", "outer", "or", "it", "ch", "gt", "this", "conn", "ou", "outs", "g", "o", "aos", "channel", "n", "io", "msg", "Out", "check", "OUT", "can", "ex", "w"]}}
{"id1": "14001795", "id2": "8047989", "code1": "    public static void copyOverWarFile() {\n        System.out.println(\"Copy Over War File:\");\n        File dir = new File(theAppsDataDir);\n        FileFilter ff = new WildcardFileFilter(\"*.war\");\n        if (dir.listFiles(ff).length == 0) {\n            dir = new File(System.getProperty(\"user.dir\") + \"/war\");\n            if (dir.exists()) {\n                File[] files = dir.listFiles(ff);\n                for (File f : files) {\n                    try {\n                        File newFile = new File(\"\" + theAppsDataDir + \"/\" + f.getName());\n                        System.out.println(\"Creating new file \\\"\" + f.getAbsolutePath() + \"\\\"\");\n                        newFile.createNewFile();\n                        InputStream fi = new FileInputStream(f);\n                        OutputStream fo = new FileOutputStream(newFile);\n                        IOUtils.copy(fi, fo);\n                        moveUnzipAndExtract(newFile);\n                    } catch (Exception ex) {\n                        Logger.getLogger(AppDataDir.class.getName()).log(Level.SEVERE, null, ex);\n                    }\n                }\n            }\n        } else {\n            System.out.println(\"Found a war in the apps data dir, ignoring a fresh copy\");\n        }\n        new JFileChooser().setCurrentDirectory(new File(theAppsDataDir));\n        System.setProperty(\"user.dir\", theAppsDataDir);\n        System.out.println(\"User.dir : \" + System.getProperty(\"user.dir\"));\n    }\n", "code2": "    protected byte[] getHashedID(String ID) {\n        try {\n            MessageDigest md5 = MessageDigest.getInstance(\"MD5\");\n            md5.reset();\n            md5.update(ID.getBytes());\n            byte[] digest = md5.digest();\n            byte[] bytes = new byte[WLDB_ID_SIZE];\n            for (int i = 0; i < bytes.length; i++) {\n                bytes[i] = digest[i];\n            }\n            return bytes;\n        } catch (NoSuchAlgorithmException exception) {\n            System.err.println(\"Java VM is not compatible\");\n            exit();\n            return null;\n        }\n    }\n", "label": 0, "substitutes": {"copyOverWarFile": ["copyoverwarfile", "copyoverWarFile", "copyOverwarFilename", "copyoverWarFilename", "copyoverwarFile", "copyOverwarfile", "copyOverWarfile", "copyoverWarfile", "copyOverWarFilename", "copyoverwarFiles", "copyOverWarFiles", "copyoverwarFilename", "copyOverTarfile", "copyoverWarFiles", "copyOverwarFile", "copyOverTarFilename", "copyOverTarFile", "copyOverTarFiles", "copyOverwarFiles"], "dir": ["window", "good", "div", " directory", "dl", "dial", "res", "vol", "di", "d", "disk", "doc", "tmp", "directory", "md", "del", "addr", "old", "log", "fd", "cur", "dr", "db", "re", "wd", "rel", "dm", "dim", "url", "def", "name", "coll", "out", "iter", " Dir", "dd", "parent", "Dir", "ir", "path", "form", "dat", "cd", "ind", "DIR", "add", "zip", "desc", "local", " d", "mk", "dist", "fin", "file", "folder", "ld", "loc", "dep", "direct", "df"], "ff": ["alf", "buff", "bf", "aft", " eff", "cb", "af", "mt", " cf", "uff", "FF", "fp", "lf", "xff", "ef", "fc", "ffe", "fd", "wind", " af", " aft", "fg", "UFF", "off", " FF", "sf", " ref", "tf", "uf", "cond", "fx", "ck", "fact", " def", "filter", "aff", " df", "iff", "F", "cf", "file", "ld", "ft", "xf", "eff", "df", "fl"], "files": ["forms", "leases", "frames", "ails", "assets", "rows", "parts", "facts", "items", "keys", "plates", "fs", "jobs", "lines", "tests", "les", "ls", "names", "models", "iles", "uploads", "issues", "flows", "styles", "days", "images", "fields", "resources", "members", "objects", "ions", "ports", "balls", "ories", "Files", "features", "values", "file", "mas", "bees", "faces"], "f": ["exp", "alf", "fe", "bf", "d", "h", "a", "m", "fs", "fm", "fp", "col", "fac", "t", "lf", "k", "c", "fc", "b", "fd", "v", "i", "e", "def", "rf", "tf", "sf", "fw", "l", "uf", "elf", "g", "fab", "n", "fa", "F", "cf", "file", "ft", "p", "xf", "fl", "w"], "newFile": [" newFiles", "oldFilename", "newNode", "anotherPlace", "newfile", "anotherFiles", "newPlace", "uniqueNode", "NewNode", "NEWfile", "NewKey", "newsfile", "newFilename", "secureFile", "NEWPage", " newfile", "newKey", "NEWNode", "newsFile", "uniqueFile", "securefile", "anotherFile", "NEWFile", " newPlace", "anotherfile", "secureKey", "NewPlace", "NewPage", "oldfile", " newFilename", "oldFile", "newsKey", "Newfile", "newFiles", "NewFilename", "uniquefile", "uniquePage", "NewFiles", "newPage", "NewFile"], "fi": ["ifa", "mi", "fe", "ini", "bf", "di", "ri", "ki", "fr", "fp", "ti", "iu", "lf", "bi", "fd", "ci", "i", "pi", "sf", "uf", "Fi", "ni", "li", "si", "flo", "afi", "ife", "FI", "fa", "io", "cf", "ii", "isi", "fin", "zi", "phi"], "fo": ["hea", "co", "ko", "tto", "oe", "opa", "tk", "bo", "ow", "ki", "mo", "uo", "ti", "FO", "po", "hi", "ho", "eno", "fam", "oo", "zo", "ph", "jo", "vo", "zz", "eto", "tf", "sf", "ott", "wt", "flo", "oooo", "o", "sty", "te", "wo", "ato", "cf", "tif", "xf"]}}
{"id1": "11475527", "id2": "13981689", "code1": "    void addDataFromURL(URL theurl) {\n        String line;\n        InputStream in = null;\n        try {\n            in = theurl.openStream();\n            BufferedReader data = new BufferedReader(new InputStreamReader(in));\n            while ((line = data.readLine()) != null) {\n                thetext.append(line + \"\\n\");\n            }\n        } catch (Exception e) {\n            System.out.println(e.toString());\n            thetext.append(theurl.toString());\n        }\n        try {\n            in.close();\n        } catch (Exception e) {\n        }\n    }\n", "code2": "    public static String md5Hash(String src) {\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"MD5\");\n            md.update(src.getBytes());\n            return bytesArrayToHexString(md.digest());\n        } catch (Exception e) {\n            return null;\n        }\n    }\n", "label": 0, "substitutes": {"addDataFromURL": ["addTextFromURL", "addTextFormurl", "addDataToLocation", "addDataTourl", "addTextFromLocation", "addDatafromUrl", "addTextFormURL", "addTextFormLocation", "addDataFromLocation", "addDataFormLocation", "addTextFromurl", "addTextFormUrl", "addDataFormurl", "addDatafromURL", "addDatafromurl", "addDataFormUrl", "addDataFormURL", "addDataFromUrl", "addDatafromLocation", "addDataToUrl", "addDataToURL", "addDataFromurl", "addTextFromUrl"], "theurl": ["thUrl", "heloader", "Theuri", "thloader", " theUrl", "teUrl", "heurl", "heuri", "teURL", "theURL", "theloader", "teuri", "thfile", " theloader", "heUrl", "thefile", "thurl", " theURL", " theuri", "TheURL", "theuri", "hefile", "theUrl", "TheUrl", "Theurl", "teurl", " thefile", "heURL"], "line": ["rule", "LINE", "zone", "lin", "block", "text", "eline", "entry", "sample", "ine", "email", "comment", "frame", "lane", "ln", "sequence", "page", "status", "stroke", "day", "char", "code", " inline", "link", "chain", "message", "cell", "ice", "node", "name", "le", "liner", "l", "valid", "lined", "point", "record", "Line", "row", "ner", "string", "inline", "source", "online", "print", "header"], "in": ["f", "lo", "mi", "rin", "en", "include", "win", "inn", "gin", "con", "IN", "ins", "pin", "reader", "oin", "al", "In", "t", "inner", "init", "phys", "open", "old", "ic", "ai", "i", "read", "bin", "ac", "serv", "inc", "l", "out", "input", "or", "proc", "it", "st", "conn", "ain", "again", "o", "r", "ma", "mc", "n", "din", "inf", "is", "isin", "source", "cin", "id", "from"], "data": ["window", "dec", "text", "DATA", "next", "d", "reader", "ata", "client", "raw", "stream", "pipe", "feed", "bus", "buffer", "result", "join", "content", "read", "cache", "def", "writer", "input", "out", "query", "this", "da", "dat", "iterator", "ad", "info", "io", "size", "file", "body", "user", "a"], "e": ["E", "event", "ze", "eeee", "f", "element", "y", "entry", "ine", "ie", "oe", "ee", "d", "h", "es", "se", "m", "t", "x", "ae", "ce", "ve", "be", "me", "ue", "err", "c", "b", "re", "v", "i", "le", "error", "or", "ec", "ele", "g", "o", "ge", "r", "ed", "te", "n", "er", "de", "eu", "p", "a", "ne", "pe", "ex"]}}
{"id1": "10936821", "id2": "8417584", "code1": "    @Override\n    public void doIt() {\n        try {\n            Shared.createBackup(\"articulo precio codigo_de_barras costo movimiento_inventario detalles_movimientos\");\n            if (mode.equals(\"FTP\")) {\n                FTPClient client = new FTPClient();\n                client.connect(Constants.ftpHost);\n                client.login(Constants.ftpUser, Constants.ftpPass);\n                client.changeDirectory(Constants.ftpDir);\n                File ff = new File(Constants.tmpDir + Constants.tmpFtpFileName);\n                client.download(\"GT99_A09.rar\", ff);\n                client.disconnect(false);\n                Shared.prepareMovements(ff);\n            } else if (mode.equals(\"File\")) {\n                JFileChooser jfc = new JFileChooser();\n                FileFilter f = new ExtensionFileFilter(\"Traslados de Total Pos\", \"rar\");\n                jfc.setFileFilter(f);\n                int selection = jfc.showOpenDialog(Shared.getMyMainWindows());\n                if (selection == JFileChooser.APPROVE_OPTION) {\n                    Shared.prepareMovements(jfc.getSelectedFile());\n                } else {\n                    return;\n                }\n            }\n            Shared.updateMovements();\n            if (Shared.isHadMovements()) {\n                MessageBox msg = new MessageBox(MessageBox.SGN_SUCCESS, \"Fue cargado el nuevo inventario satisfactoriamente!\");\n                msg.show(Shared.getMyMainWindows());\n            } else {\n                MessageBox msg = new MessageBox(MessageBox.SGN_WARNING, \"La tienda no tuvo ningun movimiento asociado.\");\n                msg.show(Shared.getMyMainWindows());\n            }\n        } catch (Exception ex) {\n            MessageBox msg = new MessageBox(MessageBox.SGN_DANGER, \"Ha ocurrido un error.\", ex);\n            msg.show(Shared.getMyMainWindows());\n        }\n    }\n", "code2": "    private String getResultFromHttpUrl(String href) {\n        String result = null;\n        try {\n            URL url = new URL(href);\n            HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n            Object o = conn.getContent();\n            log.debug(\"Opened \" + href + \" and got class \" + o.getClass().getName());\n            StringBuffer version = new StringBuffer();\n            String inputLine;\n            DataInputStream dis = new DataInputStream(conn.getInputStream());\n            while ((inputLine = dis.readLine()) != null) {\n                version.append(inputLine + \"\\n\");\n            }\n            result = version.toString();\n            log.debug(\"Read from URL:\\n\" + result);\n            dis.close();\n        } catch (Exception e) {\n            log.debug(\"Caught exception \" + e + \" whilst attempting to query URL \" + href);\n            e.printStackTrace();\n        } finally {\n            return result;\n        }\n    }\n", "label": 0, "substitutes": {"doIt": ["doWhat", "DoWhatever", "DoIt", "DoWhat", "makeWhatever", " doWhatever", " doThis", "DoThis", "doWhatever", "makeThis", "makeWhat", " doWhat", "makeIt", "doThis"], "client": ["co", "cloud", "response", "google", "dial", "con", "quick", "util", "console", "contact", "service", "resource", "utils", "Client", "force", "web", "connection", "template", "net", "secure", "cli", "to", "open", "call", "cell", "close", "ct", "cache", "url", "lib", "phone", "cm", "simple", "api", "cmd", "parent", "conn", "network", "connect", "ssl", "channel", "local", "pattern", "key", "http", "remote", "socket", "core", "control", "pool", "wrapper", "server", "cc", "cl"], "ff": ["fi", "alf", "buff", "bf", "cb", "af", "pp", "uff", "FF", "fm", "fp", "lf", "ffer", "xff", "ef", "fc", "fd", " fid", "ph", "fg", "off", "nd", "uf", "sf", "tf", "fx", "fo", "dd", "ck", "fact", "aff", "cf", "ft", "tif", "eff", "df", "aft", "cl"], "jfc": ["Jcf", "tcf", "jsfc", "qfc", "qFC", " jlc", "npc", "qcf", "jcf", "lfc", "jpc", "Jmc", "jsFC", "nfc", " jvc", "lvc", " jmc", " jFC", "ffc", "Jfc", "jFC", "fcf", "qpc", "tfc", "lcf", "jvc", "ncf", "flc", "llc", "tpc", "tFC", "jmc", " jcf", "JFC", " jpc", "Jpc", "nFC", "jlc", "fvc", "jsmc", "jspc"], "f": ["fi", "bf", "h", "m", "fs", "lf", "t", "c", "ef", "fc", "fd", "b", "only", "v", "i", "e", "fg", "rf", "tf", "sf", "l", "fx", "fo", "g", "fab", "fa", "F", "cf", "inf", "file", "p", "xf", "df", "w"], "selection": ["selected", "ion", "ing", "ification", "SELECT", "select", " Selection", "which", "opening", "wa", "connection", " selected", "elect", "soc", "icing", "finding", "state", "position", "sel", "choice", "pling", "search", "security", "focus", "lection", "ION", " selecting", "xxx", "slot", "something", "location", "sea", "election", "binding", "where", "reading", "from"], "msg": ["gent", "txt", "nm", "sm", "notice", "ms", "irm", "cmp", "bg", "comm", "task", "comment", "summary", "doc", "sys", "sum", "mess", "init", "mem", "sg", "mg", "md", "log", "pkg", "wx", "resp", "message", "Msg", "conf", "dm", "crit", "str", "alg", "gm", "cmd", "mu", "cal", "mail", "gs", "ck", "news", "mb", "g", "og", "cfg", "mn", "desc", "info", "gr", "html", "mk", "body", "map", "print"]}}
{"id1": "8747840", "id2": "5977352", "code1": "    public static void copy(File src, File dest) throws FileNotFoundException, IOException {\n        FileInputStream in = new FileInputStream(src);\n        FileOutputStream out = new FileOutputStream(dest);\n        try {\n            byte[] buf = new byte[1024];\n            int c = -1;\n            while ((c = in.read(buf)) > 0) out.write(buf, 0, c);\n        } finally {\n            in.close();\n            out.close();\n        }\n    }\n", "code2": "    public static void copyFile(File src, File dest, int bufSize, boolean force) throws IOException {\n        if (dest.exists()) if (force) dest.delete(); else throw new IOException(\"Cannot overwrite existing file: \" + dest.getName());\n        byte[] buffer = new byte[bufSize];\n        int read = 0;\n        InputStream in = null;\n        OutputStream out = null;\n        try {\n            in = new FileInputStream(src);\n            out = new FileOutputStream(dest);\n            while (true) {\n                read = in.read(buffer);\n                if (read == -1) break;\n                out.write(buffer, 0, read);\n            }\n        } finally {\n            if (in != null) try {\n                in.close();\n            } finally {\n                if (out != null) out.close();\n            }\n        }\n    }\n", "label": 1, "substitutes": {"copy": ["csv", "cat", " replicate", "sync", "create", " Copy", "link", "transfer", "Copy", "write", "slice", "delete", "load", "cp", "gc", "read", " copying", "upload", " mirror", "paste", "add", "download", "save", "clip", "clone", "map", " cp", "move"], "src": ["ser", "rc", "via", "txt", "usr", "sb", "img", "sit", "ins", "cont", "sur", "sys", "bs", "init", "urg", "sq", "pkg", "ctr", "cur", "sr", "rel", "Source", "req", "sec", "rs", "sf", "input", "sin", "rx", "sc", "st", "obs", "iv", "syn", "start", "source", "ipl", "inst", "from"], "dest": ["origin", "decl", "good", "nt", "usr", "pub", "orig", "pas", "test", "sit", "d", "cont", "way", "trans", "https", "est", "tmp", "spec", "rest", "del", "th", "master", "opt", "req", "target", "des", "gt", "st", "null", "nom", "self", "mm", "nw", "Dest", "dist", "mk", "temp", "source", "loc", "deg", "end"], "in": ["ze", "rc", "rin", "en", "inn", "con", "gin", "IN", "ins", "im", "ar", "ln", "on", "al", "In", "init", "inner", "inside", "old", "ic", "impl", "ai", "up", "i", "bin", "inc", "input", "iter", "it", "ain", "ind", "mm", "info", "din", "inf", "isin", "source", "cin", "id", "from"], "out": ["co", "en", "nt", "by", "con", "output", "res", "oss", "obj", "on", "client", "sys", "sum", "not", "t", "inner", "dis", "conv", "net", "write", "err", "to", "end", "ot", "over", "bin", "writer", "os", "outer", "it", "ch", "gt", "conn", "at", "ou", "aos", "g", "o", "outs", "auto", "n", "io", "Out", "OUT", "p", "can", "ne", "ex"], "buf": ["seq", "good", "cv", "block", "br", "buff", "prop", "cat", "ref", "bl", "cam", "cb", "bh", "bs", "bed", "col", "conv", "box", "bus", "buffer", "pkg", "bag", "b", "log", "used", "db", "aka", "fg", "Buffer", "uf", "rb", "str", "tab", "data", "cmd", "mu", "queue", "mb", "batch", "stab", "bar", "Buff", "cap", "msg", "temp", "arr", "fb", "vec", "bytes", "gen"], "c": ["co", "rc", "dec", "z", "cos", "cb", "d", "cont", "cr", "m", "C", "bc", "t", "ce", "cc", "code", "k", "ca", "fc", "b", "ci", "cu", "call", "conf", "i", "ct", "cache", "ac", "jc", "gc", "cm", "cp", "l", "ec", "cod", "ch", "lc", "cd", " C", "unc", "nc", "count", "n", "mc", "uc", "cf", "dc", "a", "cs"]}}
{"id1": "16931472", "id2": "12172485", "code1": "    public void handler(Map<String, String> result, TargetPage target) {\n        try {\n            URL url = new URL(target.getUrl());\n            BufferedReader reader = new BufferedReader(new InputStreamReader(url.openStream()));\n            String line = null;\n            while ((line = reader.readLine()) != null) {\n                for (Map.Entry<String, String> entry : result.entrySet()) {\n                    if (line.indexOf(target.getInclude()) != -1) {\n                        int fromIndex = line.indexOf(target.getFromStr());\n                        String r = line.substring(fromIndex + target.getFromStr().length(), line.indexOf(target.getToStr(), fromIndex));\n                        entry.setValue(r);\n                        line = line.substring(line.indexOf(target.getToStr()) + target.getToStr().length());\n                    }\n                }\n            }\n            reader.close();\n        } catch (MalformedURLException e) {\n        } catch (IOException e) {\n        }\n    }\n", "code2": "    public static boolean decodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.DECODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "label": 0, "substitutes": {"handler": ["transform", "handle", "output", "Handler", "forward", "callback", "request", "execute", "processor", "processing", "init", "accept", "done", "action", "Handle", "adapt", "read", "success", "proc", "controller", "handled", "hook", "received", "index", "update", "end", "render"], "result": ["all", "report", "response", "product", "res", "output", "RESULTS", "mate", "details", "sequence", "status", "page", "table", "met", "done", "profile", "buffer", "master", "current", "list", "cache", "successful", "success", "complete", "total", "out", "valid", "hash", "created", "found", "full", "ret", "make", "source", "memory", "map", "data", "results", "Result"], "target": ["window", "expected", "output", "test", "next", "internal", "page", "t", "base", "to", "primary", "detail", "node", "top", "iter", "it", "gt", "term", "info", "jp", "bolt", "arget", "tif", "arg", "type", "handle", "subject", "that", "alias", "dest", "service", "thread", "tool", "template", "link", "buffer", "Target", "name", "tree", "controller", "cmd", "history", "prototype", "local", "manager", "http", "version", "report", "layout", "goal", "view", "table", "trace", "scope", "master", "e", "complete", "external", "parent", "object", "component", "peer", "proxy", "transform", "style", "closure", "match", "task", "pkg", "format", "valid", "this", "project", "self", "trigger", "remote", "source", "translation"], "url": ["f", "browser", "hl", "address", "git", "dl", "service", "client", "bel", "ls", "web", "ll", "base", "connection", "char", "link", "build", "sl", "cert", "impl", "lr", "rel", "ur", "mount", "uri", "URL", "rl", "l", "nl", "ul", "mail", "hub", "ssl", "el", "http", "html", "file", "loc", "Url", "loader"], "reader": ["runner", "rar", "linger", "and", "layer", "parser", "driver", "resource", "builder", "ro", "stream", "context", "inner", "Reader", "buffer", "redo", "readable", "cur", "review", "read", "uri", "writer", "liner", "rl", "operator", "rr", "iter", "rot", "upper", "iterator", "row", "ner", "er", "file", "reading", "older", "loader"], "line": ["rule", "LINE", "lo", "style", "zone", "block", "lock", "lin", "text", "eline", "sample", "ine", "email", "next", "word", "frame", "comment", "ln", "sequence", "lines", "status", "page", "port", "trace", "limit", "base", "chain", "range", "link", "log", "buffer", "date", "code", "message", "cell", "detail", "stay", "node", "state", "le", "now", "liner", "entity", "l", "out", "section", "iter", "nl", "level", "point", "continue", "queue", "network", "Line", "ip", "row", "string", "no", "inline", "file", "online", "source", "body", "user", "loop", "store", "print"], "entry": ["pair", "element", "match", "ie", "deep", "quick", "part", "comment", "se", "office", "inner", "char", "cell", "list", "e", "def", "ace", "or", "ary", "ent", "ry", "it", "exit", "search", "object", "term", "enter", "record", "instance", "add", "member", "Entry", "row", "key", "pixel", "job", "field", "check", "escape", "ex"], "fromIndex": ["fromindex", "oldLink", "forindex", "FromInd", "leftindex", "forIndex", "forPosition", "FromLink", "minindex", "fromLink", "oldIndex", "normalInt", "fromPosition", "normalindex", " fromInd", "fromInd", "FromAlpha", "normalInd", " fromLink", "minInd", "FromIndex", "forInd", " fromAlpha", "normalIndex", "fromAlpha", "fromInt", "minInt", " fromInt", " fromPosition", "leftInd", "oldAlpha", "leftIndex", " fromindex", "oldInd", "leftPosition", "minIndex"], "r": ["rar", "rc", "u", "rt", "res", "mr", "rg", "ar", "cr", "R", "m", "kr", "fr", "q", "range", "err", "b", "sr", "dr", "re", "v", "rd", "e", "rs", "rr", "rb", "l", "str", "rate", "rect", "g", "nr", "n", "vr", "er", "render", "p", "w"]}}
{"id1": "838844", "id2": "18211588", "code1": "    public void convert(File src, File dest) throws IOException {\n        InputStream in = new BufferedInputStream(new FileInputStream(src));\n        DcmParser p = pfact.newDcmParser(in);\n        Dataset ds = fact.newDataset();\n        p.setDcmHandler(ds.getDcmHandler());\n        try {\n            FileFormat format = p.detectFileFormat();\n            if (format != FileFormat.ACRNEMA_STREAM) {\n                System.out.println(\"\\n\" + src + \": not an ACRNEMA stream!\");\n                return;\n            }\n            p.parseDcmFile(format, Tags.PixelData);\n            if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) {\n                System.out.println(\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n                return;\n            }\n            boolean hasPixelData = p.getReadTag() == Tags.PixelData;\n            boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12;\n            int pxlen = p.getReadLength();\n            if (hasPixelData) {\n                if (inflate) {\n                    ds.putUS(Tags.BitsAllocated, 16);\n                    pxlen = pxlen * 4 / 3;\n                }\n                if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) {\n                    System.out.println(\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                    return;\n                }\n            }\n            ds.putUI(Tags.StudyInstanceUID, uid(studyUID));\n            ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID));\n            ds.putUI(Tags.SOPInstanceUID, uid(instUID));\n            ds.putUI(Tags.SOPClassUID, classUID);\n            if (!ds.contains(Tags.NumberOfSamples)) {\n                ds.putUS(Tags.NumberOfSamples, 1);\n            }\n            if (!ds.contains(Tags.PhotometricInterpretation)) {\n                ds.putCS(Tags.PhotometricInterpretation, \"MONOCHROME2\");\n            }\n            if (fmi) {\n                ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian));\n            }\n            OutputStream out = new BufferedOutputStream(new FileOutputStream(dest));\n            try {\n            } finally {\n                ds.writeFile(out, encodeParam());\n                if (hasPixelData) {\n                    if (!skipGroupLen) {\n                        out.write(PXDATA_GROUPLEN);\n                        int grlen = pxlen + 8;\n                        out.write((byte) grlen);\n                        out.write((byte) (grlen >> 8));\n                        out.write((byte) (grlen >> 16));\n                        out.write((byte) (grlen >> 24));\n                    }\n                    out.write(PXDATA_TAG);\n                    out.write((byte) pxlen);\n                    out.write((byte) (pxlen >> 8));\n                    out.write((byte) (pxlen >> 16));\n                    out.write((byte) (pxlen >> 24));\n                }\n                if (inflate) {\n                    int b2, b3;\n                    for (; pxlen > 0; pxlen -= 3) {\n                        out.write(in.read());\n                        b2 = in.read();\n                        b3 = in.read();\n                        out.write(b2 & 0x0f);\n                        out.write(b2 >> 4 | ((b3 & 0x0f) << 4));\n                        out.write(b3 >> 4);\n                    }\n                } else {\n                    for (; pxlen > 0; --pxlen) {\n                        out.write(in.read());\n                    }\n                }\n                out.close();\n            }\n            System.out.print('.');\n        } finally {\n            in.close();\n        }\n    }\n", "code2": "    public static boolean copyTextFile(File src, File dst) {\n        try {\n            BufferedInputStream bis = new BufferedInputStream(new FileInputStream(src));\n            BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(dst));\n            byte[] buf = new byte[1024];\n            int readsize = 0;\n            while ((readsize = bis.read(buf)) != -1) {\n                bos.write(buf, 0, readsize);\n            }\n            bos.flush();\n            bos.close();\n            bis.close();\n        } catch (IOException e) {\n            ServerConsoleServlet.printSystemLog(e.toString() + \" \" + e.getMessage(), ServerConsoleServlet.LOG_ERROR);\n            return false;\n        }\n        return true;\n    }\n", "label": 1, "substitutes": {"convert": ["Converting", "compvert", "converts", "unverted", "consvert", "Conprocess", "CONversion", "converted", "Conversion", "unprocess", "confer", "unfer", "Confer", "unvert", "unverts", "compverts", "ConVERT", "Converted", "CONvert", "conversion", "conprocess", "CONfer", "Convert", "CONverted", "unversion", "compversion", "compprocess", "consversion", "converting", "CONverting", "consVERT", "consverting", "conVERT", "CONVERT", "Converts"], "src": ["ser", "buster", "rc", "txt", "hl", "scan", "usr", "attr", "img", "orig", "func", "ins", "sit", "cont", "sys", "stream", "SourceFile", "sq", "addr", "rest", "pkg", "cur", "sr", "rel", "filename", "ur", "Source", "its", "req", "url", "uri", "RC", "rs", "str", "SOURCE", "inst", "input", "upload", "sin", "rx", "sc", "st", "path", "ource", "s", "iv", "scene", "href", "http", "config", "dist", "start", "file", "source", "loc", "ipl", "ebin", "from", "host", "cc"], "dest": ["txt", "img", " destinations", "gin", "orig", "test", "disk", "est", "table", "port", "rest", "write", " Dest", "result", " dst", "mat", "target", "foreign", " orig", " destination", "dir", "dat", "Dest", "dist", "temp", " Destination", "source", "tif"], "in": ["en", "rin", "inn", "res", "IN", "ins", "d", "ar", "reader", "m", "stream", "In", "inner", "b", "up", "i", "bin", "serv", "l", "input", "sql", "st", "ind", "r", "el", "ad", "io", "din", "inf", "is", "isin", "source", "as", "file", "cin", "from"], "p": ["f", "php", "pa", "pb", "dp", "j", "pd", "tp", "rep", "vp", "sp", "d", "py", "parser", "part", "h", "op", "pp", "m", "fp", "t", "pl", "c", "pkg", "b", "pg", "ps", "ping", "post", "pro", "i", "cp", "ph", "pc", "pt", "pi", "l", "it", "per", "parse", "P", "pers", "at", "lp", "pre", "g", "r", "jp", "pm", "er", "wp", "prot", "pe", "ap"], "ds": ["dates", "dp", "di", " ads", "scripts", "loads", "yes", "qs", "tests", "ns", "ps", "drivers", "db", "dds", "sd", "ats", "dt", " DS", "ports", "ras", "terms", "ss", "DS", "ws", "bs", "docs", "hs", "workers", "iffs", "lists", "os", "edes", "gs", " dd", "hd", "vs", " d", "uds", "ils", "eds", "xs", "tags", "Ds", "dl", "els", "sets", "gd", "ls", "ts", "ags", "rs", " des", "obs", "s", "outs", "ods", "sts", "posts", "ands", "tes", "cs", "amps", "dos", "ads", "pd", "tp", "mys", "d", "cks", "js", " os", "its", "aws", "ys", "des", "eps", "dd", "ks", "points", "df", "nas", "dh"], "format": ["type", "f", "style", "layout", "settings", "output", "policy", "MAT", "feature", "mt", "fm", "set", "status", "table", "tag", "t", "feat", " Format", "module", "template", "sche", "spec", "fc", "shape", "mode", "Format", "ct", "act", "mat", "name", "ats", "pi", "top", "l", "it", "parse", "form", "path", "at", "filter", "lat", "pattern", "id", "cf", "file", "source", "size", "unit", "version", "pretty", "title"], "hasPixelData": ["HaspixelDATA", "hasixelData", "hasPixelDATA", "Haspixeldata", "hasPixeldata", "HasPixelDATA", "HaspixelData", "hasFrameData", "hasFrameDATA", "haspixelDATA", "hasFramedata", "HasPixeldata", "haspixeldata", " hasPixelDATA", " hasPixeldata", "hasixeldata", "hasixelDATA", "HasPixelData", "haspixelData"], "inflate": ["inFLated", "Inflate", "invalidATE", "inFLat", "inFLocate", "incelate", " invalidicate", "infolat", "Inflat", "invalidate", "inFlicate", "inflATE", "inflated", "incelicate", " inflocate", "incelocate", "Informocate", "Informated", "incelATE", "inFlATE", " inflicate", "inFlate", " invalidate", "informat", "infolated", "Inflocate", "inflicate", "inFlocate", "infolocate", "informocate", "informate", "Informat", "invalidicate", "Inflated", " inflATE", "inflocate", "informated", "Informate", "inFLate", "invalidocate", " invalidATE", "inflat", " invalidocate", "infolate"], "pxlen": ["pxln", "mmlin", "packlen", "pxlength", "cpln", "xplength", "cplength", "phpln", "pixellength", "pxlin", "cpden", "mxlength", "cplen", "packlength", "pexlength", "xylen", "mmlen", "pxdec", "tmpln", "packdec", "phplength", "pexln", "mxdec", "packfun", "pexls", "mxlen", "pxls", "pxfun", "xylin", "xyln", "tmplin", "xpden", "mxln", "tmplen", "pexlen", "pxden", "phplen", "pexfun", "mmlength", "pixelfun", "packls", "xpln", "phpdec", "pixells", "pexden", "tmplength", "xplen", "packln", "mmln", "pixellen", "xylength"], "out": ["output", "res", "obj", "ln", "client", "sys", "sum", "inter", "init", "net", "log", "print", "err", "list", "up", "crit", "name", "writer", "outer", "cmd", "conn", "gov", "ou", "group", "aos", "outs", "dir", "cfg", "inv", "screen", "gr", "io", "msg", "temp", "Out", "OUT", "user", "store", "pretty", "prefix", "ex"]}}
{"id1": "11475527", "id2": "9327525", "code1": "    void addDataFromURL(URL theurl) {\n        String line;\n        InputStream in = null;\n        try {\n            in = theurl.openStream();\n            BufferedReader data = new BufferedReader(new InputStreamReader(in));\n            while ((line = data.readLine()) != null) {\n                thetext.append(line + \"\\n\");\n            }\n        } catch (Exception e) {\n            System.out.println(e.toString());\n            thetext.append(theurl.toString());\n        }\n        try {\n            in.close();\n        } catch (Exception e) {\n        }\n    }\n", "code2": "    @Test\n    public void test02_ok() throws Exception {\n        DefaultHttpClient client = new DefaultHttpClient();\n        try {\n            HttpPost post = new HttpPost(chartURL);\n            List<NameValuePair> nameValuePairs = new ArrayList<NameValuePair>(1);\n            nameValuePairs.add(new BasicNameValuePair(\"ws\", \"getDomainEvolution\"));\n            nameValuePairs.add(new BasicNameValuePair(\"chartTitle\", \"test\"));\n            nameValuePairs.add(new BasicNameValuePair(\"type\", \"chart\"));\n            nameValuePairs.add(new BasicNameValuePair(\"firstDate\", \"20111124\"));\n            nameValuePairs.add(new BasicNameValuePair(\"lastDate\", \"20111125\"));\n            nameValuePairs.add(new BasicNameValuePair(\"wsParams\", \"type,counting,protocol,unit,proxy,domain,timeScale,period\"));\n            nameValuePairs.add(new BasicNameValuePair(\"wsParamsValues\", \"chart,volume,all,hits,all,google.com,day,360\"));\n            nameValuePairs.add(new BasicNameValuePair(\"serieTitle\", \"serie\"));\n            post.setEntity(new UrlEncodedFormEntity(nameValuePairs));\n            HttpResponse response = client.execute(post);\n            HttpEntity entity = response.getEntity();\n            assertNotNull(entity);\n            InputStream instream = entity.getContent();\n            BufferedReader reader = new BufferedReader(new InputStreamReader(instream));\n            System.out.println(reader.readLine());\n            instream.close();\n            assertEquals(\"error :\" + response.getStatusLine(), 200, response.getStatusLine().getStatusCode());\n        } finally {\n            client.getConnectionManager().shutdown();\n        }\n    }\n", "label": 0, "substitutes": {"addDataFromURL": ["addTextFromURL", "addTextFormurl", "addDataToLocation", "addDataTourl", "addTextFromLocation", "addDatafromUrl", "addTextFormURL", "addTextFormLocation", "addDataFromLocation", "addDataFormLocation", "addTextFromurl", "addTextFormUrl", "addDataFormurl", "addDatafromURL", "addDatafromurl", "addDataFormUrl", "addDataFormURL", "addDataFromUrl", "addDatafromLocation", "addDataToUrl", "addDataToURL", "addDataFromurl", "addTextFromUrl"], "theurl": ["thUrl", "heloader", "Theuri", "thloader", " theUrl", "teUrl", "heurl", "heuri", "teURL", "theURL", "theloader", "teuri", "thfile", " theloader", "heUrl", "thefile", "thurl", " theURL", " theuri", "TheURL", "theuri", "hefile", "theUrl", "TheUrl", "Theurl", "teurl", " thefile", "heURL"], "line": ["rule", "LINE", "zone", "lin", "block", "text", "eline", "entry", "sample", "ine", "email", "comment", "frame", "lane", "ln", "sequence", "page", "status", "stroke", "day", "char", "code", " inline", "link", "chain", "message", "cell", "ice", "node", "name", "le", "liner", "l", "valid", "lined", "point", "record", "Line", "row", "ner", "string", "inline", "source", "online", "print", "header"], "in": ["f", "lo", "mi", "rin", "en", "include", "win", "inn", "gin", "con", "IN", "ins", "pin", "reader", "oin", "al", "In", "t", "inner", "init", "phys", "open", "old", "ic", "ai", "i", "read", "bin", "ac", "serv", "inc", "l", "out", "input", "or", "proc", "it", "st", "conn", "ain", "again", "o", "r", "ma", "mc", "n", "din", "inf", "is", "isin", "source", "cin", "id", "from"], "data": ["window", "dec", "text", "DATA", "next", "d", "reader", "ata", "client", "raw", "stream", "pipe", "feed", "bus", "buffer", "result", "join", "content", "read", "cache", "def", "writer", "input", "out", "query", "this", "da", "dat", "iterator", "ad", "info", "io", "size", "file", "body", "user", "a"], "e": ["E", "event", "ze", "eeee", "f", "element", "y", "entry", "ine", "ie", "oe", "ee", "d", "h", "es", "se", "m", "t", "x", "ae", "ce", "ve", "be", "me", "ue", "err", "c", "b", "re", "v", "i", "le", "error", "or", "ec", "ele", "g", "o", "ge", "r", "ed", "te", "n", "er", "de", "eu", "p", "a", "ne", "pe", "ex"]}}
{"id1": "17791385", "id2": "5125848", "code1": "    public static void copyFile(File src, File dst) throws IOException {\n        InputStream in = new FileInputStream(src);\n        OutputStream out = new FileOutputStream(dst);\n        byte[] buf = new byte[1024];\n        int len;\n        while ((len = in.read(buf)) > 0) out.write(buf, 0, len);\n        in.close();\n        out.close();\n    }\n", "code2": "    @SuppressWarnings({ \"ResultOfMethodCallIgnored\" })\n    public static Node combineJs(URL base, List<Node> linkJs, List<File> newFiles) throws IOException {\n        File dir = File.createTempFile(\"javascript\", \"\" + System.currentTimeMillis());\n        StringBuilder name = new StringBuilder();\n        try {\n            if (dir.delete() && dir.mkdirs()) {\n                File minDir = new File(dir, \"min\");\n                minDir.mkdir();\n                File combineFile = new File(minDir, \"script.js\");\n                File concatFile = new File(minDir, \"concat.js\");\n                Writer combineWriter = new FileWriter(combineFile);\n                Writer concatWriter = new FileWriter(concatFile);\n                final List<Boolean> fails = new LinkedList<Boolean>();\n                boolean first = true;\n                for (Node link : linkJs) {\n                    String path = ((Element) link).getAttribute(\"src\");\n                    URL url = new URL(buildUrl(base, path));\n                    InputStream inputStream = url.openStream();\n                    File jsFile = new File(dir, fileName(url));\n                    FileOutputStream outputStream = new FileOutputStream(jsFile);\n                    IOUtils.copy(inputStream, outputStream);\n                    outputStream.close();\n                    inputStream.close();\n                    if (!first) {\n                        combineWriter.write(\"\\n;\\n\");\n                        concatWriter.write(\"\\n;\\n\");\n                    } else {\n                        first = false;\n                    }\n                    if (Configuration.jsMinification()) {\n                        Reader reader = new FileReader(jsFile);\n                        try {\n                            JavaScriptCompressor jsCompressor = new JavaScriptCompressor(reader, new ErrorReporter() {\n\n                                @Override\n                                public void warning(String s, String s1, int i, String s2, int i1) {\n                                    fails.add(true);\n                                }\n\n                                @Override\n                                public void error(String s, String s1, int i, String s2, int i1) {\n                                    fails.add(true);\n                                }\n\n                                @Override\n                                public EvaluatorException runtimeError(String s, String s1, int i, String s2, int i1) {\n                                    fails.add(true);\n                                    return null;\n                                }\n                            });\n                            jsCompressor.compress(combineWriter, 0, false, false, true, true);\n                        } catch (Exception e) {\n                            fails.add(true);\n                        }\n                        reader.close();\n                    }\n                    Reader reader = new FileReader(jsFile);\n                    IOUtils.copy(reader, concatWriter);\n                    reader.close();\n                    String fileName = jsFile.getName();\n                    int pos = fileName.lastIndexOf('.');\n                    if (pos >= 0) {\n                        fileName = fileName.substring(0, pos);\n                    }\n                    name.append(fileName).append(\",\");\n                }\n                combineWriter.close();\n                concatWriter.close();\n                FileReader reader;\n                if (fails.size() == 0 && Configuration.jsMinification()) {\n                    reader = new FileReader(combineFile);\n                } else {\n                    reader = new FileReader(concatFile);\n                }\n                name.append(hashCode(IOUtils.toString(reader))).append(\".js\");\n                reader.close();\n                File targetFile = new File(Configuration.getJsLocalDir(), name.toString());\n                if (!targetFile.exists()) {\n                    targetFile.getParentFile().mkdirs();\n                    if (fails.size() == 0 && Configuration.jsMinification()) {\n                        FileUtils.copyFile(combineFile, targetFile);\n                    } else {\n                        FileUtils.copyFile(concatFile, targetFile);\n                    }\n                    newFiles.add(targetFile);\n                    logger.info(\"Combined several js files into the single \" + targetFile + \" [size=\" + targetFile.length() + \"].\");\n                }\n            }\n        } finally {\n            FileUtils.deleteQuietly(dir);\n        }\n        if (name.length() != 0) {\n            Element element = (Element) linkJs.get(0);\n            element.setAttribute(\"src\", Configuration.getJsUrlPrefix() + name.toString());\n            return element;\n        } else {\n            return null;\n        }\n    }\n", "label": 1, "substitutes": {"copyFile": [" cpfile", "cloneResource", "copyFiles", " copyfile", "copyResource", "cloneFile", " cpFile", "clonefile", " cpResource", "cloneFiles", "copyfile", " copyFiles", " cpFiles", " copyResource"], "src": ["ser", "rc", "via", "txt", "usr", "sb", "sit", "ins", "cont", "sur", "ux", "sys", "bs", "init", "sq", "ctr", "cur", "sr", "usc", "rel", "req", "Source", "sec", "rs", "rl", "sf", "sel", "input", "sin", "ys", "sc", "rx", "st", "ck", "obs", "iv", "start", "source", "ipl", "inst", "from"], "dst": ["ddnt", "dnd", "Ddest", "ddest", "snt", "ddst", "dddest", "wst", "Dnd", " ddest", " dnd", "Dst", "Dnt", "sdest", "snd", "wnd", "wdest", "dth", " dth", "wth", "ddnd", "sst", "dnt", "Dth"], "in": ["ze", "en", "rin", "inn", "con", "min", "gin", "IN", "ins", "im", "ar", "ln", "on", "oin", "al", "In", "init", "inner", "inside", "ic", "ai", "up", "i", "act", "bin", "inc", "input", "sin", "iter", "it", "st", "ain", "ind", "mm", "info", "din", "inf", "is", "isin", "source", "cin", "rec", "from"], "out": ["co", "nt", "and", "by", "con", "output", "res", "oe", "oss", "cn", "obj", "on", "client", "sys", "sum", "conv", "t", "inner", "dis", "po", "net", "write", "to", "up", "bin", "writer", "os", "outer", "it", "gt", "st", "ou", "at", "g", "o", "outs", "aos", "ex", "auto", "n", "io", "Out", "OUT", "can", "ne", "ot"], "buf": ["seq", "good", "cv", "block", "br", "buff", "var", "cat", "prop", "tx", "cam", "cb", "bh", "bed", "conv", "box", "bus", "pl", "buffer", "pkg", "bag", "b", "log", "cur", "db", "aka", "cp", "Buffer", "uf", "tab", "cmd", "mu", "ck", "norm", "batch", "stab", "bar", "Buff", "cap", "msg", "cf", "arr", "fb", "vec", "bytes", "gen"], "len": ["seq", "exp", "all", "en", "nt", "wid", "z", "dl", "vol", "cmp", "h", "ln", "lic", "ls", "ll", "t", "lf", "lan", "rel", "v", "e", "lib", "le", "str", "coll", "l", "pos", "fun", "val", "length", "lon", "ren", "el", "num", "count", "n", "L", "cap", "lim", "no", "Len", "fin", "ld", "compl", "il", "size", "loc", "elt", "end", "fl"]}}
{"id1": "16550855", "id2": "3197876", "code1": "    public String readPage(boolean ignoreComments) throws Exception {\n        BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream()));\n        String inputLine;\n        String html = \"\";\n        if (ignoreComments) {\n            while ((inputLine = in.readLine()) != null) {\n                if (inputLine.length() > 0) {\n                    if (inputLine.substring(0, 1).compareTo(\"#\") != 0) {\n                        html = html + inputLine + \"\\n\";\n                    }\n                }\n            }\n        } else {\n            while ((inputLine = in.readLine()) != null) {\n                html = html + inputLine + \"\\n\";\n            }\n        }\n        in.close();\n        return html;\n    }\n", "code2": "    public ArrayList<String> showTopLetters() {\n        int[] tempArray = new int[engCountLetters.length];\n        char[] tempArrayLetters = new char[abcEng.length];\n        ArrayList<String> resultTopFiveLetters = new ArrayList<String>();\n        tempArray = engCountLetters.clone();\n        tempArrayLetters = abcEng.clone();\n        int tempCount;\n        char tempLetters;\n        for (int j = 0; j < (abcEng.length * abcEng.length); j++) {\n            for (int i = 0; i < abcEng.length - 1; i++) {\n                if (tempArray[i] > tempArray[i + 1]) {\n                    tempCount = tempArray[i];\n                    tempLetters = tempArrayLetters[i];\n                    tempArray[i] = tempArray[i + 1];\n                    tempArrayLetters[i] = tempArrayLetters[i + 1];\n                    tempArray[i + 1] = tempCount;\n                    tempArrayLetters[i + 1] = tempLetters;\n                }\n            }\n        }\n        for (int i = tempArrayLetters.length - 1; i > tempArrayLetters.length - 6; i--) {\n            resultTopFiveLetters.add(tempArrayLetters[i] + \":\" + tempArray[i]);\n        }\n        return resultTopFiveLetters;\n    }\n", "label": 0, "substitutes": {"readPage": ["printArticle", "readpage", " readpage", "printpage", "writePage", "printPages", "writePages", "writepage", "printPage", " readPages", "readPages", "writeArticle", "readArticle", " readArticle"], "ignoreComments": ["oreLeaks", "oreTags", " ignoreNotes", "hideNotes", "ignoreLeaks", "ignoreNotes", " ignoreTags", " ignoreBlocks", "ignoreBlocks", "hideComments", "oreComment", "ignoreQuotes", "oreBlocks", "hideLeaks", "hideTags", " ignoreComment", "ignoreTags", "hideBlocks", "oreNotes", "ignoreComment", " ignoreLeaks", "hideQuotes", "oreComments", "hideComment", " ignoreQuotes", "oreQuotes"], "in": ["all", "rin", "en", "inn", "and", "con", "IN", "ins", "h", "reader", "m", "on", "client", "doc", "sum", "al", "In", "init", "inner", "ill", "b", "old", "ic", "thin", "up", "conf", "i", "read", "bin", "url", "copy", "get", "inc", "cm", "input", "out", "it", " din", "cal", "again", "ind", "add", "r", "ma", "mn", "mc", "mm", "info", "io", "din", "inf", "is", "isin", "cin", "check", "from"], "inputLine": ["InputRow", " InputLine", "resultLine", "indexLin", "resultName", " inputRow", "latline", " inputNet", "inputLINE", "inputNet", "outputline", "inputName", "inLine", "multiLo", "helloLo", "inRecord", "InputNet", "inputLin", "inName", "latLine", "InputLine", "indexLine", "helloLin", "inputRow", "latChain", "outputRow", " inputEntry", "rawline", "InputCell", " Inputline", "helloLINE", "InputEntry", "helloLine", "inputChain", "rawLine", " inputLINE", "inputline", "resultLINE", "inLINE", " InputBlock", " inputCell", " inputline", "latRow", "resultRecord", "helloNet", "Inputline", " inputBlock", "inputBlock", "inputRecord", "outputBlock", "multiLINE", "multiLin", "inputLo", "inputEntry", " inputChain", " inputName", "rawChain", "helloBlock", " inputRecord", "multiLine", "InputBlock", "indexLINE", "inputCell", "helloCell", "helloRow", " InputEntry", "rawRow", "outputLine", "indexLo"], "html": ["value", "theme", "output", "h", "emphasis", "page", "sg", "err", "available", "db", "detail", "plain", "total", "form", "css", "msg", "pdf", "browser", "f", "attr", "embed", "summary", "https", "flash", "template", "md", "alert", "cache", "hash", "has", "esi", "height", "hd", "http", "header", "layout", "rss", "img", "built", "view", "raw", "web", "human", "hover", "multi", "xml", "url", "str", "hard", "enabled", "api", "HTML", "ht", "att", "body", "wrapper", "pretty", "data", "json", "js", "details", "htm", "tt", "message", "current", "result", "content", "format", "dump", "tml", "mail", "rendered", "related", "full", "p", "title"]}}
{"id1": "5399593", "id2": "13414771", "code1": "    public synchronized String encrypt(String plaintext) throws NoSuchAlgorithmException, UnsupportedEncodingException {\n        MessageDigest md = null;\n        md = MessageDigest.getInstance(\"SHA\");\n        md.update(plaintext.getBytes(\"UTF-8\"));\n        byte raw[] = md.digest();\n        String hash = (new BASE64Encoder()).encode(raw);\n        return hash;\n    }\n", "code2": "    @Digester(forField = \"password\")\n    public static String encriptPassword(String passwd) {\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"MD5\");\n            md.update(passwd.getBytes());\n            BigInteger hash = new BigInteger(1, md.digest());\n            return hash.toString(16);\n        } catch (Exception e) {\n            return null;\n        }\n    }\n", "label": 1, "substitutes": {"encrypt": ["enrypted", "enode", "decrypted", "ecrypted", "enccode", "eccode", "encode", "deccode", "decode", "encrypted", "ecrypt", "ecode", "enrypt", "decrypt"], "plaintext": [" plainth", "plainpassword", " Plaininput", "ainpassword", " plaincontext", " Plainth", "plainword", " plainpassword", "preword", "plainth", "plaininput", "pretext", "plainText", " plainText", "maincontext", " Plaintext", "aininput", "precontext", "maintext", " plainword", "aintext", "mainword", "preText", " plaininput", "mainText", " Plainpassword", "ainth", "plaincontext"], "UnsupportedEncodingException": ["UnsupportedCompoderEx", "UnsupportedEncoderEx", "UnsupportedCompoderError", "UnsupportedEncryptionError", "UnsupportedEncodingError", "UnsupportedEncryptionException", "UnsupportedEncodingEx", "UnsupportedEncoderException", "UnsupportedCompodingEx", "UnsupportedEncoderError", "UnsupportedEncryptionEx", "UnsupportedEncodedError", "UnsupportedCompodingException", "UnsupportedCompoderException", "UnsupportedEncodedException", "UnsupportedEncodedEx", "UnsupportedCompodingError"], "md": [" Md", " MD", " mc", "nt", "sm", "ms", "pd", "od", "d", "der", " mo", "mt", " cmd", "m", " m", " mm", "mo", "sha", "mod", "mg", "red", "del", "mp", "dr", "det", "dm", "sd", "def", " ma", "gm", "dd", "cmd", "mand", " dd", "cd", "mb", "hd", "MD", "ind", "add", "ad", "grad", "mn", "mc", "mm", "bd", "pm", "mk", "exec", "ld", "med", "nd", "df"], "raw": ["empty", "all", "buf", "json", "orig", "known", "serial", "draw", "cooked", "custom", "clean", "clear", "mem", "load", "message", "available", "strip", "read", "sh", "unsigned", "input", "out", "valid", "des", "was", "hex", " Raw", "data", "pack", "aw", "hook", "RAW", " RAW", "rendered", "full", "row", "n", "core", "Raw", "bytes", "bare"], "hash": ["ashes", "ashed", "mask", "tr", "ash", "Hash", "cloth", "h", "unknown", "bh", "sum", "tag", "sha", "shadow", "code", "zh", "ASH", "message", "result", "sh", "name", "hed", "hidden", "has", "total", "hex", "dump", "search", "component", "height", "proof", "key", "html", "hat", "password", "ssh", "mac", "check", "id"]}}
{"id1": "18504192", "id2": "9550506", "code1": "    static void copyFile(File in, File out) throws IOException {\n        FileChannel source = new FileInputStream(in).getChannel();\n        FileChannel destination = new FileOutputStream(out).getChannel();\n        source.transferTo(0, source.size(), destination);\n        source.close();\n        destination.close();\n    }\n", "code2": "    private String cookieString(String url, String ip) {\n        MessageDigest md = null;\n        try {\n            md = MessageDigest.getInstance(\"SHA-1\");\n            md.update((url + \"&&\" + ip + \"&&\" + salt.toString()).getBytes());\n            java.math.BigInteger hash = new java.math.BigInteger(1, md.digest());\n            return hash.toString(16);\n        } catch (NoSuchAlgorithmException e) {\n            filterConfig.getServletContext().log(this.getClass().getName() + \" error \" + e);\n            return null;\n        }\n    }\n", "label": 0, "substitutes": {"copyFile": ["CopyFiles", " transferFile", "copyFiles", "CopyStream", " transferFiles", " CopyStream", "copyStream", "copyfile", " Copyfile", " CopyFiles", "CopyFile", " transferStream", " CopyFile", "Copyfile", " transferfile"], "in": ["rin", "en", "inn", "gin", "IN", "vin", "ins", "on", "In", "old", "b", "ic", "edIn", "up", "i", "inc", "l", "input", "or", "it", "ind", "o", "el", "mm", "n", "din", "inf", "is", "isin", "as", "cin", "id", "from"], "out": ["nt", "output", "oss", "help", "t", "po", "k", "net", "log", "err", "b", "to", "ot", "v", "i", "serv", "os", "l", "it", "gt", "ou", "at", "outs", "g", "o", "s", "ex", "n", "io", "Out", "OUT", "ne", "w"], "source": ["origin", "back", "scan", "style", "access", "subject", "match", "sample", "ie", "service", "pse", "resource", "se", "reader", "comment", "sequence", "secret", "create", "force", "before", "init", "inner", "template", "me", "store", "inside", "spec", "scope", "open", "system", "src", "Source", "copy", "position", "SOURCE", "input", "sin", "query", "parse", "search", "seed", "ource", "space", "instance", "use", "iterator", "local", "info", "volume", "ources", "start", "file", "shell", "from"], "destination": ["Destation", "restinated", " destregation", " destation", "coordregation", " destification", "comification", "restinator", "destregation", " destension", "restation", "destension", "comato", "seeinator", "coordification", "destation", "comregation", "Destinated", " destinator", "Destinator", "coordato", " destato", "coordination", " destinated", "seeination", "seeension", "destification", "destinated", "seeinated", "destato", "Destination", "Destension", "destinator", "restination", "comination"]}}
{"id1": "22135199", "id2": "16215393", "code1": "    public void testCodingEmptyFile() throws Exception {\n        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n        WritableByteChannel channel = newChannel(baos);\n        HttpParams params = new BasicHttpParams();\n        SessionOutputBuffer outbuf = new SessionOutputBufferImpl(1024, 128, params);\n        HttpTransportMetricsImpl metrics = new HttpTransportMetricsImpl();\n        LengthDelimitedEncoder encoder = new LengthDelimitedEncoder(channel, outbuf, metrics, 16);\n        encoder.write(wrap(\"stuff;\"));\n        File tmpFile = File.createTempFile(\"testFile\", \"txt\");\n        FileOutputStream fout = new FileOutputStream(tmpFile);\n        OutputStreamWriter wrtout = new OutputStreamWriter(fout);\n        wrtout.flush();\n        wrtout.close();\n        FileChannel fchannel = new FileInputStream(tmpFile).getChannel();\n        encoder.transfer(fchannel, 0, 20);\n        encoder.write(wrap(\"more stuff\"));\n        String s = baos.toString(\"US-ASCII\");\n        assertTrue(encoder.isCompleted());\n        assertEquals(\"stuff;more stuff\", s);\n        tmpFile.delete();\n    }\n", "code2": "    public void importSequences() {\n        names = new ArrayList<String>();\n        sequences = new ArrayList<String>();\n        try {\n            InputStream is = urls[urlComboBox.getSelectedIndex()].openStream();\n            ImportHelper helper = new ImportHelper(new InputStreamReader(is));\n            int ch = helper.read();\n            while (ch != '>') {\n                ch = helper.read();\n            }\n            do {\n                String line = helper.readLine();\n                StringTokenizer tokenizer = new StringTokenizer(line, \" \\t\");\n                String name = tokenizer.nextToken();\n                StringBuffer seq = new StringBuffer();\n                helper.readSequence(seq, \">\", Integer.MAX_VALUE, \"-\", \"?\", \"\", null);\n                ch = helper.getLastDelimiter();\n                names.add(name);\n                sequences.add(seq.toString());\n            } while (ch == '>');\n        } catch (MalformedURLException e) {\n            e.printStackTrace();\n        } catch (EOFException e) {\n        } catch (IOException e) {\n        }\n    }\n", "label": 0, "substitutes": {"testCodingEmptyFile": [" testCodingEmptyFiles", " testCachingEmptyStream", " testCachingEmptyFile", " testCodingSizefile", " testCodingFullFiles", " testCachingEmptyfile", " testCodingEmptyStream", " testCodingEmptyfile", " testCachingemptyStream", " testCodingSizeFiles", " testCodingemptyFiles", " testCachingemptyfile", " testCodingSizeStream", " testCodingSizeFile", " testCachingemptyFiles", " testCachingEmptyFiles", " testCodingemptyStream", " testCodingFullFile", " testCodingemptyfile", " testCodingFullfile", " testCachingemptyFile", " testCodingemptyFile", " testCodingFullStream"], "baos": ["boOs", "taos", "aoos", "boos", "aoOS", "boo", "tao", "boOS", "baOs", "taOs", "baoss", " bao", " baoss", "aoo", "caoS", "booss", "taoS", " baOS", "caos", "baOS", "Baos", "caOs", "Baoss", "cao", " baOs", "BaOs", "baoS", "Bao", "bao", " baoS", "aoOs"], "channel": ["chan", "window", "block", "Channel", "con", "caster", "console", "service", "resource", "application", "client", "stream", "context", "connection", "chain", "command", "buffer", "c", "room", "message", "system", "cache", "cm", "container", "out", "input", "ch", "controller", "handler", "component", "queue", "batch", "network", "socket", "io", "file", "password", "can", "server", "session"], "params": ["services", "tags", "json", "settings", "cmp", "par", "options", "Par", "ctx", "parts", "details", "limits", "cms", "types", "sys", "names", "spec", "phys", "pins", "ps", "conf", "ams", "param", "properties", "name", "fps", "pi", "pps", "rs", "caps", "pretty", "ops", "proc", " parameters", "Parameters", "AMS", "headers", "mm", "config", "pool", "password", "p", "units", "data", "radius"], "outbuf": ["inbuff", " outbuffer", " outrb", "outputbuf", "outputbuff", "inbuf", "Outbuffer", "outputrb", " outBuffer", "outputbuffer", "inrb", "outrb", "Outbuf", "outBuffer", "OutBuffer", "Outbuff", "outbuff", " outbuff", "inbuffer", "inBuffer", "outbuffer"], "metrics": ["Metrics", "matrix", "mutcs", " metrices", "metrors", "mutrics", "metcs", "Metric", "mtcs", "matrics", "monrors", " metcs", " metths", "mtrices", "monrics", "mtrics", "monric", "Metrors", "metths", "matric", "monrix", "mtths", "metrices", "metrix", "metric", "matrors", "mutths", "mutrices", "Metrix"], "encoder": ["ecoding", "encuter", "ecoded", "enoding", "encoded", "enrier", "execoding", "encrier", "ecoder", "Encrier", " encuter", "Encuter", " encramer", "encramer", "ecramer", "Encoder", "Encramer", "Enciever", "ecrier", "enoder", "ecressor", "execoder", " encrier", "execrier", "enoded", " encressor", "eniever", "enramer", "Encoding", " encoding", "encressor", "enciever", "encoding", " encoded", "eciever", "enressor", "executer"], "tmpFile": ["tmpName", " tmpFilename", "tmpKey", "mpfile", " tmpfile", "fakeFilename", "mpFilename", "tmpFILE", "testFilename", "imgFILE", "tmpfile", "tempFilename", "tempPath", "mpFile", " tmpKey", "tmpFiles", "tempKey", "imgKey", "fakeFile", "txtfile", " tmpFILE", " tmpName", "tempfile", "mpName", "tempFILE", " tmpPath", " tmpFiles", "imgFile", "testName", "imgfile", "testfile", "tempFiles", "tempFile", "fakeFiles", "testFile", "tmpPath", "txtPath", "tmpFilename", "fakefile", "txtFile"], "fout": ["sfOut", "vout", "fulloutput", "vouts", "fao", "fullOUT", "wout", "dfoutput", "fOut", "dfbal", "sfout", "lout", "wao", "fouts", "wOut", "fbal", "lOUT", "fullout", "sfouts", "fullbal", "dfout", "sfao", "vao", "lbal", "wouts", "loutput", "vOut", "fOUT", "dfOUT", "foutput"], "wrtout": ["wrtin", "wrtn", "Wrtio", "ewltwriter", "wdrgen", "ewrtwriter", "hwrcwriter", "wRTout", "Wrdwriter", "wgtex", "wttio", "wwtout", "wwtw", "hwrtwriter", "wrdout", "wltout", "wrtex", "hwrtout", "wgtwriter", "wltin", "wrcwriter", "wgtw", "hwrcw", "Wrdio", "ewrtin", "ewrtgen", "wrdwriter", "wttwriter", "wrcex", "wrcout", "wRTio", "wRTn", "wrdgen", "Wrdout", "wttout", "hwrtw", "hwrtex", "Wrdn", "wrdin", "hwrcout", "Wrtwriter", "Wrtn", "wttn", "wdrout", "wrcw", "ewltin", "wRTwriter", "wrtio", "Wrtout", "hwrcex", "wrdn", "ewltout", "wdrin", "wwtwriter", "wrtgen", "wrtwriter", "wdrwriter", "wltgen", "wgtout", "wrtw", "ewltgen", "ewrtout", "wltwriter", "wrdio", "wwtex"], "fchannel": ["Fchannel", "flChannel", "fchan", " fChannel", " fconnection", "fChannel", "fconsole", "wchan", " fcontroller", " fchan", "fnet", " fnet", " fconsole", "fconnection", "fcontroller", "flconsole", "wchannel", "fccontroller", "flnet", "Fconsole", "wcontroller", "flchannel", "fcconnection", "fcchan", "FChannel", "Fnet", "fcchannel", "wconnection"], "s": ["f", "csv", "ss", "p", "j", "h", "js", "m", "ws", "qs", "ls", "t", "ns", "sq", "sg", "c", "b", "ts", "S", "v", "i", "e", "sv", "str", "rs", "ds", "gs", "g", "r", "n", "string", "gets", "is", "a", "w"]}}
{"id1": "14001795", "id2": "15799935", "code1": "    public static void copyOverWarFile() {\n        System.out.println(\"Copy Over War File:\");\n        File dir = new File(theAppsDataDir);\n        FileFilter ff = new WildcardFileFilter(\"*.war\");\n        if (dir.listFiles(ff).length == 0) {\n            dir = new File(System.getProperty(\"user.dir\") + \"/war\");\n            if (dir.exists()) {\n                File[] files = dir.listFiles(ff);\n                for (File f : files) {\n                    try {\n                        File newFile = new File(\"\" + theAppsDataDir + \"/\" + f.getName());\n                        System.out.println(\"Creating new file \\\"\" + f.getAbsolutePath() + \"\\\"\");\n                        newFile.createNewFile();\n                        InputStream fi = new FileInputStream(f);\n                        OutputStream fo = new FileOutputStream(newFile);\n                        IOUtils.copy(fi, fo);\n                        moveUnzipAndExtract(newFile);\n                    } catch (Exception ex) {\n                        Logger.getLogger(AppDataDir.class.getName()).log(Level.SEVERE, null, ex);\n                    }\n                }\n            }\n        } else {\n            System.out.println(\"Found a war in the apps data dir, ignoring a fresh copy\");\n        }\n        new JFileChooser().setCurrentDirectory(new File(theAppsDataDir));\n        System.setProperty(\"user.dir\", theAppsDataDir);\n        System.out.println(\"User.dir : \" + System.getProperty(\"user.dir\"));\n    }\n", "code2": "    public static void saveAttachmentBody(Context context, Part part, Attachment localAttachment, long accountId) throws MessagingException, IOException {\n        if (part.getBody() != null) {\n            long attachmentId = localAttachment.mId;\n            InputStream in = part.getBody().getInputStream();\n            File saveIn = AttachmentProvider.getAttachmentDirectory(context, accountId);\n            if (!saveIn.exists()) {\n                saveIn.mkdirs();\n            }\n            File saveAs = AttachmentProvider.getAttachmentFilename(context, accountId, attachmentId);\n            saveAs.createNewFile();\n            FileOutputStream out = new FileOutputStream(saveAs);\n            long copySize = IOUtils.copy(in, out);\n            in.close();\n            out.close();\n            String contentUriString = AttachmentProvider.getAttachmentUri(accountId, attachmentId).toString();\n            localAttachment.mSize = copySize;\n            localAttachment.mContentUri = contentUriString;\n            ContentValues cv = new ContentValues();\n            cv.put(AttachmentColumns.SIZE, copySize);\n            cv.put(AttachmentColumns.CONTENT_URI, contentUriString);\n            Uri uri = ContentUris.withAppendedId(Attachment.CONTENT_URI, attachmentId);\n            context.getContentResolver().update(uri, cv, null, null);\n        }\n    }\n", "label": 1, "substitutes": {"copyOverWarFile": ["copyoverwarfile", "copyoverWarFile", "copyOverwarFilename", "copyoverWarFilename", "copyoverwarFile", "copyOverwarfile", "copyOverWarfile", "copyoverWarfile", "copyOverWarFilename", "copyoverwarFiles", "copyOverWarFiles", "copyoverwarFilename", "copyOverTarfile", "copyoverWarFiles", "copyOverwarFile", "copyOverTarFilename", "copyOverTarFile", "copyOverTarFiles", "copyOverwarFiles"], "dir": ["window", "good", "div", " directory", "dl", "dial", "res", "vol", "di", "d", "disk", "doc", "tmp", "directory", "md", "del", "addr", "old", "log", "fd", "cur", "dr", "db", "re", "wd", "rel", "dm", "dim", "url", "def", "name", "coll", "out", "iter", " Dir", "dd", "parent", "Dir", "ir", "path", "form", "dat", "cd", "ind", "DIR", "add", "zip", "desc", "local", " d", "mk", "dist", "fin", "file", "folder", "ld", "loc", "dep", "direct", "df"], "ff": ["alf", "buff", "bf", "aft", " eff", "cb", "af", "mt", " cf", "uff", "FF", "fp", "lf", "xff", "ef", "fc", "ffe", "fd", "wind", " af", " aft", "fg", "UFF", "off", " FF", "sf", " ref", "tf", "uf", "cond", "fx", "ck", "fact", " def", "filter", "aff", " df", "iff", "F", "cf", "file", "ld", "ft", "xf", "eff", "df", "fl"], "files": ["forms", "leases", "frames", "ails", "assets", "rows", "parts", "facts", "items", "keys", "plates", "fs", "jobs", "lines", "tests", "les", "ls", "names", "models", "iles", "uploads", "issues", "flows", "styles", "days", "images", "fields", "resources", "members", "objects", "ions", "ports", "balls", "ories", "Files", "features", "values", "file", "mas", "bees", "faces"], "f": ["exp", "alf", "fe", "bf", "d", "h", "a", "m", "fs", "fm", "fp", "col", "fac", "t", "lf", "k", "c", "fc", "b", "fd", "v", "i", "e", "def", "rf", "tf", "sf", "fw", "l", "uf", "elf", "g", "fab", "n", "fa", "F", "cf", "file", "ft", "p", "xf", "fl", "w"], "newFile": [" newFiles", "oldFilename", "newNode", "anotherPlace", "newfile", "anotherFiles", "newPlace", "uniqueNode", "NewNode", "NEWfile", "NewKey", "newsfile", "newFilename", "secureFile", "NEWPage", " newfile", "newKey", "NEWNode", "newsFile", "uniqueFile", "securefile", "anotherFile", "NEWFile", " newPlace", "anotherfile", "secureKey", "NewPlace", "NewPage", "oldfile", " newFilename", "oldFile", "newsKey", "Newfile", "newFiles", "NewFilename", "uniquefile", "uniquePage", "NewFiles", "newPage", "NewFile"], "fi": ["ifa", "mi", "fe", "ini", "bf", "di", "ri", "ki", "fr", "fp", "ti", "iu", "lf", "bi", "fd", "ci", "i", "pi", "sf", "uf", "Fi", "ni", "li", "si", "flo", "afi", "ife", "FI", "fa", "io", "cf", "ii", "isi", "fin", "zi", "phi"], "fo": ["hea", "co", "ko", "tto", "oe", "opa", "tk", "bo", "ow", "ki", "mo", "uo", "ti", "FO", "po", "hi", "ho", "eno", "fam", "oo", "zo", "ph", "jo", "vo", "zz", "eto", "tf", "sf", "ott", "wt", "flo", "oooo", "o", "sty", "te", "wo", "ato", "cf", "tif", "xf"]}}
{"id1": "3187685", "id2": "4750967", "code1": "    private void copyJar(File src, File dst) throws IOException {\n        FileChannel srcChannel = null;\n        FileChannel dstChannel = null;\n        try {\n            srcChannel = new FileInputStream(src).getChannel();\n            dstChannel = new FileOutputStream(dst).getChannel();\n            dstChannel.transferFrom(srcChannel, 0, srcChannel.size());\n        } catch (IOException e) {\n            fLog.log(Level.SEVERE, e.getMessage(), e);\n        } finally {\n            srcChannel.close();\n            dstChannel.close();\n        }\n    }\n", "code2": "    public void patch() throws IOException {\n        if (mods.isEmpty()) {\n            return;\n        }\n        IOUtils.copy(new FileInputStream(Paths.getMinecraftJarPath()), new FileOutputStream(new File(Paths.getMinecraftBackupPath())));\n        JarFile mcjar = new JarFile(Paths.getMinecraftJarPath());\n    }\n", "label": 1, "substitutes": {"copyJar": [" copyingPath", "copyPath", "copyFile", "CopyPath", " copyingFile", "CopyJar", " copyFile", "CopyFile", " copyingJar", " copyPath"], "src": ["ser", "rc", "usr", "sb", "stock", "img", "rt", "ins", "dest", "cont", "js", "sys", "init", "urg", "sq", "ctr", "cur", "sr", "usc", "Source", "req", "sec", "rs", "str", "input", "sc", "rx", "st", "s", "sn", "iv", "syn", "start", "rob", "source", "ipl", "inst", "from"], "dst": ["dect", "desnd", "dlt", "Ddest", "dest", "ddest", "dkt", "ddst", "dend", "desst", "deslt", "dddest", "Dkt", "Dnd", " dnd", "Dst", "ddct", "deskt", "dedest", "Dlt", " dlt", "ddnd", "Dct", " dkt", "dct", "dnd"], "srcChannel": ["stChannel", "rcConnection", "srManager", "srcChan", "rcClass", "srChan", "rcContext", "sourceChannel", "srcManager", "sourceConnection", " srcContext", "srCategory", "sbChan", "srcClass", " srcManager", "srcConnection", "serManager", "sbChannel", "srcchannel", "singChannel", "stClass", "rcChannel", "sourcechannel", "rcchannel", "stChan", "sourceChain", "srcChain", "stchannel", "serChan", " srcCategory", "rcChan", "serCategory", "rcCategory", "singConnection", "srChannel", "serChannel", "srcContext", " srcChain", " srcClass", "singContext", "singCategory", "sbChain", " srcchannel", " srcChan", " srcConnection", "sbchannel", "srcCategory", "sourceChan", "rcChain"], "dstChannel": ["dstchannel", " dnetButton", "dotchannel", " dndRow", "dmtChan", " dstConnection", "dndRow", "dndchannel", "ddrchannel", " dnetChannel", "dnetchannel", " dstManager", " dstButton", "ddestchannel", "dndConnection", " dmtChan", "dstsChan", "dndChannel", "dndButton", "dotChannel", " dstchannel", "dstButton", "dstWriter", "dndChan", "ddrWriter", "dmtChannel", " dndChannel", "dnetChan", "dndManager", " dndchannel", "dstsChannel", " dstWriter", " dmtConnection", "ddrRow", " dstChan", " dndWriter", "ddestRow", " dotchannel", " dmtChannel", "dnetManager", "dnetChannel", "dmtchannel", " dnetManager", "ddestWriter", " dotChannel", "ddestChannel", " dotChan", "dmtConnection", "dstManager", "dstConnection", "dnetConnection", " dnetChan", " dmtchannel", "dotButton", "dndWriter", "dnetButton", "dotChan", "dstschannel", "dstsConnection", " dotConnection", "ddrChannel", "dstRow", "dstChan", "dotConnection", " dstRow", "dotManager"]}}
{"id1": "17683082", "id2": "22338097", "code1": "    HttpRepository(Path path) throws IOException {\n        super(path);\n        this.url = new URL(path.toURLString());\n        HttpURLConnection.setFollowRedirects(true);\n        this.connection = (HttpURLConnection) url.openConnection();\n        this.ns = Names.getNamespace(path);\n    }\n", "code2": "    private final String createMD5(String pwd) throws Exception {\n        MessageDigest md = (MessageDigest) MessageDigest.getInstance(\"MD5\").clone();\n        md.update(pwd.getBytes(\"UTF-8\"));\n        byte[] pd = md.digest();\n        StringBuffer app = new StringBuffer();\n        for (int i = 0; i < pd.length; i++) {\n            String s2 = Integer.toHexString(pd[i] & 0xFF);\n            app.append((s2.length() == 1) ? \"0\" + s2 : s2);\n        }\n        return app.toString();\n    }\n", "label": 0, "substitutes": {"IOException": [" IOProblem", "DownloadException", " IOError", "IOError", " ioEx", " IOEx", " ioException", "DownloadProblem", "DownloadEx", " ioProblem", "IOProblem", "DownloadError", "IOEx", " ioError"], "url": ["access", "hl", "gl", "sb", "dl", "util", "resource", "client", "https", "bel", "web", "ls", "ll", "base", "char", "link", "pl", "log", "sl", "impl", "rel", "re", "ur", "mount", "org", "gc", "URL", "str", "l", "nl", "ul", "path", "conn", "ssl", "channel", "ret", "http", "att", "file", "loc", "Url", "fl", "abs"], "connection": ["response", "connected", "pointer", "engine", "resource", "application", "client", "page", "context", "port", "link", "c", "document", "system", "condition", "Connection", "object", "handler", "conn", "network", "relation", "database", "connect", "channel", "socket", "io", "pool", "session"], "ns": ["na", "nt", "ss", "nm", "ms", "res", "cn", "fs", "sys", "bs", "ls", "NS", "names", "net", "ps", "ts", "rs", "ds", "gs", "s", "sn", "n", "Ns", "ny", "fn", "es", "ne", "cs"]}}
{"id1": "4686922", "id2": "20619879", "code1": "    public void extractResourceToFile(String resourcePath, File dest) {\n        InputStream in = getClass().getResourceAsStream(resourcePath);\n        try {\n            FileOutputStream out = FileUtils.openOutputStream(dest);\n            try {\n                IOUtils.copy(in, out);\n            } finally {\n                if (out != null) {\n                    out.close();\n                }\n            }\n        } finally {\n            if (in != null) {\n                in.close();\n            }\n        }\n    }\n", "code2": "    public void copyLogic() {\n        if (getState() == States.Idle) {\n            setState(States.Synchronizing);\n            try {\n                FileChannel sourceChannel = new FileInputStream(new File(_properties.getProperty(\"binPath\") + name + \".class\")).getChannel();\n                FileChannel destinationChannel = new FileOutputStream(new File(_properties.getProperty(\"agentFileLocation\") + name + \".class\")).getChannel();\n                sourceChannel.transferTo(0, sourceChannel.size(), destinationChannel);\n                sourceChannel.close();\n                destinationChannel.close();\n            } catch (FileNotFoundException e) {\n                e.printStackTrace();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            setState(States.Idle);\n        }\n    }\n", "label": 1, "substitutes": {"extractResourceToFile": ["extractResourcesTofile", "extractResourcesToFiles", "extractResourceAsFiles", "extractResourcesToStream", "extractResources2Stream", "extractResourceTofile", "extractResources2file", "extractResourceToStream", "extractResourceAsfile", "extractResource2file", "extractResource2File", "extractResources2File", "extractResources2Files", "extractResourceAsStream", "extractResourceFromFile", "extractResource2Stream", "extractResourceToFiles", "extractResourceFromFiles", "extractResource2Files", "extractResourceFromStream", "extractResourcesToFile", "extractResourceFromfile", "extractResourceAsFile"], "resourcePath": ["Resourcepath", "resourceLocation", "attributeLocation", "resourceUrl", "attributeName", "ResourceUrl", " resourceName", "templateIn", "ResourceLocation", "uriName", "ResourceName", " resourcepath", "resourcepath", "templateName", "ResourceIn", "templatePath", "uriUrl", "ResourcePath", "uriPath", "resourceName", " resourceIn", "templatepath", "uriLocation", "resourceIn", "attributeUrl", "attributePath"], "dest": ["origin", "decl", "coord", "good", "comb", "prop", "home", "img", "cat", "output", "orig", "sp", "cont", "trans", "tmp", "mem", "rest", "to", "lit", "result", "src", "opt", "target", "des", "this", "parent", "null", "dir", "nom", "dat", "gov", "etc", "self", "desc", "Dest", "temp", "dist", "source", "loc", "end", "w"], "in": ["f", "all", "mi", "rin", "inn", "ini", "gin", "con", "IN", "ins", "resource", "ln", "on", "m", "al", "raw", "In", "init", "inner", "inside", "re", "up", "conf", "i", "none", "bin", "inc", "l", "input", "or", "sin", "iter", "it", " din", "ind", "r", "mc", "local", "din", "inf", "no", "is", "isin", "source", "file", "cin", "id", "from", "ne"], "out": ["f", "co", "en", "nt", "na", "con", "output", "res", "cos", "oss", "cn", "obj", "client", "on", "sys", "tmp", "col", "conv", "t", "inner", "stable", "net", "print", "write", "b", "to", "ot", "v", "i", " Out", "cache", "writer", "os", "outer", "it", "ch", "note", "exit", "null", "ou", "at", "outs", "aos", "o", "again", "n", "io", "no", "Out", "pool", "OUT", "can", "ne", "w"]}}
{"id1": "15051083", "id2": "23118425", "code1": "    @Override\n    public String getMessageDigest() throws SarasvatiLoadException {\n        if (messageDigest == null) {\n            Collections.sort(nodes);\n            Collections.sort(externals);\n            try {\n                MessageDigest digest = MessageDigest.getInstance(\"SHA1\");\n                digest.update(name.getBytes());\n                for (XmlNode node : nodes) {\n                    node.addToDigest(digest);\n                }\n                for (XmlExternal external : externals) {\n                    external.addToDigest(digest);\n                }\n                messageDigest = SvUtil.getHexString(digest.digest());\n            } catch (NoSuchAlgorithmException nsae) {\n                throw new SarasvatiException(\"Unable to load SHA1 algorithm\", nsae);\n            }\n        }\n        return messageDigest;\n    }\n", "code2": "    public synchronized String encrypt(String plaintext) throws Exception {\n        MessageDigest md = null;\n        try {\n            md = MessageDigest.getInstance(\"MD5\");\n        } catch (Exception e) {\n        }\n        try {\n            md.update(plaintext.getBytes(\"UTF-8\"));\n        } catch (Exception e) {\n        }\n        byte raw[] = md.digest();\n        String hash = (new BASE64Encoder()).encode(raw);\n        return hash;\n    }\n", "label": 1, "substitutes": {"getMessageDigest": ["getMessagedigse", "getContentDigse", "getContentdigest", "getContentdigests", "getContentDigest", "getMessageDigested", "getContentDigested", "getContentdigse", "getMessageDigests", "getMessageTimests", "getContentDigests", "getMessagedigest", "getMessagedigests", "getMessageTimest", "getContentdigested", "getMessageTimested", "getMessageDigse", "getMessageTimse", "getMessagedigested"], "digest": ["mdester", "dested", "digast", " diggest", " digse", "Digend", "driverest", "diggest", "dest", "hashester", "dependest", "driverester", "signested", "dend", "drivergest", "digse", " Digest", "modest", "Digester", " digestested", " Digested", "digend", "dependast", "driverested", " Digend", " digast", "Digse", "mdest", "Diggest", " Digester", "Digast", " digestester", "dependester", "hashested", "signester", " digester", "Digested", "dependested", "hashest", "mdse", " digestest", "mdested", "modester", "modested", "digested", "signgest", "digester", "dester", "hashgest", "signest", " digested", "Digest"], "node": ["process", "element", "entry", "nn", "yn", "resource", "create", "run", "inner", "one", "dependent", "link", "attribute", "open", "document", "Node", "cell", "post", "system", "missing", "host", "angular", "name", "child", "common", "query", "note", "tree", "object", "normal", "binary", "network", "role", "n", "remote", "job", "source", "root", "ne", "peer"], "external": ["External", "extra", "export", "unique", "reference", "internal", "intern", "obj", "custom", "https", " External", "optional", "ns", "ternal", "ext", "name", "child", "get", "foreign", "global", "complete", "qualified", "common", "exit", "secondary", "note", "object", "this", "binary", "any", "express", "local", "self", "n", "remote", "multiple", "outside", "ex", "escape", "tern"], "messageDigest": ["messageDateesting", "MessageDigest", "essageDatese", "messageDigEST", "messageDesignse", "messageGuest", "MessageDigested", "messagedighest", "messageDigesting", "Messagedighest", "messageMixse", "essageDigest", "messageMixesting", "MessageDighest", "messageGuhest", "messageDateest", "messageDigested", " messageDigested", "messagedigse", "messagedigest", "messagedigEST", "messageDesignEST", "messageMixest", "Messagedigested", "essageDateest", "messageDigse", " messageDigse", "MessagedigEST", "messageGuEST", "MessageDigEST", "messageDesignest", "messagedigesting", "messageGuested", "messageDatese", " messageDigEST", "messagedigested", "essageDateesting", "Messagedigest", "messageDesignested", "essageDigesting", "messageDighest", "essageDigse"]}}
{"id1": "20091126", "id2": "6403868", "code1": "    static File copy(File in, File out) throws IOException {\n        FileChannel inChannel = new FileInputStream(in).getChannel();\n        FileChannel outChannel = new FileOutputStream(out).getChannel();\n        try {\n            inChannel.transferTo(0, inChannel.size(), outChannel);\n            return out;\n        } catch (IOException e) {\n            throw e;\n        } finally {\n            if (inChannel != null) inChannel.close();\n            if (outChannel != null) outChannel.close();\n        }\n    }\n", "code2": "    private File extractUninstallFiles(File _destPath, boolean upgrade, String lastVer) {\n        File oldlog = null;\n        try {\n            boolean oldClassCopied = false;\n            File destPath = new File(_destPath, \"vai_\" + VAGlobals.APP_NAME + \"_\" + VAGlobals.APP_VERSION);\n            if (upgrade) {\n                File lastVerPath = new File(_destPath, \"vai_\" + VAGlobals.APP_NAME + \"_\" + lastVer);\n                if (destPath.equals(lastVerPath)) {\n                    File bkdir = new File(destPath.getAbsolutePath() + \".bak\");\n                    if (!destPath.renameTo(bkdir)) {\n                        throw new IOException(VAGlobals.i18n(\"Setup_NotCreateDirectory\") + \" \" + destPath);\n                    }\n                    oldlog = new File(bkdir.getAbsolutePath() + System.getProperty(\"file.separator\") + \"uninstall.vai\");\n                    lastVerPath = bkdir;\n                } else {\n                    oldlog = new File(lastVerPath.getAbsolutePath() + System.getProperty(\"file.separator\") + \"uninstall.vai\");\n                }\n                if ((!destPath.exists()) && (!destPath.mkdirs())) {\n                    throw new IOException(VAGlobals.i18n(\"Setup_NotCreateDirectory\") + \" \" + destPath);\n                }\n                if (uInfo_.module) oldClassCopied = copyOldSetupClass(lastVerPath, destPath);\n            } else {\n                if ((!destPath.exists()) && (!destPath.mkdirs())) {\n                    throw new IOException(VAGlobals.i18n(\"Setup_NotCreateDirectory\") + \" \" + destPath);\n                }\n            }\n            dirty_ = true;\n            File[] ls = destPath.listFiles();\n            for (int i = 0; i < ls.length; i++) {\n                if (!oldClassCopied) ls[i].delete(); else if (!ls[i].getPath().equals(destPath.getAbsolutePath() + File.separator + installClassName_ + \".class\")) ls[i].delete();\n            }\n            byte[] buf = new byte[0];\n            int read = 0;\n            if (!oldClassCopied && (installClassSize_ > 0 || jarOffset_ > 0)) {\n                final File outClassFile = new File(destPath.getAbsolutePath() + File.separator + installClassName_ + \".class\");\n                if (outClassFile.exists() && !outClassFile.delete()) {\n                    ui_.showError(new Exception(VAGlobals.i18n(\"Setup_FileNotCreated\") + \":\\n\" + outClassFile.getName()));\n                }\n                final FileOutputStream out = new FileOutputStream(outClassFile);\n                final FileInputStream in = new FileInputStream(fileWithArchive_);\n                if (installClassOffset_ > 0) {\n                    in.skip(installClassOffset_);\n                }\n                buf = new byte[0];\n                if (installClassSize_ < 0) buf = new byte[(int) jarOffset_]; else buf = new byte[(int) installClassSize_];\n                read = in.read(buf, 0, buf.length);\n                out.write(buf, 0, read);\n                out.close();\n                in.close();\n            }\n            final FileInputStream in = new FileInputStream(fileWithArchive_);\n            if (jarOffset_ > 0) {\n                in.skip(jarOffset_);\n            }\n            JarInputStream jar = new JarInputStream(in);\n            final File outJarFile = new File(destPath.getAbsolutePath() + File.separator + \"install.jar\");\n            if (outJarFile.exists() && !outJarFile.delete()) {\n                ui_.showError(new Exception(VAGlobals.i18n(\"Setup_FileNotCreated\") + \":\\n\" + outJarFile.getName()));\n            }\n            JarOutputStream outJar = new JarOutputStream(new FileOutputStream(outJarFile));\n            ZipEntry entry = jar.getNextEntry();\n            final int bufSize = 32768;\n            buf = new byte[bufSize];\n            while (entry != null) {\n                String entryName = entry.getName();\n                if (entryName.equals(\"com/memoire/vainstall/resources/vainstall.properties\")) {\n                } else if (entryName.equals(installClassName_ + \".class\") && !oldClassCopied) {\n                    FileOutputStream out = null;\n                    try {\n                        out = new FileOutputStream(destPath.getAbsolutePath() + File.separator + installClassName_ + \".class\");\n                        VAGlobals.copyStream(jar, out, buf);\n                    } catch (IOException e) {\n                        throw e;\n                    } finally {\n                        if (out != null) out.close();\n                    }\n                } else if (!entryName.endsWith(\".zip\")) {\n                    if (VAGlobals.DEBUG) VAGlobals.printDebug(\"jar entry name \" + entryName);\n                    ZipEntry outEntry = new ZipEntry(entryName);\n                    CRC32 crc = new CRC32();\n                    outJar.putNextEntry(outEntry);\n                    int size = 0;\n                    while ((read = jar.read(buf, 0, bufSize)) >= 0) {\n                        size += read;\n                        if (read == 0) {\n                            Thread.yield();\n                        } else {\n                            outJar.write(buf, 0, read);\n                            crc.update(buf, 0, read);\n                        }\n                    }\n                    outEntry.setSize(size);\n                    outEntry.setCrc(crc.getValue());\n                    outJar.flush();\n                    outJar.closeEntry();\n                }\n                jar.closeEntry();\n                entry = jar.getNextEntry();\n            }\n            InputStream pin = getClass().getResourceAsStream(\"resources/vainstall.properties\");\n            Properties prop = new Properties();\n            try {\n                prop.load(pin);\n            } catch (IOException exc) {\n            }\n            if (language == null) language = \"default\";\n            prop.setProperty(\"vainstall.destination.language\", language);\n            ZipEntry outEntry = new ZipEntry(\"com/memoire/vainstall/resources/vainstall.properties\");\n            CRC32 crc = new CRC32();\n            outEntry.setCrc(crc.getValue());\n            outEntry.setSize(prop.size());\n            outJar.putNextEntry(outEntry);\n            prop.store(outJar, VAGlobals.NAME + \" \" + VAGlobals.VERSION);\n            outEntry.setCrc(crc.getValue());\n            outJar.closeEntry();\n            jar.close();\n            outJar.close();\n            in.close();\n        } catch (IOException e) {\n            String message = e.getLocalizedMessage();\n            message += \"\\n\" + VAGlobals.i18n(\"Setup_ErrorUninstallScripts\");\n            e.printStackTrace();\n            exitOnError(new IOException(message));\n        }\n        return oldlog;\n    }\n", "label": 1, "substitutes": {"copy": ["cat", "y", "sync", "create", "Transfer", " Copy", "store", "Copy", "transfer", "write", "open", "delete", "load", "call", "to", "system", "cp", "get", "upload", "paste", "Cop", "download", "io", "save", "file", "map", "clone", "move"], "in": ["rin", "en", "inn", "ini", "gin", "IN", "ins", "In", "init", "inner", "old", "b", "up", "i", "inc", "l", "input", " din", "ck", " input", "ain", "ind", "r", "el", "mm", "n", "info", "io", "din", "inf", "isin", "source", "file", "cin", "id", "from"], "out": ["co", "_", "nt", "y", "output", "res", "w", "tmp", "t", "x", "one", "err", "log", "net", "b", "to", "c", " os", "write", "result", "ot", "end", "v", "e", "os", "l", "or", "it", "ch", "gt", "null", "ou", "s", "outs", "o", "at", " it", "channel", "self", "n", "io", "msg", "Out", "file", "as", "OUT", "p", "bytes", " output", "ex"], "inChannel": ["cinChannel", " inListener", "ginChain", "InConnection", "conChannel", "INChan", "cinCommand", "binCommand", "InChan", "inChan", "INConnection", "insideChannel", "outBlock", "inListener", "inChain", "binSection", "incChain", "insideCommand", "outCommand", "cinBlock", "insideRow", "inChuck", "incChannel", "InChannel", "innChan", "innChannel", "inCommand", "conListener", "binChannel", " inSection", " inConnection", "ginChannel", " inchannel", "INListener", " inRow", "innConnection", "incChuck", "binRow", "innchannel", "INChannel", "cinchannel", "conConnection", "ginChuck", "insideSection", "binChain", "inPanel", "incPanel", "binChuck", "inBlock", " inChan", " inBlock", "inConnection", "inchannel", "conChan", "inRow", " inCommand", "outchannel", "Inchannel", "inSection", "ginPanel", "binPanel"], "outChannel": ["Outchannel", " outMany", "outMany", "inChan", "inUser", "cmdChannel", "cosChannel", "OUTChan", "modulePassword", "skyGate", "cmdMany", "outGate", "outSlot", "OUTUser", "OutChannel", " outCh", " outGate", " outChan", "OutChan", "cosChan", "moduleManager", "cosSlot", "inCh", "skyChannel", "cosUser", " outManager", "skyMany", "OUTSlot", "outUser", "skyChan", "cmdChan", "outputManager", "outputPassword", "cmdGate", "inSlot", "OUTChannel", "moduleChannel", " outchannel", "inchannel", "outChan", "outputChannel", " outPassword", "moduleChan", "outManager", "outchannel", "OutCh", "outPassword", "outCh", "outputChan"]}}
{"id1": "7761195", "id2": "12744653", "code1": "    public synchronized String encrypt(String plaintext) throws Exception {\n        StringBuffer sb = new StringBuffer();\n        MessageDigest md = null;\n        try {\n            md = MessageDigest.getInstance(\"SHA-512\");\n        } catch (NoSuchAlgorithmException e) {\n            throw new Exception(e.getMessage());\n        }\n        try {\n            md.update(plaintext.getBytes(\"UTF-8\"));\n        } catch (UnsupportedEncodingException e) {\n            throw new Exception(e.getMessage());\n        }\n        byte raw[] = md.digest();\n        String hash = (new BASE64Encoder()).encode(raw);\n        return hash;\n    }\n", "code2": "    private void getRandomGUID(boolean secure) {\n        MessageDigest md5 = null;\n        StringBuffer sbValueBeforeMD5 = new StringBuffer();\n        try {\n            md5 = MessageDigest.getInstance(\"MD5\");\n        } catch (NoSuchAlgorithmException e) {\n            System.out.println(\"Error: \" + e);\n        }\n        try {\n            long time = System.currentTimeMillis();\n            long rand = 0;\n            if (secure) {\n                rand = mySecureRand.nextLong();\n            } else {\n                rand = myRand.nextLong();\n            }\n            sbValueBeforeMD5.append(s_id);\n            sbValueBeforeMD5.append(\":\");\n            sbValueBeforeMD5.append(Long.toString(time));\n            sbValueBeforeMD5.append(\":\");\n            sbValueBeforeMD5.append(Long.toString(rand));\n            valueBeforeMD5 = sbValueBeforeMD5.toString();\n            md5.update(valueBeforeMD5.getBytes());\n            byte[] array = md5.digest();\n            StringBuffer sb = new StringBuffer();\n            for (int j = 0; j < array.length; ++j) {\n                int b = array[j] & 0xFF;\n                if (b < 0x10) {\n                    sb.append('0');\n                }\n                sb.append(Integer.toHexString(b));\n            }\n            valueAfterMD5 = sb.toString();\n        } catch (Exception e) {\n            System.out.println(\"Error:\" + e);\n        }\n    }\n", "label": 1, "substitutes": {"encrypt": ["Enccrypt", "Encryption", "ecrypt", "decryption", "decrypted", "ecrypted", "enccrypt", "Encrypted", "ecryption", "deccrypt", "encrypted", "decrypt", "eccrypt", "Encrypt", "encryption"], "plaintext": ["plainpassword", "plainmessage", "rainmessage", "mainpassword", "summarymessage", " plainpattern", "summarytex", "plainTEXT", "publicTEXT", " plaintex", " plainpassword", "summarytext", "publicText", "plainpattern", "raintex", " plainmessage", "plainText", " plainText", "raintext", "rainpattern", "publicpassword", "maintext", " plainTEXT", "publictext", "summarypattern", "mainTEXT", "mainText", "plaintex"], "sb": [" sm", "bt", "sm", "sp", "cb", "h", "bh", "set", "tmp", "sq", "sg", "b", "bb", "db", "SB", " b", "sh", "str", " SB", " sp", "s", "mb", "msg", "ssh", " db", " rs", " ss", " ssh"], "md": [" mc", "nt", "sm", "ms", "pd", "od", "di", "d", "der", " mo", "mt", "m", "managed", "mo", "mod", "mg", "del", "mp", "dr", "rm", "det", "dm", "sd", "e", "nd", "ds", "cod", "dd", "cmd", "mand", "metadata", "mu", "material", "cd", "mb", "hd", "MD", "dig", "ma", "mn", "mc", "mm", "grad", "mk", "de", "msg", "ld", "mac", "sam", "med", "bd", "df", "dh"], "raw": ["extra", "all", "buf", "shared", "empty", "value", "text", "random", "known", "unknown", "cooked", "custom", "clean", "stream", "pad", "buffer", "message", "available", "read", "right", "unsigned", "partial", "bytes", "input", "out", "valid", "hex", " Raw", "pack", "encrypted", "aw", "RAW", " RAW", "r", "bar", "full", "n", "row", "Raw", "data"], "hash": ["handle", "mask", "json", "tr", "value", "ash", "Hash", "serial", "h", "bh", "sum", "tag", "sha", "flash", "shadow", "code", "ASH", "message", "result", "url", "sh", "str", "has", "total", "sign", "hex", "search", "proof", "href", "key", "html", "string", "hat", "password", "mac", "ssh", "id", "print"]}}
{"id1": "14783950", "id2": "9096314", "code1": "    public static void compressWithZip(Vector fileList, String zipFileName) throws IOException {\n        if (fileList == null || fileList.size() == 0) return;\n        FileOutputStream fos = new FileOutputStream(zipFileName);\n        ZipOutputStream zos = new ZipOutputStream(fos);\n        Iterator iter = fileList.iterator();\n        while (iter.hasNext()) {\n            String fileName = (String) iter.next();\n            int ind = Math.max(fileName.lastIndexOf('/'), fileName.lastIndexOf('\\\\'));\n            String shortName = \"unknown\";\n            if (ind < fileName.length() - 1) shortName = fileName.substring(ind + 1);\n            zos.putNextEntry(new ZipEntry(shortName));\n            FileInputStream fis = new FileInputStream(fileName);\n            byte[] buf = new byte[10000];\n            int bytesRead;\n            while ((bytesRead = fis.read(buf)) > 0) zos.write(buf, 0, bytesRead);\n            fis.close();\n            zos.closeEntry();\n        }\n        zos.close();\n    }\n", "code2": "    private void handleNodeLostService(long eventID, long nodeID, String ipAddr, long serviceID, String eventTime) {\n        Category log = ThreadCategory.getInstance(OutageWriter.class);\n        if (eventID == -1 || nodeID == -1 || ipAddr == null || serviceID == -1) {\n            log.warn(EventConstants.NODE_REGAINED_SERVICE_EVENT_UEI + \" ignored - info incomplete - eventid/nodeid/ip/svc: \" + eventID + \"/\" + nodeID + \"/\" + ipAddr + \"/\" + serviceID);\n            return;\n        }\n        Connection dbConn = null;\n        try {\n            dbConn = DatabaseConnectionFactory.getInstance().getConnection();\n            if (openOutageExists(dbConn, nodeID, ipAddr, serviceID)) {\n                log.warn(\"\\'\" + EventConstants.NODE_LOST_SERVICE_EVENT_UEI + \"\\' for \" + nodeID + \"/\" + ipAddr + \"/\" + serviceID + \" ignored - table already  has an open record \");\n            } else {\n                PreparedStatement getNextOutageIdStmt = dbConn.prepareStatement(OutageManagerConfigFactory.getInstance().getGetNextOutageID());\n                long outageID = -1;\n                ResultSet seqRS = getNextOutageIdStmt.executeQuery();\n                if (seqRS.next()) {\n                    outageID = seqRS.getLong(1);\n                }\n                seqRS.close();\n                try {\n                    dbConn.setAutoCommit(false);\n                } catch (SQLException sqle) {\n                    log.error(\"Unable to change database AutoCommit to FALSE\", sqle);\n                    return;\n                }\n                PreparedStatement newOutageWriter = null;\n                if (log.isDebugEnabled()) log.debug(\"handleNodeLostService: creating new outage entry...\");\n                newOutageWriter = dbConn.prepareStatement(OutageConstants.DB_INS_NEW_OUTAGE);\n                newOutageWriter.setLong(1, outageID);\n                newOutageWriter.setLong(2, eventID);\n                newOutageWriter.setLong(3, nodeID);\n                newOutageWriter.setString(4, ipAddr);\n                newOutageWriter.setLong(5, serviceID);\n                newOutageWriter.setTimestamp(6, convertEventTimeIntoTimestamp(eventTime));\n                newOutageWriter.executeUpdate();\n                newOutageWriter.close();\n                try {\n                    dbConn.commit();\n                    if (log.isDebugEnabled()) log.debug(\"nodeLostService : \" + nodeID + \"/\" + ipAddr + \"/\" + serviceID + \" recorded in DB\");\n                } catch (SQLException se) {\n                    log.warn(\"Rolling back transaction, nodeLostService could not be recorded  for nodeid/ipAddr/service: \" + nodeID + \"/\" + ipAddr + \"/\" + serviceID, se);\n                    try {\n                        dbConn.rollback();\n                    } catch (SQLException sqle) {\n                        log.warn(\"SQL exception during rollback, reason\", sqle);\n                    }\n                }\n            }\n        } catch (SQLException sqle) {\n            log.warn(\"SQL exception while handling \\'nodeLostService\\'\", sqle);\n        } finally {\n            try {\n                if (dbConn != null) dbConn.close();\n            } catch (SQLException e) {\n                log.warn(\"Exception closing JDBC connection\", e);\n            }\n        }\n    }\n", "label": 0, "substitutes": {"compressWithZip": ["compressByFiles", "composeWithoutExt", "compresswithZip", "composeWithoutzip", "composeWithFiles", "compresswithExt", "compressWithoutExt", "compressWithoutFiles", "composeWithzip", "composeWithZip", "compresswithzip", "compressWithFiles", "compressWithExt", "compresswithFiles", "compressByExt", "composeWithoutZip", "compressWithoutZip", "compressByZip", "compressWithoutzip", "composeWithExt", "compressByzip", "compressWithzip", "composeWithoutFiles"], "fileList": [" fileL", "resourceList", "tileIterator", "wordIterator", "fileLock", "fileCode", "pageList", "fileIterator", " fileIterator", "resourceNames", "itemLock", "pageL", "resourceLock", " fileLIST", "fileSet", "ileL", "ileList", "fileLIST", "filelist", "tileSet", "pagelist", "tileList", "wordList", "wordLIST", " FileCode", " fileSet", " FileLIST", "pageCode", "tileLIST", " filelist", "wordSet", " fileLock", "fileNames", " FileSet", " fileNames", "ilelist", " fileCode", "pageLIST", "fileL", "pageSet", " FileList", "ileLIST", "itemNames", "itemList"], "zipFileName": ["zipFilenamename", "zFileFilename", "zFilename", "zipDirNames", "zipileName", " zipFilePath", " zipfileFilename", "zipfilePath", " zipFileFilename", "zFilenamename", "zipFilenameName", "zFilenamePath", "zFilenameFilename", "zipFilenameNames", " zipfileName", " zipFileNames", "zipDirName", "zipfileNames", "zFilePath", "zipDirFilename", "zipileFilename", "zipFilenamePath", "zipFilename", "zipFileNames", "zipfileName", " zipfileNames", "zipfileFilename", "zipDirPath", "zipfilename", "zFileName", "zipFileFilename", "zFilenameName", "zipFilePath", " zipfilePath", "zipilename", "zipFilenameFilename", "zipilePath"], "fos": ["flis", "Foss", "foss", "loos", "flos", "foos", "los", "loss", "wOS", "wos", " foos", "fOS", "lfis", "Fos", "lOS", "lfoos", "floos", "woss", " fOS", "Foos", "lfOS", "FOS", "lfos", "flOS", "woos"], "zos": ["ze", "zag", "Sax", "ss", "nz", "ses", "zon", "z", "rys", "webkit", "zin", "oss", "js", "zb", "jas", "ws", "sbm", "zen", "ess", "zh", "hz", "los", "iaz", "ps", "zo", "ossus", "less", "enos", "zes", "han", "os", "ez", "za", "enz", "iners", "bes", "cz", "zan", "css", "zu", "eros", "zzle", "zip", "zers", "zar", "rez", "ippers", "hess", "zik", "zer", "zero", "zi", "es", "sis"], "iter": ["exp", "ser", "oper", "tr", "ee", "izer", "reader", "Iter", "inter", "here", "inner", "maker", "liter", "orient", "vis", "train", "Iterator", "list", "re", "i", "its", "ptr", "ator", "coll", "ait", "outer", "valid", "it", "former", "walker", "ver", "li", "order", "iver", "ir", "gener", "iv", "iner", "ip", "fer", "iterator", "el", "ger", "ner", "er", "is", "where", "loc", "cer", "user", "loop", "loader", "ter", "kit", "ipper"], "fileName": ["ilePath", "ileSet", " filename", " fileNumber", "getStore", "tableSet", "shortStore", "fileNAME", "shortname", "getSource", "FileName", "FileCurrent", " filePath", "fSource", "getName", " fileSource", "localList", "FileNames", "localName", "ileString", "fieldname", " fileCurrent", "fileSet", "ileList", "fieldNAME", "FileString", "shortSource", " fileString", "ileBody", "ileNumber", "tablePath", "fileStore", "fieldName", "fileCurrent", "filename", "ilename", "fName", " fileSet", "tableName", "localname", "ileNAME", " fileStore", "fString", "fBody", "fname", "fileBody", "localNAME", "Filename", "filePath", "fileNames", "ileCurrent", "ileName", "fNames", "fNumber", " fileNames", "FilePath", "ileSource", " fileBody", "getname", "fileSource", "fileString", "fileNumber", "fieldList"], "ind": ["pred", "div", "dj", "find", "j", "dial", "inn", "roll", "d", "draw", "IND", "mod", "md", "red", "pl", "Ind", "mind", "stick", "butt", "wind", "i", "req", "ded", "ptr", "td", "inc", "bind", "pos", "cand", "cond", "sign", "ent", "cod", "seed", "cd", "hend", "num", "kind", "typ", "count", "n", "att", "ld", "loc", "index", "inder", "med", "nd"], "shortName": [" shortname", "fullString", "recentname", "shortname", "shortFilename", "recentCode", "smallname", "smallName", "recentName", "Shortname", "ShortKey", "ShortType", "recentFilename", "quickName", " shortKey", "quickString", "ShortString", "ShortName", "fullName", " shortString", "quickKey", "smallFilename", "shortCode", "fullname", " shortType", "shortKey", "shortString", "smallCode", "fullType", "ShortFilename", "ShortCode", "quickname", "shortType"], "fis": ["fi", "Fis", "ufi", "cfis", "fris", " fris", "ufis", "sfi", "his", "Fris", "wis", "cfois", "hi", " fIs", "sfis", "ufois", "wois", "pi", "ufris", "sfIs", "wIs", "wi", "pris", "FIs", "fois", "sfois", "fIs", "pis", "pois", "hris", "hois", "cfris", "ufIs", "cfi"], "buf": ["seq", "cv", "tr", "block", "br", "buff", "var", "img", "cat", "ref", "orig", "bl", "cb", "bed", "bc", "conv", "box", "mem", "bus", "wb", "buffer", "pkg", "bag", "b", "fam", "cur", "db", "aka", "fg", "bin", "Buffer", "uf", "rb", "tab", "cmd", "mu", "batch", "bar", "Buff", "cap", "msg", "temp", "arr", "fb", "vec", "bytes"], "bytesRead": ["postsFind", "blocksRead", "secondsWritten", "blocksWrite", "bytesLength", "usersLoad", "secondsWrite", "linesNeed", "secondsLoad", "flowsFind", "usersFind", "flowsLoad", "blocksWritten", "secondsRead", " bytesLoad", "bytesLoad", "bytesFind", " bytesWritten", "flowsReady", "flowsRead", "bytesWritten", "BytesRead", "postsRead", " bytesWrite", "linesLength", "BytesLength", "usersRead", "linesWritten", " bytesLength", "bytesReady", "postsReady", "BytesWritten", "bytesNeed", "blocksLoad", " bytesNeed", "postsLoad", "bytesWrite", "BytesNeed", "linesRead", "usersReady"]}}
{"id1": "3558512", "id2": "6988216", "code1": "    public void serialize(OutputStream out) throws IOException, BadIMSCPException {\n        ensureParsed();\n        ZipFilePackageParser parser = utils.getIMSCPParserFactory().createParser();\n        parser.setContentPackage(cp);\n        if (on_disk != null) on_disk.delete();\n        on_disk = createTemporaryFile();\n        parser.serialize(on_disk);\n        InputStream in = new FileInputStream(on_disk);\n        IOUtils.copy(in, out);\n    }\n", "code2": "    public void testSimpleQuery() throws Exception {\n        JCRNodeSource dummySource = (JCRNodeSource) resolveSource(BASE_URL + \"users/alexander.klimetschek\");\n        assertNotNull(dummySource);\n        OutputStream os = ((ModifiableSource) dummySource).getOutputStream();\n        assertNotNull(os);\n        String dummyContent = \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?><user><id>alexander</id><teamspace>cyclr</teamspace><teamspace>mindquarryTooLong</teamspace></user>\";\n        os.write(dummyContent.getBytes());\n        os.flush();\n        os.close();\n        JCRNodeSource source = (JCRNodeSource) resolveSource(BASE_URL + \"users/bastian\");\n        assertNotNull(source);\n        os = ((ModifiableSource) source).getOutputStream();\n        assertNotNull(os);\n        String content = \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?><user><id>bastian</id><teamspace>mindquarry</teamspace></user>\";\n        os.write(content.getBytes());\n        os.flush();\n        os.close();\n        QueryResultSource qResult = (QueryResultSource) resolveSource(BASE_URL + \"users?/*[.//user/teamspace='mindquarry']\");\n        assertNotNull(qResult);\n        Collection results = qResult.getChildren();\n        assertEquals(1, results.size());\n        Iterator it = results.iterator();\n        JCRNodeSource rSrc = (JCRNodeSource) it.next();\n        InputStream rSrcIn = rSrc.getInputStream();\n        ByteArrayOutputStream actualOut = new ByteArrayOutputStream();\n        IOUtils.copy(rSrcIn, actualOut);\n        rSrcIn.close();\n        assertEquals(content, actualOut.toString());\n        actualOut.close();\n        rSrc.delete();\n    }\n", "label": 1, "substitutes": {"serialize": ["erialate", " serialized", "serialization", "finalized", "Serialize", "finalize", "Serialization", "finalization", "initialze", "serializer", "serialate", " serialate", " serializer", "initialization", "finalze", "Serialze", "initialize", "Serialized", "initialized", "serialze", "Serialate", "erializer", "erialize", "serialized", "erialized", "Serializer"], "out": ["f", "report", "output", "res", "d", "sum", "stream", "t", "c", "log", "err", "b", "to", "result", "up", "v", "i", "serv", "os", " OUT", "OU", "ch", "it", "sw", "ou", "outs", "aos", "o", "n", "io", "Out", "file", "pool", "OUT", "p", "a", "w"], "parser": ["style", "worker", "tp", "bank", "layer", "util", "policy", "part", "rer", "builder", "reader", "tar", "processor", "base", "inner", "command", "pkg", "asser", "ker", "xml", "format", "ler", "now", "writer", "arser", "token", "jack", "aser", "proc", "walker", "per", "parse", "tree", "handler", "lp", "language", "instance", "magic", "ger", "manager", "er", "job", "file", "password", "Parser", "plan", "p", "loader", "peer"], "on_disk": ["On2link", "on2link", " on_volume", "on_disc", "On_Disk", "On_cloud", "on2file", "on_dis", " on_file", " on_Disk", " on_download", " on_dis", "On_disk", "On2file", "on2Disk", "on_Disk", "On2disk", "On_file", " on_disc", "On2Disk", "on_download", "on_link", "on2disk", "on_cloud", "on_file", "On_link", "on_volume"], "in": ["mi", "en", "rin", "inn", "and", "gin", "min", "IN", "vin", "ins", "on", "In", "inner", "inside", "i", "bin", "inc", "input", "sin", "it", " IN", " din", "ain", "ind", "r", "ad", "io", "din", "inf", "is", "isin", "body", "cin", "id", "from"]}}
{"id1": "21182766", "id2": "3024992", "code1": "    public static Properties load(String propsName) {\n        Properties props = new Properties();\n        URL url = ClassLoader.getSystemResource(propsName);\n        try {\n            props.load(url.openStream());\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return props;\n    }\n", "code2": "    @Test\n    public void testCopy_readerToWriter_nullIn() throws Exception {\n        ByteArrayOutputStream baout = new ByteArrayOutputStream();\n        OutputStream out = new YellOnFlushAndCloseOutputStreamTest(baout, true, true);\n        Writer writer = new OutputStreamWriter(baout, \"US-ASCII\");\n        try {\n            IOUtils.copy((Reader) null, writer);\n            fail();\n        } catch (NullPointerException ex) {\n        }\n    }\n", "label": 0, "substitutes": {"load": ["include", "process", "test", "loads", " reload", "create", "set", "append", "init", "link", "build", "store", "require", "open", "system", "read", "cache", "name", "get", "dump", "loaded", "construct", "parse", "pack", "Load", "define", "add", "use", "register", "download", "config", "save", "file", "check", "map", "loader"], "propsName": ["pepsname", "pepsFile", " propsname", "propsPath", "propsFile", "pevsPath", "propsStr", " propertiesname", " propertiesStr", "prorsname", "prorsPath", "propertiesFile", "propertiesname", "propertiesStr", "prorsFile", "pepsPath", "proPSFile", "prorsStr", "pevsFile", " propsFile", " propertiesName", "propertiesName", " propsStr", "proPSName", "provsPath", "prorsName", "proPSStr", "pepsName", "propsname", "provsName", "provsname", "pevsName", " propertiesFile", "provsFile", "proPSname", "proPSPath", "pevsname"], "props": ["prperties", "Prors", "prbes", "prcs", "provs", "schevs", "prept", "prebes", "propt", "preperties", "robbes", "schers", "robps", "Provs", " properties", " prors", "probes", " provs", "properties", "prpt", "scheperties", "scheps", " procs", "procs", "prors", "Props", "prrs", "robperties", "Procs", "prps", "Properties", "preps", "robpt"], "url": ["f", "browser", "address", "ref", "sb", "service", "resource", "obj", "ls", "ll", "context", "char", "build", "err", "sl", "open", "lr", "result", "rel", "ur", "mount", "uri", "URL", "cl", "str", "rl", "l", "this", "nl", "ul", "path", "http", "location", "config", "file", "loc", "Url", "gb", "user", "loader", "abs"]}}
{"id1": "5551393", "id2": "1862616", "code1": "    public static byte[] getMD5(String source) {\n        byte[] tmp = null;\n        try {\n            java.security.MessageDigest md = java.security.MessageDigest.getInstance(\"MD5\");\n            md.update(source.getBytes());\n            tmp = md.digest();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return tmp;\n    }\n", "code2": "    public static String fetch(String reference) throws IOException {\n        URL url = new URL(reference);\n        HttpURLConnection c = (HttpURLConnection) url.openConnection();\n        c.setRequestMethod(\"GET\");\n        c.setDoOutput(true);\n        c.setRequestProperty(\"Content-Type\", \"text/xml; charset=UTF-8\");\n        return parseISToString(c.getInputStream());\n    }\n", "label": 0, "substitutes": {"getMD5": ["getMD4", "getSHA3", "getMD3", "getmd2", " getMD3", "getMD2", " getMD2", "getSHA2", " getMD4", "getmd3", "getmd5", "getmd4", "getSHA4", "getSHA5"], "source": ["style", "image", "value", "text", "subject", "output", "sample", "resource", "sequence", "force", "site", "reason", "context", "base", "template", "spec", "message", "src", "filename", "content", "Source", "url", "name", "now", "target", "SOURCE", "input", "object", "seed", "ource", "space", "s", "string", "config", "start", "file", "body", "from", "data"], "tmp": ["buf", "attr", "txt", "nt", "bt", " mp", "cv", "lambda", "buff", "img", "cmp", "output", "test", "sp", "cb", "cont", "obj", "pp", "managed", "tar", "m", "MP", "foo", "Temp", "tt", "t", "po", "mobi", "mp", "bag", "perm", "bb", "pkg", "resp", "rup", "db", "aaa", "result", "src", "tn", "cp", "cache", "qq", "input", "out", "snap", "data", "np", "found", "etc", "jp", "mk", "msg", "temp", "gb", "p", "nd"], "md": [" Md", " MD", "nt", "sm", "pd", "ms", "and", "od", "di", "d", "der", "mt", "amd", "m", "mod", "red", "mp", "dr", "rm", "wd", "det", "dm", "sd", "td", "nd", "dd", "cmd", "mand", "mb", "cd", "hd", "MD", "ind", "ad", "mn", "desc", "mm", "pm", "mk", "de", "ld", "mac", "sam", "pdf", "bd", "df", "dh"]}}
{"id1": "20091126", "id2": "5237257", "code1": "    static File copy(File in, File out) throws IOException {\n        FileChannel inChannel = new FileInputStream(in).getChannel();\n        FileChannel outChannel = new FileOutputStream(out).getChannel();\n        try {\n            inChannel.transferTo(0, inChannel.size(), outChannel);\n            return out;\n        } catch (IOException e) {\n            throw e;\n        } finally {\n            if (inChannel != null) inChannel.close();\n            if (outChannel != null) outChannel.close();\n        }\n    }\n", "code2": "    private void download(String fileName) {\n        String filePath = Activator.showSaveDialog(fileName, new String[] { \".xls\" });\n        if (filePath != null) {\n            InputStream in = null;\n            OutputStream out = null;\n            try {\n                in = this.getClass().getResourceAsStream(\"/\" + fileName);\n                out = new FileOutputStream(filePath);\n                IOUtils.copy(in, out);\n            } catch (IOException ioe) {\n                Activator.showExceptionDialog(ioe);\n            } finally {\n                if (in != null) {\n                    try {\n                        in.close();\n                    } catch (IOException e1) {\n                        Activator.showExceptionDialog(e1);\n                    }\n                }\n                if (out != null) {\n                    try {\n                        out.close();\n                    } catch (IOException e1) {\n                        Activator.showExceptionDialog(e1);\n                    }\n                }\n            }\n        }\n    }\n", "label": 1, "substitutes": {"copy": ["cat", "y", "sync", "create", "Transfer", " Copy", "store", "Copy", "transfer", "write", "open", "delete", "load", "call", "to", "system", "cp", "get", "upload", "paste", "Cop", "download", "io", "save", "file", "map", "clone", "move"], "in": ["rin", "en", "inn", "ini", "gin", "IN", "ins", "In", "init", "inner", "old", "b", "up", "i", "inc", "l", "input", " din", "ck", " input", "ain", "ind", "r", "el", "mm", "n", "info", "io", "din", "inf", "isin", "source", "file", "cin", "id", "from"], "out": ["co", "_", "nt", "y", "output", "res", "w", "tmp", "t", "x", "one", "err", "log", "net", "b", "to", "c", " os", "write", "result", "ot", "end", "v", "e", "os", "l", "or", "it", "ch", "gt", "null", "ou", "s", "outs", "o", "at", " it", "channel", "self", "n", "io", "msg", "Out", "file", "as", "OUT", "p", "bytes", " output", "ex"], "inChannel": ["cinChannel", " inListener", "ginChain", "InConnection", "conChannel", "INChan", "cinCommand", "binCommand", "InChan", "inChan", "INConnection", "insideChannel", "outBlock", "inListener", "inChain", "binSection", "incChain", "insideCommand", "outCommand", "cinBlock", "insideRow", "inChuck", "incChannel", "InChannel", "innChan", "innChannel", "inCommand", "conListener", "binChannel", " inSection", " inConnection", "ginChannel", " inchannel", "INListener", " inRow", "innConnection", "incChuck", "binRow", "innchannel", "INChannel", "cinchannel", "conConnection", "ginChuck", "insideSection", "binChain", "inPanel", "incPanel", "binChuck", "inBlock", " inChan", " inBlock", "inConnection", "inchannel", "conChan", "inRow", " inCommand", "outchannel", "Inchannel", "inSection", "ginPanel", "binPanel"], "outChannel": ["Outchannel", " outMany", "outMany", "inChan", "inUser", "cmdChannel", "cosChannel", "OUTChan", "modulePassword", "skyGate", "cmdMany", "outGate", "outSlot", "OUTUser", "OutChannel", " outCh", " outGate", " outChan", "OutChan", "cosChan", "moduleManager", "cosSlot", "inCh", "skyChannel", "cosUser", " outManager", "skyMany", "OUTSlot", "outUser", "skyChan", "cmdChan", "outputManager", "outputPassword", "cmdGate", "inSlot", "OUTChannel", "moduleChannel", " outchannel", "inchannel", "outChan", "outputChannel", " outPassword", "moduleChan", "outManager", "outchannel", "OutCh", "outPassword", "outCh", "outputChan"]}}
{"id1": "15797402", "id2": "11933797", "code1": "    public void parse(InputStream stream, ContentHandler handler, Metadata metadata, ParseContext context) throws IOException, SAXException, TikaException {\n        String name = metadata.get(Metadata.RESOURCE_NAME_KEY);\n        if (name != null && wanted.containsKey(name)) {\n            FileOutputStream out = new FileOutputStream(wanted.get(name));\n            IOUtils.copy(stream, out);\n            out.close();\n        } else {\n            if (downstreamParser != null) {\n                downstreamParser.parse(stream, handler, metadata, context);\n            }\n        }\n    }\n", "code2": "    public static void CopyFile(String in, String out) throws Exception {\n        FileChannel sourceChannel = new FileInputStream(new File(in)).getChannel();\n        FileChannel destinationChannel = new FileOutputStream(new File(out)).getChannel();\n        sourceChannel.transferTo(0, sourceChannel.size(), destinationChannel);\n        sourceChannel.close();\n        destinationChannel.close();\n    }\n", "label": 1, "substitutes": {"parse": ["transform", "php", "handle", "process", "parser", "se", "resource", "execute", "create", "tag", "build", "write", "load", "slice", "interpret", "shape", "ping", "close", "xml", "format", "read", "dump", "split", "filter", "add", "use", "scale", "save", "apply", "patch", "map", "p", "print", "pe", "render"], "stream": ["event", "window", "handle", "response", "image", "output", "sample", "sync", "test", "console", "cont", "resource", "reader", "sequence", "clean", "Stream", "in", "chain", "buffer", "open", "document", "message", "stack", "content", "ream", "read", "url", "archive", "input", "upload", "form", "length", "instance", "iterator", "channel", "zip", "download", "http", "file", "source", "data"], "handler": ["event", "handle", "worker", "address", "ctx", "Handler", "policy", "callback", "parser", "service", "storage", "resource", "application", "reader", "h", "processor", "connection", "management", "function", "shape", "hander", "message", "host", "writer", "controller", "hand", "pool", "password", "wrapper", "loader", "server"], "metadata": ["adata", "handle", "json", "image", "dirty", "google", "ctx", "policy", "parts", "mt", "unknown", "details", "managed", "tar", "m", "general", "module", "mem", "met", "template", "md", "management", "basic", "document", "message", "hold", "xml", "property", "content", "detail", "properties", "td", "definition", "meta", "common", "data", "dd", "material", "java", "MD", "iterator", "manager", "info", "config", "still", "memory", "pdf", "header"], "context": ["event", "Context", "response", "ctx", "options", "dict", "frame", "resource", "sequence", "set", "reason", "module", "environment", "connection", "template", "chain", "ce", "command", "document", "current", "system", "stack", "content", "state", "condition", "sc", "component", "null", "network", "instance", "collection", "local", "location", "config", "usage", "translation", "cc"], "name": ["type", "all", "nm", "image", "value", "default", "named", "alias", "time", "part", "comment", "service", "resource", "description", "client", "on", "create", "reason", "names", "base", "label", "old", "current", "system", "family", "filename", "none", "url", "lower", "l", "NAME", "common", "nl", "len", "path", "term", "null", "ame", "channel", "local", "key", "n", "string", "no", "size", "source", "file", "body", "version", "id", "Name", "data", "prefix", "title", "pass"], "out": ["all", "lay", "co", "flush", "us", "con", "output", "cos", "res", "oss", "cn", "obj", "sys", "sum", "table", "col", "conv", "in", "po", "one", "net", "to", "list", "up", "conf", "v", "url", "serv", "writer", "external", "outer", "OU", "it", "cmd", "null", "ou", "aos", "outs", "o", "auto", "n", "io", "Out", "file", "OUT", "user", "print", "gen", "ex"]}}
{"id1": "18374478", "id2": "5836744", "code1": "    public void updateUser(final User user) throws IOException {\n        try {\n            Connection conn = null;\n            boolean autoCommit = false;\n            try {\n                conn = pool.getConnection();\n                autoCommit = conn.getAutoCommit();\n                conn.setAutoCommit(false);\n                final PreparedStatement updateUser = conn.prepareStatement(\"update users set mainRoleId=? where userId=?\");\n                updateUser.setInt(1, user.getMainRole().getId());\n                updateUser.setString(2, user.getUserId());\n                updateUser.executeUpdate();\n                final PreparedStatement deleteRoles = conn.prepareStatement(\"delete from userRoles where userId=?\");\n                deleteRoles.setString(1, user.getUserId());\n                deleteRoles.executeUpdate();\n                final PreparedStatement insertRoles = conn.prepareStatement(\"insert into userRoles (userId, roleId) values (?,?)\");\n                for (final Role role : user.getRoles()) {\n                    insertRoles.setString(1, user.getUserId());\n                    insertRoles.setInt(2, role.getId());\n                    insertRoles.executeUpdate();\n                }\n                conn.commit();\n            } catch (Throwable t) {\n                if (conn != null) conn.rollback();\n                throw new SQLException(t.toString());\n            } finally {\n                if (conn != null) {\n                    conn.setAutoCommit(autoCommit);\n                    conn.close();\n                }\n            }\n        } catch (final SQLException sqle) {\n            log.log(Level.SEVERE, sqle.toString(), sqle);\n            throw new IOException(sqle.toString());\n        }\n    }\n", "code2": "    public int read(String name) {\n        status = STATUS_OK;\n        try {\n            name = name.trim();\n            if (name.indexOf(\"://\") > 0) {\n                URL url = new URL(name);\n                in = new BufferedInputStream(url.openStream());\n            } else {\n                in = new BufferedInputStream(new FileInputStream(name));\n            }\n            status = read(in);\n        } catch (IOException e) {\n            status = STATUS_OPEN_ERROR;\n        }\n        return status;\n    }\n", "label": 0, "substitutes": {"updateUser": ["putUSER", "updateMe", "UpdateUser", " updateGroup", " updateOne", "updatePer", "updateCommon", "putCommon", "makeOne", "setPer", "makeUsers", "uploadUSER", "putUse", " updateUsers", "gePer", "updateUsers", "insertUsers", "insertGroup", "updateGroup", "uploadUser", "putMe", "UpdateGroup", "UpdateAccount", "makeByte", " updateUSER", "insertUser", "uploadCommon", " updateUse", "uploadUsers", "UpdateUsers", "updateuser", "uploaduser", " updateByte", "putByte", "putOne", "updateByte", "makeUser", "geUse", "updateUse", " updatePer", "putuser", " updateAccount", " updateuser", "setUser", "geUser", "putUsers", "geuser", "uploadUse", "putUser", "updateUSER", " updateMe", "updateAccount", "updateOne", "setUse", "insertAccount", " updateCommon", "uploadMe", "setuser"], "user": ["rule", "admin", "author", "report", "usr", "u", "item", "by", "util", "users", "word", "part", "resource", "other", "client", "usa", "sum", "table", "module", "base", "profile", "me", "char", "ud", "connection", "USER", "device", "message", "used", "result", "post", "up", "plugin", "re", "v", "content", "owner", "name", "get", "token", "valid", "order", "data", "per", "this", "object", "form", "record", "uid", "instance", "use", "add", "info", "row", "account", "key", "usage", "config", "job", "file", "password", "User", "ver", "version", "username", "update", "host", "display"], "conn": [" con", "ctx", "comm", "cb", "enc", "yn", "oc", "gate", "t", "port", "ns", "connection", "cons", "c", "err", "db", "rel", "conf", "gc", "pt", "cm", "bind", "out", "dt", "typ", "info", "n", "jp", "wp", "dc", "handle", "nt", "pub", "cat", "res", "pas", "cont", "bo", "obj", "lang", "col", "conv", "ce", "link", "net", "log", "ctr", "cur", "iw", "req", "act", "coll", "ch", "cmd", "priv", "connect", "ssl", "nc", "exec", "cc", "con", "cn", "ann", "addr", "open", "resp", "cert", "wd", "cp", "quote", "cf", "pool", "gen", "wr", "co", "tp", "oss", "mt", "client", "die", "pkg", "pg", "close", "org", "com", "ct", "Conn", "Connection", "apt", "wn", "cfg", "mc", "socket", "Con"], "autoCommit": ["autoActivlate", " autoCompe", "autoCompmit", "autoRemend", "AutoCommort", "autoCommcommit", "AutoCommit", "autoCommmit", "autoActivort", "autoRemmit", "autoCompend", "autoCollort", "anoCommlate", " autoCommmit", "autoCompit", "autoComlate", "autoDeblate", "anoActivmit", "autoCommlate", " autoComme", "AutoDebit", "autoComcommit", " autoCompmit", "anoActivit", "autoCommend", "anoCommmit", "autoComit", "autoCollcommit", "autoComort", "autoCommort", "autoActivmit", "autoQue", "autoQumit", "autoReme", " autoCompend", "AutoDebort", "autoQuit", "anoCommort", "autoDebit", "autoQuend", "autoCollmit", " autoCommend", "autoCompe", "autoActivit", "AutoDebmit", "autoComme", "anoActivort", "AutoCommcommit", "autoDebmit", "autoDebcommit", "autoCollit", "autoDebort", "anoActivlate", "autoRemit", " autoCompit", "AutoDebcommit", "anoCommit", "AutoCommmit"], "deleteRoles": ["deleteTanguages", "deleteNoles", "deleteRadoles", "deleteroles", "deleteGroups", "detailRanguages", " deleteRles", "deleteCorules", "deleteRoids", "deleteRles", "detailRules", "deleteResoids", " deleteResoids", "deleteGles", "deleteNols", "deleteGols", "deleteTules", "deleteCorroups", "detailCorules", "deleterules", "deleteRadles", "deleteResoles", " deleteResroups", "deleteGoles", "detailCorroups", "deleteCoroles", "detailRroups", "deleteErles", "deleteNles", "deleteResroups", "deleteRules", "deleteResols", "detailCoranguages", " deleteRroups", "detailCoroles", "deleteranguages", " deleteResols", " deleteRoids", "deleterroups", "deleteEroids", "deleteResles", "deleteTroups", " deleteRols", "deleteRols", "deleteRadoids", "detailRoles", "deleteRadols", " deleteResoles", "deleteNroups", "deleteRroups", "deleteErols", "deleteCoranguages", "deleteRanguages", "deleteEroles", " deleteResles", "deleteToles"], "insertRoles": ["insertCodes", "InsertRoles", "stepReploles", "insertRsrots", "deletePights", "insertLodes", "sequenceRobrots", "insertRsles", "insertRobels", "insertReships", "insertLoles", "insertGroups", "insertColes", "sequenceRoles", "insertGoles", "insertRobrots", "insertGodes", "stepReplodes", "insertNodes", "insertRsels", "deleteRights", "insertRiders", "insertRroups", "sequenceRoboles", "InsertRodes", "insertCows", "insertRights", "insertCights", "insertRodes", "insertResodes", "stepRroups", "deleteRows", "insertResles", "insertReploles", "insertResoles", "insertRsoles", "stepReplroups", "insertPoles", "insertRles", "insertRows", "stepRepliders", "insertNhips", "insertRels", "insertNoles", "insertGiders", "insertPodes", "deleteRodes", "insertRobles", "insertLroups", "insertReplroups", "sequenceRels", "insertPows", "sequenceRobles", "insertLiders", "insertRoboles", "InsertRhips", "insertRepliders", "stepRodes", "stepRiders", "stepRoles", "sequenceRobels", "InsertRles", "deletePodes", "insertPights", "insertReplodes", "deletePows", "deletePoles", "sequenceRles", "insertRrots", "sequenceRrots", "insertRhips", "insertNles"], "role": ["rol", "type", "rule", "hole", "rice", "tro", "zone", "block", "oval", "entry", "part", "word", "slave", "resource", "office", "feature", "ro", "tag", "col", "profile", "char", "ce", "range", "label", "cell", "family", "hero", "country", "rel", "node", "def", "right", "le", "aco", "rl", "r", "relation", "row", "te", "ole", "ule", "password", "Role", "pe", "peer"]}}
{"id1": "21092340", "id2": "9109613", "code1": "    public static URL addToArchive(Pod pod, ZipOutputStream podArchiveOutputStream, String filename, InputStream source) throws IOException {\n        ZipEntry entry = new ZipEntry(filename);\n        podArchiveOutputStream.putNextEntry(entry);\n        IOUtils.copy(source, podArchiveOutputStream);\n        podArchiveOutputStream.closeEntry();\n        return PodArchiveResolver.withinPodArchive(pod, filename);\n    }\n", "code2": "    public static void fileCopy(String from_name, String to_name) throws IOException {\n        File fromFile = new File(from_name);\n        File toFile = new File(to_name);\n        if (fromFile.equals(toFile)) abort(\"cannot copy on itself: \" + from_name);\n        if (!fromFile.exists()) abort(\"no such currentSourcepartName file: \" + from_name);\n        if (!fromFile.isFile()) abort(\"can't copy directory: \" + from_name);\n        if (!fromFile.canRead()) abort(\"currentSourcepartName file is unreadable: \" + from_name);\n        if (toFile.isDirectory()) toFile = new File(toFile, fromFile.getName());\n        if (toFile.exists()) {\n            if (!toFile.canWrite()) abort(\"destination file is unwriteable: \" + to_name);\n        } else {\n            String parent = toFile.getParent();\n            if (parent == null) abort(\"destination directory doesn't exist: \" + parent);\n            File dir = new File(parent);\n            if (!dir.exists()) abort(\"destination directory doesn't exist: \" + parent);\n            if (dir.isFile()) abort(\"destination is not a directory: \" + parent);\n            if (!dir.canWrite()) abort(\"destination directory is unwriteable: \" + parent);\n        }\n        FileInputStream from = null;\n        FileOutputStream to = null;\n        try {\n            from = new FileInputStream(fromFile);\n            to = new FileOutputStream(toFile);\n            byte[] buffer = new byte[4096];\n            int bytes_read;\n            while ((bytes_read = from.read(buffer)) != -1) to.write(buffer, 0, bytes_read);\n        } finally {\n            if (from != null) try {\n                from.close();\n            } catch (IOException e) {\n                ;\n            }\n            if (to != null) try {\n                to.close();\n            } catch (IOException e) {\n                ;\n            }\n        }\n    }\n", "label": 1, "substitutes": {"addToArchive": ["addInHarive", "addInArchFile", "addToArchFile", "addToHarZip", "addToExiver", "addToArchiver", "addInHariver", "addInHarZip", "addToHarFile", "addInArchZip", "addToZipFile", "addToHariver", "addInHarFile", "addInArchive", "addToArchZip", "addToZipiver", "addInArchiver", "addToZipive", "addToExive", "addToZipZip", "addToHarive", "addToExZip", "addToExFile"], "pod": ["report", "zone", "od", "policy", "poll", "task", "disk", "op", "table", "pad", "module", "spec", "pkg", "device", "message", "post", "cp", "pc", "pick", "archive", "top", "proc", "pack", "project", "component", "point", "ods", "ad", "Pod", "volume", "job", "wp", "start", "body", "check", "p", "ack"], "podArchiveOutputStream": ["podArchiveInputStreamer", "podArchiveStreamStream", "podArchiveOutputstream", "podArchiveStreamSync", "podArchiveOutSteam", "podArchiveOutputPoint", "podArchiveOUForm", "podArchiverInputstream", "podArchiveMainStreamer", "podArchiveInputContext", "podArchiverInputContext", "podArchiverInputStreamer", "podArchiveOUMap", "podArchiverInputForm", "podArchiveInputStream", "podArchiveOUSync", "podArchiveOutputSteam", "podArchiveInputstream", "podArchiverOutputSync", "podArchiverOutputPoint", "podArchiverInputSteam", "podArchiverInputMap", "podArchiveOUStream", "podArchiveoutputStream", "podArchiveoutputStreamer", "podArchiveStreamMap", "podArchiverOutputSteam", "podArchiverOutputMap", "podArchiveOutputForm", "podArchiveInputForm", "podArchiveOutPoint", "podArchiveInputSync", "podArchiveMainSteam", "podArchiveOutputSync", "podArchiveoutputForm", "podArchiverOutputstream", "podArchiveOutStream", "podArchiverOutputForm", "podArchiveInputSteam", "podArchiverOutputContext", "podArchiverOutputStreamer", "podArchiveMainForm", "podArchiveResourceStream", "podArchiveOutContext", "podArchiveOutputMap", "podArchiveEntryPoint", "podArchiveoutputSteam", "podArchiveEntryStream", "podArchiverInputStream", "podArchiverInputSync", "podArchiverOutputStream", "podArchiveOutputContext", "podArchiveStreamForm", "podArchiveEntrySteam", "podArchiveMainStream", "podArchiveInputPoint", "podArchiveResourcestream", "podArchiveResourceContext", "podArchiveOutputStreamer", "podArchiveOutstream", "podArchiveResourceSteam", "podArchiverInputPoint", "podArchiveInputMap"], "filename": ["nil", "txt", "nm", "subject", "p", "output", "original", "FILE", "release", "resource", "description", "fil", "fp", "names", "directory", "jpg", "message", "println", "ename", "family", "url", "uri", "name", "archive", "upload", "NAME", "FN", "png", "kl", "Filename", "path", "stem", "binary", "ame", "key", "location", "string", "file", "fn", "latest", "folder", "version", "username", "prefix", "title"], "source": ["series", "ser", "style", "image", "address", "select", "sample", "supp", "service", "resource", "view", "sequence", "force", "stream", "context", "inner", "template", "spec", "store", "src", "Source", "copy", "get", "SOURCE", "input", "proc", "sql", "seed", "ource", "component", "iterator", "use", "info", "start", "file", "password", "body", "shell", "loader", "from"], "entry": ["good", "nt", "element", "ie", "quick", "task", "comment", "word", "resource", "obj", "se", "set", "tmp", "ce", "connection", "char", "ment", "attribute", "link", "log", "system", "cell", "ace", "archive", "or", "ent", "ry", "query", "component", "enter", "record", "line", "sheet", "book", "channel", "zip", "Entry", "row", "key", "job", "file", "card", "data", "cue"]}}
{"id1": "11616716", "id2": "12783713", "code1": "    private static InputStream getCMSResultAsStream(String rqlQuery) throws RQLException {\n        OutputStreamWriter osr = null;\n        try {\n            URL url = new URL(\"http\", HOST, FILE);\n            URLConnection conn = url.openConnection();\n            conn.setDoOutput(true);\n            osr = new OutputStreamWriter(conn.getOutputStream());\n            osr.write(rqlQuery);\n            osr.flush();\n            return conn.getInputStream();\n        } catch (IOException ioe) {\n            throw new RQLException(\"IO Exception reading result from server\", ioe);\n        } finally {\n            if (osr != null) {\n                try {\n                    osr.close();\n                } catch (IOException ioe) {\n                }\n            }\n        }\n    }\n", "code2": "    @Override\n    public void sendErrorMessage(String message) throws EntriesException, StatementNotExecutedException, NotConnectedException, MessagingException {\n        if (query == null) {\n            throw new NotConnectedException();\n        }\n        ArrayList<String> recipients = query.getUserManager().getTecMail();\n        Mail mail = new Mail(recipients);\n        try {\n            ZipOutputStream zos = new ZipOutputStream(new FileOutputStream(\"log/ossobooklog.zip\"));\n            FileInputStream fis = new FileInputStream(\"log/ossobook.log\");\n            ZipEntry entry = new ZipEntry(\"ossobook.log\");\n            zos.putNextEntry(entry);\n            byte[] buffer = new byte[8192];\n            int read = 0;\n            while ((read = fis.read(buffer, 0, 1024)) != -1) {\n                zos.write(buffer, 0, read);\n            }\n            zos.closeEntry();\n            fis.close();\n            zos.close();\n            mail.sendErrorMessage(message, new File(\"log/ossobooklog.zip\"), getUserName());\n        } catch (Exception ex) {\n            ex.printStackTrace();\n        }\n    }\n", "label": 0, "substitutes": {"getCMSResultAsStream": ["getCMSResultAsSteam", "getCMSResultsasStream", "getCMSResultasSteam", "getCMSResultsAsStream", "getCMSResultsasString", "getCMSResultsasView", "getCMSResultasString", "getCMSResultasView", "getCMSResultsAsString", "getCMSResultsasSteam", "getCMSResultAsView", "getCMSResultsAsSteam", "getCMSResultAsString", "getCMSResultsAsView", "getCMSResultasStream"], "rqlQuery": [" rsqlStatement", "rqCommand", "rqlquery", "rqlCommand", "rQLquery", "RQLCommand", "rqQuery", "rsqlQuery", "rsqlStatement", "rviewquery", "RQLquery", "Rqlquery", "RQLQuery", " rsqlString", "rqquery", "rqStatement", "rviewQuery", "RqlCommand", " rsqlQuery", "RqlQuery", "rQLQuery", "rumbleStatement", "rqString", "rumbleQuery", "rqlStatement", " rqlStatement", "rQLCommand", " rqlString", "rumbleString", "rsqlString", "rviewCommand", "rqlString"], "osr": ["osrator", " oscr", "oeser", "iosq", "ossq", " osq", "osvr", "ioser", "iosrator", "osq", "osrw", "ossrw", "osssr", "oesmr", " osvr", "osesr", "ossvr", "oseser", "iosvr", "osmr", "possr", "oessr", "osrar", "posrator", "ooscr", "iossr", " osmr", " osrar", "ossh", "iosrg", "osd", " osh", "ooser", "osser", " ossr", "oosr", "ioscr", "iosr", "osesrw", "osscr", "oosd", "or", "osrg", "orar", "iosd", "oscr", "ossd", "ossrar", "ossmr", "ossr", "oesrw", "iosh", "oesr", "posr", "osesmr", "oesrator", "iosmr", " osrg", "ovr", "oser", "osh", "ossrg"], "url": ["hl", "gl", "dl", "lb", "client", "https", "bel", "ls", "web", "ll", "char", "link", "build", "net", "sl", "open", "pkg", "cert", "rel", "ur", "mount", "uri", "URL", "str", "l", "nl", "ul", "mail", "mb", "ol", "ssl", "el", "ret", "http", "ld", "loc", "il", "Url", "host", "abs"], "conn": ["canon", "nt", "win", "j", "ctx", "con", "res", "pas", "connected", "sync", "comm", "cn", "cb", "cont", "enc", "obj", "client", "sys", "col", "conv", "init", "ns", "connection", "link", "addr", "c", "open", "resp", "pg", "cert", "cur", "close", "rel", "org", "conf", "req", "cp", "ct", "act", "Conn", "os", "l", "out", "proc", "ch", "cmd", "syn", "connect", "nc", "jp", "n", "nw", "socket", "exec", "loc"]}}
{"id1": "18891988", "id2": "12055086", "code1": "    public static String getFile(String serviceName, String wsdlLocation, String endpoint) throws AxisFault {\n        mLog.debug(\"Downloading WSDL file from: \" + wsdlLocation);\n        mLog.debug(\"Received endpoint: \" + endpoint);\n        String fileLocation = null;\n        try {\n            String tempDir = System.getProperty(\"java.io.tmpdir\");\n            URL url = new URL(wsdlLocation);\n            String WSDLFile = tempDir + File.separator + serviceName + \".wsdl\";\n            String tmpWSDLFile = WSDLFile + \".tmp\";\n            File inputFile = new File(WSDLFile);\n            File tmpFile = new File(tmpWSDLFile);\n            if (!inputFile.exists() || inputFile.length() == 0) {\n                mLog.debug(\"Downloading the WSDL\");\n                inputFile.createNewFile();\n                InputStream in = url.openStream();\n                FileOutputStream out = new FileOutputStream(inputFile);\n                URLConnection con = url.openConnection();\n                int fileLength = con.getContentLength();\n                ReadableByteChannel channelIn = Channels.newChannel(in);\n                FileChannel channelOut = out.getChannel();\n                channelOut.transferFrom(channelIn, 0, fileLength);\n                channelIn.close();\n                channelOut.close();\n                out.flush();\n                out.close();\n                in.close();\n                Document tmpDocument = XMLUtils.newDocument(new FileInputStream(inputFile));\n                NodeList nl1 = tmpDocument.getElementsByTagName(\"wsdlsoap:address\");\n                for (int i = 0; i < nl1.getLength(); i++) {\n                    Node node1 = nl1.item(i);\n                    if (node1.getNodeName().equals(\"wsdlsoap:address\")) {\n                        ((Element) node1).setAttribute(\"location\", endpoint);\n                    }\n                }\n                FileOutputStream tmpOut = new FileOutputStream(tmpFile);\n                XMLUtils.DocumentToStream(tmpDocument, tmpOut);\n                tmpOut.flush();\n                tmpOut.close();\n                boolean retVal = inputFile.delete();\n                if (retVal) {\n                    retVal = tmpFile.renameTo(new File(WSDLFile));\n                }\n                mLog.debug(\"Return Value: \" + retVal);\n            } else {\n                mLog.debug(\"The WSDL is already at the ServiceProvider\");\n            }\n            fileLocation = WSDLFile;\n        } catch (MalformedURLException mx) {\n            mLog.error(\"MalformedURLException: \" + mx.getMessage() + \", cause: \" + mx.getCause().getMessage());\n            throw new AxisFault(mx.getMessage(), mx.getCause());\n        } catch (IOException ix) {\n            mLog.error(\"IOException: \" + ix.getMessage() + \", cause: \" + ix.getCause().getMessage());\n            throw new AxisFault(ix.getMessage(), ix.getCause());\n        } catch (ParserConfigurationException px) {\n            mLog.error(\"ParserConfigurationException: \" + px.getMessage() + \", cause: \" + px.getCause().getMessage());\n            throw new AxisFault(px.getMessage(), px.getCause());\n        } catch (SAXException sx) {\n            mLog.error(\"SAXException: \" + sx.getMessage() + \", cause: \" + sx.getCause().getMessage());\n            throw new AxisFault(sx.getMessage(), sx.getCause());\n        }\n        return fileLocation;\n    }\n", "code2": "    protected static void copyDeleting(File source, File dest) throws IOException {\n        byte[] buf = new byte[8 * 1024];\n        FileInputStream in = new FileInputStream(source);\n        try {\n            FileOutputStream out = new FileOutputStream(dest);\n            try {\n                int count;\n                while ((count = in.read(buf)) >= 0) out.write(buf, 0, count);\n            } finally {\n                out.close();\n            }\n        } finally {\n            in.close();\n        }\n    }\n", "label": 1, "substitutes": {"getFile": ["createfile", "getString", "GetFile", "selectFile", "getfile", "selectFilename", "createString", "selectString", "GetFilename", "getFilename", "createFilename", "GetString", "Getfile", "selectfile", "createFile"], "serviceName": ["serviceNames", "serviceFamily", "serviceType", "serverCode", "serviceCode", "libraryName", "libraryFamily", "ServiceNames", "ServiceCode", "ServiceName", "serverName", "libraryNames", " serviceNames", "ServiceType", " serviceFamily", " serviceCode", "serverType", " serviceType", "libraryType", "ServiceFamily"], "wsdlLocation": ["awsdlocation", "wssdlocation", "wlLocation", "wlPath", "wslLoc", "wsdURL", "wsDLlocation", "wslPath", "wssdLoc", "wlFolder", "wsdlLoc", "wdlLoc", "awsdlLocation", "wsollocation", "wssdURL", "awsolURL", "wsdLoc", "wsDLURL", "awsdlLoc", "awsdURL", "wssdFolder", "wslFolder", "wsolURL", "awsolLoc", "awsolLocation", "awsdLocation", "wsdlFolder", "wsolLocation", "wsDLLoc", "wssdPath", "wslLocation", "wsdlocation", "wlLoc", "awsollocation", "wssdLocation", "wsDLLocation", "wsdllocation", "wsDLPath", "wdlPath", "wdlLocation", "wsdlPath", "awsdlURL", "wdlFolder", "wsolLoc", "wsdlURL", "awsdLoc", "wsDLFolder", "awsdllocation", "wsdLocation"], "endpoint": ["beginPoint", "Endport", "bindpoints", "idpoint", " endpoints", "Endword", "idpoints", " endline", "bindpoint", "bindport", "endpoints", "beginpoints", " endport", "startline", "Endpoint", "beginpoint", "idline", "endport", "startword", "startpoint", "beginword", "endword", "endPoint", "EndPoint", "endline", "bindPoint", " endPoint", "startPoint", "idPoint", "Endpoints", "startpoints"], "fileLocation": ["FileLocation", "fileLoc", "documentPosition", "FilePosition", "documentLoc", " filelocation", "Filelocation", " filePosition", "filelocation", " fileLoc", "FileLoc", "documentlocation", "documentLocation", "filePosition"], "tempDir": [" tempFolder", "TempPath", "TempUrl", "TempFolder", "TempDirectory", "tempDirectory", "tempPath", "Tempdir", " tempUrl", "tmpDir", "tempdir", " tempDirectory", "tempFolder", "tmpDirectory", "tmpFolder", " tempPath", "TempDir", "tmpdir", "tmpUrl", "tmpPath", "tempUrl", " tempdir"], "url": ["f", "browser", "window", "gl", "dl", "service", "cr", "sur", "m", "https", "bel", "web", "ls", "ll", "base", "char", "link", "pl", "build", "sl", "open", "cert", "rel", "up", "ur", "mount", "re", "cp", "un", "uri", "URL", "str", "l", "nl", "ul", "mail", "li", "conn", "ctrl", "github", "r", "ssl", "ret", "http", "location", "socket", "job", "loc", "il", "Url"], "WSDLFile": ["WSDDLFILE", "WSDELfile", "WSDDLString", "WSDLLFilename", "WSDLLFILE", "WHDLFile", "WSDLSfile", "WSDLFilename", "WNDDLFILE", "WHDLfile", "WSDELFile", "WSDMLFile", "WNDDLFilename", "WNDLFilename", "WSDDLType", "WSDMLfile", "WNDLFile", "WSDQLFILE", "WSDLSString", "WIDLFile", "WSDLLType", "WIDDLType", "WSDELFilename", "WNDLFILE", "WSDDLfile", "WSDQLFile", "WSDLType", "WSDELFILE", "WSDMLFILE", "WNDDLFile", "WIDDLString", "WSDLLFile", "WIDDLfile", "WSDLString", "WSDLfile", "WSDDLFilename", "WHDDLfile", "WSDDLFile", "WSDLSType", "WIDLString", "WNDDLfile", "WSDLLString", "WIDDLFile", "WSDLLfile", "WSDQLfile", "WHDDLFile", "WIDLType", "WSDLSFile", "WSDLFILE", "WHDLFILE", "WHDDLFILE", "WNDLfile", "WIDLfile"], "tmpWSDLFile": ["tmpWSDLFilename", "tmpWIDDLFilename", "tmpWSDLFILE", "tmpWIDLFilename", "tmpWIDLFile", "tmpWSDLfile", "tmpWSDlfile", "tmpWSDDLFILE", "tmpWSDDLFilename", "tmpWSDLDFile", "tmpWSDLLFiles", "tmpWSDLLFilename", "tmpWSDLFiles", "tmpWNDLfile", "tmpWIDLFILE", "tmpWIDDLfile", "tmpWNDDLFilename", "tmpWNDLFile", "tmpWSDLLfile", "tmpWSDDLfile", "tmpWIDDLFile", "tmpWSDLDfile", "tmpWSDDLFiles", "tmpWNDLFilename", "tmpWSDDLFile", "tmpWIDLfile", "tmpWIDDLFILE", "tmpWSDLDFilename", "tmpWSDLDFILE", "tmpWNDDLFile", "tmpWSDlFilename", "tmpWNDDLFiles", "tmpWSDLLFILE", "tmpWSDlFiles", "tmpWNDLFiles", "tmpWSDlFile", "tmpWNDDLfile", "tmpWSDLLFile"], "inputFile": ["tmpSourceFile", "tmpStream", " inputSourceFile", " inputfile", "InputStream", "inputStream", "interfacefile", "clientFile", "indexStream", "tmpFILE", " inputDo", "clientFiles", "outputfile", "errorfile", "tmpfile", "inputDo", "indexfile", "InputFiles", "outputFile", "errorStream", "indexFile", "InputDo", " inputPlace", "inputFILE", "intFiles", "inPath", " inputFiles", "inputFiles", "Inputfile", "outputFILE", " inputPath", "outputStream", "InputFile", "inputPlace", "inFile", "interfaceSourceFile", " inputFILE", "InputPath", "intFILE", "inputSourceFile", "indexFILE", "inputfile", "intFile", "clientFILE", "InputFILE", "clientPath", "inDo", "inputPath", "errorFILE", "interfacePlace", "errorFile", "tmpPlace", "interfaceFile", "infile", "intfile"], "tmpFile": ["inputFilename", "mpfile", " tmpfile", "tmpFILE", "tmpfile", "empFilename", "tempPath", "tempFilename", "empFile", "mpFile", "tmpFiles", "inputFILE", "mpFiles", "mpPath", "empFILE", "tempfile", "tempFILE", " tmpPath", " tmpFiles", "inputfile", "empfile", "tempFiles", "tempFile", "tmpPath", "tmpFilename"], "in": ["mi", "rin", "en", "inn", "ini", "IN", "ins", "cont", "ar", "ri", "ln", "client", "stream", "In", "t", "inner", "init", "c", "ic", "ai", "bin", "inc", "input", "sin", "it", "ch", "conn", "ain", "ind", "o", "r", "inv", "n", "io", "din", "inf", "is", "isin", "source", "file", "cin", "id", "from"], "out": ["all", "co", "en", "lock", "by", "output", "ao", "oss", "obj", "client", "on", "sys", "tmp", "conv", "t", "connection", "net", "we", "write", "c", "to", "log", "buffer", "conf", "cache", "writer", "os", "cm", "outer", "OU", "ch", "this", "conn", "null", "ou", "group", "outs", "at", "o", "aos", "inv", "auto", "ex", "n", "io", "Out", "file", "pool", "OUT", "can", "ne", "w"], "con": ["co", "acon", "win", "cos", "func", "cn", "ln", "ws", "conv", "connection", "cons", "CON", "c", "fc", "soc", "cur", "re", "un", "conf", "com", "cp", "ran", "sec", "Conn", "cm", "const", "login", "ch", "cone", "cal", "conn", "ain", "exc", "tc", "num", "connect", "nc", "mc", "cf", "fn", "cin", "can", "Con"], "fileLength": ["FILELen", "fileFontSize", "objectLength", "fileSize", "ileLen", "FILELength", "fileLen", "objectSize", "ileLength", "fileDuration", " fileLen", "channelSize", "channelFontSize", " fileDuration", " fileSize", "channelLength", "ileDuration", "objectFontSize", "channelDuration", " fileFontSize", "objectDuration", "FILEDuration", "FILESize", "ileSize"], "channelIn": ["Channelin", "ChannelIN", "chanIN", "channelIN", "ChanneledIn", "channelSet", "consoleIN", " channelIN", "channelin", " channeledIn", "clientIn", "channeledIn", "consoleOut", "chanOut", "chanSet", "ChannelSet", "clientSet", "clientin", " channelin", "clientIN", "chanIn", "clientOut", "consoleIn", "consoleedIn", "ChannelOut", "ChannelIn"], "channelOut": ["chanConn", "Channelout", "consoleout", "ChannelConn", " channelout", " channelConn", "ChannelOUT", "courseout", "consoleOut", "chanOut", "consoleOUT", "channelConn", " channelOUT", "channelout", "courseOUT", "chanIn", "courseOut", "courseIn", "consoleIn", "chanout", "channelOUT", "ChannelOut", "ChannelIn"], "tmpDocument": ["mkdocument", "cpdocument", "tmDocument", " tmpMedia", "mpdocument", "npMedia", "tmdocument", "mkDocument", "tmpDoc", "tmDoc", " tmpDocuments", "tpDocument", "npFile", "tmpDocuments", "mpDocument", "tempdocument", " tmpdocument", "tmpdocument", "tpMedia", " tmpDoc", "tmpMedia", "mkDoc", "tpDocuments", "tpFile", "npDocument", "cpDocument", "npDocuments", "tempDoc", "cpDoc", "tempDocument", "mpDoc"], "nl1": ["ln0", "sol9", "rn6", "nr1", "lnOne", "NL2", "nel1", "nrOne", "rn1", "nr01", "nel3", "pelOne", "ln3", "pel1", "nl6", "pel01", "rnOne", "nelOne", "sol0", "nl2", "NL0", "ln6", "NL1", "ln1", "ln9", "nl0", "ln01", "nl01", "rn3", "nl9", "nel6", "nlOne", "sol2", "NL9", "ln2", "nl3", "sol1"], "i": ["mi", "span", "u", "j", "ini", "us", "y", "ms", "I", "ie", "qi", "di", "ri", "m", "ami", "init", "x", "hi", "me", "ti", "k", "bi", "cli", "ic", "multi", "ci", "ai", "sim", "gi", "ui", "v", "pi", "ij", "it", "ji", "li", "xi", "mu", "ims", "si", "\u0438", "ori", "o", "ip", "info", "n", "key", "io", "ii", "is", "index", "id", "a", "ix"], "node1": ["Node2", "n0", "node91", "Node1", " node0", "node2", "nOne", "Node001", "nodeOne", "node0", "Node0", "layer91", " node2", "n1", "componentOne", "layer1", " nodeOne", "ode0", "n91", "ode1", "ode2", "ode001", "layer0", "layerOne", "component0", "NodeOne", "component2", "node001", " node91", " node001", "component1"], "tmpOut": ["tmpObj", "tmpIn", "mpIn", "npIn", "TempOut", "empout", "mpObj", "tempIs", " tmpIs", " tmpObj", "tmpOUT", "npOut", "tmpIs", "mpOut", "tempout", "TempObj", "cmpIn", "TempOUT", "cmpOut", "empIs", "npObj", "tempOUT", "empOut", "tmpout", " tmpIn", "mpout", " tmpOUT", "TempIn", "cmpout", "tempObj", " tmpout", "tempIn", "npout", "tempOut"], "retVal": ["RetTrue", "RetVal", " retValue", "returnTrue", "RetValue", "retValue", "retval", " retTrue", "returnval", "retTrue", "returnValue", "returnVal", "Retval", " retval"]}}
{"id1": "8119563", "id2": "21531069", "code1": "    protected boolean checkLink(URL url) {\n        try {\n            URLConnection connection = url.openConnection();\n            connection.connect();\n            return true;\n        } catch (IOException e) {\n            MsgLog.error(\"DapParser.checkLink(): IOException: \" + e.toString());\n            return false;\n        }\n    }\n", "code2": "    public int updateuser(User u) {\n        int i = 0;\n        Connection conn = null;\n        PreparedStatement pm = null;\n        try {\n            conn = Pool.getConnection();\n            conn.setAutoCommit(false);\n            pm = conn.prepareStatement(\"update user set username=?,passwd=?,existstate=?,management=? where userid=?\");\n            pm.setString(1, u.getUsername());\n            pm.setString(2, u.getPasswd());\n            pm.setInt(3, u.getExiststate());\n            pm.setInt(4, u.getManagement());\n            pm.setString(5, u.getUserid());\n            i = pm.executeUpdate();\n            conn.commit();\n            Pool.close(pm);\n            Pool.close(conn);\n        } catch (Exception e) {\n            e.printStackTrace();\n            try {\n                conn.rollback();\n            } catch (SQLException e1) {\n                e1.printStackTrace();\n            }\n            Pool.close(pm);\n            Pool.close(conn);\n        } finally {\n            Pool.close(pm);\n            Pool.close(conn);\n        }\n        return i;\n    }\n", "label": 0, "substitutes": {"checkLink": ["processlink", "checklink", "openUrl", "checkLinks", "openlink", " checklink", "processUrl", "processLink", " checkLinks", "checkUrl", "openLinks", " checkUrl", "processLinks", "openLink"], "url": ["f", "all", "browser", "address", "ref", "dl", "email", "resource", "ll", "base", "char", "link", "build", "sl", "b", "cert", "xml", "ur", "uri", "URL", "name", "str", "rl", "l", "nl", "path", "ssl", "n", "http", "string", "location", "job", "server", "file", "Url", "print", "host"], "connection": ["ion", "generation", "response", "reference", "connected", "operation", "entry", "pointer", "city", "service", "way", "resource", "application", "description", "client", "category", "directory", "link", "command", "c", "net", "open", "function", "management", "message", "system", "number", "condition", "position", "statement", "Connection", "conn", "network", "connect", "database", "channel", "nc", "relation", "communication", "version", "session", "character"]}}
{"id1": "19206412", "id2": "11005804", "code1": "    public static String md5String(String str) {\n        try {\n            MessageDigest md;\n            md = MessageDigest.getInstance(\"MD5\");\n            md.update(str.getBytes());\n            byte[] hash = md.digest();\n            final char[] hexChars = { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f' };\n            StringBuffer res = new StringBuffer();\n            for (int i = 0; i < hash.length; i++) {\n                res.append(hexChars[(0xF0 & hash[i]) >> 4]);\n                res.append(hexChars[0x0F & hash[i]]);\n            }\n            return res.toString();\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n            return null;\n        }\n    }\n", "code2": "    public String kodetu(String testusoila) {\n        MessageDigest md = null;\n        try {\n            md = MessageDigest.getInstance(\"SHA\");\n        } catch (NoSuchAlgorithmException e) {\n            new MezuLeiho(\"Ez da zifraketa algoritmoa aurkitu\", \"Ados\", \"Zifraketa Arazoa\", JOptionPane.ERROR_MESSAGE);\n            e.printStackTrace();\n        }\n        try {\n            md.update(testusoila.getBytes(\"UTF-8\"));\n        } catch (UnsupportedEncodingException e) {\n            new MezuLeiho(\"Errorea kodetzerakoan\", \"Ados\", \"Kodeketa Errorea\", JOptionPane.ERROR_MESSAGE);\n            e.printStackTrace();\n        }\n        byte raw[] = md.digest();\n        String hash = (new BASE64Encoder()).encode(raw);\n        return hash;\n    }\n", "label": 1, "substitutes": {"md5String": ["md4String", "md4Str", "md5Str", "md2string", "md7String", "MD4Str", "md5Bytes", "md7Str", "MD5Str", "md4Bytes", "md4string", "MD4String", "MD4string", "md2String", "MD5String", "md2Str", "md5string", "md7string", "MD5string", "md7Bytes", "MD5Bytes", "md2Bytes", "MD4Bytes"], "str": ["wr", "txt", "oct", "tr", "br", "text", "vol", "piece", "sp", "cr", "enc", "obj", "t", "wcs", "char", "spec", "c", "cs", "b", "ctr", "cur", "Str", "v", "e", "name", "input", "out", "ch", "this", "st", "s", "r", "n", "string", "STR", "msg", "arr", "p", "print", "data", "w"], "md": [" Md", "nt", " sch", "sm", "bf", "ms", "pd", "vol", "od", " mac", " ms", "d", "di", "der", "mt", " cmd", "m", "mod", "sha", "me", "mg", "red", "del", "mp", "man", "dr", "det", "dm", "sd", " de", "def", " cd", "nd", "cond", "dd", "cmd", " img", "mand", "metadata", " dd", " def", "mail", "dir", "cd", "hd", "MD", "dig", "ind", "ad", "grad", " man", "mc", "mm", " df", "mn", "add", "html", "mk", "de", "exec", "ld", "mac", "bd", "df", "dh"], "hash": ["ashes", "ah", "all", "handle", "style", "stock", "ash", "her", "Hash", "match", "sample", "test", "h", "score", "sum", "esh", "here", "sha", "flash", "char", "dash", "hz", "log", "used", "result", "stack", "array", "cache", "node", "sh", "hed", "has", "total", "hex", "ch", "history", "search", "show", "height", "dig", "filter", "key", "oh", "html", "rh", "where", "mac", "check", "id", "map", "print", "host"], "hexChars": ["hexCHroups", "hexchaps", "exChaps", "hexChroups", " hexChables", "exChrs", "hexCHords", " hexChords", "hexChrs", "hexThrs", "hexchables", "hexchars", "hexchrs", "hexChords", " hexChroups", "exchaps", "hexChaps", "hexCars", "hexChables", "hexCaps", "hexCords", "hexCroups", "hexThaps", "hexThars", " hexChaps", "hexCrs", "hexThables", "exchrs", "hexCHars", "hexCHaps", " hexChrs", "exChars", "exchars"], "res": ["ser", "rc", "response", "fresh", "usr", "us", "vol", "reset", "ress", "rep", "next", "ins", "pas", "cr", "js", "fr", "sys", "bs", "cons", "red", "rest", "resh", "ber", "resp", "ps", "ts", "Res", "rem", "re", "result", "rel", "req", "rs", "RES", "sol", "rx", "expr", "pres", "pers", "r", "rex", "full", "ret", "gr", "rez", "rus", "pr", "results", "cs"], "i": ["series", "mi", "major", "span", "json", "u", "j", "ini", "us", "y", "z", "I", "qi", "di", "im", "gravity", "ei", "ri", "m", "iq", "ki", "t", "x", "in", "ti", "hi", "me", "k", "q", "bi", "c", "cli", "ic", "slice", "ci", "multi", "ai", "sim", "gi", "ui", "e", "v", "uri", "pi", "it", "ji", "li", "xi", "\u0438", "my", "si", "point", "ind", "o", "zi", "info", "n", "io", "ii", "is", "index", "id", "a", "ix", "ex"]}}
{"id1": "4629990", "id2": "21555906", "code1": "    private String logonToServer(FTPClient ftpClient, String ftpAddress, int noRetries) {\n        String remoteHomeDir = null;\n        noRetriesSoFar = 0;\n        while (true) {\n            try {\n                ftpClient.connect(ftpAddress, ftpPort);\n                int reply = ftpClient.getReplyCode();\n                if (!FTPReply.isPositiveCompletion(reply)) {\n                    ftpClient.disconnect();\n                    throw new IOException();\n                }\n                if (!ftpClient.login(user, password)) {\n                    throw new IOException();\n                }\n                remoteHomeDir = ftpClient.printWorkingDirectory();\n                msgEntry.setAppContext(\"logonToServer()\");\n                msgEntry.setMessageText(\"Logged into FTP server \" + ftpAddress + \":\" + ftpPort + \" as user \" + user);\n                logger.logProcess(msgEntry);\n                break;\n            } catch (IOException e) {\n                logoutAndDisconnect(ftpClient);\n                if (noRetriesSoFar++ < noRetries) {\n                    waitBetweenRetry();\n                    notifyAndStartWaitingFlag = false;\n                } else {\n                    notifyAndStartWaitingFlag = true;\n                    errEntry.setThrowable(e);\n                    errEntry.setAppContext(\"logonToServer()\");\n                    errEntry.setAppMessage(\"Unable to login after \" + (noRetriesSoFar - 1) + \" retries. Max Retries.\\n\" + \"Address:\" + ftpAddress + \"\\n\" + \"User:\" + user);\n                    errEntry.setSubjectSendEmail(\"Unable to login to \" + ftpAddress + \" after \" + (noRetriesSoFar - 1) + \" retries.\");\n                    logger.logError(errEntry);\n                    break;\n                }\n            }\n        }\n        return remoteHomeDir;\n    }\n", "code2": "    public void actionPerformed(ActionEvent ae) {\n        if (ae.getSource() == jbutton) {\n            try {\n                String toservlet = \"http://localhost:8080/direto-project/arquivos/teste.odt\";\n                URL servleturl = new URL(toservlet);\n                URLConnection servletconnection = servleturl.openConnection();\n                servletconnection.setDoInput(true);\n                servletconnection.setDoOutput(true);\n                servletconnection.setUseCaches(false);\n                servletconnection.setDefaultUseCaches(false);\n                DataInputStream inputFromClient = new DataInputStream(servletconnection.getInputStream());\n                inputFromClient.readByte();\n                OutputStream fos = new FileOutputStream(\"/home/danillo/arquivo_carregado.odt\");\n                byte[] buf = new byte[1024];\n                int bytesread;\n                while ((bytesread = inputFromClient.read(buf)) > -1) {\n                    fos.write(buf, 0, bytesread);\n                }\n                inputFromClient.close();\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        }\n    }\n", "label": 0, "substitutes": {"logonToServer": ["logonForClient", "logonTOSite", "logonTOClient", "logonToSite", "logOntoSite", "logOnToClient", "logOnToServer", "logOntoserver", "logOntoServer", "logontoServer", "logonToserver", "logonForServer", "logontoClient", "logOntoClient", "logOnToserver", "logonForserver", "logonTOServer", "logontoserver", "logonToClient", "logontoSite", "logonForSite", "logonTOserver", "logOnToSite"], "ftpClient": ["fttLib", "aftpResponse", "aftcpclient", "aftcpConnection", "ftpBuilder", "ftpLib", " fttpClient", "ftspClient", "aftcpServer", "ftpResponse", "fttpBuilder", "ftpConnection", "ftcpResponse", "aftcpClient", "ftcpConnection", "ftcpLib", " ftpBuilder", " fttpclient", "afttpConnection", " ftpLib", "ftcclient", "aftcpResponse", "fttpConnection", "ftcpClient", "aftpClient", "aftpConnection", " fttpBuilder", "fttpclient", "fttclient", "ftcpServer", " fttpLib", "aftpServer", "ftcpclient", "ftcpBuilder", "fftConnection", "fttpLib", "ftspServer", "fttClient", "fttResponse", "ftspclient", "ffpConnection", "afttpclient", "ftcConnection", " ftpclient", "fttpServer", "ftcResponse", "ftcClient", "afttpClient", "ftpclient", "fttConnection", "aftpclient", "fttBuilder", "fttpClient", "fftClient", "ffpClient", "ffpclient", "ftpServer", "fftclient"], "ftpAddress": ["ettpAdd", "ftrAdd", "ftfaddress", "ftPAddress", "aftpaddress", "etpAdd", "ftcpPath", "ftfPath", "ftpInterface", "ftrClient", "ftpeAddress", "ffpStreet", "aftpAddress", "aftpAdd", "ftpeaddress", "ftphaddress", "ftcpAddress", "ftpOrder", "ftfHost", "fttInterface", "etpAddress", "ftrAddress", "ftPInterface", " fttpPath", "ffcpStreet", "ftpHost", "ftpPort", "fttpHost", "fttpAdd", "ftcpClient", "fttpaddress", "fttpOrder", "aftpClient", "ftfPort", "ftphClient", "ftcpPort", "afttpAdd", "ftcpStreet", "ftraddress", "etpOrder", "ftpStreet", "ftcpAdd", "afttpaddress", " fttpAddress", "ftfAddress", " fttpPort", "fttpAddress", " ftpPort", " ftpaddress", "aftrClient", "ftpAdd", "aftrAddress", "ffpAddress", "fttpPath", "aftpHost", "etpaddress", "ffcpInterface", "ffcpAddress", "ftcpOrder", "afttpHost", "ftphAddress", "ftPStreet", "ffpInterface", "ftcpHost", "afttpAddress", "fttpPort", "aftrAdd", "ftcpInterface", "fttAddress", " ftpPath", "ftpeAdd", "fttStreet", "aftraddress", "ettpOrder", " fttpaddress", "ftpaddress", "ftpPath", "ftpeOrder", "ettpaddress", "ftcpaddress", "ettpAddress", "ftphAdd", "ftfAdd"], "noRetries": ["noretrys", "noreties", "NOretries", "noretry", "noTry", "NOretry", "noContries", "noRetorts", "noEntrys", "noContorts", "noEntries", " noReties", "noretorts", "noTries", "noReties", "NOreties", "noRetry", "NORetrys", "noEntorts", "NORetry", "noEntry", "noTrys", " noEntries", " noEntorts", " noRetorts", "noEnties", " noEnties", " noRetrys", "NOReties", "noRetrys", "noTies", " noEntrys", "noConties", "NORetries", "NOretrys", "noContrys", "noretries"], "remoteHomeDir": ["remoteHostRoot", " remoteHomeDirectory", "remoteRootDirectory", "RemoteHomePath", "remoteWelcomeDir", "remotehomeDirectory", "externalHomeDirectory", " remoteHomePath", "remoteWelcomePath", "RemoteRootRoot", "remoteRootPath", " remoteRootPath", "remotehomePath", "remoteHomedir", "externalHomedir", "remoteRootDir", "RemoteRootPath", "RemoteHomeDir", "remoteHomeRoot", "remoteRootRoot", "remoteHomeDirectory", "remotehomeDir", "remoteRootdir", "remotehomedir", "remoteWelcomeRoot", "remoteBaseDirectory", " remoteRootDirectory", "remoteHostPath", "remoteBaseDir", "remoteHomePath", "remoteHostDir", "externalHomeDir", "RemoteHomeRoot", " remoteRootDir", "remoteBasePath", "externalHomePath", "RemoteRootDir"], "noRetriesSoFar": ["noRetriesSoNear", "noRetriesPefar", "noRetriesSoobar", "noRetriesSOOld", "noRetriesTooFar", "noRetrysSoOld", "noRetriesTooNear", "noRetriesPeFar", "noRetriessoobar", "noRetriesOffNear", "noRetriessoMuch", "noRetriesTooobar", "noRetriesSofar", "noRetryssofar", "noRetriesToofar", "noRetrysSofar", "noRetriesSOfar", "noRetriesSOMuch", "noRetriesPeOld", "noRetriesSoOld", "noRetriesSoMuch", "noRetrysSoMuch", "noRetrysSOobar", "noRetriessoNear", "noRetriessoOld", "noRetryssoNear", "noRetriessofar", "noRetriessoFar", "noRetrysSoFar", "noRetriesOffFar", "noRetryssoOld", "noRetrysSoobar", "noRetrysSONear", "noRetriesOfffar", "noRetriesSOobar", "noRetrysSOFar", "noRetriesSOFar", "noRetrysSOMuch", "noRetrysSOfar", "noRetryssoFar", "noRetriesPeNear", "noRetriesSONear", "noRetrysSoNear"], "reply": ["echo", "report", "response", "address", "notice", "reset", "match", "next", "py", "part", "comment", "status", "code", "ply", "link", "consider", "write", "command", "message", "result", "close", " Reply", "number", "nb", "state", "error", "success", "ignore", "exit", "answer", "continue", "flag", "count", "info", "Reply", "job", "repl", "apply", "shell", "zero", "print", "power"]}}
{"id1": "8132219", "id2": "13852596", "code1": "    public static void copyFile(String inFile, String outFile) {\n        File in = new File(inFile);\n        File out = new File(outFile);\n        try {\n            FileChannel inChannel = new FileInputStream(in).getChannel();\n            FileChannel outChannel = new FileOutputStream(out).getChannel();\n            try {\n                inChannel.transferTo(0, inChannel.size(), outChannel);\n            } finally {\n                if (inChannel != null) inChannel.close();\n                if (outChannel != null) outChannel.close();\n            }\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        }\n    }\n", "code2": "    public void execute() {\n        try {\n            if (methods == null) {\n                return;\n            }\n            List<Resource> resources = new ArrayList<Resource>();\n            for (Iterator<Resource> i = classFiles.iterator(); i.hasNext(); ) {\n                final Resource classFile = i.next();\n                if (!classFile.getName().equals(CALLSTACK_FILE)) {\n                    try {\n                        InputStream inputStream = classFile.getInputStream();\n                        ClassReader reader = new ClassReader(inputStream);\n                        reader.accept(new MethodAnalyzer(), 0);\n                        resources.add(classFile);\n                        oldSize += classFile.getSize();\n                    } catch (IllegalStateException e) {\n                    }\n                }\n            }\n            for (Iterator<Resource> i = resources.iterator(); i.hasNext(); ) {\n                final Resource classFile = i.next();\n                try {\n                    InputStream inputStream = classFile.getInputStream();\n                    ClassReader reader = new ClassReader(inputStream);\n                    ClassWriter writer = new ClassWriter(reader, ClassWriter.COMPUTE_MAXS);\n                    if (!classFile.getName().startsWith(CALLSTACK_FILE.substring(0, CALLSTACK_FILE.indexOf('.')))) {\n                        reader.accept(new MethodInjector(writer), 0);\n                        byte[] b = writer.toByteArray();\n                        inputStream.close();\n                        OutputStream outputStream = classFile.getOutputStream();\n                        outputStream.write(b);\n                        outputStream.close();\n                        injectedClasses++;\n                    }\n                } catch (IllegalStateException e) {\n                }\n                newSize += classFile.getSize();\n            }\n            File classFile = new File(classFiles.getDir(), CALLSTACK_FILE);\n            if (!classFile.exists()) {\n                throw new BuildException(\"Missing net.yura.mobile.logging.CallStack class\");\n            }\n            InputStream inputStream = new FileInputStream(classFile);\n            ClassReader reader = new ClassReader(inputStream);\n            ClassWriter writer = new ClassWriter(reader, ClassWriter.COMPUTE_MAXS);\n            try {\n                reader.accept(new PushMethodGenerator(writer), 0);\n            } finally {\n                inputStream.close();\n            }\n            byte[] b = writer.toByteArray();\n            inputStream.close();\n            OutputStream outputStream = new FileOutputStream(classFile);\n            outputStream.write(b);\n            outputStream.close();\n            log(injectedClasses + \" classes injected\");\n            log((injectedMethods * 100) / Math.max(1, totalMethods) + \"% of methods injected\");\n            log((100 - ((oldSize * 100) / newSize)) + \"% code size increase\");\n        } catch (IOException e) {\n            log(e, 0);\n        }\n    }\n", "label": 1, "substitutes": {"copyFile": ["CopyFiles", "copyFiles", " copyfile", "CopyStream", " copyStream", " CopyStream", "copyfile", " Copyfile", " CopyFiles", "CopyFile", "copyStream", " CopyFile", "Copyfile", " copyFiles"], "inFile": ["inputFilename", "inFilename", "inputFile", "ninFilename", "inputName", "dinEmail", "inName", "ninName", "outFilename", "inPath", "dinFile", "innEmail", " inRow", "inTemplate", "dinPath", "inputTemplate", "innFile", "innRow", "ninFile", "innPath", "outTemplate", " inEmail", "inEmail", "inRow", "dinRow", "outName", " inPath", "ninTemplate"], "outFile": ["outFILE", "destfile", "inFilename", "outputfile", "ouFilename", " outfile", "outputFile", "destFILE", "outputTable", "outputFilename", "outfile", "destFormat", "outFilename", "ouFile", "outputFILE", "outputFormat", " outFILE", "ouFILE", "inFILE", "outTable", "destFile", "outFormat", " outFormat", "ouTable", "inTable"], "in": ["ze", "rin", "en", "inn", "ini", "irm", "gin", "IN", "ins", "on", "In", "init", "inner", "old", "ic", "ai", "up", "i", "bin", "inc", "input", "sin", "it", " din", "ir", " input", "ain", "s", "ind", "o", "el", "info", "din", "inf", "is", "isin", "source", "cin", "id", "from"], "out": ["all", "co", "en", "by", "output", "res", "client", "w", "t", "one", "net", "c", "b", "to", "v", "e", "name", "os", "it", "gt", "ou", "at", "outs", "g", "o", "aos", "ex", "n", "io", "Out", "file", "OUT", "p", "can", "ne", "ot"], "inChannel": ["cinChannel", "cinStream", "innSlot", "inButton", "newCategory", "newPanel", "inChan", "inColumn", "sinCategory", "isinCase", " inHandler", "insideChannel", "outBlock", "isinCategory", " inButton", "insideHandler", "vinCase", "cinColumn", "cinBlock", "outConnection", "sinSlot", "inCase", "insideComponent", "cinComponent", "isinSlot", "inHandler", "innerChan", "cinHandler", "innChannel", "inComponent", "cinButton", "vinPanel", " inConnection", "ginChannel", " inComponent", " inchannel", "innerChannel", "newChannel", "innCategory", "vinCategory", "innerConnection", "sinStream", "ginCase", "sinColumn", "vinChannel", "inCategory", "inPanel", "outStream", "inBlock", "newCase", "outColumn", " inChan", "inConnection", "inSlot", "inchannel", "innerchannel", "outChan", "sinChannel", "sinCase", "sinBlock", "innCase", "insideButton", "isinChannel", "outchannel", "ginPanel", "inStream", "ginCategory"], "outChannel": ["nStream", "outputConnection", "nChan", "oChan", "inChan", "exChain", "outBlock", "exBlock", "outConnection", "OutChannel", " outCh", "oClient", "outChain", " outChan", "OutChan", "exChan", "nChannel", " outStream", "inPassword", " outChain", " outClient", "outPassword", "outStream", " outConnection", "OutConnection", " outchannel", "exChannel", "inchannel", "nchannel", "outChan", "outputChannel", "outputCh", "oPassword", " outPassword", "outchannel", "outClient", "inClient", "oChannel", " outBlock", "OutCh", "inStream", "outCh", "outputChan"]}}
{"id1": "14794404", "id2": "1097147", "code1": "    private String encryptPassword(String password) throws NoSuchAlgorithmException {\n        StringBuffer encryptedPassword = new StringBuffer();\n        MessageDigest md5 = MessageDigest.getInstance(\"MD5\");\n        md5.reset();\n        md5.update(password.getBytes());\n        byte digest[] = md5.digest();\n        for (int i = 0; i < digest.length; i++) {\n            String hex = Integer.toHexString(0xFF & digest[i]);\n            if (hex.length() == 1) {\n                encryptedPassword.append('0');\n            }\n            encryptedPassword.append(hex);\n        }\n        return encryptedPassword.toString();\n    }\n", "code2": "    public static String getMessageDigest(String[] inputs) {\n        if (inputs.length == 0) return null;\n        try {\n            MessageDigest sha = MessageDigest.getInstance(\"SHA-1\");\n            for (String input : inputs) sha.update(input.getBytes());\n            byte[] hash = sha.digest();\n            String CPass = \"\";\n            int h = 0;\n            String s = \"\";\n            for (int i = 0; i < 20; i++) {\n                h = hash[i];\n                if (h < 0) h += 256;\n                s = Integer.toHexString(h);\n                if (s.length() < 2) CPass = CPass.concat(\"0\");\n                CPass = CPass.concat(s);\n            }\n            CPass = CPass.toUpperCase();\n            return CPass;\n        } catch (NoSuchAlgorithmException e) {\n            throw new IllegalStateException(e.getMessage());\n        }\n    }\n", "label": 1, "substitutes": {"encryptPassword": ["decryptPass", "decryptPassword", "encryptionSecret", "decryptSecret", "encryptpassword", "encryptedpassword", "encryptedSecret", "decryptedPassword", "encryptSecret", "decryptpassword", "encipherPassword", "encryptionPassword", "encryptionPass", "decryptedpassword", "encryptedPass", "encryptionpassword", "encipherpassword", "decryptedPass", "decryptedSecret", "encryptPass", "encipherSecret", "encipherPass"], "password": ["phrase", "address", "value", "text", "reset", "entry", "email", "word", "description", "secret", "w", "shadow", "directory", "command", "attribute", "Password", "past", "message", "filename", "content", "wordpress", "number", "name", "token", "hash", "input", "login", "path", "sword", "database", "pattern", "padding", "key", "string", "user", "username", "data", "prefix", "pass"], "encryptedPassword": ["encryptedGuest", "installedAttribute", "updatedGuest", " encryptedGuest", "installedDatabase", "initializedConnection", "encryptedpassword", "finishedPassword", "updatedAttribute", "confirmedDatabase", "updatedpassword", "finishedpassword", "encryptedAttribute", "ryptedpassword", "coloredPassword", "encryptedStatement", "finishedGuest", " encryptedConnection", "encryptedDatabase", "updatedPassword", "updatedDatabase", "initializedDatabase", "encryptedDirectory", "confirmedpassword", " encryptedAttribute", "initializedPassword", "finishedDatabase", "coloredConnection", "initializedStatement", " encryptedDirectory", "confirmedPassword", "encryptedConnection", "updatedDirectory", "ryptedPassword", "ryptedDirectory", "installedDirectory", " encryptedpassword", "ryptedDatabase", "coloredStatement", "coloredDatabase", "installedPassword", "confirmedDirectory", " encryptedStatement", " encryptedDatabase"], "md5": ["MD25", " md25", " MD2", " Mdle", "MD7", "MD2", "MD5", " mdle", "MD3", "mdle", " md3", "dig5", " md2", " MD3", " Md5", "md7", "dig3", " md7", " md512", " MDle", " MD8", "md25", " Md8", "sha512", "sha5", "dig2", "MD512", "md8", " md8", "md3", "md512", "md2", "dig25", " Md3", "sha7", " MD5", "sha2"], "digest": ["mdester", "Digness", " digse", "hexEST", "hashester", "hashEST", "digests", "digse", "digum", "hashum", "Digester", "Digests", "Digum", " digests", "hexest", "mdEST", "hexness", "mdum", "Digse", "digEST", "mdest", "mdness", "hashested", "hashest", "Digested", "mdse", "hexested", "mdested", " digEST", "digested", "digness", "DigEST", "digester", "mdests", "Digest"], "i": ["mi", "major", "span", "u", "j", "z", "ski", "y", "I", "ie", "qi", "di", "im", "ri", "ei", "m", "iq", "yi", "conv", "init", "x", "t", "in", "ti", "hi", "q", "me", "err", "bi", "c", "b", "ic", "multi", "ci", "ai", "sim", "gi", "ui", "uri", "pi", "ij", "ix", "iter", "it", "ji", "li", "\u0438", "xi", "my", "si", "point", "ind", "o", "ip", "zi", "n", "key", "io", "gu", "is", "ii", "index", "id", "a", "phi"], "hex": ["exp", "pex", "hl", "oct", "txt", "solid", "json", "br", " Hex", "alpha", "tx", "serial", "h", "raw", "x", "flash", "sex", "print", "cert", "lit", "tex", "color", "ph", "com", "none", "sv", "sh", "def", "unsigned", "str", "hash", "des", "iter", "dump", "comp", "ch", "cmd", "form", "uint", "term", "mix", "rendered", "rex", "full", "zip", "kw", "html", "cf", "temp", "rh", "percent", "check", "xf", "ne", "ex"]}}
{"id1": "3266833", "id2": "13063241", "code1": "    public MotixFileItem(final InputStream is, final String name, final String contentType, final int index) throws IOException {\n        this.name = name;\n        this.contentType = contentType;\n        this.index = index;\n        this.extension = FilenameUtils.getExtension(this.name);\n        this.isImage = ImageUtils.isImage(name);\n        ArrayInputStream isAux = null;\n        final ByteArrayOutputStream out = new ByteArrayOutputStream();\n        try {\n            IOUtils.copy(is, out);\n            isAux = new ArrayInputStream(out.toByteArray());\n            if (this.isImage) {\n                this.bufferedImage = imaging.read(isAux);\n            }\n        } finally {\n            IOUtils.closeQuietly(out);\n            IOUtils.closeQuietly(isAux);\n        }\n        this.inputStream = new ArrayInputStream(out.toByteArray());\n    }\n", "code2": "    public static void copyFile(File src, File dest) throws IOException {\n        FileInputStream fis = new FileInputStream(src);\n        FileOutputStream fos = new FileOutputStream(dest);\n        java.nio.channels.FileChannel channelSrc = fis.getChannel();\n        java.nio.channels.FileChannel channelDest = fos.getChannel();\n        channelSrc.transferTo(0, channelSrc.size(), channelDest);\n        fis.close();\n        fos.close();\n    }\n", "label": 1, "substitutes": {"is": ["ois", "iris", "us", "parts", "Is", "fs", "sys", "bs", "isa", "ais", "init", "in", "bits", "i", "its", "serv", "get", "ris", "os", "IS", "has", "was", "isc", "isl", "lis", "s", "bis", "isf", "any", "info", "ists", "isi", "ios", "as", "isin", "iso", "iss", "sis"], "name": ["type", "admin", "handle", "image", "value", "default", "named", "alias", "part", "word", "description", "sequence", "create", "names", "in", "base", "template", "code", "current", "family", "filename", "number", "format", "i", "url", "position", "get", "NAME", "order", "this", "parent", "search", "path", "length", "term", "normal", "null", "ame", "local", "self", "n", "key", "location", "string", "info", "file", "size", "source", "body", "class", "id", "version", "Name", "data", "prefix", "title"], "contentType": ["messageLength", " contentLength", "messageType", "mediaQuery", "contentQuery", "Contenttype", "messagetype", "messageControl", " contenttype", "mediaControl", "contentUnit", "mediaTypes", "contentLength", "messageQuery", "ContentTypes", "ContentType", "ContentLength", " contentTypes", " contentControl", "fileType", "fileQuery", "messageTypes", "contentControl", "fileTypes", "mediaUnit", "mediaType", "fileLength", "contenttype", " contentUnit", "messageUnit", "mediatype", "contentTypes", "mediaLength"], "index": ["type", "access", "address", "image", "lock", "find", "value", "test", "fee", "depth", "sequence", "exclusive", "create", "axis", "x", "level", "code", "action", "open", "slice", "max", "list", "i", "Index", "number", "content", "position", "error", "success", "sort", "pos", "offset", "path", "length", "height", "si", "dx", "ind", "batch", "instance", "num", "count", "n", "row", "key", "info", "start", "size", "timeout", "id", "update", "prefix"], "extension": ["protend", "protension", "contention", "xtitude", "extention", "contitude", "xtention", "protention", "xtend", "extitude", "extend", "xtension", "protitude", "contension", "contend"], "isImage": ["isFile", "hasMedia", "wasFile", " isFile", "isaPhoto", "ISImage", "wasMedia", "wasImage", "needsimage", "needsMedia", "needsPhoto", "ISPhoto", "isoImage", " isItemImage", "hasFile", "hasImage", "areImage", "isItemImage", "areItemImage", "isPicture", "hasimage", "needsImage", "ISPicture", "needsFile", "isaPicture", " isMedia", "areMedia", "isoItemImage", "isoFile", "isoMedia", "isimage", "needsPicture", "isaImage", "isMedia", "isPhoto", "areFile", "ISimage", "isaimage", "wasimage"], "isAux": ["wasAult", "isAAxx", "isPaUX", "isAcux", "isiOAiox", "isOAaux", " isAaux", " isAx", "isinPaUX", "isiAux", "isAaux", " isAUX", "isOAult", "isAiox", "isiAuxe", "isCAuxe", "isauxe", "isinAaux", "isAult", "isAAUX", "isPaux", "isCAiox", "isAndUX", "isAx", "isCAux", "isCAx", "isAndux", "isNAux", "isAcx", "isOAUX", "isSAUX", "isAndaux", "isiAaux", "wasAxx", "wasAAult", "isiOAaux", "isNAmp", "isOAiox", "wasAAxx", "isiOAux", "isaaux", "isCAUX", "isSAmp", "isaiox", "isaux", "isinPaaux", "wasAUX", "isinPaux", "isOAux", "isAAux", "isAxx", "isAmp", "isAcUX", "isOAxx", " isCAx", "isiAiox", "wasAAux", "isiOAuxe", " isCAux", "isCAaux", "isinPamp", "isSAux", "isAcaux", "isNAaux", "isPamp", "isinAmp", "isSAaux", "wasAAUX", "isAUX", "isinAux", "isAuxe", "isPaaux", "isAAult", " isCAUX", "isAndx", "isinAUX", "isOAuxe", "wasAux", "isNAUX", " isCAaux"], "out": ["all", "ion", "co", "nt", "lock", "by", "vol", "output", "con", "cos", "res", "oss", "cn", "sys", "sum", "tmp", "conv", "t", "in", "port", "chain", "net", "we", "log", "b", "to", "go", "result", "list", "up", "v", "gc", " Out", "cache", "os", " OUT", "outer", "pos", "ent", "OU", "order", "it", "this", "conn", "null", "at", "batch", "o", "outs", "aos", "boot", "auto", "n", "io", "Out", "pool", "timeout", "OUT", "user", "p", "ex", " output", "w"], "bufferedImage": ["bufferredImages", "renderedImages", "renderedVideo", "bufferingImage", "bufferingimage", "buffererImages", "bufferedimage", "renderingImage", "renderedImage", "bufferredimage", "renderingImages", "renderedimage", "bufferredImage", "bufferingImages", "buffererImage", "bufferedVideo", "buffererimage", "bufferedImages", "bufferredVideo", "bufferingVideo", "renderingVideo", "buffererVideo", "renderingimage"], "inputStream": ["outputView", "outputStream", "InputStream", "InputView", "InputSteam", "currentStream", "Inputstream", "outputSteam", "outputstream", "currentSteam", "inputstream", "currentstream", "currentView", "inputSteam", "inputView"]}}
{"id1": "11082670", "id2": "22442270", "code1": "    @SuppressWarnings(\"unchecked\")\n    public List<Event> lookupFutureEvents(String groupIdentifier) throws GtugsException {\n        StringBuilder json = new StringBuilder();\n        String requestUrl = \"http://api.meetup.com/events.json/?group_urlname=\" + groupIdentifier + \"&key=\" + key;\n        try {\n            URL url = new URL(requestUrl.toString());\n            BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream()));\n            String inputLine;\n            while ((inputLine = in.readLine()) != null) {\n                json.append(inputLine);\n            }\n            in.close();\n        } catch (IOException e) {\n            throw new GtugsException(e);\n        }\n        List<Event> events = new ArrayList<Event>();\n        JSONObject jsonObj = (JSONObject) JSONValue.parse(json.toString());\n        JSONArray results = (JSONArray) jsonObj.get(\"results\");\n        for (int i = 0; i < results.size(); i++) {\n            JSONObject result = (JSONObject) results.get(i);\n            Event e = new Event();\n            e.setAttendeeCount(Integer.parseInt((String) result.get(\"rsvpcount\")));\n            e.setCity((String) result.get(\"venue_city\"));\n            e.setDescription((String) result.get(\"description\"));\n            e.setLatitude(Double.parseDouble((String) result.get(\"venue_lat\")));\n            e.setLongitude(Double.parseDouble((String) result.get(\"venue_lon\")));\n            e.setName((String) result.get(\"name\"));\n            Date myDate = null;\n            String time = (String) result.get(\"time\");\n            try {\n                myDate = meetupDateFormat.parse(time);\n                e.setStartTime(timeDateFormat.format(myDate));\n                e.setEndTime(timeDateFormat.format(myDate));\n                e.setStartDate(myDate);\n                e.setEndDate(myDate);\n                String tz = tzDateFormat.format(myDate);\n                if (tz != null && tz.startsWith(\"+\")) {\n                    tz = tz.substring(1);\n                }\n                e.setTimeZone(Integer.toString(Integer.parseInt(tz) / 100));\n            } catch (ParseException ex) {\n                ex.printStackTrace();\n                continue;\n            }\n            e.setState((String) result.get(\"venue_state\"));\n            StringBuilder addressBuilder = new StringBuilder();\n            if (result.get(\"venue_address1\") != null) {\n                addressBuilder.append((String) result.get(\"venue_address1\") + \" \");\n            }\n            if (result.get(\"venue_address2\") != null) {\n                addressBuilder.append((String) result.get(\"venue_address2\") + \" \");\n            }\n            if (result.get(\"venue_address3\") != null) {\n                addressBuilder.append((String) result.get(\"venue_address3\") + \" \");\n            }\n            if (result.get(\"venue_address4\") != null) {\n                addressBuilder.append((String) result.get(\"venue_address4\"));\n            }\n            e.setStreetAddress(addressBuilder.toString().trim());\n            e.setZipCode((String) result.get(\"venue_zip\"));\n            e.setUrl((String) result.get(\"event_url\"));\n            events.add(e);\n        }\n        return events;\n    }\n", "code2": "            @Override\n            public void handledRun() throws Throwable {\n                try {\n                    URL url = new URL(ONLINE_CLIENT_DATA + \"gamedata.xml\");\n                    BufferedReader br = new BufferedReader(new InputStreamReader(url.openStream()));\n                    int lastversion = 0;\n                    String readHeader1 = br.readLine();\n                    String readHeader2 = br.readLine();\n                    String[] parts = readHeader2.split(\" \");\n                    lastversion = new Integer(parts[1]);\n                    GameDatabase.loadVersion();\n                    if (GameDatabase.version < lastversion) {\n                        Logger.log(LogTypes.LOG, \"Downloading new gamedata\");\n                        BufferedOutputStream bo = null;\n                        File destfile = new File(GameDatabase.dataFilePath);\n                        if (!destfile.createNewFile()) {\n                            destfile.delete();\n                            destfile.createNewFile();\n                        }\n                        bo = new BufferedOutputStream(new FileOutputStream(destfile));\n                        bo.write((readHeader1 + \"\\n\").getBytes());\n                        bo.write((readHeader2 + \"\\n\").getBytes());\n                        int readedbyte;\n                        while ((readedbyte = br.read()) != -1) {\n                            bo.write(readedbyte);\n                        }\n                        bo.flush();\n                        try {\n                            br.close();\n                            bo.close();\n                        } catch (Exception ex) {\n                            Logger.log(ex);\n                        }\n                    }\n                } catch (java.net.UnknownHostException unknownHost) {\n                    Logger.log(\"Sourceforge is down, cannot update gamedata\");\n                } catch (Exception e) {\n                    JOptionPane.showMessageDialog(FrameOrganizer.getClientFrame(), \"The gamedata is outdated, but Coopnet couldn't update it!\", \"Gamedata outdated\", JOptionPane.INFORMATION_MESSAGE);\n                    throw e;\n                } finally {\n                    GameDatabase.loadVersion();\n                    GameDatabase.load(\"\", GameDatabase.dataFilePath);\n                    GameDatabase.detectGames();\n                }\n            }\n", "label": 1, "substitutes": {"lookupFutureEvents": ["lookUpFutureEvent", "lookupAsyncEvents", "lookupFutureEvent", "lookupAsyncServices", "lookupPastServices", "lookupLatestEvents", "lookUpAsyncEvents", "lookUpFutureServices", "lookupFutureServices", "lookUpFutureEvents", "lookupAsyncEvent", "lookupPastEvent", "lookupAsyncUsers", "lookupPastEvents", "lookupLatestEvent", "lookUpAsyncUsers", "lookupLatestUsers", "lookupFutureUsers", "lookupPastUsers", "lookupLatestServices", "lookUpFutureUsers", "lookUpAsyncServices", "lookUpAsyncEvent"], "groupIdentifier": ["groupSpecificifer", "groupSpecifier", "groupSpecification", "groupIdificate", "groupIdentification", "groupIdentifiers", "groupSpecifiers", " groupIdentifer", " groupIdentificate", " groupIdification", "groupSpecificification", "groupidentifiers", " groupIdifier", "groupIdifer", " groupidentificate", " groupidentification", " groupIdentification", "groupIdification", " groupidentifier", "groupidentificate", "groupIdentifer", "groupIdifier", "groupIdifiers", "groupSpecificifier", " groupIdifer", "groupSpecificificate", " groupidentifer", "groupidentifier", "groupidentification", " groupIdifiers", "groupIdentificate", "groupSpecifer", " groupIdentifiers", "groupidentifer"], "json": ["csv", "report", "response", "j", "son", "params", "request", "js", "details", "raw", "status", "jj", "log", "print", "human", "stats", "document", "message", "journal", "javascript", "join", "alert", "xml", "list", "format", "gc", "properties", "sv", "state", "now", "pi", "total", "kj", "jack", "api", "hex", "it", "query", "sql", "note", "JSON", "metadata", "tree", "form", "batch", "network", "database", "zip", "lost", "string", "html", "pretty", "data"], "requestUrl": ["RequestWar", "requestWar", "serviceURL", " requestStr", "RequestURL", "RequestLink", "responseUr", "responseLink", "requestURL", "requestUr", "requestLink", "requestStr", "RequestUrl", "RequestStr", "serviceWar", "responseUrl", " requestWar", "responseURL", "serviceUrl", " requestUr", " requestURL", "RequestUr", " requestLink", "serviceStr"], "url": ["f", "browser", "address", "sb", "ref", "dl", "res", "resource", "web", "ll", "base", "char", "link", "build", "sl", "open", "b", "rel", "re", "ur", "mount", "uri", "URL", "get", "str", "l", "input", "nl", "ul", "mail", "github", "r", "ssl", "ret", "http", "socket", "io", "Url", "p", "host"], "in": ["f", "all", "inn", "and", "gin", "con", "IN", "mr", "ins", "ob", "reader", "ln", "on", "doc", "raw", "In", "inner", "buffer", "log", "b", "ic", "impl", "re", "conf", "bin", "get", "inc", "l", "input", "out", "iter", " din", "again", "line", "r", "ssl", "mc", "info", "io", "din", "er", "is", "isin", "file", "source", "body", "cin", "from"], "inputLine": ["outputLINE", "InputRow", " inputRow", "InputStream", "inputStream", "inputLINE", "firstRow", "outputline", "outputEntry", "InputLine", " inputStream", "configRow", "inputRow", "configLINE", "readRow", "outputRow", " inputEntry", "readLine", " inputLINE", "inputline", " inputCell", " inputline", "Inputline", "firstCell", "outputCell", "inputEntry", "readStream", "readline", "configEntry", "configLine", "inputCell", "firstline", "firstLine", "outputLine"], "events": ["services", "forms", "Events", "dates", "reports", "options", "assets", "versions", "rows", "items", "types", "tests", "views", "errors", "names", "issues", "devices", "ents", "actions", "history", "objects", "groups", "pages", "sections", "archives", "videos", "es"], "jsonObj": ["sonObject", "JSONObject", "jsonobj", "sonobj", "sonEx", "JSONCons", "javascriptObj", "JSONobj", "sonObj", "xmlObject", "JSONEx", " jsonEx", "javascriptObject", " jsonobj", "xmlCons", "javascriptCons", "JSONObj", "jsonEx", "xmlObj", " jsonObject", "jsonObject", "jsonCons", "xmlEx", "javascriptEx"], "results": ["terms", "forms", "photos", "vals", "games", "reports", "orders", "res", "assets", "RESULTS", "rows", "ms", "versions", "users", "items", "details", "idents", "artifacts", "roots", "tests", "docs", "lines", "errors", "runs", "ings", "finals", "issues", "ults", "its", "roads", "lists", "successful", "images", "blocks", "resources", "thumbnails", "products", "objects", "pages", "rates", "sections", "features", "values", "posts", "Results", "rings"], "i": ["f", "mi", "u", "ini", "j", "us", "y", "I", "qi", "di", "im", "ri", "ei", "m", "iq", "ki", "yi", "ami", "x", "hi", "me", "chain", "bi", "cli", "ic", "ci", "multi", "ai", "sim", "gi", "ui", "pi", "ij", "ix", "it", "ji", "li", "xi", "ori", "si", "batch", "o", "ip", "info", "io", "ii", "is", "index", "id", "print", "phi"], "result": ["rule", "first", "report", "response", "pair", "process", "product", "duration", "output", "entry", "match", "res", "test", "dict", "mate", "feature", "runtime", "details", "description", "currency", "status", "table", "reverse", "context", "profile", "done", "associated", "function", "document", "message", "primary", "detail", "successful", "success", "complete", "definition", "valid", "total", "true", "search", "answer", "record", "created", "relation", "full", "manager", "remote", "folder", "class", "latest", "wrapper", "data", "Result"], "e": ["event", "exp", "y", "oe", "ine", "h", "ei", "t", "me", "be", "ate", "c", "err", "ome", "ef", "re", "v", "or", "ent", "it", "ev", "el", "ed", "n", "er", "eff", "ne", "pe", "f", "en", "email", "se", "x", "ce", "ve", "one", "ade", "eur", "g", "eg", "ge", "es", "E", "ze", "u", "j", "entry", "et", "create", "ae", "b", "le", "s", "o", "de", "eu", "a", "eeee", "element", "ie", "ee", "d", "m", "die", "em", "ue", "entity", "l", "ec", "r", "te", "p", "ke", "end"], "myDate": ["myD", "morningD", "thisDat", "MyDay", "amiD", "miDate", "miEvent", "myWrite", "miDay", "myEvent", "thisDay", " myEvent", "morningWrite", "mysData", "myDay", "thisWrite", " myWrite", "mysTime", "mysEvent", "mineD", "amiWrite", " myCart", "mineCart", "mysDate", "amiDay", " myD", "mysUser", "miTime", " myDay", " myBody", "mysDay", "MYCart", "mineDate", "amiDat", " myTime", "amiBody", "MYTime", "MyDate", "MYD", "myData", "mineTime", "miUser", "miData", "amiDate", "myBody", " myUser", "myDat", " myDat", " myData", "myUser", "MyTime", "morningBody", "thisDate", "myTime", "morningDate", "MYDate", "myCart"], "time": ["type", "event", "ime", "year", "zone", "value", "text", "shift", "test", "runtime", "mt", "Time", "hour", "context", "t", "TIME", "trace", "tt", "template", "date", "code", "before", "c", "message", "timer", "join", "format", "name", "etime", "clock", "tc", "tim", "instance", "info", "string", "start", "timeout", "id", "tm", "data", "title"], "tz": ["zone", "z", "webkit", "tk", " td", " z", "etz", "tt", "ns", "Zone", " xx", "ts", " os", "hh", " dst", " zone", " zones", "os", "etime", "cond", "dt", " dd", "tc", "etc", "local", "loc", " ss", "tm", " ns"]}}
{"id1": "20623709", "id2": "4895903", "code1": "    public Long split(File targetDirectory, String prefix, long maxUnitBases, long maxUnitEntries) throws Exception {\n        if (!targetDirectory.exists()) {\n            if (!targetDirectory.mkdirs()) throw new Exception(\"Could not create target directory \" + targetDirectory.getAbsolutePath());\n        }\n        if (!size.isUnknown() && size.getBases() < maxUnitBases && (maxUnitEntries <= 0 || size.getEntries() < maxUnitEntries)) {\n            FileInputStream fis = new FileInputStream(this);\n            FileChannel fci = fis.getChannel();\n            FileOutputStream fos = new FileOutputStream(new File(targetDirectory, prefix + \"_0\" + \".fasta\"));\n            FileChannel fco = fos.getChannel();\n            ByteBuffer buffer = ByteBuffer.allocate(64000);\n            while (fci.read(buffer) > 0) {\n                buffer.flip();\n                fco.write(buffer);\n                buffer.clear();\n            }\n            fci.close();\n            fco.close();\n            return (long) 1;\n        } else {\n            long currentBasesCount = 0;\n            long currentEntriesCount = 0;\n            int targetCount = 0;\n            FileChannel fastaChannel = new FileInputStream(this).getChannel();\n            int totalSeqCount = 0;\n            long totalResiduesCount = 0;\n            try {\n                long prevTime = System.currentTimeMillis();\n                long fastaFileSize = this.length();\n                long fastaFileReadOffset = 0L;\n                long partitionStartOffset = 0L;\n                final int bufferSize = 1024 * 1024;\n                ByteBuffer fastaBuffer = ByteBuffer.allocateDirect(bufferSize);\n                int fastaReadState = FASTAFileTokenizer.UNKNOWN;\n                for (; fastaFileReadOffset < fastaFileSize; ) {\n                    long nBytes = fastaChannel.read(fastaBuffer);\n                    if (nBytes <= 0) {\n                        fastaBuffer.limit(0);\n                        break;\n                    } else {\n                        fastaBuffer.flip();\n                        fastaFileReadOffset += nBytes;\n                    }\n                    for (; ; ) {\n                        if (!fastaBuffer.hasRemaining()) {\n                            fastaBuffer.clear();\n                            break;\n                        }\n                        int b = fastaBuffer.get();\n                        if (b == '\\r') {\n                        } else if (b == '\\n') {\n                            if (fastaReadState == FASTAFileTokenizer.DEFLINE) {\n                                fastaReadState = FASTAFileTokenizer.SEQUENCELINE;\n                            }\n                        } else if (b == '>') {\n                            if (fastaReadState == FASTAFileTokenizer.UNKNOWN) {\n                                fastaReadState = FASTAFileTokenizer.STARTDEFLINE;\n                            } else if (fastaReadState == FASTAFileTokenizer.SEQUENCELINE) {\n                                fastaReadState = FASTAFileTokenizer.STARTDEFLINE;\n                            }\n                            if (fastaReadState == FASTAFileTokenizer.STARTDEFLINE) {\n                                if (currentBasesCount >= maxUnitBases || maxUnitEntries > 0 && currentEntriesCount >= maxUnitEntries) {\n                                    fastaBuffer.position(fastaBuffer.position() - 1);\n                                    long currentTime = System.currentTimeMillis();\n                                    System.out.println(new java.util.Date() + \" Partition \" + targetCount + \" containing \" + currentEntriesCount + \" sequences and \" + currentBasesCount + \" residues ends at \" + (fastaFileReadOffset - fastaBuffer.remaining()) + \" and was created in \" + (currentTime - prevTime) + \" ms\");\n                                    prevTime = currentTime;\n                                    long partitionEndOffset = fastaFileReadOffset - fastaBuffer.remaining();\n                                    FileChannel partitionChannel = new FileOutputStream(new File(targetDirectory, prefix + \"_\" + targetCount + \".fasta\")).getChannel();\n                                    nBytes = fastaChannel.transferTo(partitionStartOffset, partitionEndOffset - partitionStartOffset, partitionChannel);\n                                    partitionChannel.force(true);\n                                    partitionChannel.close();\n                                    targetCount++;\n                                    partitionStartOffset += nBytes;\n                                    currentBasesCount = 0;\n                                    currentEntriesCount = 0;\n                                    fastaReadState = FASTAFileTokenizer.UNKNOWN;\n                                } else {\n                                    fastaReadState = FASTAFileTokenizer.DEFLINE;\n                                    currentEntriesCount++;\n                                }\n                                totalSeqCount++;\n                            }\n                        } else {\n                            if (fastaReadState == FASTAFileTokenizer.SEQUENCELINE) {\n                                totalResiduesCount++;\n                                currentBasesCount++;\n                            }\n                        }\n                    }\n                }\n                if (partitionStartOffset < fastaFileSize) {\n                    long currentTime = System.currentTimeMillis();\n                    System.out.println(new java.util.Date() + \" Partition \" + targetCount + \" containing \" + currentEntriesCount + \" sequences and \" + currentBasesCount + \" residues ends at \" + (fastaFileSize) + \" and was created in \" + (currentTime - prevTime) + \" ms\");\n                    FileChannel partitionChannel = new FileOutputStream(new File(targetDirectory, prefix + \"_\" + targetCount + \".fasta\")).getChannel();\n                    fastaChannel.transferTo(partitionStartOffset, fastaFileSize - partitionStartOffset, partitionChannel);\n                    partitionChannel.force(true);\n                    partitionChannel.close();\n                    targetCount++;\n                }\n                if (size.isUnknown()) {\n                    size.setBases(totalResiduesCount);\n                    size.setEntries(totalSeqCount);\n                }\n            } finally {\n                fastaChannel.close();\n            }\n            return (long) targetCount;\n        }\n    }\n", "code2": "    public List load(String sourceType, Object source, String param) throws Exception {\n        if (log.isTraceEnabled()) {\n            log.trace(\"load \" + source);\n        }\n        String location = null;\n        String type = null;\n        Object inputsource = null;\n        if (source instanceof DynamicMBean) {\n            sourceType = \"MbeansDescriptorsDynamicMBeanSource\";\n            inputsource = source;\n        } else if (source instanceof URL) {\n            URL url = (URL) source;\n            location = url.toString();\n            type = param;\n            inputsource = url.openStream();\n            if (sourceType == null) {\n                sourceType = sourceTypeFromExt(location);\n            }\n        } else if (source instanceof File) {\n            location = ((File) source).getAbsolutePath();\n            inputsource = new FileInputStream((File) source);\n            type = param;\n            if (sourceType == null) {\n                sourceType = sourceTypeFromExt(location);\n            }\n        } else if (source instanceof InputStream) {\n            type = param;\n            inputsource = source;\n        } else if (source instanceof Class) {\n            location = ((Class) source).getName();\n            type = param;\n            inputsource = source;\n            if (sourceType == null) {\n                sourceType = \"MbeansDescriptorsIntrospectionSource\";\n            }\n        }\n        if (sourceType == null) {\n            sourceType = \"MbeansDescriptorsDigesterSource\";\n        }\n        ModelerSource ds = getModelerSource(sourceType);\n        List mbeans = ds.loadDescriptors(this, location, type, inputsource);\n        return mbeans;\n    }\n", "label": 0, "substitutes": {"split": ["scan", "process", "lock", "sync", "part", "disk", "share", "Split", "append", "write", "transfer", "open", "slice", "join", "seek", "format", "read", "copy", "align", "upload", "parse", "batch", "use", "count", "scale", "unit", "map"], "targetDirectory": [" targetMemory", "localdirectory", "localDir", "targetDirect", "localDirectory", "testLocation", "targetFile", "TargetDirect", "baseFile", "targetDir", "TargetFolder", "TargetDirectory", "Targetdirectory", "localFile", " targetDirect", " targetDir", " targetdirectory", "TargetDir", "baseDirectory", " targetLocation", "TargetMemory", "baseDir", "baseMemory", "testDirect", "testDir", " targetFile", "baseDirect", "targetFolder", "targetLocation", "testDirectory", "targetMemory", "baseFolder", " targetFolder", "TargetLocation", "basedirectory", "targetdirectory"], "prefix": ["type", " suffix", "p", "alias", "Pref", "FIX", "fix", "status", "tag", "PRE", "base", "directory", "template", "command", "pkg", "division", "filename", "format", "uri", "fixed", "name", "pi", "localhost", "ix", "this", "path", "fixes", "pres", "pre", "pattern", "padding", "key", "size", "password", "zero", "root", "index", "version", "username", "title"], "maxUnitBases": ["maxUnityAliias", "maxUnitChias", "maxUnitChades", "maxUnityBages", "maxUnitLages", "maxUnitBages", "maxUnitbades", "maxUnitAliases", "maxUnityLounds", "maxUnityAliounds", "maxUnitLounds", "maxUnitbias", "maxUnitBounds", "maxUnitLicas", "maxUnitAliounds", "maxUnityAliades", "maxUnitAliades", "maxUnitChicas", "maxUnitChages", "maxUnityAliases", "maxUnityBounds", "maxUnitBias", "maxUnityBades", "maxUnityBicas", "maxUnitLases", "maxUnityLases", "maxUnitChounds", "maxUnityLicas", "maxUnitBades", "maxUnityBias", "maxUnitChases", "maxUnitAliias", "maxUnityBases", "maxUnitReplases", "maxUnitReplicas", "maxUnitbases", "maxUnitBicas", "maxUnitReplounds", "maxUnitbounds", "maxUnityLages", "maxUnitReplages"], "maxUnitEntries": ["maxUnityentries", "maxUnitIntegrys", "maxUnitErries", "maxUnitEntryrys", "maxunitEntries", "maxunitEntrys", "maxUnityentrys", "maxUnitEntrys", "maxUnitEntryries", "maxUnitIntegries", "maxUnitEntires", "maxUnityEntrys", "maxUnitentires", "maxunitEntrs", "maxUnitentrs", "maxUnityEntries", "maxUnitEntryriers", "maxUnityEntrs", "maxUnitentries", "maxunitEntires", "maxUnityentrs", "maxUnitIntegriers", "maxUnityentires", "maxUnitentrys", "maxUnitErires", "maxUnitEntrs", "maxUnityEntires", "maxUnitErrys", "maxUnitEntriers", "maxUnitEntryires", "maxUnitIntegires", "maxUnitErrs"], "fis": ["fi", "Fis", "ifci", "fic", " fii", "Fic", "fii", "vis", " fi", " fic", "Fiss", "viss", "ifis", "fiss", "ific", "Fi", "Fci", "vi", "Fii", "vic", " fiss", "ifii"], "fci": ["mco", "cfai", " fico", "cfci", "Fis", "tco", "cfis", " fini", "Fico", " fai", "fcu", "fic", " fii", "mci", "cfic", "Fic", "Fco", "Fai", "fii", "cfini", " fic", "fai", "cfico", "tii", "tci", "fico", "fini", "cfco", "Fci", "mcu", "tcu", "Fini", "mii", " fcu"], "fos": ["Foss", "fbos", "yaos", " fbos", "wbos", "foss", " faos", "flos", "floss", "wios", "faos", "flaos", "yos", "wos", "fOS", "ybos", "Fos", " fOS", "fios", " fios", "Faos", " foss", "FOS", "waos", "flOS", "yios"], "fco": ["pco", "pci", "tco", "Fcon", " fcos", "foco", "fdo", "cco", "pso", "pcos", "Fco", "cso", "tdo", " fdo", " fso", "Fcos", "fso", "Fso", "cdo", " fcon", "Fdo", "tcos", "Fci", " foco", "fcon", "Foco", "toco", "ccon", "fcos"], "buffer": ["event", "phrase", "buf", "window", "pause", "block", "address", "buff", "flush", "match", "entry", "bridge", "sample", "reset", "callback", "comment", "sequence", "append", "table", "library", "limit", "template", "char", "command", "print", "function", "document", "message", "result", "stack", "read", "cache", "Buffer", "position", "black", "complete", "iter", "order", "note", "length", "queue", "binary", "batch", "record", "filter", "database", "channel", "padding", "row", "temp", "button", "source", "timeout", "memory", "index", "holder", "data"], "currentBasesCount": ["currentBasedCount", "currentBadesCount", "currentBasesLength", "currentBadesCode", "currentbasesLength", "currentbasesCount", "currentBasedCode", "currentBasesCode", "currentbaseLength", "currentBadesLength", "currentBaseCode", "currentBaseCount", "currentBaseLength", "currentBasedLength", "currentbaseCode", "currentbasesCode", "currentbaseCount"], "currentEntriesCount": ["currentEntrsFlag", "currentEntiesCount", "currentEntrysCount", "currentEntiesCode", "currentEntriesCode", "currentEntrsCount", "currentEntrysFlag", "currentEntriesFlag", "currentEntrsCode", "currentEntrysCode", "currentEntiesFlag"], "targetCount": ["TargetNum", "argetNum", "targetAmount", " targetAmount", " targetInfo", "argetCount", "targetInfo", " targetNum", "TargetCount", "argetAmount", "TargetInfo", "TargetAmount", "targetNum", "argetInfo"], "fastaChannel": ["fastaiChan", "fastaiStream", "fastityChan", "fastpaProvider", "fastityStream", "fastaStream", "fastoChannel", "fastpaChannel", "fastoProvider", "fastpaConnection", " fastaQueue", "fastoChan", " fastoChannel", "fastoStream", "fastityChannel", "fastaProvider", "fastaButton", " fastoChan", " fastoQueue", " fastoStream", "fastpaButton", " fastaButton", " fastaProvider", "fastaiChannel", "fastaConnection", " fastaConnection", "fastoConnection", " fastaChan", "fastoQueue", "fastityQueue", "fastoButton", "fastaQueue", "fastaChan", " fastaStream", "fastaiQueue"], "totalSeqCount": ["totalSeqCode", "totalSeqSize", "totalSegCount", "totalSeqsCount", "totalSeqsCounter", "totalSegSize", "totalSegCounter", "totalSeQSize", "totalSegCode", "totalSeqsCode", "totalSeQCode", "totalSeQCount", "totalSeQCounter", "totalSeqCounter", "totalSeqsSize"], "totalResiduesCount": ["totalResidueFlag", "totalResidusCount", "totalResidusFlag", "totalResiduesCode", "totalResIdueFlag", "totalResiduationsCount", "totalResIduesCount", "totalResidusCode", "totalResIduesFlag", "totalResIdueCount", "totalResiduationsFlag", "totalResidueCode", "totalResiduationsCode", "totalResidueCount", "totalResIduesCode", "totalResiduesFlag", "totalResIdueCode"], "prevTime": ["prevThread", "parTime", " prevT", "parThread", "parT", " previousTime", " previousThread", " prevThread", "prevT", " previousT"], "fastaFileSize": ["fastaChainSIZE", "fastaFilesSize", "fastATableName", "fastoTableSize", "fastaChainLength", "fastATableHeight", "fastaTableOwner", "fastaTableSIZE", "fastaTableHeight", "fastaTableSize", "fastoFileOwner", "fastoFileSIZE", "fastoTableOwner", "fastaFileHeight", "fastaChainSize", "fastaFileName", "fastaFilesHeight", "fastaReaderSize", "fastAFileSize", "fastafileOwner", "fastoFileLength", "fastaFilesName", "fastaChainOwner", "fastafileSIZE", "fastoFileSize", "fastaTableName", "fastaFileLength", "fastaTableLength", "fastaReaderLength", "fastaReaderName", "fastAFileName", "fastafileSize", "fastaFilesLength", "fastATableSize", "fastAFileHeight", "fastoTableSIZE", "fastoTableLength", "fastaReaderHeight", "fastATableLength", "fastaFileSIZE", "fastafileLength", "fastaFileOwner", "fastAFileLength"], "fastaFileReadOffset": ["fastaFileReadPos", "fastaFileLoadPos", "fastaFileWriteOffset", "fastaChainCurrentoffset", "fastaFileInputPosition", "fastaFileLoadAmount", "fastaFileReadLocation", "fastaFilesLoadLength", "fastaFileCurrentoffset", "fastaFileReadLength", "fastaFileInputoffset", "fastaFileCurrentOffset", "fastaChainReadOffset", "fastaFileReaderOffset", "fastaFileReadAmount", "fastaFileInputOrder", "fastaFilereadPos", "fastaChainReadPosition", "fastaFileLoadOrder", "fastaFilesReadOffset", "fastaFileInputLength", "fastaFileInputLocation", "fastaFileViewOffset", "fastaFileWriteLength", "fastaFileViewOrder", "fastaFileReadoffset", "fastaFileLoadLength", "fastaPageLoadOffset", "fastaFileReadOrder", "fastaFileCurrentPosition", "fastaPageLoadAmount", "fastaFileReaderPosition", "fastaFileInputAmount", "fastaChainCurrentPosition", "fastaFilesLoadOrder", "fastaFilereadAmount", "fastaPageReadPos", "fastaChainCurrentLocation", "fastaFileLoadOffset", "fastaFileReaderLocation", "fastaPageLoadOrder", "fastaFilesLoadAmount", "fastaFilereadOrder", "fastaChainReadoffset", "fastaFileCurrentLocation", "fastaFilereadOffset", "fastaFileViewPos", "fastaFilesReadOrder", "fastaFileWriteOrder", "fastaPageReadAmount", "fastaFileViewAmount", "fastaFileReaderoffset", "fastaFileReadPosition", "fastaPageReadOrder", "fastaChainReadLocation", "fastaFileInputOffset", "fastaFilesReadLength", "fastaFileWriteAmount", "fastaFilesReadAmount", "fastaPageReadOffset", "fastaFilesLoadOffset", "fastaChainCurrentOffset", "fastaPageLoadPos"], "partitionStartOffset": ["partitonStartOff", "partitonStartingPoint", "partitionStartPoint", "partitionDataOff", "partitionStartingPoint", "partitionEndPoint", "partitionStartingOff", "partitionStartPosition", "partitionEndPosition", "partitionStartingPosition", "partitionDataPoint", "partitionStartOff", "partitionDataOffset", "partitonStartOffset", "partitonStartPoint", "partitionEndOff", "partitonStartPosition", "partitionStartingOffset", "partitonStartingOffset", "partitonStartingOff", "partitonStartingPosition", "partitionDataPosition"], "bufferSize": ["BufferSize", "tableSIZE", "buffLength", "buffName", "BufferName", "BufferSIZE", " bufferLength", "bufferLength", "bufferName", "BufferLength", "bufSize", "bufSIZE", "tableSize", "sequenceLength", "bufferCode", "tableName", "sequenceCode", "tableLength", "buffSIZE", "sequenceSIZE", "sequenceSize", " bufferCode", " bufferSIZE", "buffSize", "bufferSIZE", "bufLength", "bufCode"], "fastaBuffer": ["fastcaCache", "FastaBuff", "fastasBuilder", "fastuBuff", "fastuBuffer", "wildanCache", " fastoQueue", "fastaMemory", "fastmaStore", "fastaDB", "FastmaRequest", "fastmaBuffer", "fastanCache", "fastasCache", "fastmaBuff", "fasteDB", "FastaRequest", "FastaBuffer", "fastsaBuff", " fastaBuilder", "fastasCounter", " fastaQueue", "fastasRequest", "fastasQueue", "fastoRequest", "fastaCounter", "wildanRequest", " fastoCounter", "FastmaBuffer", " fastaCache", "fastasStore", "FastaStore", "fastsaChannel", "fastalCounter", " fastaBuff", "FastmaStore", "fastuMemory", "wildaCache", "fastanBuff", "fastaBuff", " fastoBuff", "fastcaBuffer", " fastaCounter", "fastanRequest", "fastsaQueue", "fastoBuff", "wildanBuffer", "fastanBuffer", "wildaBuff", "fasteBuffer", "fastmaQueue", "fastoQueue", " fastaMemory", "fastoBuffer", "fastaCache", " fastoBuffer", "fastaQueue", "fastoCounter", "fastaRequest", "fastmaChannel", "FastmaBuff", "fastmaCache", "wildanBuff", "fasteMemory", "fastasBuffer", "fastuDB", "wildaRequest", "fastsaBuffer", "fastalBuffer", " fastaDB", "fasteBuff", "fastalQueue", "fastmaBuilder", "fastasBuff", "wildaBuffer", "fastmaRequest", "fastcaRequest", "fastaBuilder", "fastoStore", "fastcaBuff", "fastaStore", "fastalBuff"], "fastaReadState": ["fastaCurrentStatus", "fastaLoadState", "fastaCurrentSTATE", "fastaReaderSTATE", "fastoReaderState", "fastaReadType", "fastoReadStatus", "fastaReaderType", "fastoReadSTATE", "fastaLoadStatus", "fastoReaderSTATE", "fastaCurrentState", "fastaReadSTATE", "fastoReadState", "fastaReaderStatus", "fastaLoadSTATE", "fastoReaderStatus", "fastaReaderState", "fastoReadType", "fastaReadStatus", "fastaLoadType", "fastaCurrentType", "fastoReaderType"], "nBytes": ["nobytes", " nNs", "nBlocks", "noBytes", "noNs", "nsbytes", "nsBytes", " nKeys", "nKeys", "NItems", " nParts", "nNs", " nbytes", "Nbytes", " nBlocks", "numBlocks", "nsWords", "NParts", " nWords", "nbytes", " nItems", "nrBytes", "noBlocks", "NKeys", "NWords", "nWords", "nItems", "nrbytes", "numbytes", "nrItems", "nParts", "NBytes", "numBytes", "nrKeys", "numNs", "nsParts"]}}
{"id1": "13152325", "id2": "293167", "code1": "    public void loadExistingAntlibs(ClassLoader classLoader) {\n        URL antlibUrl;\n        URI antlibUri;\n        try {\n            Enumeration<URL> resources = classLoader == null ? ClassLoader.getSystemResources(antLibsResource) : classLoader.getResources(antLibsResource);\n            while (resources.hasMoreElements()) {\n                URL url = resources.nextElement();\n                InputStream stream = url.openStream();\n                BufferedReader reader = new BufferedReader(new InputStreamReader(stream, \"UTF-8\"));\n                for (String line = reader.readLine(); line != null; line = reader.readLine()) {\n                    String pkg = line.trim();\n                    URI uri = URI.create(\"antlib:\" + pkg);\n                    URI resource2antlib = URI.create(antLibsResource2root + pkg.replace('.', '/') + (pkg.isEmpty() ? \"\" : \"/\") + \"antlib.xml\");\n                    antlibUri = NetUtils.resolve(url.toURI(), resource2antlib);\n                    try {\n                        antlibUrl = antlibUri.toURL();\n                    } catch (IllegalArgumentException e) {\n                        System.err.println(\"base uri: \" + url);\n                        System.err.println(\"relativepath: \" + resource2antlib);\n                        System.err.println(\"target uri: \" + antlibUri);\n                        throw new RuntimeException(antlibUri.toString(), e);\n                    }\n                    loadAntLib(antlibUrl, uri);\n                }\n                reader.close();\n                stream.close();\n            }\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        } catch (URISyntaxException e) {\n            throw new RuntimeException(e);\n        }\n    }\n", "code2": "    public static void doVersionCheck(View view) {\n        view.showWaitCursor();\n        try {\n            URL url = new URL(jEdit.getProperty(\"version-check.url\"));\n            InputStream in = url.openStream();\n            BufferedReader bin = new BufferedReader(new InputStreamReader(in));\n            String line;\n            String version = null;\n            String build = null;\n            while ((line = bin.readLine()) != null) {\n                if (line.startsWith(\".version\")) version = line.substring(8).trim(); else if (line.startsWith(\".build\")) build = line.substring(6).trim();\n            }\n            bin.close();\n            if (version != null && build != null) {\n                if (jEdit.getBuild().compareTo(build) < 0) newVersionAvailable(view, version, url); else {\n                    GUIUtilities.message(view, \"version-check\" + \".up-to-date\", new String[0]);\n                }\n            }\n        } catch (IOException e) {\n            String[] args = { jEdit.getProperty(\"version-check.url\"), e.toString() };\n            GUIUtilities.error(view, \"read-error\", args);\n        }\n        view.hideWaitCursor();\n    }\n", "label": 1, "substitutes": {"loadExistingAntlibs": ["loadExistingantlibFiles", "loadExistingAntibd", "loadExistingAntlibFiles", "loadExistingAntibs", "loadExistingAntribs", "loadExistingAntLibFiles", "loadExistingantlibz", "loadExistingAntibz", "loadExistingantLibs", "loadExistingAntLibz", "loadExistingAntlibz", "loadExistingantlibs", "loadExistingAntribFiles", "loadExistingantLibd", "loadExistingAntribd", "loadExistingantLibFiles", "loadExistingantLibz", "loadExistingAntLibd", "loadExistingantlibd", "loadExistingAntlibd", "loadExistingAntribz", "loadExistingAntLibs", "loadExistingAntibFiles"], "classLoader": [" ClassPath", "classLoad", " ClassReader", " ClassLoad", "classReader", "classloader", "ClassPath", " ClassLoader", "ClassLoad", "ClassReader", "classPath", "ClassLoader", " Classloader", " classloader", " classReader", "Classloader", " classPath", " classLoad"], "antlibUrl": ["antLiburl", "antappUr", "antslibUr", "antlabUr", "antribUr", "antLibURL", "antlibraryurl", "antlibraryUr", "antLibStr", "antsLibUr", "antsLibRel", "antlibURL", "AntLibUrl", "antsLibStr", "antlibraryURL", "antribURL", "antappUrl", "antsLibURL", "antLibUr", "AntlibUrl", "antlibraryRel", "antriburl", "antdburl", "antlibraryUrl", "antliburl", "antlibraryStr", "antappURL", "antlibRel", "antappRel", "AntLiburl", "antlibUr", "antsLiburl", "antlaburl", "antslibUrl", "antdbURL", "antLibUrl", "AntLibURL", "antlabStr", "antslibURL", "antLibRel", "antlibStr", "Antliburl", "AntlibUr", "antribUrl", "antdbUrl", "AntLibUr", "antslibStr", "antlabUrl", "antdbUr", "antslibRel", "AntlibURL", "antsliburl", "antsLibUrl"], "antlibUri": ["antlibUrid", "antlibraryUri", "antLibIri", "antlibraryUr", "antlibUmi", "antlibGeri", "antlibUtris", "antlibIri", "antlibIRI", "antlibGerid", "antlibraryUsRI", "antlibIis", "antlibURmi", "antlibUtrid", "antlibUURI", "antLibUtri", "antLibUis", "antlibUsri", "antlibIne", "antlibUsURI", "antlibUtri", "antlibIr", "antLibUrid", "antLibUri", "antlibOr", "antlibUsris", "antLibUpi", "antlibIURI", "antlibraryUsmi", "antLibUris", "antlibURI", "antlibGeris", "antlibUsRI", "antlibUsr", "antlibEUpi", "antlibIrid", "antlibraryUsris", "antlibOne", "antlibUtmi", "antlibUr", "antlibUis", "antLibIRI", "antlibIpi", "antlibGeRI", "antlibEri", "antlibURri", "antlibOri", "antlibUris", "antLibUURI", "antlibUpi", "antlibraryUne", "antlibUtRI", "antlibraryUsr", "antLibIURI", "antLibIis", "antlibEris", "antLibIrid", "antlibraryUris", "antlibUsis", "antlibUsmi", "antLibUtris", "antlibraryUmi", "antlibEURI", "antlibURris", "antlibIris", "antlibOris", "antlibUsne", "antlibEUris", "antlibEUri", "antLibURI", "antlibraryURI", "antlibUne", "antlibUtpi", "antlibURRI", "antLibIris", "antlibraryUsne", "antlibraryUsri", "antLibUtpi", "antlibEis"], "resources": ["parents", "maps", "services", "iers", "dates", "these", "writers", "reports", "links", "res", "ples", "users", "keys", "seconds", "types", "modules", "roots", "packages", "classes", "names", "models", "years", "issues", "builders", "stores", "workers", "rs", "images", "ries", "actions", "events", "objects", "headers", "ports", "ions", "states", "groups", "pages", "files", "relations", "Resources", "values", "archives", "works", "ues", "bytes", "books", "checks"], "url": ["f", "browser", "gl", "address", "ref", "dl", "entry", "util", "service", "request", "resource", "lb", "bel", "web", "ls", "ll", "base", "char", "date", "link", "addr", "sl", "lr", "rel", "xml", "ur", "mount", "format", "URL", "name", "host", "str", "rl", "get", "l", "nl", "li", "path", "github", "add", "r", "ssl", "el", "key", "http", "remote", "location", "string", "file", "loc", "source", "Url", "server", "abs"], "stream": ["window", "response", "sample", "console", "resource", "view", "client", "Stream", "standard", "pipe", "context", "feed", "inner", "buffer", "sl", "open", "message", "system", "stack", "ream", "content", "read", "progress", "input", "out", "history", "sw", "path", "iterator", "channel", "zip", "row", "socket", "io", "file", "source", "body", "user", "store", "loader", "data"], "reader": ["runner", "rar", "via", "sample", "entry", "layer", "console", "parser", "driver", "rer", "resource", "ri", "client", "ro", "inner", "Reader", "range", "buffer", "readable", "reads", "roller", "review", "read", "writer", "liner", "rl", "rr", "reviewed", "input", "READ", "iter", "dd", "per", "rx", "upper", "handler", "query", "length", "instance", "collection", "iterator", "r", "row", "ner", "volume", "socket", "er", "file", "reading", "older", "loader", "server"], "line": ["LINE", "lo", "handle", "lin", "block", "text", "eline", "entry", "ine", "sample", "next", "column", "comment", "frame", "word", "ln", "lines", "page", "ls", "port", "lf", "profile", "link", "range", "buffer", "sl", "log", "label", "message", "cell", "stay", "le", "liner", "str", "l", "pos", "iter", "sql", "nl", "li", "point", "len", "Line", "row", "n", "string", "msg", "inline", "file", "online", "body", "print", "pe", "header"], "pkg": ["kid", "mask", "pair", "var", "dl", "gp", "ctx", "pid", "alias", "entry", "imp", "cmp", "part", "pp", "pod", "lang", "packages", "col", "deb", "module", "Package", "mod", "init", "port", "ppa", "perm", "pg", "jar", "kg", "wd", "family", "plugin", "req", "cp", "name", "lib", "pt", "fx", "pack", "path", "dir", "ip", "rpm", "zip", "key", "quote", "msg", "password", "patch", "root", "p", "prefix"], "uri": ["proxy", "mi", "address", "reference", "util", "resource", "ri", "URI", "library", "base", "directory", "profile", "connection", "link", "cli", "system", "ur", "ui", "i", "pi", " URI", "api", "iri", "uu", "handler", "term", "uid", "ip", "domain", "local", "http", "location", "io", "file", "source", "folder", "id"], "resource2antlib": ["resource2Antib", "resource2AntLib", "resource2agentLib", "resource1antLib", "resource2ntib", "resource2agentib", "resource1agentib", "resourcetoANTconfig", "resource2boltloc", "resourcetoANTloc", "resourcetoANTlib", "resource1antib", "resource2antconfig", "resource1antlibrary", "resource2boltib", "resource2ANTib", "resourcetoantlib", "resource1agentLib", "resource2antLib", "resource2antsib", "resource2boltconfig", "resource2agentlibrary", "resource2etli", "resource2boltlib", "resource2ANTlib", "resource1antlib", "resource2antsloc", "resource2antib", "resource2Antli", "resource1agentlibrary", "resourcetoantloc", "resource1agentlib", "resource2antloc", "resource2ANTconfig", "resourcetoantib", "resourcetoANTib", "resource2ntLib", "resourcetoantconfig", "resource2antli", "resource2etlib", "resource2ntlib", "resource2antsconfig", "resource2antslib", "resource2antlibrary", "resource2Antlib", "resource2etlibrary", "resource2ntli", "resource2ANTloc", "resource2agentlib", "resource2Antlibrary", "resource2ntlibrary", "resource2etLib"]}}
{"id1": "8452134", "id2": "310182", "code1": "    public int exists(String fileToCheck) throws IOException {\n        FTPClient ftp = new FTPClient();\n        int found = 0;\n        try {\n            int reply = 0;\n            ftp.connect(this.endpointURL, this.endpointPort);\n            reply = ftp.getReplyCode();\n            if (!FTPReply.isPositiveCompletion(reply)) {\n                ftp.disconnect();\n                throw new IOException(\"Ftp exists server refused connection.\");\n            }\n            if (!ftp.login(\"anonymous\", \"\")) {\n                ftp.logout();\n                throw new IOException(\"FTP: server wrong passwd\");\n            }\n            ftp.enterLocalPassiveMode();\n            if (ftp.listNames(fileToCheck) != null) {\n                found = 1;\n            }\n            ftp.logout();\n        } catch (Exception e) {\n            throw new IOException(e.getMessage());\n        }\n        return found;\n    }\n", "code2": "    public void convert(File src, File dest) throws IOException {\n        InputStream in = new BufferedInputStream(new FileInputStream(src));\n        DcmParser p = pfact.newDcmParser(in);\n        Dataset ds = fact.newDataset();\n        p.setDcmHandler(ds.getDcmHandler());\n        try {\n            FileFormat format = p.detectFileFormat();\n            if (format != FileFormat.ACRNEMA_STREAM) {\n                System.out.println(\"\\n\" + src + \": not an ACRNEMA stream!\");\n                return;\n            }\n            p.parseDcmFile(format, Tags.PixelData);\n            if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) {\n                System.out.println(\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n                return;\n            }\n            boolean hasPixelData = p.getReadTag() == Tags.PixelData;\n            boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12;\n            int pxlen = p.getReadLength();\n            if (hasPixelData) {\n                if (inflate) {\n                    ds.putUS(Tags.BitsAllocated, 16);\n                    pxlen = pxlen * 4 / 3;\n                }\n                if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) {\n                    System.out.println(\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                    return;\n                }\n            }\n            ds.putUI(Tags.StudyInstanceUID, uid(studyUID));\n            ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID));\n            ds.putUI(Tags.SOPInstanceUID, uid(instUID));\n            ds.putUI(Tags.SOPClassUID, classUID);\n            if (!ds.contains(Tags.NumberOfSamples)) {\n                ds.putUS(Tags.NumberOfSamples, 1);\n            }\n            if (!ds.contains(Tags.PhotometricInterpretation)) {\n                ds.putCS(Tags.PhotometricInterpretation, \"MONOCHROME2\");\n            }\n            if (fmi) {\n                ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian));\n            }\n            OutputStream out = new BufferedOutputStream(new FileOutputStream(dest));\n            try {\n            } finally {\n                ds.writeFile(out, encodeParam());\n                if (hasPixelData) {\n                    if (!skipGroupLen) {\n                        out.write(PXDATA_GROUPLEN);\n                        int grlen = pxlen + 8;\n                        out.write((byte) grlen);\n                        out.write((byte) (grlen >> 8));\n                        out.write((byte) (grlen >> 16));\n                        out.write((byte) (grlen >> 24));\n                    }\n                    out.write(PXDATA_TAG);\n                    out.write((byte) pxlen);\n                    out.write((byte) (pxlen >> 8));\n                    out.write((byte) (pxlen >> 16));\n                    out.write((byte) (pxlen >> 24));\n                }\n                if (inflate) {\n                    int b2, b3;\n                    for (; pxlen > 0; pxlen -= 3) {\n                        out.write(in.read());\n                        b2 = in.read();\n                        b3 = in.read();\n                        out.write(b2 & 0x0f);\n                        out.write(b2 >> 4 | ((b3 & 0x0f) << 4));\n                        out.write(b3 >> 4);\n                    }\n                } else {\n                    for (; pxlen > 0; --pxlen) {\n                        out.write(in.read());\n                    }\n                }\n                out.close();\n            }\n            System.out.print('.');\n        } finally {\n            in.close();\n        }\n    }\n", "label": 0, "substitutes": {"exists": ["Exits", "exinates", "existinates", "Exists", "exits", "extists", "existits", "Exinates", "extits", "exist", " exies", "exception", "Exies", "xits", "comists", "exies", " exits", "xist", "comist", "comits", "existies", "existists", "xists", " exinates", "extist", "extception", "comception", "xception"], "fileToCheck": ["filenameTOTest", "filenameTOcheck", "fileTOCheck", "fileTOSee", "fileTOTest", "filetoTest", "pathToWatch", "pathTOSee", "fileToSee", "file2Check", "file2Test", "filetoCheck", "filetoWatch", "pathTOWatch", "filenameToCheck", "pathToTest", "filenameTocheck", "fileTocheck", "filenameToTest", "pathToCheck", "pathTOTest", "fileToWatch", "pathTOCheck", "file2check", "fileTOWatch", "filetoSee", "pathToSee", "fileTOcheck", "filenameTOCheck", "fileToTest"], "ftp": [" ftph", "aftm", "aptp", " ftchange", "ctps", "ffcache", "ftr", "aftt", "ctp", "fabph", "ftt", " ftps", " ftpl", "cttp", "fabphp", "iftp", "fttp", "aftchange", "ftc", "ffp", " fttp", "afttp", " ftt", "aftc", " ftv", "fabc", "latphp", "ffphp", "ftphp", " ftphp", "rotp", "ctcp", "lattp", "rotps", "aftr", "rotchange", "rottp", "ldp", "iftphp", "ftm", "ldphp", "fftp", "ffr", " ftr", "ftchange", "rotcp", "aftl", "aftv", "apttp", "latp", " ftm", "ftv", "aftpl", "ldc", "ftpl", "ftps", "ftph", "fft", "ftl", "aptl", "rotl", "ftcp", "aftcp", "ldph", " ftc", " ftl", " ftcp", "fabp", "ffc", "iftcache", "aftp", "rotm", "ftcache", "latcache", "aptcp", "rotpl", "ffv", "ffcp", "ifttp"], "found": ["installed", "killed", "expected", "good", "Found", "find", "built", "d", " Found", "finder", "finished", "done", "Find", "fd", "result", "identified", "started", "seen", "fixed", "printed", "successful", "enabled", "success", "out", "valid", "matched", "tested", "loaded", "search", "initialized", "checked", "created", "successfully", "ed", "full", "count", "sent", "failed", "affected", "index", "id", "needed", "elt", "results", "filled"], "reply": ["echo", "back", "report", "pop", "mi", "txt", "response", "embed", "notice", "match", "sync", "next", "py", "comment", "force", "status", "base", "code", "ply", "link", "replace", "message", "ping", "result", "close", "onse", "strip", "conf", " Reply", "post", "nb", "state", "error", "success", "vote", "len", "cor", "nl", "answer", "continue", "flag", "record", "ret", "count", "Reply", "msg", "repl", "shell", "zero", "index", "check", "print", "push"]}}
{"id1": "8588992", "id2": "823074", "code1": "    public ActionForward perform(ActionMapping mapping, ActionForm form, HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {\n        String status = null;\n        HttpSession session = request.getSession();\n        ReportingBean reportingBean = null;\n        NewConceptBean conceptBean = null;\n        String conceptName = null;\n        String primitive = null;\n        MessageResources errorMessages = MessageResources.getMessageResources(\"com.apelon.apps.dts.treebrowser.resources.error_messages\");\n        LogonUtilities logonUtilities = new LogonUtilities();\n        if (logonUtilities.checkSession(session, status, reportingBean, errorMessages)) {\n            reportingBean = (ReportingBean) session.getAttribute(\"reportingBean\");\n            if ((reportingBean.getMessageHtml().indexOf(\"Classify\")) == -1) {\n                reportingBean.setReportingHtml(\"\");\n            }\n            conceptBean = (NewConceptBean) session.getAttribute(\"newConceptEntity\");\n            conceptName = request.getParameter(\"conceptName\");\n            primitive = request.getParameter(\"primitive\");\n            if (primitive == null) {\n                primitive = \"false\";\n            }\n            conceptBean.setConceptName(conceptName);\n            conceptBean.setPrimitive(primitive);\n            String namespace = conceptBean.getConceptNamespace();\n            if (namespace == null) {\n                reportingBean.setReportingHtml(errorMessages.getMessage(\"classify_3\"));\n                session.setAttribute(\"reportingBean\", reportingBean);\n                status = \"classify_fail\";\n                return (mapping.findForward(status));\n            }\n            String[] roleMods = request.getParameterValues(\"some_or_all\");\n            String[] roleGrps = request.getParameterValues(\"role_group\");\n            Vector roles = conceptBean.getRoles();\n            RoleBean[] roleCons = new RoleBean[roles.size()];\n            roles.copyInto(roleCons);\n            if (roleMods != null && roleGrps != null && roleCons != null) {\n                if (roleCons.length == roleMods.length && roleCons.length == roleGrps.length) {\n                    for (int i = 0; i < roleCons.length; i++) {\n                        roleCons[i].setSomeOrAll(roleMods[i]);\n                        roleCons[i].setRoleGroup(roleGrps[i]);\n                    }\n                }\n            }\n            session.setAttribute(\"newConceptEntity\", conceptBean);\n            NewConceptXMLDisplayBean xmlBean = new NewConceptXMLDisplayBean();\n            xmlBean.setNewConceptXml(conceptBean);\n            String data = BrowserUtilities.encodeUrl(\"conceptXml\") + \"=\" + BrowserUtilities.encodeUrl(xmlBean.getNewConceptXml()) + \"&\" + BrowserUtilities.encodeUrl(\"nameSpace\") + \"=\" + BrowserUtilities.encodeUrl(namespace);\n            XMLPropertyHandler configPh = new XMLPropertyHandler(\"dtsbrowserclassify.xml\");\n            Properties configProps = configPh.getProps();\n            String urlString = configProps.getProperty(\"url\");\n            URL url = new URL(urlString);\n            URLConnection conn = url.openConnection();\n            conn.setDoOutput(true);\n            OutputStreamWriter wr = new OutputStreamWriter(conn.getOutputStream());\n            wr.write(data);\n            wr.flush();\n            BufferedReader rd = new BufferedReader(new InputStreamReader(conn.getInputStream()));\n            String line;\n            StringBuffer buf = new StringBuffer();\n            while ((line = rd.readLine()) != null) {\n                buf.append(line);\n            }\n            String resultXml = buf.toString();\n            wr.close();\n            rd.close();\n            ClassifiedConceptBean ccBean = new ClassifiedConceptBean();\n            ClassifyResultParser parser = new ClassifyResultParser(resultXml);\n            ResultBuilder rbuilder = new ResultBuilder();\n            rbuilder.setConceptBean(ccBean);\n            rbuilder.setParser(parser);\n            rbuilder.setNamespace(namespace);\n            try {\n                rbuilder.buildResult();\n                ccBean = rbuilder.getConceptBean();\n                ClassifiedConceptDisplayBean displayBean = new ClassifiedConceptDisplayBean();\n                displayBean.setNewConceptHtml(ccBean);\n                session.setAttribute(\"classifyResult\", ccBean);\n                session.setAttribute(\"classifyDisplayResult\", displayBean);\n                status = \"success\";\n            } catch (Exception e) {\n                Categories.dataServer().error(StackTracePrinter.getStackTrace(e));\n                reportingBean.setReportingHtml(errorMessages.getMessage(\"classify_1\") + e.getMessage());\n                session.setAttribute(\"reportingBean\", reportingBean);\n                status = \"classify_fail\";\n            }\n        }\n        return (mapping.findForward(status));\n    }\n", "code2": "    public void convert(File src, File dest) throws IOException {\n        InputStream in = new BufferedInputStream(new FileInputStream(src));\n        DcmParser p = pfact.newDcmParser(in);\n        Dataset ds = fact.newDataset();\n        p.setDcmHandler(ds.getDcmHandler());\n        try {\n            FileFormat format = p.detectFileFormat();\n            if (format != FileFormat.ACRNEMA_STREAM) {\n                System.out.println(\"\\n\" + src + \": not an ACRNEMA stream!\");\n                return;\n            }\n            p.parseDcmFile(format, Tags.PixelData);\n            if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) {\n                System.out.println(\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n                return;\n            }\n            boolean hasPixelData = p.getReadTag() == Tags.PixelData;\n            boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12;\n            int pxlen = p.getReadLength();\n            if (hasPixelData) {\n                if (inflate) {\n                    ds.putUS(Tags.BitsAllocated, 16);\n                    pxlen = pxlen * 4 / 3;\n                }\n                if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) {\n                    System.out.println(\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                    return;\n                }\n            }\n            ds.putUI(Tags.StudyInstanceUID, uid(studyUID));\n            ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID));\n            ds.putUI(Tags.SOPInstanceUID, uid(instUID));\n            ds.putUI(Tags.SOPClassUID, classUID);\n            if (!ds.contains(Tags.NumberOfSamples)) {\n                ds.putUS(Tags.NumberOfSamples, 1);\n            }\n            if (!ds.contains(Tags.PhotometricInterpretation)) {\n                ds.putCS(Tags.PhotometricInterpretation, \"MONOCHROME2\");\n            }\n            if (fmi) {\n                ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian));\n            }\n            OutputStream out = new BufferedOutputStream(new FileOutputStream(dest));\n            try {\n            } finally {\n                ds.writeFile(out, encodeParam());\n                if (hasPixelData) {\n                    if (!skipGroupLen) {\n                        out.write(PXDATA_GROUPLEN);\n                        int grlen = pxlen + 8;\n                        out.write((byte) grlen);\n                        out.write((byte) (grlen >> 8));\n                        out.write((byte) (grlen >> 16));\n                        out.write((byte) (grlen >> 24));\n                    }\n                    out.write(PXDATA_TAG);\n                    out.write((byte) pxlen);\n                    out.write((byte) (pxlen >> 8));\n                    out.write((byte) (pxlen >> 16));\n                    out.write((byte) (pxlen >> 24));\n                }\n                if (inflate) {\n                    int b2, b3;\n                    for (; pxlen > 0; pxlen -= 3) {\n                        out.write(in.read());\n                        b2 = in.read();\n                        b3 = in.read();\n                        out.write(b2 & 0x0f);\n                        out.write(b2 >> 4 | ((b3 & 0x0f) << 4));\n                        out.write(b3 >> 4);\n                    }\n                } else {\n                    for (; pxlen > 0; --pxlen) {\n                        out.write(in.read());\n                    }\n                }\n                out.close();\n            }\n            System.out.print('.');\n        } finally {\n            in.close();\n        }\n    }\n", "label": 0, "substitutes": {"perform": ["preprocess", "predo", "transform", "Perdo", "Perform", "preforms", "preform", "transforms", "performs", "perprocess", "transdo", "perdo", "transprocess", "Perprocess", "Performs"], "mapping": [" mappings", "smappings", "Mapped", "smapped", "Mapper", "Mappings", " mapper", "mappings", "smapper", "smapping", "mapped", "Mapping", " mapped", "mapper"], "form": ["f", "transform", "forms", "process", "con", "view", "m", "fr", "create", "formed", "fac", "feed", "command", "fc", "flow", "format", "def", "Form", "input", " Form", "parent", "path", "FORM", "config", "send", "apply", "orm", "map"], "request": ["first", "browser", "report", "handle", "address", "each", "reference", "process", "subject", "the", "reset", "forward", "runtime", "frame", "resource", "application", "requ", "client", "create", "set", "quest", "context", "environment", "connection", "command", "buffer", "attribute", "open", "document", "current", "message", "Request", "re", "xml", "list", "req", "condition", "position", "get", "complete", "input", "initial", "order", "query", "controller", "project", "search", "path", "question", "batch", "register", "remote", "http", "begin", "QUEST", "version", "store", "server", "setup"], "response": ["report", "reply", "output", "res", "next", "sp", "frame", "application", "view", "Response", "page", "site", "context", "connection", "resp", "document", "message", "result", "re", "state", "success", "respond", "http"], "status": ["type", "report", "access", "active", "step", "settings", "res", "sync", " Status", "speed", "service", "score", "details", "description", "wait", "summary", "uses", "reason", "comments", "char", "code", "err", "warning", "stats", "message", "result", "mode", "detail", "format", "content", "Status", "state", "name", "str", "error", "success", "enabled", "out", "method", "login", "stage", "stat", "sql", "exit", "sc", "search", "security", "s", "ssl", "html", "string", "id", "msg", "scale", "source", "version", "index", "check", "server", "prefix", "title"], "session": ["window", "layout", "sb", "subject", "process", "settings", "lock", "ses", "about", "task", "Session", "se", "application", "runtime", "view", "client", "site", "context", "environment", "sid", "connection", "ess", "attribute", "secure", "document", "message", "current", "system", "list", "second", "cache", "state", "condition", "ession", "position", "person", "bind", "global", "container", "ESSION", "region", "sql", "parent", "search", "security", "language", "record", "instance", "collection", "database", "connect", "local", "manager", "http", "socket", "save", "display", "binding", "source", "essions", "store", "server"], "reportingBean": ["reportingAssan", "reportingIsann", "reportingbeAN", "reportingPeans", "reportedFean", " reportingSchebean", " reportingPean", "reportingFeann", "reportingLean", "reportingMeans", "reportingScheant", "reportingBycan", " reportingMacan", " reportingScheann", "reportingByann", "reportedFeann", "storageBean", "storagePebean", "reportingScbean", " reportingBeant", " reportingBeann", "reportingBEcan", "reportingTeer", "reportingBeann", " reportingbeAN", "reportingBAN", "reportingPeoon", "reportingBann", "reportingBeao", " reportingSchean", "reportingBEan", "storageBEanan", "storagePean", "reportingPeann", "reportingAssant", " reportingMacAN", "reportingbean", "reportingBebean", " reportingBeAN", " reportingbeans", "reportingBecan", "reportingScan", "reportingAlan", "reportingBeanan", "reportingIsan", "storageBecan", "reportingMacan", "storageBebean", "storageBEcan", "storageBeann", "reportingAssbean", " reportingBeao", "reportingBeen", " reportingScheant", "storagePeoon", "reportingIsans", "reportingBeae", " reportingMacen", " reportingPeAN", " reportingbean", "reportedBeae", "reportedFeae", "reportingBEann", "reportingLeAN", "reportingBehan", "reportingBeans", "reportingBeer", "reportingAloon", "reportingBae", "reportingSchean", "reportingPeer", "reportingLogan", "storageBEan", " reportingBeans", "reportingBEae", "reportingTean", "reportingbeann", "reportingLeao", " reportingBebean", "reportingSchebean", "reportingPeAN", "reportingByan", "reportingTeoon", "reportingRoan", "reportingMacao", "reportingBEAN", "reportingRoans", "reportingMacAN", "reportingLogann", "reportingLogcan", "reportingBeAN", "reportingMacen", "reportedBeAN", "reportingBehen", "storageBeoon", "reportingLeen", "reportingScann", "reportingLoganan", "reportingBan", "reportingPean", "reportingAlbean", "reportingMeAN", "reportingScheann", "reportingBEanan", "reportingFeae", "reportingMean", "reportingAler", "reportingBehao", " reportingMacao", "reportingTebean", "storageBeanan", "reportingAssann", "reportingIsAN", "storageBEann", "reportingMeann", " reportingbeann", "reportingPebean", "reportingRoann", "reportingBehAN", "reportedBean", "reportingFean", "reportingFeAN", "reportingRoAN", " reportingPeann", "reportingBeoon", "reportingByanan", "storageBeer", " reportingBeen", "reportingScant", "reportedFeAN", " reportingPeans", "reportingBeant", "storagePeer", "reportedBeann", "reportingbeans"], "conceptBean": ["conceptBeoon", " conceptBeAN", "countryBeet", "conceptReann", " conceptBeanned", "indexBelom", "conceptReoon", "countryRoan", "conceptBoxin", "conceptRoAN", "conceptBelan", "conceptFean", " conceptReann", "conceptBEans", "conceptObjann", " conceptEan", "conceptObjan", " conceptRean", "conceptProan", "conceptMean", "countryBebean", "conceptEann", "conceptObjanned", "conceptMeans", "conceptLinean", "indexBelans", "conceptMen", "countryRoAN", " conceptBeann", "conceptRobean", "conceptFeann", " conceptBEan", "conceptBoxn", "indexBeom", " conceptBen", "conceptBelom", " conceptBEoon", "countryBean", "conceptBeans", "conceptMeann", "conceptCoin", "conceptMeAN", "conceptBEet", "conceptMeean", " conceptBein", "conceptRoan", "conceptEan", "conceptProoon", "conceptRean", " conceptCoan", " conceptBeean", "conceptObjans", " conceptEann", "conceptBoxean", "conceptMein", " conceptBeans", "conceptBEoon", "conceptEans", "countryRobean", "countryRoet", "conceptMeom", "conceptCoan", "conceptFeans", "conceptBelans", "conceptBeanned", "conceptReAN", "conceptRein", "conceptCon", " conceptCoean", "conceptBEAN", " conceptReAN", " conceptCon", "conceptRoet", " conceptBeoon", "conceptBeann", " conceptReans", "conceptBEom", "conceptBen", "countryBeAN", " conceptEans", "conceptFeanned", "conceptProAN", "conceptProbean", "conceptBoxan", "conceptBeean", "conceptBein", "conceptBeAN", "conceptProet", "indexBean", "indexBebean", "indexBeans", "conceptLineans", "conceptMebean", "conceptReans", "conceptBebean", " conceptBEAN", "conceptLineAN", " conceptEanned", "indexBelbean", "conceptBeet", "conceptBEbean", "conceptEanned", "conceptBelbean", "conceptLineann", "conceptCoean", "indexBelan", "conceptBEin", "conceptBeom", "conceptProin", "conceptBEan", " conceptBEin", " conceptCoin"], "conceptName": ["ceptName", "versionName", " ConceptN", " ConceptName", "conceptNAME", " conceptNames", " conceptname", " conceptNAME", "conceptN", "featType", "versionNames", " Conceptname", "ceptType", " conceptN", " ConceptNames", "conceptNames", "conceptname", "versionNAME", "featNames", "ceptname", " conceptType", "featNAME", "featName", "ceptN", "ceptNames", "ceptNAME", "conceptType", "versionType"], "primitive": ["predractive", "primitives", "pritative", "protative", " primitiveness", "promity", "provenitive", "provenitiveness", "Primitives", "predity", "penative", "penitive", "positive", "priitive", "positivity", "promitivity", "Primitiveness", "prietric", "pritive", "priative", "promitive", "provenity", "Primative", "provenitives", "Primitivity", "penity", "Primitive", "protitive", "posity", "Primitative", "primitiveness", "priity", "Primractive", "Primity", "primractive", "primity", "primetric", "primitivity", "posative", "primative", "prometric", "predative", "posetric", " primitives", "penitivity", "positative", "protractive", "prity", " primity", "promative", "primitative", "preditive", "pritivity", "protity"], "errorMessages": ["errorMessage", "errorGuengers", "rorMessages", "rorMessage", "errorMsgages", "errorMessengers", "errorMsagers", "errorMsgings", "errorEres", "errorGuagers", "rorLogages", "errorErages", "errorMsges", "errorGuages", "errorMessags", "errorMessagers", "errorLogage", " errormessags", "errorLogages", "errorMesses", "Errormessagers", "errormessengers", "errorMessings", "errorGuGES", "ErrorMessages", "ErrorMessagers", " errorMessings", "errorMsages", "ErrormessGES", "errormessGES", "errorMsengers", "errorMsgags", "ErrorMessGES", "errormessagers", "errormessags", "errormessings", "ErrorMessengers", "rorLogage", "errormessage", "rorLogags", "errorErings", "errorMessGES", " errorMessags", "errorMethodsags", "errorErags", " errorMesses", "errorMsGES", "errorMethodsage", "errorMethodsages", "errormesses", " errormessings", "Errormessages", "rorMessags", "errormessages", " errormesses", " errormessages", "errorLogags", "Errormessengers"], "logonUtilities": ["logenUtils", " logonMutil", " logonUtil", " logonUiles", " logonMutiles", "logonUtili", "logenUtili", " logonMutility", "logonutiles", " logonMutilities", "logonUtiles", " logonUtility", "logenUtilities", " logonUility", "logonUtils", " logenUil", " logenUiles", " logonUtiles", " logenUtil", " logenUtiles", " logenUtility", " logonUil", " logenUtilities", "logenUtiles", " logenUility", "logonutils", " logonUilities", "logonutilities", "logonutili", " logenUilities"], "namespace": ["valuespace", "worksspace", "scheenter", "namesspace", "keysace", "namesistence", "Namesspace", "workspace", "Namesace", "nameship", "keyspaces", "valueship", "presenter", "worksace", "namespaces", "presistence", "valuesistence", "namesace", "namesenter", "Namespace", "prespace", "workspaces", "keyspace", "scheistence", "preship", "keysspace", "schehip", "Namespaces", "schepace", "valuesenter"], "roleMods": ["RoleMod", " rolemods", "roMs", "RoleMD", "balanceMods", "balanceMod", "rolemods", "RoleMs", "roleMs", "balanceMD", "roleMD", " roleMD", "roMods", " roleMod", "RoleMods", "romods", "roleMod", " roleMs", "balancemods", "Rolemods", "roMod"], "roleGrps": ["roGRps", "roleGarrs", "resourceGRrs", "roleGRpers", "roleGrgs", "roleGarPs", "resourceGrrs", "roleGRrs", "roleGarps", "roleGPs", "roleGRgs", "roleGps", "roleGhpes", "roleComps", "roGrpers", "roleGrpes", "roleCompers", "roGrPs", "roGRPs", "resourceGRPs", "resourceGrPs", "roleGRPs", "roleGrrs", "resourceGrgs", "resourceGRgs", "roleGhps", "roGRpers", "roleGrs", "roleGhPs", "resourceGRps", "roleGargs", "roleCompes", "roleComPs", "roleGRps", "roGrps", "roleGrpers", "roGrpes", "roleGhpers", "roleGRpes", "resourceGrps", "roleGrPs", "roGRpes", "roleGgs"], "roles": ["ROols", "rls", "ROoles", "robgers", "roboles", "ruels", "rools", "rugers", "ROgers", "robols", "trles", "trls", "rules", "ROls", "roels", "robels", "trgers", "troles", "rogers", "robls", " rogers", " roels", "rols", " rooles", "ruoles", "robles", "rooles", "rles", "ROles"], "roleCons": [" roleIns", "seatCon", "relationCon", "seatPres", "RoleCon", "ruleLens", "oleCons", " roleCon", "oleCop", "relationCons", "relationPres", " roleRes", " roleCop", " roleLens", "oleCon", "rolePres", "roleCon", "relationIns", "relationMods", "roleCop", "seatMods", "ruleRes", "roleIns", "RoleCons", " rolePres", "ruleIns", "relationRes", "roleLens", "ruleCons", "seatCons", "RoleCop", "roleRes", "relationLens"]}}
{"id1": "16466743", "id2": "9826240", "code1": "    public String getmd5(String password) {\n        String pwHash = \"\";\n        MessageDigest md = null;\n        try {\n            md = MessageDigest.getInstance(\"MD5\");\n            md.reset();\n            md.update(password.getBytes());\n            byte[] b = md.digest();\n            for (int i = 0; i < b.length; i++) {\n                pwHash += Integer.toString((b[i] & 0xFF) + 0x100, 16).substring(1);\n            }\n        } catch (NoSuchAlgorithmException ex) {\n            Logger.fatal(\"MD5 Hash Algorithm not found\", ex);\n        }\n        Logger.info(\"PWHash erzeugt und wird \u00fcbergeben\");\n        return pwHash;\n    }\n", "code2": "    private boolean checkHashBack(Facade facade, HttpServletRequest req) {\n        String txtTransactionID = req.getParameter(\"txtTransactionID\");\n        String txtOrderTotal = req.getParameter(\"txtOrderTotal\");\n        String txtShopId = facade.getSystemParameter(GlobalParameter.yellowPayMDMasterShopID);\n        String txtArtCurrency = facade.getSystemParameter(GlobalParameter.yellowPayMDCurrency);\n        String txtHashBack = req.getParameter(\"txtHashBack\");\n        String hashSeed = facade.getSystemParameter(GlobalParameter.yellowPayMDHashSeed);\n        String securityValue = txtShopId + txtArtCurrency + txtOrderTotal + hashSeed + txtTransactionID;\n        MessageDigest digest;\n        try {\n            digest = java.security.MessageDigest.getInstance(\"MD5\");\n            digest.update(securityValue.getBytes());\n            byte[] array = digest.digest();\n            StringBuffer sb = new StringBuffer();\n            for (int j = 0; j < array.length; ++j) {\n                int b = array[j] & 0xFF;\n                if (b < 0x10) sb.append('0');\n                sb.append(Integer.toHexString(b));\n            }\n            String hash = sb.toString();\n            System.out.println(\"com.eshop.http.servlets.PaymentController.checkHashBack: \" + hash + \" \" + txtHashBack);\n            if (txtHashBack.equals(hash)) {\n                return true;\n            }\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        }\n        return false;\n    }\n", "label": 1, "substitutes": {"getmd5": ["getsha4", "getsha2", "getsha6", "getMD4", "getmd2", "getMD5", " getMD5", "getMD2", "getmd6", " getMD6", " getMD2", " getMD4", " getmd4", "getmd4", "getMD6", " getmd2", " getmd6", "getsha5"], "password": ["phrase", "address", "value", "text", "p", "entry", "email", "hello", "word", "description", "secret", " Password", "shadow", "code", "attribute", "Password", "message", "wd", "wordpress", "name", "token", "hash", "pass", "login", "auth", "ew", "path", "security", "sword", "database", "pattern", "padding", "key", "string", "user", "username", "data", "prefix", "w"], "pwHash": [" pwSum", "pswSum", " pwdHash", "pwHas", "spwdSum", "pwtHas", "pswhash", " pwdSum", "pwsHas", "pwshash", "pwhash", "pswHash", "pswHas", "pwdHas", "pwtSum", "pWHas", "pwsHash", "pwthash", "pwtHash", " pwhash", "spwhash", "spwHash", "pwdhash", "pwSum", "spwdHas", " pwHas", "spwdHash", "spwHas", "pWHash", "pWSum", "pwsSum", "spwdhash", "pWhash", "spwSum", " pwdhash", " pwdHas", "pwdHash", "pwdSum"], "md": [" Md", " mc", "sm", "pd", "ms", "cmp", "od", "ng", "di", "d", "der", " mo", "mt", "m", " mm", "doc", "mo", "mod", "mem", "mg", "red", "del", "mp", "man", "rm", "det", "dm", "sd", "def", "td", "nd", "cond", "ds", "dd", "cmd", "metadata", "mail", " dd", "material", "dir", "cd", "mb", "hd", "MD", "dig", "add", "ind", "grad", "mn", "mc", "mm", "desc", "ad", "pm", "mk", "msg", "exec", "ld", "bd", "df"], "b": ["f", "sb", "B", "buff", "bf", "br", "y", "ib", "cb", "d", "ob", "obj", "m", "bh", "bs", "bc", "bas", "abs", "be", "bi", "bb", "db", "bp", "v", "nb", "ba", "rb", "reb", "l", "bu", "eb", "binary", "mb", "batch", "g", "bis", "bar", "fb", "gb", "p", "a", "bytes", "ab", "w"], "i": ["mi", "span", "json", "u", "ini", "j", "us", "y", "ms", "I", "ski", "qi", "di", "ie", "im", "next", "ri", "ei", "m", "ki", "yi", "init", "x", "in", "iu", "ti", "hi", "q", "bi", "ic", "cli", "ci", "multi", "ai", "sim", "gi", "ui", "v", "pi", "ij", "l", "ix", "iter", "it", "ji", "li", "my", "\u0438", "xi", "si", "ind", "o", "ip", "n", "io", "gu", "is", "ii", "oi", "index", "id", "p", "a", "phi"]}}
{"id1": "14001795", "id2": "4618237", "code1": "    public static void copyOverWarFile() {\n        System.out.println(\"Copy Over War File:\");\n        File dir = new File(theAppsDataDir);\n        FileFilter ff = new WildcardFileFilter(\"*.war\");\n        if (dir.listFiles(ff).length == 0) {\n            dir = new File(System.getProperty(\"user.dir\") + \"/war\");\n            if (dir.exists()) {\n                File[] files = dir.listFiles(ff);\n                for (File f : files) {\n                    try {\n                        File newFile = new File(\"\" + theAppsDataDir + \"/\" + f.getName());\n                        System.out.println(\"Creating new file \\\"\" + f.getAbsolutePath() + \"\\\"\");\n                        newFile.createNewFile();\n                        InputStream fi = new FileInputStream(f);\n                        OutputStream fo = new FileOutputStream(newFile);\n                        IOUtils.copy(fi, fo);\n                        moveUnzipAndExtract(newFile);\n                    } catch (Exception ex) {\n                        Logger.getLogger(AppDataDir.class.getName()).log(Level.SEVERE, null, ex);\n                    }\n                }\n            }\n        } else {\n            System.out.println(\"Found a war in the apps data dir, ignoring a fresh copy\");\n        }\n        new JFileChooser().setCurrentDirectory(new File(theAppsDataDir));\n        System.setProperty(\"user.dir\", theAppsDataDir);\n        System.out.println(\"User.dir : \" + System.getProperty(\"user.dir\"));\n    }\n", "code2": "    public static void writeFileToFile(File fin, File fout, boolean append) throws IOException {\n        FileChannel inChannel = new FileInputStream(fin).getChannel();\n        FileChannel outChannel = new FileOutputStream(fout, append).getChannel();\n        try {\n            inChannel.transferTo(0, inChannel.size(), outChannel);\n        } finally {\n            if (inChannel != null) try {\n                inChannel.close();\n            } catch (IOException ex) {\n            }\n            if (outChannel != null) try {\n                outChannel.close();\n            } catch (IOException ex) {\n            }\n        }\n    }\n", "label": 1, "substitutes": {"copyOverWarFile": ["copyoverwarfile", "copyoverWarFile", "copyOverwarFilename", "copyoverWarFilename", "copyoverwarFile", "copyOverwarfile", "copyOverWarfile", "copyoverWarfile", "copyOverWarFilename", "copyoverwarFiles", "copyOverWarFiles", "copyoverwarFilename", "copyOverTarfile", "copyoverWarFiles", "copyOverwarFile", "copyOverTarFilename", "copyOverTarFile", "copyOverTarFiles", "copyOverwarFiles"], "dir": ["window", "good", "div", " directory", "dl", "dial", "res", "vol", "di", "d", "disk", "doc", "tmp", "directory", "md", "del", "addr", "old", "log", "fd", "cur", "dr", "db", "re", "wd", "rel", "dm", "dim", "url", "def", "name", "coll", "out", "iter", " Dir", "dd", "parent", "Dir", "ir", "path", "form", "dat", "cd", "ind", "DIR", "add", "zip", "desc", "local", " d", "mk", "dist", "fin", "file", "folder", "ld", "loc", "dep", "direct", "df"], "ff": ["alf", "buff", "bf", "aft", " eff", "cb", "af", "mt", " cf", "uff", "FF", "fp", "lf", "xff", "ef", "fc", "ffe", "fd", "wind", " af", " aft", "fg", "UFF", "off", " FF", "sf", " ref", "tf", "uf", "cond", "fx", "ck", "fact", " def", "filter", "aff", " df", "iff", "F", "cf", "file", "ld", "ft", "xf", "eff", "df", "fl"], "files": ["forms", "leases", "frames", "ails", "assets", "rows", "parts", "facts", "items", "keys", "plates", "fs", "jobs", "lines", "tests", "les", "ls", "names", "models", "iles", "uploads", "issues", "flows", "styles", "days", "images", "fields", "resources", "members", "objects", "ions", "ports", "balls", "ories", "Files", "features", "values", "file", "mas", "bees", "faces"], "f": ["exp", "alf", "fe", "bf", "d", "h", "a", "m", "fs", "fm", "fp", "col", "fac", "t", "lf", "k", "c", "fc", "b", "fd", "v", "i", "e", "def", "rf", "tf", "sf", "fw", "l", "uf", "elf", "g", "fab", "n", "fa", "F", "cf", "file", "ft", "p", "xf", "fl", "w"], "newFile": [" newFiles", "oldFilename", "newNode", "anotherPlace", "newfile", "anotherFiles", "newPlace", "uniqueNode", "NewNode", "NEWfile", "NewKey", "newsfile", "newFilename", "secureFile", "NEWPage", " newfile", "newKey", "NEWNode", "newsFile", "uniqueFile", "securefile", "anotherFile", "NEWFile", " newPlace", "anotherfile", "secureKey", "NewPlace", "NewPage", "oldfile", " newFilename", "oldFile", "newsKey", "Newfile", "newFiles", "NewFilename", "uniquefile", "uniquePage", "NewFiles", "newPage", "NewFile"], "fi": ["ifa", "mi", "fe", "ini", "bf", "di", "ri", "ki", "fr", "fp", "ti", "iu", "lf", "bi", "fd", "ci", "i", "pi", "sf", "uf", "Fi", "ni", "li", "si", "flo", "afi", "ife", "FI", "fa", "io", "cf", "ii", "isi", "fin", "zi", "phi"], "fo": ["hea", "co", "ko", "tto", "oe", "opa", "tk", "bo", "ow", "ki", "mo", "uo", "ti", "FO", "po", "hi", "ho", "eno", "fam", "oo", "zo", "ph", "jo", "vo", "zz", "eto", "tf", "sf", "ott", "wt", "flo", "oooo", "o", "sty", "te", "wo", "ato", "cf", "tif", "xf"]}}
{"id1": "5414088", "id2": "9846843", "code1": "    public static void saveFileData(File file, File destination, java.io.File newDataFile) throws Exception {\n        String fileName = file.getFileName();\n        String assetsPath = FileFactory.getRealAssetsRootPath();\n        new java.io.File(assetsPath).mkdir();\n        java.io.File workingFile = getAssetIOFile(file);\n        DotResourceCache vc = CacheLocator.getVeloctyResourceCache();\n        vc.remove(ResourceManager.RESOURCE_TEMPLATE + workingFile.getPath());\n        if (destination != null && destination.getInode() > 0) {\n            FileInputStream is = new FileInputStream(workingFile);\n            FileChannel channelFrom = is.getChannel();\n            java.io.File newVersionFile = getAssetIOFile(destination);\n            FileChannel channelTo = new FileOutputStream(newVersionFile).getChannel();\n            channelFrom.transferTo(0, channelFrom.size(), channelTo);\n            channelTo.force(false);\n            channelTo.close();\n            channelFrom.close();\n        }\n        if (newDataFile != null) {\n            FileChannel writeCurrentChannel = new FileOutputStream(workingFile).getChannel();\n            writeCurrentChannel.truncate(0);\n            FileChannel fromChannel = new FileInputStream(newDataFile).getChannel();\n            fromChannel.transferTo(0, fromChannel.size(), writeCurrentChannel);\n            writeCurrentChannel.force(false);\n            writeCurrentChannel.close();\n            fromChannel.close();\n            if (UtilMethods.isImage(fileName)) {\n                BufferedImage img = javax.imageio.ImageIO.read(workingFile);\n                int height = img.getHeight();\n                file.setHeight(height);\n                int width = img.getWidth();\n                file.setWidth(width);\n            }\n            String folderPath = workingFile.getParentFile().getAbsolutePath();\n            Identifier identifier = IdentifierCache.getIdentifierFromIdentifierCache(file);\n            java.io.File directory = new java.io.File(folderPath);\n            java.io.File[] files = directory.listFiles((new FileFactory()).new ThumbnailsFileNamesFilter(identifier));\n            for (java.io.File iofile : files) {\n                try {\n                    iofile.delete();\n                } catch (SecurityException e) {\n                    Logger.error(FileFactory.class, \"EditFileAction._saveWorkingFileData(): \" + iofile.getName() + \" cannot be erased. Please check the file permissions.\");\n                } catch (Exception e) {\n                    Logger.error(FileFactory.class, \"EditFileAction._saveWorkingFileData(): \" + e.getMessage());\n                }\n            }\n        }\n    }\n", "code2": "    public byte[] getResponse() {\n        final ByteArrayInputStream bais = new ByteArrayInputStream(request);\n        final ByteArrayOutputStream baos = new ByteArrayOutputStream();\n        List<String> lines = Collections.emptyList();\n        try {\n            @SuppressWarnings(\"unchecked\") List<String> dl = IOUtils.readLines(bais);\n            lines = dl;\n        } catch (IOException ioex) {\n            throw new AssertionError(ioex);\n        }\n        String resource = null;\n        for (String line : lines) {\n            if (line.startsWith(\"GET \")) {\n                int endIndex = line.lastIndexOf(' ');\n                resource = line.substring(4, endIndex);\n            }\n        }\n        final PrintStream printStream = new PrintStream(baos);\n        if (resource == null) {\n            printStream.println(\"HTTP/1.1 400 Bad Request\");\n        } else {\n            final InputStream inputStream = getClass().getResourceAsStream(resource);\n            if (inputStream == null) {\n                printStream.println(\"HTTP/1.1 404 Not Found\");\n                printStream.println();\n            } else {\n                printStream.println(\"HTTP/1.1 200 OK\");\n                printStream.println();\n                try {\n                    IOUtils.copy(inputStream, printStream);\n                } catch (IOException ioex) {\n                    throw new AssertionError(ioex);\n                }\n            }\n        }\n        printStream.flush();\n        printStream.close();\n        return baos.toByteArray();\n    }\n", "label": 1, "substitutes": {"saveFileData": ["storeFileData", "saveAssetContent", "savefileData", "saveStreamdata", "saveStreamResource", "saveFiledata", "storeFiledata", "saveAssetData", "saveStreamData", "savefiledata", "storeAssetdata", "savefileResource", "storeAssetData", "savefileContent", "storeAssetResource", "storeFileResource", "saveFileResource", "saveStreamContent", "saveFileContent", "saveAssetResource", "storeFileContent", "saveAssetdata", "storeAssetContent"], "file": ["type", "f", "rule", "report", "style", "handle", "play", "image", "address", "block", "picture", "entry", "policy", "File", "task", "FILE", "feature", "comment", "resource", "disk", "foo", "create", "page", "table", "run", "work", "port", "base", "module", "link", "attribute", "document", "message", "db", "filename", "ile", "format", "e", "cache", "url", "node", "name", "get", "error", "entity", "input", "issue", "parent", "mail", "path", "object", "null", "form", "change", "language", "model", "local", "info", "place", "http", "key", "io", "job", "field", "source", "class", "id", "print", "data"], "destination": ["destacement", "domining", "Destinations", "destining", " destinations", "Destinate", " destification", "targetinator", "combination", "targetination", "destinate", "coordinations", "destino", "domacement", "Destining", "coordification", "combinator", "domination", "combino", "Destinated", " destinator", "Destinator", "dominator", "Destacement", "transinator", "coordination", "transino", "declination", "targetining", "combinated", "destinations", "destification", "coordinator", "declinator", "Destification", "dominate", "destinated", "Destino", "Destination", "declinate", "destinator", "targetinate", "transinated", "declacement", "transination"], "newDataFile": ["newsImageStream", "newdataNode", "newDateTable", "newVersionFILE", "newVersionNode", "uniqueContentFile", "newdataTable", "newdataFiles", "uniqueContentfile", "uniqueContentChannel", "newsImageFile", "newsDataFile", "uniqueContentFILE", "newDataTable", "newDataFiles", "uniqueDataFile", "newsDataStream", "newDatefile", "uniqueDataFILE", "newVersionStream", "newsImagefile", "newsDataTable", " newDataNode", "newVersionTable", "newDatafile", "newDateStream", "newImagefile", "newVersionfile", "newsDatafile", "newdataFile", "newContentfile", "newDataChannel", "uniqueDataChannel", "newDATAfile", "newImageTable", "uniqueDatafile", "newImageFiles", "newContentChannel", "newImageNode", " newDataFiles", "newDataStream", " newVersionTable", "newDataNode", "newVersionChannel", "newVersionFiles", "newImageFile", " newVersionNode", "newDATAChannel", "newDataFILE", "newsImageTable", "newDATAFile", "newImageStream", "newContentFile", " newVersionFiles", "newContentFILE", "newDateFile", " newDataTable", "newDATAFILE"], "fileName": ["applicationAgent", "FileType", "fileNAME", "FileName", "applicationSource", "FILEName", "imageSource", "imageName", "wordSource", "imageOrder", "applicationOrder", "fileType", "filename", "FileNAME", "applicationName", "linkNAME", "FILEname", "fileAgent", "fileOrder", "Filename", "linkname", "wordAgent", "wordOrder", "linkType", "wordName", "FILENAME", "fileSource", "linkName", "imageAgent", "FILEType"], "assetsPath": ["scriptsDir", " assetspath", " assetsTh", "assetsRoot", " assetsRoot", "filesDir", " assetsDir", "filesRoot", "filesPath", "scriptsPath", "packagesTh", "filespath", "assetsDir", "packagesPath", "packagesDir", "assetsTh", "filesTh", "packagesRoot", "scriptspath", "scriptsRoot", "assetspath"], "workingFile": [" workingSet", "runningFile", "workSourceFile", " workingModel", " workingSourceFile", "workingPath", "movingFile", "workPage", " workingPage", "runningLine", "writingfile", "workFile", "workingfile", "workingPage", "WorkingFile", "workingFolder", "startingPage", " workingLine", "WorkingFolder", "movingFolder", " workingStore", "workStore", "WorkingFiles", " workingFiles", " workingPath", "runningfile", "workingStore", " workingUnit", "WorkingFILE", "playingModel", "WorkingPage", "workingSourceFile", "WorkingModel", "playingFile", "workPath", "movingfile", "runningFILE", "playingfile", "workingFILE", "WorkingSourceFile", " workingfile", "workingModel", "workingSet", "startingfile", "Workingfile", "workfile", "movingPage", "workingUnit", "WorkingPath", "startingFile", "workingLine", "workLine", "WorkingSet", "workFolder", "workingFiles", "startingSet", "WorkingStore", "writingLine", "workFiles", "writingFile", "writingFILE", "playingUnit", "WorkingUnit", "WorkingLine"], "vc": ["vd", "rc", "cv", "bt", "rt", "vp", "vt", "bc", "WC", "conv", "CV", "hw", "c", "cs", "fc", "ic", "cu", "lv", "v", "xc", "cache", "sv", "cm", "ec", "vv", "lc", "tc", "lp", "VC", "etc", "mc", "nc", "vr", "cf", "ht", "vm", "cin", "nv", "dc", "cc"], "is": ["does", "ms", "iris", "ins", "im", "Is", "nis", "ri", "sys", "ls", "isa", "in", "isd", "ic", "i", "its", "ris", "os", "has", "are", "ys", "IS", "sis", "isc", "ir", "isl", "lis", "bis", "isf", "gets", "ii", "isi", "ios", "still", "isin", "iso", "iss", "\u00eds", "ib", "abs"], "channelFrom": ["memberFrom", "Channelfrom", "ChannelBy", "memberfrom", "channelBy", " channelOf", "memberBefore", "categoryIn", " channelBefore", "entityTo", "categoryBy", " channelFor", "buttonfrom", "memberOf", "ChannelFrom", "memberFor", "ChannelFor", "pixelTo", "categoryFrom", "buttonBefore", "categoryTo", "memberTo", "buttonFrom", "entityFrom", "channelBefore", "channelFor", "pixelBefore", " channelBy", "ChannelTo", "pixelfrom", " channelfrom", "channelIn", "channelOf", "entityOf", " channelIn", "channelfrom", "pixelFrom", "buttonTo", "entityBefore", "ChannelIn"], "newVersionFile": ["newVersionsClass", "newVersionsFile", "nextVersionFile", "newServerTable", "newVersionsfile", "newVfile", "newversionImage", "newVERSIONFiles", "newVFile", "newVersionImage", "nextVersionTable", "newVersionClass", "newServerFiles", "nextversionTable", "newVersionTable", "nextversionFiles", "nextVersionFiles", "newVClass", "newversionTable", "newVERSIONTable", "newVersionfile", "nextversionImage", "newServerFile", "oldVersionfile", "oldVersionFile", "oldVersionClass", "nextVersionImage", "newversionFiles", "newVERSIONFile", "newVersionFiles", "newServerImage", "nextversionFile", "newVERSIONImage", "newversionFile"], "channelTo": ["memberFrom", " channelTO", "ChannelTarget", "memberTO", "consoleTO", "connectionTo", "channelTarget", "ChannelFrom", "Channelto", "clientto", "consoleTo", "clientTo", "connectionTO", "channelTO", "memberTo", "memberto", "commandFrom", " channelTarget", "consoleto", "ChannelTO", "commandTo", "clientFrom", "ChannelTo", "channelto", " channelto", "commandto", "consoleTarget", "commandTO", "connectionto", "clientTO", "connectionFrom"], "writeCurrentChannel": ["writeCurrentlychannel", "writeCurrentlyChan", " writecurrentHandler", "readCurrentchannel", "writeURRENTPassword", " writeCurrentChan", " writeCurrentPassword", "writeCurrentConnection", " writecurrentButton", " writeCurrentchannel", "writeCurrentPassword", "readcurrentRoom", " writecurrentchannel", "readcurrentButton", "writeByChan", "writeByChannel", " writecurrentCategory", " writecurrentSlot", "writeCurrentlyConnection", "writeURRENTConnection", " writecurrentChannel", " writeCurrentlyChan", "writeNowSlot", " writeCurrentSlot", "writecurrentHandler", "writeNowChannel", "writeCurrentSlot", "writecurrentRoom", "writeCurrentButton", " writeCurrentCategory", "writeCurrentlyHandler", "writeNowchannel", "writeCurrentRoom", "writeURRENTChannel", "writecurrentCategory", "writeRecentChannel", "writeCurrentlyChannel", "writeNowConnection", "writeBychannel", "writecurrentPassword", "writeCurrentChan", "writeCurrentlyButton", "writeCurrentlyRoom", "writeURRENTHandler", " writecurrentPassword", "readcurrentChannel", "writeRecentRoom", "writeRecentPassword", "writeRecentCategory", " writeCurrentlyConnection", "writecurrentchannel", "writeRecentButton", "writecurrentChannel", "writecurrentButton", "writeURRENTButton", "writecurrentChan", "writeURRENTchannel", " writecurrentConnection", "writecurrentSlot", "readCurrentRoom", " writeCurrentlyChannel", " writeCurrentConnection", "writeRecentSlot", "writeRecentchannel", "writeRecentConnection", " writeCurrentHandler", " writeCurrentButton", "writecurrentConnection", "writeURRENTCategory", " writeCurrentlychannel", "writeCurrentchannel", "readCurrentButton", "writeCurrentHandler", "readcurrentchannel", "writeCurrentCategory", "writeByConnection", "readCurrentChannel"], "fromChannel": ["formChannel", "Fromchannel", "fromChan", "boundChan", "boundChannel", "toCh", " fromConnection", "formChan", " fromByte", "fromCan", "FromButton", "withChan", " fromChan", "fromchannel", "boundCh", "innerCan", "formByte", " fromchannel", " fromButton", "fromCh", "innerChannel", "tochannel", "innerConnection", "formchannel", "boundchannel", "FromCan", "fromConnection", "fromButton", "FromConnection", "toConnection", "fromByte", "FromCh", "innerButton", "FromChannel", "toChannel", "withByte", "toChan", "FromChan", "withChannel", " fromCan", "withchannel"], "img": ["gif", "buf", "image", "um", "picture", "bg", "im", "obj", "m", "medium", "gd", "tmp", "ami", "md", "mp", "pg", "jpg", "anim", "src", "Image", "ext", "lib", "uf", "imag", "images", "fig", "png", "gm", "it", "pic", "mb", "info", "iam", "html", "io", "shr", "pixel", "aug", "imgur", "big", "data"], "height": ["acity", "window", "style", "hang", "ows", "alpha", "icity", "rows", "h", "capacity", "gravity", "depth", "view", "medium", "stroke", "ure", "itude", "rank", "build", "gh", "Height", "max", "bottom", "grow", "gy", "def", "huge", "resolution", "hash", "ty", "png", "history", "heads", "length", "density", "kw", "volume", "html", "size", "angle", "w"], "width": ["window", "wid", "span", "layout", "radius", "min", "console", "left", "frame", "depth", "description", "area", "w", "page", "port", "x", "write", "only", "message", "max", "west", "widget", "format", "position", "resolution", "top", "idth", "margin", "Width", "length", "term", "rail", "amount", "lat", "weight", "padding", "blue", "crop", "size", "body", "version", "duration", "title", "render"], "folderPath": ["browserPath", "FolderDir", "foldPath", "foldDir", "FolderPath", "foldName", " folderDir", "browserName", "folderpath", "browserUrl", " folderpath", "browserpath", " folderUrl", "folderDir", "folderName", " folderName", "foldpath", "folderUrl", "Folderpath", "FolderUrl", "FolderName"], "directory": ["reference", " manager", " previous", " residing", "application", "Directory", " located", "context", " directories", "library", " future", "connection", "module", "buffer", "division", "ory", " rectangle", "document", " directly", "filename", "Director", "ORY", "archive", "container", " Directory", " temporary", "tree", "Folder", "parent", "secondary", "path", " document", "dir", "collection", "database", " director", "manager", " database", " repository", "volume", "folder", "root", " library", "direct", " dictionary"], "files": ["photos", "links", "assets", " Files", "versions", "users", "items", "children", "keys", "types", "fs", "modules", "classes", "names", "iles", "uploads", "workers", "images", "fields", "resources", "thumbnails", "members", "objects", "Files", "values", "data", "results"]}}
{"id1": "812803", "id2": "8490297", "code1": "    public void convert(File src, File dest) throws IOException {\n        InputStream in = new BufferedInputStream(new FileInputStream(src));\n        DcmParser p = pfact.newDcmParser(in);\n        Dataset ds = fact.newDataset();\n        p.setDcmHandler(ds.getDcmHandler());\n        try {\n            FileFormat format = p.detectFileFormat();\n            if (format != FileFormat.ACRNEMA_STREAM) {\n                System.out.println(\"\\n\" + src + \": not an ACRNEMA stream!\");\n                return;\n            }\n            p.parseDcmFile(format, Tags.PixelData);\n            if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) {\n                System.out.println(\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n                return;\n            }\n            boolean hasPixelData = p.getReadTag() == Tags.PixelData;\n            boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12;\n            int pxlen = p.getReadLength();\n            if (hasPixelData) {\n                if (inflate) {\n                    ds.putUS(Tags.BitsAllocated, 16);\n                    pxlen = pxlen * 4 / 3;\n                }\n                if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) {\n                    System.out.println(\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                    return;\n                }\n            }\n            ds.putUI(Tags.StudyInstanceUID, uid(studyUID));\n            ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID));\n            ds.putUI(Tags.SOPInstanceUID, uid(instUID));\n            ds.putUI(Tags.SOPClassUID, classUID);\n            if (!ds.contains(Tags.NumberOfSamples)) {\n                ds.putUS(Tags.NumberOfSamples, 1);\n            }\n            if (!ds.contains(Tags.PhotometricInterpretation)) {\n                ds.putCS(Tags.PhotometricInterpretation, \"MONOCHROME2\");\n            }\n            if (fmi) {\n                ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian));\n            }\n            OutputStream out = new BufferedOutputStream(new FileOutputStream(dest));\n            try {\n            } finally {\n                ds.writeFile(out, encodeParam());\n                if (hasPixelData) {\n                    if (!skipGroupLen) {\n                        out.write(PXDATA_GROUPLEN);\n                        int grlen = pxlen + 8;\n                        out.write((byte) grlen);\n                        out.write((byte) (grlen >> 8));\n                        out.write((byte) (grlen >> 16));\n                        out.write((byte) (grlen >> 24));\n                    }\n                    out.write(PXDATA_TAG);\n                    out.write((byte) pxlen);\n                    out.write((byte) (pxlen >> 8));\n                    out.write((byte) (pxlen >> 16));\n                    out.write((byte) (pxlen >> 24));\n                }\n                if (inflate) {\n                    int b2, b3;\n                    for (; pxlen > 0; pxlen -= 3) {\n                        out.write(in.read());\n                        b2 = in.read();\n                        b3 = in.read();\n                        out.write(b2 & 0x0f);\n                        out.write(b2 >> 4 | ((b3 & 0x0f) << 4));\n                        out.write(b3 >> 4);\n                    }\n                } else {\n                    for (; pxlen > 0; --pxlen) {\n                        out.write(in.read());\n                    }\n                }\n                out.close();\n            }\n            System.out.print('.');\n        } finally {\n            in.close();\n        }\n    }\n", "code2": "    public static void copyFile(File src, File dst) throws IOException {\n        try {\n            InputStream in = new FileInputStream(src);\n            OutputStream out = new FileOutputStream(dst);\n            byte[] buf = new byte[TEMP_FILE_BUFFER_SIZE];\n            int len;\n            while ((len = in.read(buf)) > 0) out.write(buf, 0, len);\n            in.close();\n            out.close();\n        } catch (FileNotFoundException e1) {\n            MLUtil.runtimeError(e1, src.toString());\n        } catch (IOException e2) {\n            MLUtil.runtimeError(e2, src.toString());\n        }\n    }\n", "label": 1, "substitutes": {"convert": ["Converting", "compvert", "converts", "unverted", "consvert", "Conprocess", "CONversion", "converted", "Conversion", "unprocess", "confer", "unfer", "Confer", "unvert", "unverts", "compverts", "ConVERT", "Converted", "CONvert", "conversion", "conprocess", "CONfer", "Convert", "CONverted", "unversion", "compversion", "compprocess", "consversion", "converting", "CONverting", "consVERT", "consverting", "conVERT", "CONVERT", "Converts"], "src": ["ser", "buster", "rc", "txt", "hl", "scan", "usr", "attr", "img", "orig", "func", "ins", "sit", "cont", "sys", "stream", "SourceFile", "sq", "addr", "rest", "pkg", "cur", "sr", "rel", "filename", "ur", "Source", "its", "req", "url", "uri", "RC", "rs", "str", "SOURCE", "inst", "input", "upload", "sin", "rx", "sc", "st", "path", "ource", "s", "iv", "scene", "href", "http", "config", "dist", "start", "file", "source", "loc", "ipl", "ebin", "from", "host", "cc"], "dest": ["txt", "img", " destinations", "gin", "orig", "test", "disk", "est", "table", "port", "rest", "write", " Dest", "result", " dst", "mat", "target", "foreign", " orig", " destination", "dir", "dat", "Dest", "dist", "temp", " Destination", "source", "tif"], "in": ["en", "rin", "inn", "res", "IN", "ins", "d", "ar", "reader", "m", "stream", "In", "inner", "b", "up", "i", "bin", "serv", "l", "input", "sql", "st", "ind", "r", "el", "ad", "io", "din", "inf", "is", "isin", "source", "as", "file", "cin", "from"], "p": ["f", "php", "pa", "pb", "dp", "j", "pd", "tp", "rep", "vp", "sp", "d", "py", "parser", "part", "h", "op", "pp", "m", "fp", "t", "pl", "c", "pkg", "b", "pg", "ps", "ping", "post", "pro", "i", "cp", "ph", "pc", "pt", "pi", "l", "it", "per", "parse", "P", "pers", "at", "lp", "pre", "g", "r", "jp", "pm", "er", "wp", "prot", "pe", "ap"], "ds": ["dates", "dp", "di", " ads", "scripts", "loads", "yes", "qs", "tests", "ns", "ps", "drivers", "db", "dds", "sd", "ats", "dt", " DS", "ports", "ras", "terms", "ss", "DS", "ws", "bs", "docs", "hs", "workers", "iffs", "lists", "os", "edes", "gs", " dd", "hd", "vs", " d", "uds", "ils", "eds", "xs", "tags", "Ds", "dl", "els", "sets", "gd", "ls", "ts", "ags", "rs", " des", "obs", "s", "outs", "ods", "sts", "posts", "ands", "tes", "cs", "amps", "dos", "ads", "pd", "tp", "mys", "d", "cks", "js", " os", "its", "aws", "ys", "des", "eps", "dd", "ks", "points", "df", "nas", "dh"], "format": ["type", "f", "style", "layout", "settings", "output", "policy", "MAT", "feature", "mt", "fm", "set", "status", "table", "tag", "t", "feat", " Format", "module", "template", "sche", "spec", "fc", "shape", "mode", "Format", "ct", "act", "mat", "name", "ats", "pi", "top", "l", "it", "parse", "form", "path", "at", "filter", "lat", "pattern", "id", "cf", "file", "source", "size", "unit", "version", "pretty", "title"], "hasPixelData": ["HaspixelDATA", "hasixelData", "hasPixelDATA", "Haspixeldata", "hasPixeldata", "HasPixelDATA", "HaspixelData", "hasFrameData", "hasFrameDATA", "haspixelDATA", "hasFramedata", "HasPixeldata", "haspixeldata", " hasPixelDATA", " hasPixeldata", "hasixeldata", "hasixelDATA", "HasPixelData", "haspixelData"], "inflate": ["inFLated", "Inflate", "invalidATE", "inFLat", "inFLocate", "incelate", " invalidicate", "infolat", "Inflat", "invalidate", "inFlicate", "inflATE", "inflated", "incelicate", " inflocate", "incelocate", "Informocate", "Informated", "incelATE", "inFlATE", " inflicate", "inFlate", " invalidate", "informat", "infolated", "Inflocate", "inflicate", "inFlocate", "infolocate", "informocate", "informate", "Informat", "invalidicate", "Inflated", " inflATE", "inflocate", "informated", "Informate", "inFLate", "invalidocate", " invalidATE", "inflat", " invalidocate", "infolate"], "pxlen": ["pxln", "mmlin", "packlen", "pxlength", "cpln", "xplength", "cplength", "phpln", "pixellength", "pxlin", "cpden", "mxlength", "cplen", "packlength", "pexlength", "xylen", "mmlen", "pxdec", "tmpln", "packdec", "phplength", "pexln", "mxdec", "packfun", "pexls", "mxlen", "pxls", "pxfun", "xylin", "xyln", "tmplin", "xpden", "mxln", "tmplen", "pexlen", "pxden", "phplen", "pexfun", "mmlength", "pixelfun", "packls", "xpln", "phpdec", "pixells", "pexden", "tmplength", "xplen", "packln", "mmln", "pixellen", "xylength"], "out": ["output", "res", "obj", "ln", "client", "sys", "sum", "inter", "init", "net", "log", "print", "err", "list", "up", "crit", "name", "writer", "outer", "cmd", "conn", "gov", "ou", "group", "aos", "outs", "dir", "cfg", "inv", "screen", "gr", "io", "msg", "temp", "Out", "OUT", "user", "store", "pretty", "prefix", "ex"]}}
{"id1": "9371421", "id2": "9081749", "code1": "    public static String eventHash(String eventstr) {\n        try {\n            if (md == null) {\n                md = MessageDigest.getInstance(\"MD5\");\n            }\n            md.update(eventstr.getBytes(\"utf-8\"));\n            byte[] theDigest = md.digest();\n            return new BASE64Encoder().encode(theDigest);\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        } catch (UnsupportedEncodingException e) {\n            e.printStackTrace();\n        }\n        return null;\n    }\n", "code2": "    private static String encrypt(String password, String encryptType) {\n        try {\n            MessageDigest md = MessageDigest.getInstance(encryptType);\n            md.update(password.getBytes());\n            byte[] hash = md.digest();\n            StringBuffer hexString = new StringBuffer();\n            for (int i = 0; i < hash.length; i++) {\n                if ((0xff & hash[i]) < 0x10) {\n                    hexString.append(\"0\" + Integer.toHexString((0xFF & hash[i])));\n                } else {\n                    hexString.append(Integer.toHexString(0xFF & hash[i]));\n                }\n            }\n            password = hexString.toString();\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        }\n        return password.toUpperCase();\n    }\n", "label": 1, "substitutes": {"eventHash": [" eventhash", "textHash", "Eventhash", "textRender", " eventName", "EventRender", " eventRender", "EventHash", "EventName", "eventhash", "eventRender", "texthash", "eventName", "textName"], "eventstr": ["ventstr", "ventenc", "EventStr", "Eventstr", " eventstring", "ventname", "msgStr", " eventenc", " eventname", "Eventstring", "eventStr", "Eventname", "msgname", "Eventenc", "eventstring", "msgstring", "ventStr", "eventname", " eventStr", "eventenc", "msgstr"], "md": ["nt", "ms", "pd", "od", "di", "d", "der", "mt", "m", "mo", "mod", "mem", "met", "mg", "red", "del", "mp", "dr", "rm", "det", "dm", "sd", "td", "down", "dd", "cmd", "mand", "metadata", "dat", "mb", "cd", "hd", "MD", "dig", "ind", "ad", "grad", "mn", "mc", "mm", "bd", "ma", "pm", "mk", "ld", "nd", "df", "dh"], "theDigest": ["THEDigests", "theDFested", "theDest", "THEMDests", " theDested", "theDFest", "theDecests", "theMDest", "THEDigEST", "theDFEST", "theDecest", " theDEST", "theMDEST", "theDigesting", "THEDigest", " theDigested", "theDEST", "theDested", "theDecEST", "thedigesting", "thedigest", "theMDests", "theDests", " theDigEST", "theDesting", "thedigEST", "THEMDEST", "THEMDested", "THEMDest", "theDFesting", " theDigesting", "theDigests", "theDecested", "thedigested", "theDigEST", "theMDested", " theDesting", "theDigested", "THEDigested", " theDest"]}}
{"id1": "4168534", "id2": "7425022", "code1": "    public String insertSmsInf(Sms sms) throws Exception {\n        String smsId = null;\n        Connection conn = null;\n        PreparedStatement pstmt = null;\n        StringBuffer buffer = new StringBuffer();\n        try {\n            buffer.append(\"INSERT INTO COMTNSMS\\n\");\n            buffer.append(\"  (SMS_ID, TRNSMIS_TELNO, TRNSMIS_CN,\\n\");\n            buffer.append(\"   FRST_REGISTER_ID, FRST_REGIST_PNTTM )\\n\");\n            buffer.append(\"VALUES\\n\");\n            buffer.append(\"(?, ?, ?, ?, SYSDATE())\");\n            conn = SmsBasicDBUtil.getConnection();\n            conn.setAutoCommit(false);\n            smsId = getNextId(conn);\n            pstmt = conn.prepareStatement(buffer.toString());\n            int index = 0;\n            pstmt.setString(++index, smsId);\n            pstmt.setString(++index, sms.getTrnsmitTelno());\n            pstmt.setString(++index, sms.getTrnsmitCn());\n            pstmt.setString(++index, sms.getFrstRegisterId());\n            pstmt.executeUpdate();\n            conn.commit();\n            return smsId;\n        } catch (Exception ex) {\n            if (conn != null) {\n                conn.rollback();\n            }\n            throw ex;\n        } finally {\n            SmsBasicDBUtil.close(null, pstmt, conn);\n        }\n    }\n", "code2": "    private String transferWSDL(String wsdlURL, String userPassword) throws WiseConnectionException {\n        String filePath = null;\n        try {\n            URL endpoint = new URL(wsdlURL);\n            HttpURLConnection conn = (HttpURLConnection) endpoint.openConnection();\n            conn.setDoOutput(false);\n            conn.setDoInput(true);\n            conn.setUseCaches(false);\n            conn.setRequestMethod(\"GET\");\n            conn.setRequestProperty(\"Accept\", \"text/xml,application/xml,application/xhtml+xml,text/html;q=0.9,text/plain;q=0.8,image/png,*/*;q=0.5\");\n            conn.setRequestProperty(\"Connection\", \"close\");\n            if (userPassword != null) {\n                conn.setRequestProperty(\"Authorization\", \"Basic \" + (new BASE64Encoder()).encode(userPassword.getBytes()));\n            }\n            InputStream is = null;\n            if (conn.getResponseCode() == 200) {\n                is = conn.getInputStream();\n            } else {\n                is = conn.getErrorStream();\n                InputStreamReader isr = new InputStreamReader(is);\n                StringWriter sw = new StringWriter();\n                char[] buf = new char[200];\n                int read = 0;\n                while (read != -1) {\n                    read = isr.read(buf);\n                    sw.write(buf);\n                }\n                throw new WiseConnectionException(\"Remote server's response is an error: \" + sw.toString());\n            }\n            File outputDir = new File(wiseProperties.getProperty(\"wise.tmpDir\"));\n            if (!outputDir.exists()) {\n                outputDir.mkdir();\n                wiseProperties.setProperty(\"wise.forceImportObject\", \"true\");\n            }\n            File file = new File(wiseProperties.getProperty(\"wise.tmpDir\"), new StringBuffer(\"Wise\").append(IDGenerator.nextVal()).append(\".xml\").toString());\n            OutputStream fos = new BufferedOutputStream(new FileOutputStream(file));\n            IOUtils.copyStream(fos, is);\n            fos.close();\n            is.close();\n            filePath = file.getPath();\n        } catch (WiseConnectionException wce) {\n            throw wce;\n        } catch (Exception e) {\n            throw new WiseConnectionException(\"Wsdl download failed!\", e);\n        }\n        return filePath;\n    }\n", "label": 0, "substitutes": {"insertSmsInf": [" insertSmsById", " insertSmbId", " insertsMSConf", " insertSmtInf", " insertSMSInf", " insertSMSById", " insertsmsConf", " insertSmtId", " insertsmsInf", " insertSmtConf", " insertSmsId", " insertsMSById", " insertSmbConf", " insertSMSConf", " insertSMSId", " insertsMSId", " insertsMSInf", " insertSmsConf", " insertSmbById", " insertSmbInf", " insertsmsId", " insertSmtById", " insertsmsById"], "sms": ["smb", "gsvc", "ssms", "esvc", "jsmt", "Smo", "mspm", "msts", " sts", "spm", "ssems", "mscs", "ssmm", " smm", " smt", "jsms", " sems", "scs", "gsms", "msems", "gsmo", "sps", "esps", "msmm", " scs", "esmo", "jsmb", "svc", " smo", " svc", " sps", "smt", "msms", " spm", "sts", "jsmo", "esms", "Smb", "gsps", "sems", " smb", "smm", "Smt", "smo", "ssts", "Sms"], "smsId": ["gesmsID", "gesmsById", "smbID", "snsid", " smbName", "sessById", "snewsID", "sMSKey", "smsKey", "smsID", "hsmsById", "sessId", "gesnsId", "sMSid", "hsnewsKey", " smsID", " sessid", " sessById", "sMSID", " sessID", "gesnsName", "snsId", "smmName", "smsById", "hsnewsById", " smbId", "snsID", "smbName", "sessid", "sessID", "smbId", "smsName", "smedID", " smsid", "smsgId", "hsmsID", "smmById", "smbById", "snsById", "hsnewsID", "snsName", "snewsId", "snewsById", "snewsKey", "sMSById", "hsnewsId", "smsgID", "gesmsName", "hsmsId", "gesmsId", "smedId", " smbID", "smsgName", "smedName", " smsById", "smmId", "smmID", " smsName", "sMSId", "smsid", "hsmsKey", " sessId", "gesnsID", " smbById", "snsKey", "smsgById", "gesnsById", "smedById"], "conn": [" con", "co", "txt", "nt", "en", "handle", "ctx", "con", "rt", "pas", "res", "comm", "cb", "cn", "cont", "bo", "js", "enc", "obj", "yn", "mt", "client", "ont", "lang", "gate", "col", "conv", "mem", "ann", "connection", "ns", "ce", "po", "ca", "c", "addr", "open", "link", "cert", "pg", "cur", "db", "close", "org", "conf", "reg", "ct", "cp", "sec", "tn", "gc", "Conn", "coll", "Connection", "out", "ec", "ch", "cmd", "sql", "np", "ctrl", "cfg", "connect", "mc", "nc", "jp", "n", "msg", "exec", "pool", "loc", "dc", "session", "cc"], "pstmt": ["pstymt", "ppstmm", "pstatmn", " pstg", " pstm", "pfrmod", " postwr", "pctrel", "ystystat", "psetmt", "postmt", " pctmt", "ppstmt", "perstph", "pstmsg", "pfrmp", "pstymn", "pctgr", "pstnm", "pstcmd", "pStmt", "pStmn", "pstygr", "pputcmd", " pstcmd", "pputmr", "pconstmr", "pstmr", "pprestmn", "pstatmm", "pputgr", "prestmn", "pStmm", "pputmt", " pstatstat", "ystmn", "prestem", "pstymb", " postmt", "pctnm", "pstatmb", "pstm", "pputmm", " pstatg", "pstym", "pstecmd", "pSTstat", "psetmm", "pstmn", "pstatm", "pstmp", " pstmr", "persetmm", "pstyg", "perstmt", "perstmm", "pctmp", " pctmod", "pstmm", " pstnm", "pprestmm", " postgr", "pconstnm", " pstmb", "persetph", "yststat", "ystymt", "psstygr", "pstatem", "pstph", "psstgr", " pctmm", "pstystat", " pstmp", "pstatgr", "pstmod", "pctstat", " pstmm", " pststat", "pputg", "postgr", "pstgr", " pctnm", "pconstmt", "pSTgr", "pprestmt", "pstatmp", "psstm", "ystygr", "pstatmod", "ystmt", "ppstmn", "pstemt", "pputmb", "psetph", "pststat", "pctmm", "perstmsg", "pprestem", "pStem", "pstatg", "ppstem", "pstg", "pstyrel", "pputwr", " pctmp", "ystymn", "pputnm", "pctmr", "ystgr", "psstrel", "persetmt", "pctm", "psstyrel", "prestmm", "pstwr", " pctmr", "pstatstat", "pstatmt", "pctmod", "pstegr", " pstgr", "pputstat", "psstym", "postcmd", "pstatrel", "pfrm", "postwr", " pstmod", "pSTmt", "pconstmm", "pstatph", " pstatmb", " pstwr", " postcmd", "pstatmsg", " pstatmt", "persetmsg", " pctm", "pctmt", "pstewr", "psetmsg", "pSTmn", "prestmt", "psstmt", "psstymt", "pstmb", "pctmn", "pstem", "pstrel", "pfrmt"], "buffer": ["empty", "phrase", "buf", "window", "block", "buff", "reset", "output", "py", "comment", "bo", "builder", "sequence", "create", "append", "table", "library", "mem", "base", "directory", "template", "code", "profile", "command", "build", "connection", "b", "function", "document", "message", "printf", "join", "cache", "Buffer", "url", "black", "uf", "initial", "out", "iter", "order", "history", "queue", "group", "mb", "batch", "database", "trace", "key", "string", "quote", "display", "temp", "control", "button", "file", "size", "pool", "memory", "shell", "print", "server", "header", "escape"], "index": ["exp", "empty", "ion", "access", "process", "value", "find", "ctx", "default", "rand", "column", "draw", "request", "create", "set", "axis", "IND", "thread", "gate", "context", "init", "x", "append", "fac", "attribute", "push", "open", "scope", "stick", "strip", "Index", "number", "read", "second", "see", "condition", "position", "success", "pos", "EX", "cond", "lex", "hex", "query", "exit", "val", "mix", "ind", "num", "add", "connect", "count", "row", "key", "scale", "with", "size", "loc", "zero", "check", "card", "ix"], "ex": ["exp", "event", "pex", "txt", "con", "ax", "se", "obj", "w", "nex", "t", "x", "wx", "err", "ception", "exe", "re", "tex", "ext", "e", "pac", "ox", "example", "external", " dex", "EX", "or", "expl", "lex", "hex", "cre", "Ex", "rx", "exit", "exc", "rex", "aux", "a"]}}
{"id1": "12380475", "id2": "18974466", "code1": "    public void transport(File file) throws TransportException {\n        if (file.exists()) {\n            if (file.isDirectory()) {\n                File[] files = file.listFiles();\n                for (int i = 0; i < files.length; i++) {\n                    transport(file);\n                }\n            } else if (file.isFile()) {\n                try {\n                    FileChannel inChannel = new FileInputStream(file).getChannel();\n                    FileChannel outChannel = new FileOutputStream(destinationDir).getChannel();\n                    inChannel.transferTo(0, inChannel.size(), outChannel);\n                } catch (IOException e) {\n                    log.error(\"File transfer failed\", e);\n                }\n            }\n        }\n    }\n", "code2": "    protected boolean copyFile(File sourceFile, File destinationFile) {\n        try {\n            FileChannel srcChannel = new FileInputStream(sourceFile).getChannel();\n            FileChannel dstChannel = new FileOutputStream(destinationFile).getChannel();\n            dstChannel.transferFrom(srcChannel, 0, srcChannel.size());\n            srcChannel.close();\n            dstChannel.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n            return false;\n        }\n        return true;\n    }\n", "label": 1, "substitutes": {"transport": ["export", "Translate", "trports", "Transceive", "intermit", "traction", "transports", "traceive", "transaction", "exmit", "exports", "traport", "Transmit", "interport", "traaction", "translate", "trport", "traports", "transmit", "trceive", "exlate", "exceive", "Transport", "interlate", "exaction", "interceive", "transceive"], "file": ["event", "rule", "output", "File", "FILE", "page", "t", "port", "base", "work", "be", "db", "get", "out", "record", "relation", "channel", "domain", "info", "config", "io", "type", "f", "handle", "resource", "force", "template", "link", "log", "document", "ile", "name", "tree", "line", "local", "key", "http", "report", "block", "entry", "comment", "create", "table", "module", "e", "url", "input", "path", "dir", "pool", "user", "data", "image", "fp", "directory", "spec", "attribute", "message", "current", "format", "entity", "valid", "null", "running", "use", "full", "remote", "source", "class", "folder", "p", "title"], "files": ["times", "papers", "photos", "reports", " Files", "assets", "items", "keys", "plates", "scripts", "fs", "modules", "lines", "types", "tests", "ls", "jobs", "packages", "classes", "names", "iles", "uploads", "issues", "styles", "images", "ids", "fields", "thumbnails", "members", "projects", "checked", "objects", "headers", "balls", "mails", "ories", "ors", "Files", "pages", "books", "faces"], "i": ["mi", "u", "ini", "j", "us", "y", "ms", "I", "cos", "qi", "di", "ie", "im", "m", "client", "ki", "t", "in", "x", "init", "me", "base", "ti", "inner", "bi", "b", "ic", "cli", "multi", "ci", "ai", "sim", "gi", "ui", "e", "uri", "pi", "ix", "iter", "uu", "li", "my", "ims", "si", "batch", "ip", "io", "gu", "is", "ii", "id", "phi"], "inChannel": ["openCategory", "InConnection", "openFace", "inStream", "InChan", "inChan", "createChannel", "dinchannel", "dinChan", "openChannel", "createCategory", "InChannel", "innChan", "innChannel", "InStream", "dinConnection", "innStream", "dinChannel", " inConnection", "fromPanel", " inchannel", "innchannel", "fromFace", "createPanel", "createFace", " inStream", "inCategory", "fromChannel", "openPanel", "inPanel", "fromCategory", " inChan", "inConnection", "inchannel", "Inchannel", "inFace"], "outChannel": ["outputConnection", "inChan", "OUTChan", "outConnection", "outputchannel", " outCh", "OUTCh", "OUTchannel", " outChan", "outputStream", " outStream", "outStream", " outConnection", "OUTChannel", "inConnection", " outchannel", "outChan", "outputChannel", "outputCh", "outchannel", "inStream", "outCh", "outputChan"]}}
{"id1": "7044685", "id2": "2910383", "code1": "    static String encrypt(String plaintext) {\n        MessageDigest d = null;\n        try {\n            d = MessageDigest.getInstance(\"SHA-1\");\n            d.update(plaintext.getBytes(\"UTF-8\"));\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return new String(Base64.encodeBase64(d.digest()));\n    }\n", "code2": "    public String downloadAndOpen(JProgressBar bar) {\n        long size = 0;\n        try {\n            size = photo.getSize();\n        } catch (ServiceException ex) {\n            ex.printStackTrace();\n        }\n        try {\n            bar.setMaximum((int) size);\n        } catch (Exception ex) {\n            ex.printStackTrace();\n        }\n        bar.setValue(0);\n        image = new File(\"TMP/\" + photo.getTitle().getPlainText());\n        try {\n            if (!image.exists()) {\n                image.createNewFile();\n                image.deleteOnExit();\n                URL url = null;\n                BufferedOutputStream fOut = null;\n                try {\n                    url = new URL(photo.getMediaContents().get(0).getUrl());\n                    InputStream html = null;\n                    html = url.openStream();\n                    fOut = new BufferedOutputStream(new FileOutputStream(image));\n                    byte[] buffer = new byte[32 * 1024];\n                    int bytesRead = 0;\n                    int in = 0;\n                    while ((bytesRead = html.read(buffer)) != -1) {\n                        in += bytesRead;\n                        bar.setValue(in);\n                        fOut.write(buffer, 0, bytesRead);\n                    }\n                    html.close();\n                    fOut.close();\n                } catch (Exception ex) {\n                    ex.printStackTrace();\n                }\n            }\n        } catch (Exception ex) {\n            ex.printStackTrace();\n        }\n        return image.getAbsolutePath();\n    }\n", "label": 0, "substitutes": {"encrypt": [" encryption", "Encryption", "cryption", "crypted", "Encrypted", " encrypted", "encrypted", "Encrypt", "encryption", "crypt"], "plaintext": ["mainstring", "ainstring", " plaindata", "aindata", "messageText", "messagetext", "messageprint", "ainprint", "plainText", "plainprint", " plainText", "messagedata", " plainprint", "ainText", "maintext", "aintext", " plainstring", "plainstring", "mainText", "plaindata"], "d": ["f", "dec", "ord", "pd", "dl", "y", "od", "z", "di", "h", "m", "D", "w", "gd", "t", " md", "mod", "done", "debug", "md", "c", "red", "fd", "end", "dr", "db", "e", "sd", "ded", "dm", "nd", "l", "dal", "ds", "dd", "da", "dat", "dx", "cd", "hd", "dig", "g", "ind", "ad", "did", "de", "ld", "p", "bd", "df", "dh"]}}
{"id1": "23510383", "id2": "8788371", "code1": "    public boolean saveProject(File file, Set<String> types, Set<String> images, Set<String> trajectories, boolean databasesIncluded, boolean onlyLinks) throws IOException, SQLException {\n        int index = file.getName().lastIndexOf(\".\");\n        String name = file.getName().substring(0, index);\n        DecimalFormat format = new DecimalFormat(\"####\");\n        format.setMinimumIntegerDigits(4);\n        int count = 0;\n        File main = new File(name);\n        if (main.exists()) {\n            throw new IOException(main.getAbsolutePath());\n        }\n        main.mkdir();\n        File version = new File(main, \"version\");\n        version.createNewFile();\n        PrintWriter writer = new PrintWriter(version);\n        writer.write(Videso3D.VERSION);\n        writer.flush();\n        writer.close();\n        File xmlDir = new File(main.getAbsolutePath() + \"/xml\");\n        xmlDir.mkdir();\n        if (types != null && !types.isEmpty()) {\n            File databases = new File(main.getAbsolutePath() + \"/databases\");\n            databases.mkdir();\n            for (String t : types) {\n                Type type = DatabaseManager.stringToType(t);\n                if (type != null) {\n                    if (onlyLinks) {\n                        if (databasesIncluded) {\n                            String currentName = DatabaseManager.getCurrentName(type);\n                            File baseCopy = new File(databases, currentName + \".\" + type);\n                            baseCopy.createNewFile();\n                            FileChannel source = new FileInputStream(new File(currentName)).getChannel();\n                            FileChannel destination = new FileOutputStream(baseCopy).getChannel();\n                            destination.transferFrom(source, 0, source.size());\n                            source.close();\n                            destination.close();\n                            List<String[]> clefs = new ArrayList<String[]>();\n                            Statement st = DatabaseManager.getCurrent(Type.Databases);\n                            ResultSet rs = st.executeQuery(\"select * from clefs where type='\" + currentName + \"'\");\n                            while (rs.next()) {\n                                clefs.add(new String[] { rs.getString(\"name\"), rs.getString(\"value\") });\n                            }\n                            st.close();\n                            if (!clefs.isEmpty()) {\n                                File clefsFile = new File(databases, currentName + \"_clefs\");\n                                clefsFile.createNewFile();\n                                ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(clefsFile));\n                                oos.writeObject(clefs);\n                                oos.close();\n                            }\n                            File filesDir = new File(currentName + \"_files\");\n                            if (filesDir.exists() && filesDir.isDirectory()) {\n                                File baseFiles = new File(databases, currentName + \"_files\");\n                                baseFiles.mkdirs();\n                                for (File f : filesDir.listFiles()) {\n                                    File copy = new File(baseFiles, f.getName());\n                                    copy.createNewFile();\n                                    source = new FileInputStream(f).getChannel();\n                                    destination = new FileOutputStream(copy).getChannel();\n                                    destination.transferFrom(source, 0, source.size());\n                                    source.close();\n                                    destination.close();\n                                }\n                            }\n                        }\n                        File selectedObjects = new File(databases, type.toString());\n                        selectedObjects.createNewFile();\n                        ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(selectedObjects));\n                        oos.writeObject(objects.get(type));\n                        oos.close();\n                    } else {\n                        for (Restorable r : DatasManager.getController(type).getSelectedObjects()) {\n                            this.saveObjectInXml(r, new File(xmlDir, r.getClass().getName() + \"-\" + type + \"-\" + format.format(count++) + \".xml\"));\n                        }\n                    }\n                }\n            }\n        }\n        File imagesDir = new File(main.getAbsolutePath() + \"/images\");\n        imagesDir.mkdir();\n        for (EditableSurfaceImage si : this.getImages()) {\n            if (images.contains(si.getName())) {\n                int idx = si.getName().lastIndexOf(\".\");\n                String newName = si.getName();\n                if (idx != -1) {\n                    newName = si.getName().substring(0, idx);\n                }\n                File img = new File(imagesDir, newName + \".gtif\");\n                ImageUtils.writeImageToFile(si.getSector(), (BufferedImage) si.getImageSource(), img);\n            }\n        }\n        File trajectoDir = new File(main, \"trajectory\");\n        trajectoDir.mkdirs();\n        for (Layer l : wwd.getModel().getLayers()) {\n            if (l instanceof GEOTracksLayer && trajectories.contains(l.getName())) {\n                GEOWriter geoWriter = new GEOWriter(trajectoDir.getAbsolutePath() + \"/\" + l.getName(), true);\n                for (VidesoTrack track : ((GEOTracksLayer) l).getModel().getVisibleTracks()) {\n                    geoWriter.writeTrack((GEOTrack) track);\n                }\n                geoWriter.close();\n            }\n        }\n        if (types != null && types.contains(\"Autres objets affich\u00e9s.\")) {\n            for (Layer l : wwd.getModel().getLayers()) {\n                if (l.getName().equals(AIRSPACE_LAYER_NAME)) {\n                    for (Airspace r : ((AirspaceLayer) l).getAirspaces()) {\n                        this.saveObjectInXml((Restorable) r, new File(xmlDir, r.getClass().getName() + \"-\" + format.format(count++) + \".xml\"));\n                    }\n                } else if (l.getName().equals(RENDERABLE_LAYER_NAME)) {\n                    for (Renderable r : ((RenderableLayer) l).getRenderables()) {\n                        if (r instanceof Restorable) {\n                            this.saveObjectInXml((Restorable) r, new File(xmlDir, r.getClass().getName() + \"-\" + format.format(count++) + \".xml\"));\n                        }\n                    }\n                } else if (l.getName().equals(BALISES2D_LAYER_NAME)) {\n                    for (Balise2D b : ((Balise2DLayer) l).getVisibleBalises()) {\n                        this.saveObjectInXml(b, new File(xmlDir, b.getClass().getName() + \"-\" + format.format(count++) + \".xml\"));\n                    }\n                } else if (l.getName().equals(BALISES3D_LAYER_NAME)) {\n                    for (Balise3D b : ((Balise3DLayer) l).getVisibleBalises()) {\n                        this.saveObjectInXml(b, new File(xmlDir, b.getClass().getName() + \"-\" + format.format(count++) + \".xml\"));\n                    }\n                }\n            }\n        }\n        for (Airspace a : PolygonEditorsManager.getLayer().getAirspaces()) {\n            if (a.isVisible()) this.saveObjectInXml(a, new File(xmlDir, a.getClass().getName() + \"-\" + format.format(count++) + \".xml\"));\n        }\n        this.saveObjectInXml(this.wwd.getView(), new File(main, \"globe.xml\"));\n        FileManager.createZipFile(file, main);\n        FileManager.deleteFile(main);\n        return true;\n    }\n", "code2": "    private void tail(String[] cmd, int pos) throws IOException {\n        CommandFormat c = new CommandFormat(\"tail\", 1, 1, \"f\");\n        String src = null;\n        Path path = null;\n        try {\n            List<String> parameters = c.parse(cmd, pos);\n            src = parameters.get(0);\n        } catch (IllegalArgumentException iae) {\n            System.err.println(\"Usage: java FsShell \" + TAIL_USAGE);\n            throw iae;\n        }\n        boolean foption = c.getOpt(\"f\") ? true : false;\n        path = new Path(src);\n        FileSystem srcFs = path.getFileSystem(getConf());\n        if (srcFs.isDirectory(path)) {\n            throw new IOException(\"Source must be a file.\");\n        }\n        long fileSize = srcFs.getFileStatus(path).getLen();\n        long offset = (fileSize > 1024) ? fileSize - 1024 : 0;\n        while (true) {\n            FSDataInputStream in = srcFs.open(path);\n            in.seek(offset);\n            IOUtils.copyBytes(in, System.out, 1024, false);\n            offset = in.getPos();\n            in.close();\n            if (!foption) {\n                break;\n            }\n            fileSize = srcFs.getFileStatus(path).getLen();\n            offset = (fileSize > offset) ? offset : fileSize;\n            try {\n                Thread.sleep(5000);\n            } catch (InterruptedException e) {\n                break;\n            }\n        }\n    }\n", "label": 1, "substitutes": {"saveProject": ["createApp", " SaveProject", "saveFile", "savePackage", "saveApp", " saveApp", "createPackage", " SaveApp", "createProject", " savePackage", " saveFile", " SaveFile", " SavePackage", "createFile"], "file": ["report", "handle", "image", "File", "FILE", "resource", "foo", "create", "table", "port", "base", "in", "link", "log", "open", "db", "filename", "ile", "e", "real", "get", "complete", "parent", "project", "path", "dir", "use", "full", "local", "info", "files", "io", "id", "data", "ame"], "types": ["times", "services", "apps", "tags", "options", "assets", "versions", "strings", " Types", "parts", "items", "keys", "scripts", "sets", "plugins", "tests", "views", "packages", "classes", "names", "models", "otypes", "pes", "issues", "ts", "sites", "styles", "ids", "ties", "resources", "thumbnails", "actions", "projects", "ypes", "events", "objects", "ports", "groups", "pages", "files", "features", "posts", "codes", "packs", "values", "Types"], "images": ["tags", "Images", "photos", "image", "frames", "picture", "links", "assets", "versions", "scripts", "views", "classes", "models", "icons", "uploads", "boxes", "Image", "styles", "media", "blocks", "thumbnails", "events", "groups", "pages", "files", "videos", "faces"], "trajectories": ["Trajectories", "Trajors", "trajors", "tractory", "traceptables", "traceptories", "Trajectors", "Trajories", "traceptory", "tractories", "trajectors", "Trajectables", "trajectory", "Trajectory", "trajories", "tractors", "Trajables", "traceptors", "trajables", "trajory", "trajectables", "tractables", "Trajory"], "databasesIncluded": ["databasesedInclusion", "databasesIngclusions", "databasesInsclusion", "daturesIncluded", "databasesedInclusions", "datadesInsjected", "datadesInified", "databasesInclusions", "datadesIncluded", "daturesInscluded", "databasesInscluded", "databasesInglisted", "daturesInslisted", "databasesInsclusions", "databasesIngcluded", "databasesInsjected", "databasesINjected", "databasesInslisted", "daturesInsclusions", "databasesINified", "databasesedInlisted", "datadesInsclusion", "daturesInlisted", "daturesInclusions", "databasesINcluded", "databasesINclusion", "databasesedInified", "databasesInlisted", "datadesInjected", "databasesInified", "databasesInjected", "datadesInsified", "datadesInscluded", "databasesInclusion", "databasesedInjected", "databasesInsified", "databasesedIncluded", "datadesInclusion"], "onlyLinks": [" onlyRelations", "forcelinks", "forceLinks", "onlyLink", "onlylinks", "OnlyLink", "onlyRelations", "OnlyRelations", " onlyLink", "OnlyLinks", " onlylinks", "alsoRelations", "Onlylinks", "forceLink", "alsoLink", "alsoLinks"], "index": ["first", "ion", "all", "address", "find", "match", "fail", "nn", "sequence", "set", "x", "open", "max", "i", "Index", "second", "number", "position", "inc", "pos", "initial", "offset", "length", "amount", "ind", "add", "connect", "num", "info", "n", " sidx", "no", " Index", "loc", "zero", "check", "update", "end", "ex"], "name": ["nm", "image", "default", "about", "named", "word", "m", "create", "table", "run", "names", "base", "me", "man", "primary", "system", "filename", "none", "NAME", "parent", "path", "ame", "full", "local", "n", "string", "root", "id", "Name", "data", "prefix", "title"], "format": ["style", "layout", "value", "default", "util", "MAT", "mt", "fm", "set", "table", "init", " Format", "base", "print", "printf", "list", "v", "Format", "color", "get", "it", "parse", "cal", "form", "term", "language", "use", "pattern", "scale", "percent", "unit", "pretty", "data", "prefix"], "count": ["process", "z", "reset", "depth", "sum", "mark", "table", "set", "code", "c", "err", "skip", "counter", "ount", "error", "total", "order", "length", "flag", "amount", "found", "Count", "add", "num", "start", "size"], "version": ["translation", "video", "major", "json", "virtual", "j", "about", "versions", "release", "description", "summary", "page", "Version", "header", "connection", "build", "mint", "document", "current", "journal", "result", "xml", "v", "alone", "number", "information", "section", "ver", "tree", "parent", "java", "record", "database", "vers", "VERSION", "latest", "root", "VER", "server", "python", "draft"], "writer": ["browser", "report", "window", "author", "access", "creator", "flush", "writers", "Writer", "output", "entry", "caster", "console", "driver", "comment", "service", "reader", "builder", "description", "client", "wright", "writing", "stream", "inner", "maker", "connection", "editor", "write", "buffer", "writ", "to", "woman", "document", "journal", "function", "counter", "variable", "external", "operator", "written", "outer", "order", "walker", "sw", "handler", "language", "iterator", "er", "wrote", "server", "wrapper", "print", "data", "w"], "xmlDir": ["mlDir", "logDirectory", "imageFolder", "imagedir", " xmlFile", "xmlFolder", "xmldir", " xmlFolder", "logFolder", "mlFolder", "mlDirectory", "logDir", "mlFile", "imageDir", "logFile", "logdir", " xmldir", "xmlDirectory", " xmlDirectory", "xmlFile", "imageDirectory"], "databases": ["generabase", "baselines", " datates", " datables", "mutables", "Datelines", "Datasha", "datas", "mutases", "basables", " datases", "Datases", "notelines", "notabases", "generas", "datates", "Datables", "mutabases", "Datures", "datures", "Datas", "generabases", "Database", "notables", "generates", "datelines", "basures", "Datates", "database", "notures", " database", "datables", "mutasha", " datasha", "basabases", "Databases", "datases", " datas", "datasha"], "t": ["txt", "tr", "j", "y", "h", "mt", "tt", "x", "template", "k", "q", "c", "tm", "ts", "ot", "v", "i", "e", "ct", "pt", "str", "it", "term", "s", "tc", "o", "typ", "te", "n", "temp", "T", "id", "p", "w"], "type": ["rule", "ime", "style", "address", "p", "y", "match", "test", "time", "resource", "single", "other", "tag", "site", "tool", "base", "module", "template", "link", "action", "to", "shape", "ping", "result", "error", "top", "TYPE", "ty", "this", "parse", "object", "null", "language", "instance", "role", "kind", "relation", "typ", "info", "key", "te", "config", "id", "Type", "class", "root", "ype", "ver", "unit", "check", "pe", "title"], "currentName": ["currentFace", "currentTime", "reportedLock", "updateName", "currentYear", "reportedDir", "completeKey", "updatePort", "thisSet", "updateFace", "baseName", "thisName", "reportedTime", "CurrentDir", "currentlyKey", "CurrentLock", "thisKey", "currentlyPath", "reportedParent", "completeSet", "reportedPath", "CurrentNames", "completeName", "currentlyTime", "updateOrder", "currentLock", "CurrentName", "CurrentPath", " currentDir", " currentNames", "currentlyName", "CurrentParent", "currentDir", "reportedNames", " currentFace", " currentOrder", "currentPath", "baseFace", "currentNames", "completeYear", "currentlySet", "currentPort", "thisYear", "currentlyLock", "basePort", " currentPort", "reportedName", "currentParent", "currentKey", "CurrentTime", "currentlyYear", "baseOrder", "currentSet", " currentParent", "currentOrder"], "baseCopy": ["parentName", "BaseCop", "parentCopy", "buffercopy", "baseStore", "parentCop", "baseName", "Basecopy", "basicCopy", "BaseCopy", "BaseStore", " basecopy", " baseName", "parentcopy", " baseCop", "bufferCopy", "basicStore", "bufferCop", " baseStore", "baseCop", "BaseName", "basicCop", "basecopy", "basiccopy"], "source": ["origin", "scan", "subject", "select", "sample", "console", "original", "service", "resource", "reader", "se", "sequence", "create", "stream", "site", "init", "before", "base", "connection", "inner", "store", "scope", "master", "join", "src", "system", "Source", "owner", "target", "SOURCE", "input", "initial", "parent", "search", "ource", "space", "iterator", "channel", "local", "ources", "start", "size", "shell", "from", "data"], "destination": ["Destuation", "Destinations", " destinations", "messuation", "datinations", "destregation", " destructure", "messructure", "datregation", "declinations", "messinated", " destuation", "Destinated", "declregation", "Destinator", "datinator", "datination", "messinations", "Destregation", " destinated", "Destructure", "declination", "destuation", "destructure", "destinations", "declinator", "destinated", "Destination", "destinator", "messination"], "clefs": [" Clefs", "CLEFs", " Clecs", " CleFS", "CLEfits", "clebs", " cleFs", " Clefits", "CLEcs", " CleFs", " clebs", "cleFS", " Clebs", "clecs", "CleFs", " cleFS", "Clecs", "cleFs", "CleFS", "Clefs", "Clebs", "Clefits", "clefits", "CLEfs"], "st": ["bt", "sb", "sm", "ist", "ost", "bl", "sp", "h", "cr", "storage", "mt", "se", "fr", "est", "tt", "ST", "rest", "sl", "stra", "ts", "ct", "ste", "pt", "str", "St", "statement", "std", "it", "dd", "query", "stat", "sc", "sw", "sn", "sy", "sts", " ST", "start", "inst", "irst", "sth", "cl"], "rs": ["rc", "rys", "rt", "res", "mr", "ins", " ms", "Rs", "ls", " pts", "ps", "ts", "rd", "ris", "os", "ds", " sr", "ers", " RS", " iss", " cs", "sts", " ins", "as", "ks", "RS", " ps", "cs"]}}
{"id1": "11865906", "id2": "7948308", "code1": "    @Test\n    public void testIdentification() {\n        try {\n            String username = \"muchu\";\n            String password = \"123\";\n            MessageDigest md5 = MessageDigest.getInstance(\"MD5\");\n            md5.update(password.getBytes());\n            LogService logServiceMock = EasyMock.createMock(LogService.class);\n            DbService dbServiceMock = EasyMock.createMock(DbService.class);\n            userServ.setDbServ(dbServiceMock);\n            userServ.setLogger(logServiceMock);\n            logServiceMock.info(DbUserServiceImpl.class, \">>>identification \" + username + \"<<<\");\n            IFeelerUser user = new FeelerUserImpl();\n            user.setUsername(username);\n            user.setPassword(new String(md5.digest()));\n            EasyMock.expect(dbServiceMock.queryFeelerUser(username)).andReturn(user);\n            EasyMock.replay(logServiceMock, dbServiceMock);\n            Assert.assertTrue(userServ.identification(username, password));\n            EasyMock.verify(logServiceMock, dbServiceMock);\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        }\n    }\n", "code2": "    private void getRandomGUID(boolean secure) {\n        MessageDigest md5 = null;\n        StringBuffer sbValueBeforeMD5 = new StringBuffer();\n        try {\n            md5 = MessageDigest.getInstance(\"MD5\");\n        } catch (NoSuchAlgorithmException e) {\n            logger.error(\"At RandomGUID !!!\", e);\n        }\n        try {\n            long time = System.currentTimeMillis();\n            long rand = 0;\n            if (secure) {\n                rand = mySecureRand.nextLong();\n            } else {\n                rand = myRand.nextLong();\n            }\n            sbValueBeforeMD5.append(s_id);\n            sbValueBeforeMD5.append(\":\");\n            sbValueBeforeMD5.append(Long.toString(time));\n            sbValueBeforeMD5.append(\":\");\n            sbValueBeforeMD5.append(Long.toString(rand));\n            valueBeforeMD5 = sbValueBeforeMD5.toString();\n            md5.update(valueBeforeMD5.getBytes());\n            byte[] array = md5.digest();\n            StringBuffer sb = new StringBuffer();\n            for (int j = 0; j < array.length; ++j) {\n                int b = array[j] & 0xFF;\n                if (b < 0x10) sb.append('0');\n                sb.append(Integer.toHexString(b));\n            }\n            valueAfterMD5 = sb.toString();\n        } catch (Exception e) {\n            logger.error(\"At RandomGUID !!!\", e);\n        }\n    }\n", "label": 1, "substitutes": {"testIdentification": ["testidentification", "Testidentication", "Testidentify", "TestIdentification", "testIdifier", "testIdification", "testIdication", "TestIdentifier", "testIDENTifier", "testidentication", "testidentify", "Testidentifier", "Testidentification", "testIdentifier", "testIDENTication", "testIDENTification", "testIDENTify", "TestIdentication", "testIdify", "testidentifier", "testIdentication", "TestIdentify", "testIdentify"], "username": ["admin", "author", "subject", "displayText", "pai", "about", "character", "email", "hello", "your", "minimum", "uno", "unknown", "sudo", "dn", "connection", "profile", "attribute", "seat", "twitter", "human", "USER", "ubuntu", "blood", "filename", "wordpress", "information", "owner", "uri", "name", "url", "knife", "ername", "person", "token", "operator", "initial", "position", "login", "approximately", "john", "\u4eba", "impact", "rue", "NAME", "metadata", "project", "component", "taker", "term", "localhost", "language", "uid", "stab", "instance", "sword", "key", "account", "string", "otype", "pty", "assuming", "albeit", "source", "latest", "lead", "phone", "prefix", "title"], "password": ["phrase", "PASS", "address", "value", "picture", "reset", "entry", "email", "hello", "word", "comment", "description", "application", "secret", " Password", "shadow", "profile", "command", "attribute", "Password", "device", "message", "words", "number", "token", "hash", "definition", "login", "auth", "height", "confirmed", "language", "sword", "database", "pattern", "padding", "account", "string", "REDACTED", "remember", "power", "python", "crypt", "pass"], "md5": ["sha3", "MD2", "MD5", "MD3", " md3", "dig5", " md2", " Md5", "md7", " md7", "dig3", " Md7", " mdol", "MD4", " md512", "sha4", "mdol", "sha512", "md4", "sha5", "dig2", " md4", "MDol", "md512", "md3", "md2", "digol", " Md512", " Md3", "sha7"], "logServiceMock": ["logServiceManocked", "logServicemck", "logServiceMOCK", "logServiceVocker", "logServicePOCK", "logServiceMXocker", "logStoreMox", "logServiceDex", "logServiceMlock", "logServiceMMOCK", "logServMlock", "logServiceManocks", "logServMck", "logStorePock", "logServiceMXock", "logServMocked", "logServMTck", "logServiceMck", "logServiceMex", "logServicemOCK", "logServicePox", "logStorePOCK", "logStorePocker", "logServMTock", "logServiceMMox", "logServiceVex", "logServicemocker", "logServiceManock", "logServiceMuock", "logServiceMTck", "logStorePox", "logServiceVock", "logServiceMTlock", "logServicemex", "logServiceJMocker", "logStoreMock", "logServiceMocker", "logServicePocker", "logServiceVocks", "logServicemox", "logServiceMTock", "logServiceMMock", "logServiceMulock", "logServiceMuocked", "logStoreMOCK", "logServicemocks", "logServiceManocker", "logServiceDocker", "logServiceMox", "logServiceMuck", "logServicemocked", "logServiceDocked", "logServMock", "logServiceMMocker", "logServiceMocked", "logServiceMTocked", "logServicemock", "logServicePock", "logStoreMocker", "logServiceJMocked", "logServMTocked", "logServiceJMock", "logServiceVocked", "logServiceDock", "logServiceMXocked", "logServicemlock", "logServMTlock", "logServiceMocks"], "dbServiceMock": ["dbServiceTrap", "dbServiceSocked", "dbServicemess", "dbServiceJMock", "dbServiceTock", "dbServiceMonocked", "dbServiceMXocks", "dbServicesmike", "dbStoremock", "dbServicemocker", "dbServiceSaj", "dbStoremrap", "dbStoreMocked", "dbServiceMick", "dbServicemocked", "dbStoreMrap", "dbServicemox", "dbServiceVck", "dbFactoryMocks", "dbServiceTox", "dbFactoryMck", "dbServicesMock", "dbServicemock", "dbFactoryMXck", "dbServiceVock", "dbServiceTocked", "dbServiceMocked", "dbFactoryMocked", "dbServiceVox", "dbServiceMrap", "dbServiceMocker", "dbServiceMonox", "dbServiceSick", "dbServicemck", "dbServiceMoness", "dbServiceMox", "dbServiceHMox", "dbFactoryMXocks", "dbServiceSocker", "dbStoremocked", "dbServiceMonick", "dbServicemaj", "dbStoreMock", "dbServiceMaj", "dbServiceVocked", "dbServicemocks", "dbServicesmock", "dbServiceJMocked", "dbServicesMike", "dbStoremox", "dbFactoryMock", "dbServicesmocked", "dbServicesMaj", "dbServicemike", "dbServiceMck", "dbFactoryMXock", "dbServiceMocks", "dbServiceMike", "dbServiceJMaj", "dbFactoryMXocked", "dbServiceHMocked", "dbServiceMXocked", "dbServiceHMock", "dbServicesMocked", "dbStoreMox", "dbServiceMXock", "dbServicemick", "dbServicesmaj", "dbServiceMXck", "dbServiceSike", "dbServiceMess", "dbServiceSock", "dbServiceHMess", "dbServiceMonocker", "dbServiceVrap", "dbServicemrap", "dbServiceMonock", "dbServiceVocks", "dbServiceJMike"], "user": ["rule", "report", "author", "reply", "response", "json", "creator", "actor", "usr", "u", "by", "output", "entry", "contact", "word", "comment", "other", "client", "usa", "profile", "menu", "char", "write", "human", "USER", "to", "message", "used", "result", "system", "plugin", "list", "read", "owner", "name", "person", "entity", "per", "auth", "object", "component", "form", "null", "responsible", "record", "uid", "instance", "role", "use", "prof", "key", "account", "core", "usage", "temp", "body", "User", "student"]}}
{"id1": "6009527", "id2": "11546108", "code1": "    private void doFinishLoadAttachment(long attachmentId) {\n        if (attachmentId != mLoadAttachmentId) {\n            return;\n        }\n        Attachment attachment = Attachment.restoreAttachmentWithId(MessageView.this, attachmentId);\n        Uri attachmentUri = AttachmentProvider.getAttachmentUri(mAccountId, attachment.mId);\n        Uri contentUri = AttachmentProvider.resolveAttachmentIdToContentUri(getContentResolver(), attachmentUri);\n        if (mLoadAttachmentSave) {\n            try {\n                File file = createUniqueFile(Environment.getExternalStorageDirectory(), attachment.mFileName);\n                InputStream in = getContentResolver().openInputStream(contentUri);\n                OutputStream out = new FileOutputStream(file);\n                IOUtils.copy(in, out);\n                out.flush();\n                out.close();\n                in.close();\n                Toast.makeText(MessageView.this, String.format(getString(R.string.message_view_status_attachment_saved), file.getName()), Toast.LENGTH_LONG).show();\n                new MediaScannerNotifier(this, file, mHandler);\n            } catch (IOException ioe) {\n                Toast.makeText(MessageView.this, getString(R.string.message_view_status_attachment_not_saved), Toast.LENGTH_LONG).show();\n            }\n        } else {\n            try {\n                Intent intent = new Intent(Intent.ACTION_VIEW);\n                intent.setData(contentUri);\n                intent.addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION);\n                startActivity(intent);\n            } catch (ActivityNotFoundException e) {\n                mHandler.attachmentViewError();\n            }\n        }\n    }\n", "code2": "    @Override\n    public void run() {\n        try {\n            BufferedReader in = new BufferedReader(new InputStreamReader(new URL(urlInfo).openStream()));\n            String ligneEnCours;\n            int i = 0;\n            informations = \"\";\n            while ((ligneEnCours = in.readLine()) != null) {\n                switch(i) {\n                    case 0:\n                        version = ligneEnCours;\n                        break;\n                    case 1:\n                        url = ligneEnCours;\n                        break;\n                    default:\n                        informations += ligneEnCours + '\\n';\n                        break;\n                }\n                i++;\n            }\n            in.close();\n            erreur = false;\n        } catch (IOException e) {\n            erreur = true;\n            texteErreur = e.getMessage();\n            if (texteErreur.equals(\"Network is unreachable\")) {\n                texteErreur = \"Pas de r\u00e9seau\";\n                numErreur = 1;\n            }\n            if (e instanceof FileNotFoundException) {\n                texteErreur = \"Probl\u00e8me param\u00e9trage\";\n                numErreur = 2;\n            }\n            e.printStackTrace();\n        } finally {\n            for (ActionListener al : listeners) {\n                al.actionPerformed(null);\n            }\n        }\n    }\n", "label": 0, "substitutes": {"doFinishLoadAttachment": ["doFinishLoadAttachachment", "doFinishLoadAttachention", "doFinishLoadDetachment", "doFinishShowAttention", "doFinishShowDetachment", "doFinishLoadAttention", "doFinishLoadAttachached", "doFinishLoadAssached", "doFinishLoadDetention", "doFinishLoadAssachment", "doFinishLoadAssention", "doFinishLoadDetached", "doFinishShowDetention", "doFinishShowAttachment", "doFinishShowAttached", "doFinishLoadAttached", "doFinishShowDetached"], "attachmentId": ["attachmentById", "atachmentId", "detachmentid", "attentionName", "attentionById", "detachedKey", "attutationId", "attociationName", "attachmentid", "atachmentById", "attutationName", "ATTachmentById", "ATTachmentId", "attagramid", "ATTachmentid", "ATTociationKey", "attachmentKey", "attociationId", "attagramId", "detachedid", "attachmentID", "atutationId", "ATTociationById", "attentionID", "attachedById", "detachmentId", "atachmentName", "attgmentid", "atutationById", "attentionId", "atutationID", "attachedKey", "attociationById", "attutationID", "detachedId", "ATTociationId", "ATTociationid", "attgmentKey", "attachmentName", "attociationID", "attachedId", "attagramKey", "ATTachmentKey", "attociationKey", "detachmentKey", "atutationName", "attutationById", "attgmentId", "attagramById", "attachedid", "attociationid", "atachmentID"], "attachment": [" attment", "attaching", "addached", "attachaching", "detachment", "attention", "assachment", "attment", "detached", "attachached", "ATTached", "contachment", "attachachment", "assached", "attachociation", "ATTachment", "attachacher", "detacher", "contacher", "contment", "attociation", "ATTention", "addachment", "addaching", "assacher", "association", "ATTacher", " attacher", "assaching", "addociation", "attacher", " attached", "attachention", "detment", "assention", "attached", "contached"], "attachmentUri": ["attachmentUpi", "attachmentUtRI", "attentionUtri", "attachmentTpi", "attachableOri", "attachmentTuri", "attachableUri", "attachmentURI", "attentionUpi", "attachmentUnURI", "attentionUri", "attachmenturi", "attachableOpi", "attachmentTURI", "attachmenturid", "attachmentOURI", "attachmentTri", "attachmentUuri", "attachmentOri", "attachmentUtpi", "attachmentUnri", "attachableUuri", "attachmentUtri", "attentionUrid", "attachmentUtrid", "attachmentOuri", "attachableUpi", "attentionUtrid", "attachmentUrid", "attentionUtRI", "attentionUtpi", "attachableOURI", "attachableUURI", "attachmentuRI", "attachmentupi", "attachmentUURI", "attachmentUnuri", "attachmentOpi", "attentionURI", "attachmentUnpi", "attachableOuri"], "contentUri": ["contentUsri", "contentUuri", "messageUuri", "contentUtris", "contentUtri", "contentURI", "contentUsris", "contentUrid", "ContentUsrid", "ContentUrid", "contentSuri", "resourceURuri", "resourceUri", "contentUtRI", "resourceUuri", "ContentUsri", "contentUris", "contentUsuri", "contentUnris", "contentUres", "resourceURI", "ContentUri", "contentures", "contentSric", "contentUnri", "contentUnuri", "contentURuri", "resourceURri", "contentUturi", "contentuuri", "contentUrri", "contentUtiri", "contentUric", "contentUtres", "ContentUsris", "ContentUris", "contentURri", "messageUiri", "contentUruri", "messageUturi", "contentUriri", "resourceUres", "contentUtrid", "contentUnrid", "contentuRI", "contenturi", "contentUiri", "resourceURRI", "messageUtric", "messageUtri", "contentUsrid", "resourceURres", "messageUtiri", "messageUric", "contentSiri", "contentUrric", "contentURres", "contentSri", "contentUtric", "contentURRI", "ContentUuri", "ContentUsuri", "messageUri"], "file": ["type", "f", "rule", "play", "image", "picture", "output", "File", "FILE", "h", "disk", "resource", "fp", "create", "page", "table", "init", "port", "base", "template", "work", "link", "ca", "buffer", "to", "document", "message", "from", "result", "db", "filename", "ile", "format", "content", "media", "name", "le", "sf", "entity", "upload", "tree", "path", "dir", "line", "channel", "zip", "local", "files", "save", "source", "pool", "il", "folder", "user", "angle", "header"], "in": ["mi", "rin", "en", "play", "inn", "ini", "and", "gin", "con", "IN", "ins", "ar", "on", "al", "In", "inside", "inner", "ic", "up", "i", "read", "bin", "inc", "l", "input", "it", " IN", "sql", " din", "ain", "ind", "io", "din", "inf", "is", "isin", "source", "body", "cin", "from"], "out": ["all", "co", "nt", "flush", "con", "output", "res", "put", "oss", "ao", "obj", "client", "sys", "conv", "stable", "net", "write", "print", "b", "to", "v", "i", "serv", "writer", "os", "outer", "OU", "it", "null", "ou", "outs", "g", "aos", "o", "auto", "screen", "n", "io", "Out", "OUT", "check", "can", "ex", "w"], "intent": ["event", "automatic", "phrase", "window", "json", "text", "spirit", "displayText", "ant", "concept", "entry", "service", "ink", "skill", "intention", "asso", "animate", "context", "init", "q", "ment", "action", "agent", "man", "device", "ic", "alert", "xml", "wordpress", "widget", "act", "condition", "activate", "venture", "statement", "entity", "complete", "initial", "method", "prom", "ent", "query", "term", "continue", "ident", "inv", "activity", "express", "verbal", "voice", "communication", " Intent", "Activity", "inst", "activation", "ence"]}}
{"id1": "2521141", "id2": "18489832", "code1": "    public static void copy(String from_name, String to_name) throws IOException {\n        File from_file = new File(from_name);\n        File to_file = new File(to_name);\n        if (!from_file.exists()) abort(\"FileCopy: no such source file: \" + from_name);\n        if (!from_file.isFile()) abort(\"FileCopy: can't copy directory: \" + from_name);\n        if (!from_file.canRead()) abort(\"FileCopy: source file is unreadable: \" + from_name);\n        if (to_file.isDirectory()) to_file = new File(to_file, from_file.getName());\n        if (to_file.exists()) {\n            if (!to_file.canWrite()) abort(\"FileCopy: destination file is unwriteable: \" + to_name);\n        } else {\n            String parent = to_file.getParent();\n            if (parent == null) parent = System.getProperty(\"user.dir\");\n            File dir = new File(parent);\n            if (!dir.exists()) abort(\"FileCopy: destination directory doesn't exist: \" + parent);\n            if (dir.isFile()) abort(\"FileCopy: destination is not a directory: \" + parent);\n            if (!dir.canWrite()) abort(\"FileCopy: destination directory is unwriteable: \" + parent);\n        }\n        FileInputStream from = null;\n        FileOutputStream to = null;\n        try {\n            from = new FileInputStream(from_file);\n            to = new FileOutputStream(to_file);\n            byte[] buffer = new byte[4096];\n            int bytes_read;\n            while ((bytes_read = from.read(buffer)) != -1) {\n                to.write(buffer, 0, bytes_read);\n            }\n        } finally {\n            if (from != null) {\n                try {\n                    from.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            if (to != null) {\n                try {\n                    to.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n", "code2": "    private static URL downLoadZippedFile(URL url, File destDir) throws Exception {\n        URLConnection urlConnection = url.openConnection();\n        File tmpFile = null;\n        try {\n            tmpFile = File.createTempFile(\"remoteLib_\", null);\n            InputStream in = null;\n            FileOutputStream out = null;\n            try {\n                in = urlConnection.getInputStream();\n                out = new FileOutputStream(tmpFile);\n                IOUtils.copy(in, out);\n            } finally {\n                if (out != null) {\n                    out.close();\n                }\n                if (in != null) {\n                    in.close();\n                }\n            }\n            unzip(tmpFile, destDir);\n        } finally {\n            if (tmpFile != null) {\n                tmpFile.delete();\n            }\n        }\n        URL localURL = destDir.toURI().toURL();\n        return localURL;\n    }\n", "label": 1, "substitutes": {"copy": ["drop", "edit", "export", "cop", "insert", "select", "sync", "share", "remove", "create", "set", "link", "ate", "Copy", "transfer", "write", "slice", "replace", "load", "close", "cp", "get", "archive", "upload", "paste", "opy", "cut", "zip", "download", "io", "save", "crop", "file", "source", "clip", "clone", "delete", "move"], "from_name": ["fromkpart", "fromkname", "from_Name", "fromamekey", "fromkcase", "from_filename", "from_resource", "fromkName", "from_case", " from_key", " from_part", "from_part", "fromameName", " from_names", "from_names", "fromamefilename", "from_info", " from_info", "from_key", " from_no", " from_filename", " from_case", "from_no", " from_resource", " from_Name", "fromamename"], "to_name": ["to7name", "toNamename", "tolynm", "toNameget", "tolyfile", "tolyname", "to_word", "to_Name", "tolynumber", "toNamefile", "to_get", "to7get", "toNamenew", "to_nm", "eto_Name", "from_new", "eto_word", "to_number", "to_new", "to7file", " to_nm", "eto_name", "from_get", "to7new", " to_number"], "from_file": ["from_run", "to_dir", "from_type", "or_File", " from_do", "fromsfile", "fromlynode", "fromsdir", "fromsname", "from_resource", "from_node", " from_node", "or_run", "fromlyFile", "fromlyfile", "fromlyresource", "from_port", "from_dir", "from_do", "or_name", " from_port", "from_time", "from_File", " from_time", " from_File", " from_resource", "or_file", " from_type"], "to_file": ["TO_element", "to_dir", "from_type", "TO_port", "to_FILE", "to_port", "to_files", " to_local", " to_create", "to_create", "to_block", "TO_name", " to_base", "toJblock", " to_dir", "to_drop", "TO_file", " to_block", "that_link", " to_File", "to_link", "TO_FILE", "to_local", " to_run", "that_tree", " to_drop", "to_File", "to_run", "that_file", "TO_files", "toJfile", "from_dir", "toJdrop", "to_type", "that_File", "to_base", "to_element", "toJFile", "to_tree"], "parent": ["event", "parents", "rule", "pa", "block", "home", "prop", "cmp", "default", "par", "pid", "test", "params", "sp", "part", "comment", "tar", "client", "page", "port", "base", "directory", "chain", "spec", "man", "shape", "master", "family", "up", "holder", "owner", "def", "name", "child", "position", "top", "global", "tree", "my", "point", "path", "mother", "null", "per", "form", "instance", "ip", "ma", "desc", "remote", "id", "pixel", "where", "temp", "relative", "percent", "file", "folder", "Parent", "pool", "source", "root", "timeout", "unit", "p", "server", "prefix", "peer", "user", "paren"], "dir": ["good", "div", "tr", "vol", "di", "d", "sp", "cont", "part", "dict", "mod", "module", "init", "directory", "red", "md", "del", "addr", "fd", "cur", "dr", "db", "rel", "wd", "det", "dim", "def", "coll", "str", "cond", "iter", "dd", "cmd", "Dir", "ir", "path", "cd", "ind", "DIR", "self", "local", "dist", "file", "folder", "loc", "dep", "rec"], "from": ["empty", "back", "window", "style", "en", "and", "by", "vol", "reset", "con", "From", "orig", "entry", "func", "ie", "left", "se", "on", "bound", "fr", "client", "set", "stream", "before", "in", "inner", "init", "base", "link", "old", "re", "com", "false", "error", "out", "or", "pos", "ent", "fun", "query", "st", "form", "normal", "term", "local", "io", "ra", "with", "start", "file", "source", "no", "so", "check", "user", "store"], "to": ["co", "nt", "that", "by", "To", "output", "tto", "two", "toc", "op", "client", "on", "sys", "TO", "please", "can", "table", "t", "tt", "base", "po", "stable", "will", "go", "b", "ts", "must", "tty", "e", "eto", "pi", "token", "top", "total", "out", "too", "or", "pretty", "target", "into", "null", "o", "auto", "ma", "te", "ato", "no", "so", "ta", "ne"], "buffer": ["event", "phrase", "buf", "window", "block", "buff", "sample", "entry", "frame", "word", "sequence", "page", "table", "append", "stroke", "base", "template", "char", "command", "attribute", "function", "document", "message", "available", "stack", "cache", "variable", "Buffer", "iter", "paste", "queue", "binary", "batch", "database", "bar", "row", "temp", "button", "password", "memory", "character"], "bytes_read": [" bytes_range", " bytes2read", "bytes2Read", " bytes2write", "wordsyncreport", " bytes_write", "words_write", "bytes2range", "bytes__Read", "words_report", " bytes_Read", "wordsyncread", "Bytes_write", "bytesynclen", "bytesyncwrite", "bytes2read", " bytes2Read", "words_len", "Bytes_run", "bytes_Read", "bytes_range", "bytesyncread", "words_read", "bytes_write", "bytes__read", "Bytes_read", "bytesyncreport", "bytes__write", "bytes_report", " bytes2range", "wordsynclen", "bytes__range", "wordsyncwrite", "bytes_len", "bytes2write", "bytes_run"]}}
{"id1": "13362846", "id2": "19549577", "code1": "    public static void setContenu(ContenuFichierElectronique contenuFichier, FichierElectronique fichierElectronique, UtilisateurIFGD utilisateurCourant) throws IOException, DocumentVideException {\n        if (contenuFichier != null) {\n            SupportDocument support = fichierElectronique.getSupport();\n            support.setFichierElectronique(fichierElectronique);\n            FicheDocument ficheDocument = support.getFicheDocument();\n            String nomFichier = contenuFichier.getNomFichier();\n            String extension = FilenameUtils.getExtension(nomFichier);\n            if (ficheDocument.getFichierElectronique(nomFichier) != null) {\n                FichierElectronique fichierElectroniqueExistant = ficheDocument.getFichierElectronique(nomFichier);\n                if (fichierElectroniqueExistant.getId() != null && !fichierElectroniqueExistant.getId().equals(fichierElectronique.getId())) {\n                    throw new FichierElectroniqueExistantException(nomFichier, ficheDocument);\n                }\n            }\n            if (fichierElectronique.getId() == null) {\n                if (OfficeDocumentPropertiesUtil.canWriteIdIGID(extension)) {\n                    Long idIgid = OfficeDocumentPropertiesUtil.getIdIGID(contenuFichier);\n                    if (idIgid != null) {\n                        throw new FichierElectroniqueExistantException(nomFichier, idIgid, ficheDocument);\n                    }\n                }\n            }\n            InputStream inputStream = contenuFichier.getInputStream();\n            OutputStream outputStream = fichierElectronique.getOutputStream();\n            try {\n                IOUtils.copy(inputStream, outputStream);\n            } finally {\n                try {\n                    inputStream.close();\n                } finally {\n                    outputStream.close();\n                }\n            }\n            String typeMime = contenuFichier.getContentType();\n            long tailleFichier = contenuFichier.getTailleFichier();\n            Date dateDerniereModification = new Date();\n            fichierElectronique.setNom(nomFichier);\n            fichierElectronique.setTypeMime(extension);\n            creerFormatSiNecessaire(typeMime, extension);\n            fichierElectronique.setTaille(tailleFichier);\n            fichierElectronique.setDateDerniereModification(dateDerniereModification);\n            fichierElectronique.setSoumetteur(utilisateurCourant);\n            if (extension.endsWith(\"msg\")) {\n                CourrielUtils.peuplerMetadonneesCourriel(fichierElectronique.getNom(), ficheDocument, contenuFichier.getInputStream(), utilisateurCourant);\n            } else if (extension.endsWith(\"eml\")) {\n                Map<String, Object> properties = new GestionnaireProprietesMimeMessageParser().parseMsg(contenuFichier.getInputStream());\n                CourrielUtils.peuplerMetadonneesCourriel(fichierElectronique.getNom(), ficheDocument, properties, utilisateurCourant);\n            } else {\n                FGDProprietesDocumentUtils.copierMetadonneesProprietes(fichierElectronique, ficheDocument);\n            }\n        }\n    }\n", "code2": "    protected InputStream callApiPost(String apiUrl, Map<String, List<String>> parameters, int expected) {\n        try {\n            URL url = new URL(apiUrl);\n            HttpURLConnection request = (HttpURLConnection) url.openConnection();\n            if (ApplicationConstants.CONNECT_TIMEOUT > -1) {\n                request.setConnectTimeout(ApplicationConstants.CONNECT_TIMEOUT);\n            }\n            if (ApplicationConstants.READ_TIMEOUT > -1) {\n                request.setReadTimeout(ApplicationConstants.READ_TIMEOUT);\n            }\n            for (String headerName : requestHeaders.keySet()) {\n                request.setRequestProperty(headerName, requestHeaders.get(headerName));\n            }\n            request.setRequestMethod(\"POST\");\n            request.setDoOutput(true);\n            PrintStream out = new PrintStream(new BufferedOutputStream(request.getOutputStream()));\n            out.print(getParametersString(parameters));\n            out.flush();\n            out.close();\n            request.connect();\n            if (request.getResponseCode() != expected) {\n                throw new BingMapsException(convertStreamToString(request.getErrorStream()));\n            } else {\n                return getWrappedInputStream(request.getInputStream(), GZIP_ENCODING.equalsIgnoreCase(request.getContentEncoding()));\n            }\n        } catch (IOException e) {\n            throw new BingMapsException(e);\n        }\n    }\n", "label": 0, "substitutes": {"setContenu": ["setcontensenux", "setContensenU", "setcontensenu", "setcontensenue", "setContenue", "setContensenu", "setcontenU", "setcontenux", "setcontenue", "setContenux", "setCont\u00ednu", "setcontenu", "setContensenux", "setContennue", "setContenU", "setContennu", "setCont\u00ednU", "setCont\u00ednue", "setContennux", "setCont\u00ednux", "setContensenue", "setcontensenU", "setContennU"], "contenuFichier": ["contenuFrenchaire", "contenuMichier", "contenuFileochier", "contenuFithiest", "contenuFChaire", "contenuFChier", "contenuFileichier", "contenuFamilyichorie", "contenuFechire", "contenuFuffieri", "contenuFuffer", "contenuFiverier", "contenuFigner", "contenuFamilyachie", "contenuFachier", "contenuFolfire", "contenuVichIER", "contenuFicheie", "contenuFsrenchire", "contenuVchier", "contenuFileochiers", "contenuFsechier", "contenuFchie", "contenuFechieri", "contenuFigniere", "contenuFileochiere", "contenuVichiest", "contenuFichorie", "contenuVichiere", "contenuFichire", "contenuVechiest", "contenuFicheer", "contenuFithiere", "contenuFignier", "contenuFicheorie", "contenuMichiere", "contenuFiverire", "contenuFicheiers", "contenuFochIER", "contenuFolfieri", "contenuFsechieri", "contenuFamilyichie", "contenuFichIER", "contenuFachorie", "contenuFileichiere", "contenuFachiere", "contenuFihiest", "contenuFechier", "contenuFuffire", "contenuFsichier", "contenuFichiest", "contenuFochiere", "contenuFichtiere", "contenuMichaire", "contenuVichie", "contenuFsichire", "contenuFamilyichier", "contenuFchier", "contenuFicher", "contenuFichyr", "contenuFichtier", "contenuFamilyachiere", "contenuFicheiere", "contenuFsrenchier", "contenuFolfer", "contenuFsichaire", "contenuMicheiere", "contenuFchIER", "contenuFichiere", "contenuFechiere", "contenuFecher", "contenuFsichieri", "contenuFileichiers", "contenuFichtIER", "contenuFrenchire", "contenuFrenchier", "contenuVchiere", "contenuMicher", "contenuFChiere", "contenuVechyr", "contenuFiverieri", "contenuVichier", "contenuFicheieri", "contenuFichieri", "contenuVechiere", "contenuFithier", "contenuFamilyichiere", "contenuFachiers", "contenuFsrenchaire", "contenuFihyr", "contenuFechyr", "contenuFihiere", "contenuFithyr", "contenuFichaire", "contenuFileochie", "contenuFchiere", "contenuFicheier", "contenuFechiest", "contenuFihier", "contenuMicheer", "contenuFsicher", "contenuFichie", "contenuFithie", "contenuFochiers", "contenuVchIER", "contenuFichiers", "contenuVichyr", "contenuFuffier", "contenuFicheire", "contenuFCher", "contenuFochier", "contenuVechier", "contenuFamilyachier", "contenuFsechire", "contenuFichtie", "contenuFsecher", "contenuFignaire", "contenuFochie", "contenuVchie", "contenuFachie", "contenuFicheaire", "contenuFolfier", "contenuFiveraire", "contenuMicheaire", "contenuFamilyachorie", "contenuFrenchieri", "contenuMicheier", "contenuFithorie", "contenuFileichie", "contenuFsrenchieri"], "fichierElectronique": ["fichierElectronsier", "fichierElectrenaire", "fichierTransferronie", "fichierelectronier", "fichierElectronaire", "fichierElectchronaire", "fichierElectronier", "fichierElectRONaire", "fichierAdministroniques", "fichierElectonier", "fichierElectronsoch", "fichierTransferronius", "fichierElectchronoch", "fichierElectronsique", "fichierCentronius", "fichierElectrenier", "fichierElectchronius", "fichierTransferronic", "fichierElectroneipolar", "fichierElectricique", "fichierCentRONicy", "fichierElectroneiques", "fichierElectradorique", "fichierelectrenier", "fichierelectronique", "fichierElectoniques", "fichierTransferradorie", "fichierElectRONius", "fichierCentronicy", "fichierelectreniques", "fichierElectreniques", "fichierSelectroneicity", "fichierElectchroniques", "fichierElectronicity", "fichierElectronicy", "fichierCentRONique", "fichierSelectronoch", "fichierElectronticity", "fichierElectronsie", "fichierElectronic", "fichierElectronie", "fichierElectradorie", "fichierCentRONius", "fichierAdministroneique", "fichierSelectroneoch", "fichierElectromipolar", "fichierElectonic", "fichierElectrontipolar", "fichierCentRONaire", "fichierElectronsiq", "fichierelectronic", "fichierSelectronique", "fichierElectrenius", "fichierSelectroneiques", "fichierAdministroneiques", "fichierElectriciques", "fichierElectRONicy", "fichierElectradorius", "fichierElectrontaire", "fichierElectroneie", "fichierElectronsicity", "fichierElectRONique", "fichierSelectroniques", "fichierAdministroniq", "fichierElectronipolar", "fichierAdministroneie", "fichierElectroneaire", "fichierElectronsiques", "fichierElectroniques", "fichierelectrenique", "fichierElectromicity", "fichierSelectroneique", "fichierElectronius", "fichierAdministronique", "fichierElectroneicity", "fichierElectromaire", "fichierAdministroneiq", "fichierElectroneic", "fichierelectrenic", "fichierElectrenic", "fichierTransferradorique", "fichierElectronoch", "fichierCentronique", "fichierElectronsic", "fichierElectroneique", "fichierElectrenicy", "fichierElectchronicity", "fichierElectromique", "fichierElectchronicy", "fichierAdministronie", "fichierElectroneius", "fichierElectricie", "fichierElectrontique", "fichierElectrenique", "fichierSelectronicity", "fichierTransferradoric", "fichierTransferronique", "fichierelectroniques", "fichierCentronaire", "fichierElectonique", "fichierElectradoric", "fichierElectromie", "fichierElectromius", "fichierElectromic", "fichierElectroneoch", "fichierElectroneiq", "fichierTransferradorius", "fichierElectchronique", "fichierElectroniq", "fichierElectriciq"], "utilisateurCourant": ["utilisateurRepresentant", "utilisateursGovernants", "utilisateurParticipiant", "utilisateurParticipant", "utilisateurParticipante", "utilisateurCourante", "utilisateurGoverniant", "utilisateursCourante", "utilisateursCourant", "utilisateurGovernants", "utilisateursCouriant", "utilisateurRepresentants", "utilisateursGovernant", "utilisateurRepresentante", "utilisateursGoverniant", "utilisateurCouriant", "utilisateurRepresentiant", "utilisateurGovernant", "utilisateursCourants", "utilisateurCourants", "utilisateurParticipants", "utilisateurGovernante", "utilisateursGovernante"], "support": ["access", "supp", "pport", "know", "service", "storage", "feature", "share", "cover", "force", "allow", "please", "help", "context", "library", "accept", "port", "profile", "replace", "document", "system", "supported", "format", "SUP", "see", "media", "trust", "success", " Support", "history", "null", "language", "prototype", "Support", "collection", "use", "proof", "cap", "evidence", "control", "install"], "ficheDocument": ["FicheDoc", "frenchDocuments", "fliciDocument", "fcheDoc", "foyerTree", "fcheDocument", "hicheDocument", "fiqueDocument", "fliciMatrix", "foyerDatabase", "flicheMatrix", "ficheTree", "frenchDocument", "ficiTransaction", "bacheDoc", "foyerDoc", "frenchDoc", "ficheTransaction", "fiqueDatabase", "fitimeDocument", "hacheJournal", "fruitTransaction", "fruitDocument", "frenchTransaction", "fliciTransaction", " ficheDescription", "ficiDatabase", "ficheMatrix", "facheDoc", " frenchDocument", "fiqueDescription", "fachedocument", "ficheDoc", "hichedocument", "ficheDescription", "ficheDatabase", "flicheTransaction", "FicheDatabase", " frenchDescription", "fayeDocuments", "frenchDescription", "fcheTree", "facheDatabase", " frenchDatabase", "fifaDoc", "foyerDocument", "fayeDatabase", "FayeDocument", "facheDocument", "FicheDocuments", "ficiDocument", "bicheDatabase", "ficiMatrix", "FayeDoc", "flicheDatabase", "fifaDocuments", "fichedocument", "hacheDocument", "ficheJournal", "fruitdocument", "facheJournal", "fitimeDescription", "fayeDoc", "fitimeMatrix", "flicheDocument", "frenchMatrix", "hacheTransaction", "FayeDatabase", "ficiJournal", "hicheJournal", "bacheDatabase", "FicheDocument", "bicheDocument", "FayeDocuments", "ficheDocuments", "bacheDocument", "fcheDatabase", "fifaDatabase", "facheTree", "bacheTree", "hicheTransaction", "fitimeTransaction", "frenchDatabase", "hachedocument", "fayeDocument", "fliciDatabase", "fitimeDatabase", "fifaDocument", "bicheTree", "ficidocument", "facheTransaction", "fruitJournal", "bicheDoc", " ficheDatabase"], "nomFichier": ["nomPFichiller", "nomNolfire", "nomFachiner", "nomFicheiere", "nomFolfier", "nomFchiere", "nomFachancer", "nomFicheer", "nomNichire", "nomPichire", "nomFericier", "nomFchire", "nomUFichIER", "nomFericancer", "nomPFichier", "nomUFichire", "nomFicheire", "nomFilicier", "nomUFichery", "nomPFichjer", "nomFachier", "nomUFachire", "nomFichER", "nomFihire", "nomFihIER", "nomPFoiljer", "nomFicER", "nomFichoier", "nomFolfire", "nomFicheie", "nomFicire", "nomFicheier", "nomFoiljer", "nomFihery", "nomFiverery", "nomFericanger", "nomFichiner", "nomNolfiere", "nomFchier", "nomFericIER", "nomFilicER", "nomPFoilER", "nomFacherer", "nomFichery", "nomFichancer", "nomPFoilier", "nomFoilier", "nomFichire", "nomPFichER", "nomFachery", "nomFoililler", "nomNichiere", "nomFihier", "nomFicheiner", "nomUFichier", "nomFichiere", "nomFacher", "nomFcherer", "nomFchiner", "nomFicherer", "nomFachanger", "nomPichier", "nomFachomer", "nomFachIER", "nomFiverIER", "nomFicjer", "nomPicherer", "nomFichoanger", "nomFiliciller", "nomFiciller", "nomFicerer", "nomFachiere", "nomFicomer", "nomFichie", "nomFicher", "nomFchomer", "nomFolfie", "nomPichomer", "nomFolfiere", "nomNolfier", "nomFichiller", "nomPachomer", "nomFiverire", "nomUFachier", "nomPacherer", "nomNichier", "nomFichjer", "nomNichie", "nomPFoililler", "nomFichoIER", "nomPachier", "nomNolfie", "nomFoilER", "nomFichoancer", "nomFichomer", "nomFachire", "nomFcher", "nomFichIER", "nomFichanger", "nomFachie", "nomFiverier", "nomUFachIER", "nomFilicjer", "nomFicier", "nomUFachery", "nomPachire"], "extension": ["contitude", "strending", "expension", "protractor", "protension", "contention", "contractor", "Extensions", "Extending", "strensions", "extending", "extractor", "expention", "xtensions", "extitude", "extensions", "expitude", "xtension", "protitude", "contension", "xtending", "strension", "protention", "extention", "Extension", "expractor"], "fichierElectroniqueExistant": ["fichierElectronicityExistance", "fichierElectroniqueLocalclusive", "fichierElectroniqueEXvant", "fichierElectronogueExister", "fichierElectroniqueExistent", "fichierElectroniquePlusistant", "fichierElectroniqueExiker", "fichierElectroniqueInvant", "fichierElectronicityExistant", "fichierElectroniqueInclusive", "fichierElectroniqueInistance", "fichierElectroniqueAssistant", "fichierElectroniqueExplert", "fichierElectronicityExvant", "fichierElectroniqueLocalistent", "fichierElectroniqueExplvant", "fichierElectroniqueAssistance", "fichierElectronogramLocalistance", "fichierElectroniqueInert", "fichierElectroniqueInistent", "fichierElectroniqueLocalistant", "fichierElectroniqueExert", "fichierElectroniquePresentister", "fichierElectroniqueExplistant", "fichierElectronogramExistant", "fichierElectroniquePersister", "fichierElectroniquePlusister", "fichierElectroniquePersiker", "fichierElectroniqueEXistant", "fichierElectronogramExclusive", "fichierElectronoguePersiker", "fichierElectroniqueExvant", "fichierElectroniqueInistant", "fichierElectroniquePresentistent", "fichierElectronogueExiker", "fichierElectronogramLocalclusive", "fichierElectroniqueExister", "fichierElectronicityExert", "fichierElectroniqueEXert", "fichierElectronogramLocalistent", "fichierElectroniquePersistent", "fichierElectronicityInert", "fichierElectroniquePresentistant", "fichierElectronoguePersistant", "fichierElectronicityInistance", "fichierElectroniqueEXistance", "fichierElectronogramExistent", "fichierElectroniqueLocalistance", "fichierElectroniqueExplistance", "fichierElectroniqueAssistent", "fichierElectroniquePersistant", "fichierElectroniquePresentiker", "fichierElectroniqueExclusive", "fichierElectronogramLocalistant", "fichierElectronicityInistant", "fichierElectronogueExistant", "fichierElectronogramExistance", "fichierElectroniqueAssclusive", "fichierElectronogueExistent", "fichierElectroniquePlusistent", "fichierElectroniquePlusiker", "fichierElectronoguePersister", "fichierElectronicityInvant", "fichierElectroniqueExistance", "fichierElectronoguePersistent"], "idIgid": ["idIgzoid", "idIegkey", "idIgdoid", "idIgcid", "idAgaddress", "idIgis", "idImgid", "idImglimit", "idIgzida", "idImgids", "idImgdata", "idIegdata", "idAgis", "idIgids", "idIkglimit", "idIgdid", "idIIgzid", "idIegids", "idIigmaddress", "idIIgzida", "idImgaddress", "idIgcida", "idIgzid", "idIgdida", "idIIgid", "idIgoid", "idIIgzido", "idIvgdata", "idIkgis", "idIIgoid", "idAglimit", "idIgdata", "idIgido", "idIgkey", "idIkgaddress", "idIigmid", "idIvgids", "idImgis", "idIvgid", "idImgkey", "idIvgkey", "idAmgaddress", "idAmgis", "idIgzido", "idIigmlimit", "idAmglimit", "idIgaddress", "idIgcoid", "idIigmis", "idAmgid", "idIgcido", "idIkgid", "idIIgido", "idIIgida", "idIegid", "idIIgzoid", "idIgdido", "idIglimit", "idIgida", "idAgid"], "inputStream": ["inputStreamer", "InputStream", "inputTime", "inputLoop", " inputSteam", "imageLoop", "inputSteam", " inputChannel", "InputTime", "outputThread", "inputChannel", "InputThread", " inputStreamer", "imageStream", "helloSteam", "imageTime", "outputSteam", "outputstream", "helloStream", "inputstream", "imageSteam", "helloChannel", " inputLoop", "helloStreamer", " inputThread", "InputLoop", "outputChannel", " inputTime", "InputSteam", "Inputstream", " inputstream", "inputThread", "outputStreamer"], "outputStream": ["inputForm", "sequenceStream", " outputStyle", "outputView", "OutputStreamer", "outputForm", "inputSteam", "sequenceSteam", "sequenceStyle", "webStream", "OutputStream", " outputView", "outputStyle", "webView", "writeView", "OutputView", "writeStream", " outputStreamer", "webSteam", "OutputStyle", "OutputSteam", " outputSteam", "writeForm", "outputSteam", "OutputForm", "inputView", "webStreamer", "sequenceStreamer", "writeSteam", "outputStreamer"], "typeMime": ["TypemIME", "Typemme", "typeRIME", "typeMim", "typeSmime", "Typemim", "typeSmim", "typeRme", "typemme", "typeMme", "typeRim", "TypeMIME", "typeSmIME", "typemim", "typemime", "typeMIME", "typeSmme", "typeRime", "TypeMim", "TypeMime", "TypeMme", "typemIME", "Typemime"], "tailleFichier": [" taillefichie", " tailleFichies", " taillefichier", " tailleFuzzie", " tailleFicheies", " tailleficheier", " tailleficheie", " tailleFixie", " tailleFuzzier", " tailleFicheiers", " taillefichies", " tailleFicheier", " tailleficheies", " tailleFixiers", " tailleFixier", " tailleFichie", " tailleFixies", " tailleFichiers", " tailleFuzziers", " taillefichiers", " tailleFuzzies", " tailleFicheie", " tailleficheiers"]}}
{"id1": "17791385", "id2": "3187685", "code1": "    public static void copyFile(File src, File dst) throws IOException {\n        InputStream in = new FileInputStream(src);\n        OutputStream out = new FileOutputStream(dst);\n        byte[] buf = new byte[1024];\n        int len;\n        while ((len = in.read(buf)) > 0) out.write(buf, 0, len);\n        in.close();\n        out.close();\n    }\n", "code2": "    private void copyJar(File src, File dst) throws IOException {\n        FileChannel srcChannel = null;\n        FileChannel dstChannel = null;\n        try {\n            srcChannel = new FileInputStream(src).getChannel();\n            dstChannel = new FileOutputStream(dst).getChannel();\n            dstChannel.transferFrom(srcChannel, 0, srcChannel.size());\n        } catch (IOException e) {\n            fLog.log(Level.SEVERE, e.getMessage(), e);\n        } finally {\n            srcChannel.close();\n            dstChannel.close();\n        }\n    }\n", "label": 1, "substitutes": {"copyFile": [" cpfile", "cloneResource", "copyFiles", " copyfile", "copyResource", "cloneFile", " cpFile", "clonefile", " cpResource", "cloneFiles", "copyfile", " copyFiles", " cpFiles", " copyResource"], "src": ["ser", "rc", "via", "txt", "usr", "sb", "sit", "ins", "cont", "sur", "ux", "sys", "bs", "init", "sq", "ctr", "cur", "sr", "usc", "rel", "req", "Source", "sec", "rs", "rl", "sf", "sel", "input", "sin", "ys", "sc", "rx", "st", "ck", "obs", "iv", "start", "source", "ipl", "inst", "from"], "dst": ["ddnt", "dnd", "Ddest", "ddest", "snt", "ddst", "dddest", "wst", "Dnd", " ddest", " dnd", "Dst", "Dnt", "sdest", "snd", "wnd", "wdest", "dth", " dth", "wth", "ddnd", "sst", "dnt", "Dth"], "in": ["ze", "en", "rin", "inn", "con", "min", "gin", "IN", "ins", "im", "ar", "ln", "on", "oin", "al", "In", "init", "inner", "inside", "ic", "ai", "up", "i", "act", "bin", "inc", "input", "sin", "iter", "it", "st", "ain", "ind", "mm", "info", "din", "inf", "is", "isin", "source", "cin", "rec", "from"], "out": ["co", "nt", "and", "by", "con", "output", "res", "oe", "oss", "cn", "obj", "on", "client", "sys", "sum", "conv", "t", "inner", "dis", "po", "net", "write", "to", "up", "bin", "writer", "os", "outer", "it", "gt", "st", "ou", "at", "g", "o", "outs", "aos", "ex", "auto", "n", "io", "Out", "OUT", "can", "ne", "ot"], "buf": ["seq", "good", "cv", "block", "br", "buff", "var", "cat", "prop", "tx", "cam", "cb", "bh", "bed", "conv", "box", "bus", "pl", "buffer", "pkg", "bag", "b", "log", "cur", "db", "aka", "cp", "Buffer", "uf", "tab", "cmd", "mu", "ck", "norm", "batch", "stab", "bar", "Buff", "cap", "msg", "cf", "arr", "fb", "vec", "bytes", "gen"], "len": ["seq", "exp", "all", "en", "nt", "wid", "z", "dl", "vol", "cmp", "h", "ln", "lic", "ls", "ll", "t", "lf", "lan", "rel", "v", "e", "lib", "le", "str", "coll", "l", "pos", "fun", "val", "length", "lon", "ren", "el", "num", "count", "n", "L", "cap", "lim", "no", "Len", "fin", "ld", "compl", "il", "size", "loc", "elt", "end", "fl"]}}
{"id1": "18046717", "id2": "20210699", "code1": "    private String getFullClassName(URL url, String className) throws Exception {\n        JarInputStream jis = new JarInputStream(url.openStream());\n        ZipEntry zentry = null;\n        while ((zentry = jis.getNextEntry()) != null) {\n            String name = zentry.getName();\n            int lastPos = name.lastIndexOf(\".class\");\n            if (lastPos < 0) {\n                continue;\n            }\n            name = name.replace('/', '.');\n            int pos = -1;\n            if (className != null) {\n                pos = name.indexOf(className);\n                if (pos >= 0 && name.length() == pos + className.length() + 6) {\n                    jis.close();\n                    return (name.substring(0, lastPos));\n                }\n            }\n        }\n        jis.close();\n        return (null);\n    }\n", "code2": "    public List<RTTicket> getTicketsForQueue(final String queueName, long limit) {\n        getSession();\n        final List<NameValuePair> params = new ArrayList<NameValuePair>();\n        params.add(new BasicNameValuePair(\"query\", \"Queue='\" + queueName + \"' AND Status='open'\"));\n        params.add(new BasicNameValuePair(\"format\", \"i\"));\n        params.add(new BasicNameValuePair(\"orderby\", \"-id\"));\n        final HttpGet get = new HttpGet(m_baseURL + \"/REST/1.0/search/ticket?\" + URLEncodedUtils.format(params, \"UTF-8\"));\n        final List<RTTicket> tickets = new ArrayList<RTTicket>();\n        final List<Long> ticketIds = new ArrayList<Long>();\n        try {\n            final HttpResponse response = getClient().execute(get);\n            int responseCode = response.getStatusLine().getStatusCode();\n            if (responseCode != HttpStatus.SC_OK) {\n                throw new RequestTrackerException(\"Received a non-200 response code from the server: \" + responseCode);\n            } else {\n                InputStreamReader isr = null;\n                BufferedReader br = null;\n                try {\n                    if (response.getEntity() == null) return null;\n                    isr = new InputStreamReader(response.getEntity().getContent());\n                    br = new BufferedReader(isr);\n                    String line = null;\n                    do {\n                        line = br.readLine();\n                        if (line != null) {\n                            if (line.contains(\"does not exist.\")) {\n                                return null;\n                            }\n                            if (line.startsWith(\"ticket/\")) {\n                                ticketIds.add(Long.parseLong(line.replace(\"ticket/\", \"\")));\n                            }\n                        }\n                    } while (line != null);\n                } catch (final Exception e) {\n                    throw new RequestTrackerException(\"Unable to read ticket IDs from query.\", e);\n                } finally {\n                    IOUtils.closeQuietly(br);\n                    IOUtils.closeQuietly(isr);\n                }\n            }\n        } catch (final Exception e) {\n            LogUtils.errorf(this, e, \"An exception occurred while getting tickets for queue \" + queueName);\n            return null;\n        }\n        for (final Long id : ticketIds) {\n            try {\n                tickets.add(getTicket(id, false));\n            } catch (final RequestTrackerException e) {\n                LogUtils.warnf(this, e, \"Unable to retrieve ticket.\");\n            }\n        }\n        return tickets;\n    }\n", "label": 0, "substitutes": {"getFullClassName": ["getRealClassname", "getRealMethodName", "getFullFullNames", "getRealClassClass", "getFullFullClass", "getFullClassClass", "getFullMethodname", "getRealClassNames", "getRealMethodClass", "getFullMethodNames", "getFullclassClass", "getFullMethodClass", "getFullMethodName", "getFullclassName", "getFullClassNames", "getRealMethodNames", "getRealMethodname", "getFullclassNames", "getRealClassName", "getFullFullName", "getFullclassname", "getFullFullname", "getFullClassname"], "url": ["browser", "address", "ref", "dl", "fail", "resource", "web", "ls", "ll", "char", "link", "log", "sl", "open", "cert", "xml", "ur", "mount", "uri", "URL", "str", "l", "kl", "nl", "ul", "mail", "path", "r", "ssl", "zip", "domain", "http", "location", "html", "job", "file", "loc", "Url"], "className": ["classInfo", "classNAME", "caseName", "modulename", "CLASSInfo", "CLASSNAME", "classString", "packageNames", "ClassString", " classClass", "ClassType", " classType", "classType", " classNames", " classNAME", "caseType", " classEvent", "interfaceEvent", "cellDef", "ClassName", "packageString", "Classname", "interfaceNAME", "classNames", " classname", "classEvent", "cellType", "CLASSName", "moduleType", "classname", "moduleClass", " classInfo", "cellName", "ClassClass", "ClassNames", "interfaceName", "caseString", "packageName", " classString", "CLASSEvent", "packageType", "interfaceInfo", "classDef", "moduleName", "classClass", "caseDef", "cellString", "ClassDef"], "jis": ["ijIS", "Jais", "ujis", "ujris", "zIS", "zis", "jais", "jris", "jbs", " jris", "zus", "zipus", "wis", "ujbs", "wais", "zipiss", "zais", "ijris", "jus", "jIS", "wris", "zipis", "jiss", "ijis", " jus", " jiss", "zipris", " jais", "Jiss", "ujais", "ijiss", "wbs", " jbs", "Jis", "zris", " jIS", "ziss"], "zentry": ["qentry", "qenter", "joffice", "zipEntry", "qEntry", " zipiter", "jiter", "zsystem", " zipentry", "zipsystem", "jlink", "gzEntry", "qiter", " zipEntry", "zspace", "zipoffice", "ziter", " zEntry", "jenter", "ozsystem", "zipentry", "zenter", "ozEntry", "zlink", "gzentry", "gzlink", "zEntry", "ozentry", "ozoffice", "gzspace", "jspace", "jentry", " zlink", "zoffice", " zspace", "jsystem", " zipenter", "jEntry"], "name": ["all", "admin", "nm", "zone", "text", "item", "min", "named", "entry", "part", "word", "comment", "description", "on", "raw", "run", "init", "mem", "base", "names", "me", "one", "label", "old", "message", "max", "family", "filename", "format", "number", "state", "now", "str", "total", "NAME", "common", "order", "tree", "parent", "search", "path", "length", "term", "null", "ame", "ma", "full", "local", "info", "n", "key", "string", "core", "id", "no", "size", "source", "file", "wrapper", "Name", "prefix", "title"], "lastPos": ["latestPOS", "lastLoc", "leftPOS", "lastpos", "leftpos", " lastLoc", "latestPos", "latestPosition", "lastDef", "rightDef", "firstLoc", " lastPOS", "leftPos", "oldLoc", " lastDef", "latestDef", " lastRes", "oldpos", "oldPos", "firstPosition", "rightpos", "leftLoc", "lastPosition", "latestpos", " lastpos", "firstPos", "lastPOS", "firstRes", "latestLoc", "oldPOS", "rightPos", "rightPOS", "lastRes", "latestRes", " lastPosition"], "pos": ["exp", "co", "apo", "prop", "z", "min", "cos", "res", "oss", "sp", "part", "bo", "op", "trans", "px", "doc", "yes", "col", "port", "x", "po", "POS", "pl", "addr", "pg", "ps", "pose", "lit", "end", "post", "pro", "conf", "i", "max", "off", "def", "pc", "position", "pt", "pi", "top", "cond", "proc", "offset", "len", "val", "point", "pres", "ind", "add", "slot", "n", "no", "start", "size", "diff", "loc", "floor", "Pos", "index", "pr", "pat", "p", "prot", "zero", "ex"]}}
{"id1": "1188100", "id2": "16092702", "code1": "    public void test() throws Exception {\n        StorageStringWriter s = new StorageStringWriter(2048, \"UTF-8\");\n        s.addText(\"Test\");\n        try {\n            s.getOutputStream();\n            fail(\"Should throw IOException as method not supported.\");\n        } catch (IOException e) {\n        }\n        s.getWriter().write(\"ing is important\");\n        s.close(ResponseStateOk.getInstance());\n        assertEquals(\"Testing is important\", s.getText());\n        InputStream input = s.getInputStream();\n        StringWriter writer = new StringWriter();\n        IOUtils.copy(input, writer, \"UTF-8\");\n        assertEquals(\"Testing is important\", writer.toString());\n        try {\n            s.getWriter();\n            fail(\"Should throw IOException as storage is closed.\");\n        } catch (IOException e) {\n        }\n    }\n", "code2": "    public static boolean doTest(Getter<?> context, Document node) {\n        try {\n            URL url = new URL(StringUtil.evaluateEL(Documents.getDocumentValue(node, \"url\"), context));\n            HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n            Assert.isTrue(conn.getResponseCode() < 400);\n            conn.disconnect();\n            return true;\n        } catch (Exception e) {\n            return false;\n        }\n    }\n", "label": 0, "substitutes": {"test": [" Test", "Test", "sample", " tests", "execute", "tests", "est", "debug", "load", "testing", "example", "tested", " evaluate", "show", " TEST", "use", "Testing", "evaluate", "some", "check", "unit", "store", " testing", "print", "server"], "s": ["xs", "ss", "sb", "ses", "sm", "p", "ms", "z", "y", "j", "sports", "comm", "h", "service", "js", "south", "details", "m", "ws", "fs", "sys", "qs", "bs", "https", "ls", "status", "t", "sa", "ns", "sq", "abs", "spec", "c", "sl", "stats", "b", "ps", "ts", "S", "v", "i", "e", "less", "aws", "sv", "state", "ats", "sd", "rs", "os", "l", "ds", "sql", "sc", "sw", "gs", "st", "pers", "ssl", "self", "n", "http", "sts", "socket", "is", "still", "so", "store", "session", "cs", "w"], "input": ["active", "image", "json", "text", "output", "sample", "hello", "cont", "request", "reader", "raw", "stream", "context", "in", "feed", "inner", "inside", "accept", "buffer", "open", "current", "Input", "i", "read", "media", "get", "initial", "upload", "this", "my", "form", "null", "ahead", "ip", "iterator", "io", "start", "file", "source", "data"], "writer": ["window", "worker", "creator", "her", "writers", "Writer", "caster", "output", "WR", "console", "draw", "driver", "storage", "service", "builder", "reader", "word", "writing", "processor", "wright", "stream", "inner", "maker", "buffer", "write", "editor", "writ", "to", "woman", "widget", "format", "external", "operator", "written", "out", "handler", "wire", "term", "manager", "wrote", "temp", "file", "riter", "winner", "player", "rew", "loader", "end", "w"]}}
{"id1": "23672408", "id2": "8135072", "code1": "    private void copyIconFiles(UmlClass clazz) {\n        if (clazz.hasAnnotation(\"icon16\")) {\n            String i16 = clazz.annotationValue(\"icon16\");\n            String fileType = \".png\";\n            if (i16.endsWith(\".jpg\")) fileType = \".jpg\";\n            if (i16.endsWith(\".gif\")) fileType = \".gif\";\n            String desti16 = output_dir + \"/../resources/images/\" + clazz.getName() + \"16\" + fileType;\n            try {\n                FileChannel src = new FileInputStream(i16).getChannel();\n                FileChannel dst = new FileOutputStream(desti16).getChannel();\n                dst.transferFrom(src, 0, src.size());\n                src.close();\n                dst.close();\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        }\n        if (clazz.hasAnnotation(\"icon32\")) {\n            String i32 = clazz.annotationValue(\"icon32\");\n            String fileType = \".png\";\n            if (i32.endsWith(\".jpg\")) fileType = \".jpg\";\n            if (i32.endsWith(\".gif\")) fileType = \".gif\";\n            String desti32 = output_dir + \"/../resources/images/\" + clazz.getName() + \"32\" + fileType;\n            try {\n                FileChannel src = new FileInputStream(i32).getChannel();\n                FileChannel dst = new FileOutputStream(desti32).getChannel();\n                dst.transferFrom(src, 0, src.size());\n                src.close();\n                dst.close();\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        }\n    }\n", "code2": "    public void setImg() {\n        JFileChooser jFileChooser1 = new JFileChooser();\n        String separator = \"\";\n        if (JFileChooser.APPROVE_OPTION == jFileChooser1.showOpenDialog(this.getFatherFrame())) {\n            setPath(jFileChooser1.getSelectedFile().getPath());\n            separator = jFileChooser1.getSelectedFile().separator;\n            File dirImg = new File(\".\" + separator + \"images\");\n            if (!dirImg.exists()) {\n                dirImg.mkdir();\n            }\n            int index = getPath().lastIndexOf(separator);\n            String imgName = getPath().substring(index);\n            String newPath = dirImg + imgName;\n            try {\n                File inputFile = new File(getPath());\n                File outputFile = new File(newPath);\n                if (!inputFile.getCanonicalPath().equals(outputFile.getCanonicalPath())) {\n                    FileInputStream in = new FileInputStream(inputFile);\n                    FileOutputStream out = new FileOutputStream(outputFile);\n                    int c;\n                    while ((c = in.read()) != -1) out.write(c);\n                    in.close();\n                    out.close();\n                }\n            } catch (Exception ex) {\n                ex.printStackTrace();\n                LogHandler.log(ex.getMessage(), Level.INFO, \"LOG_MSG\", isLoggingEnabled());\n                JOptionPane.showMessageDialog(null, ex.getMessage().substring(0, Math.min(ex.getMessage().length(), getFatherPanel().MAX_DIALOG_MSG_SZ)) + \"-\" + getClass(), \"Set image\", JOptionPane.ERROR_MESSAGE);\n            }\n            setPath(newPath);\n            bckImg = new ImageIcon(getPath());\n        }\n    }\n", "label": 1, "substitutes": {"copyIconFiles": ["copyIndexfiles", "copyiconImages", " copyiconImages", "copyiconDocuments", " copyiconfiles", "copyiconfiles", " copyIconDocuments", "copyIconImages", " copyiconFiles", " copyiconDocuments", "copyIconfiles", "copyIndexFiles", " copyIconImages", "copyIndexDocuments", "copyIconDocuments", "copyiconFiles", " copyIconfiles", "copyIndexImages"], "clazz": ["classuddy", "sclace", "pkgasse", "classazz", "Claz", "escace", "closer", "plasse", "Clace", "crus", "callazz", "pkgaz", "Close", " classe", "cluddy", "clojure", "sclazz", " clbean", "clbo", "plashed", "chojure", "callace", "descazz", "escazz", "clotted", "scloser", " clbo", "CLoser", "clab", "CLace", "colluddy", "crazz", " plub", "chotted", " closer", "classe", " plus", "clbean", " claz", "chazz", "relose", " cluddy", "chace", " clace", "relaz", "Clazz", "claz", " club", "relazz", "CLazz", "crub", "clace", "relab", " clus", "cluster", "Clbo", "club", "Clab", "pkgazz", "clashed", "classotted", "clus", "collazz", "pkgashed", "CLbean", "descab", " cluster", " plazz", "callbo", "callaz", "sclbean", " clojure", "close", "craz", "descose", "descaz", "escotted", " clashed", "colluster", "escojure", "classuster", " clotted", "plazz", "collotted", "plaz", " plaz"], "i16": ["ami16", " i160", "ji63", "ri16", " i216", "i63", "ri157", "iri6", "ini160", "ami6", "li19", "liShort", "i157", "pi63", "iri157", "ii160", "ii16", "ji150", "ini19", "li16", "i24", "ji16", "i19", "ami2016", "iri16", "i216", "li2016", "ami150", "ami63", "pi6", " i157", "amiShort", "ini24", "iniShort", "i160", "i2016", "ri2016", " i24", "pi150", "iri2016", "ini2016", " i6", "ii216", "i150", "ji6", "ii24", "ini216", " i2016", "pi16", "ini16", "ri6", "i6", "iShort", "ami19"], "fileType": ["fieldTyp", "formatValue", " filePattern", " fileFormat", "fieldDef", "FILEtype", "resourceUnit", "formatTime", "iletype", " fileValue", "fileFormat", "policyTyp", "ileTyp", "fileList", "issuetype", "fileUnit", "webDef", "policyType", "formType", " fileList", "FILEType", " fileTYPE", "webTYPE", "eventFormat", "coreType", "formName", "FileType", "fieldType", "formtype", "treeTYPE", "coreDef", "relationType", "relationFamily", "fileDef", "coreTYPE", "formattype", "fileTime", "viewtype", "coreTyp", "policyFamily", "fileName", "eventUnit", "issueTyp", "fieldTYPE", "formatTYPE", "fileHandler", " fileTyp", "Filetype", "filePattern", "FileName", "relationTyp", "eventList", "fileTyp", "eventType", "policyHandler", "viewValue", "FILEName", "fileValue", " fileTime", "formatType", " filetype", "viewTYPE", "viewType", "issueType", "filetype", "fileTYPE", "ilePattern", "issuePattern", "resourceType", "treeTime", "resourceFormat", "webTyp", "coreHandler", "relationHandler", "fileFamily", " fileUnit", "coreFamily", "webList", "treeType", "webType", "treetype", "eventTYPE", "resourceTYPE", "ileType"], "desti16": ["desti18", " desti18", "destii2016", "resulti16", "destgi24", "destsi32", "destgi2016", "destsi16", "destui160", "destui32", "resultii216", " destsi18", "desti160", "destsi18", "destsi160", "desti24", "desti2016", "destii16", "destii24", " desti160", "destui18", " destsi160", "destui16", "destxi16", "destui24", "resultii2016", "destii216", "resulti24", "destui216", " destsi32", " destsi16", "resulti216", "destxi32", "destxi160", "destui2016", "resulti2016", "destgi16", "destxi18", "destgi216", "desti216", "resultii24", "resultii16"], "src": ["ser", "rc", "hl", "via", "txt", "usr", "sb", "scan", "ctx", "cmp", "img", "sync", "bg", "rg", "sit", "sp", "ins", "cont", "ibl", "cb", "dest", "ln", "bh", "sys", "tmp", "ls", "bc", "inner", "urg", "sq", "rest", "addr", "sl", "pkg", "fc", "ctr", "cli", "cur", "sr", "rel", "sec", "req", "ptr", "bin", "rb", "sel", "rl", "rs", "std", "input", "proc", "comp", "iter", "sol", "nl", "sc", "gs", "isl", "rx", "st", "obs", "sn", "iv", "syn", "etc", "ssl", "desc", "vr", "sub", "rob", "source", "loc", "inst"], "dst": ["dernd", " dbl", "ddmn", "dLnet", "dmn", "dgt", "ndmt", "rdest", "rst", "dsest", " dnet", " ddr", "tnd", "dsnet", "Ddest", "derdest", "dest", "fdr", "nput", "ddest", " dput", "dsst", "ddst", "ddr", "derst", "dermn", "nnd", "ngt", "dddest", "ndest", " dmt", "rcut", "dcut", "dLdest", "fnd", "dLot", "tgt", "rdmt", "Dnd", "Ddr", " ddest", " dnd", "dput", "Dst", "dLst", "dsot", "tput", "rdsts", "dbl", "tst", "dmt", "dsts", "rbl", " dcut", " dsts", " dmn", " dest", "dot", "dLcut", "rdst", "dnet", " dot", "ndsts", "fdest", " dgt", "dLest", "ddnd", "dLbl", "ndst", "dnd", "nst", "fst"], "i32": ["ip32", "pi31", "ic31", "ii342", "ic86", "xi31", "xi32", "pi64", "isi86", " i86", "i342", "i86", "ini22", "ii32", " i34", "pi34", " i64", "pi32", "ini48", " i31", "ii34", "xi22", "ic64", "ip64", "ini31", "isi40", "ic342", "ii28", "ic40", "isi64", "ic48", " i28", "i31", "i64", "i40", "ic28", "ip34", "i22", "isi32", "ic32", " i342", "ic22", "ic34", "ip31", "xi48", "i48", "i28", "ini32", "i34", " i40"], "desti32": ["targetpi30", "desti256", "destu31", "destI32", "Desti31", "DestI31", "destI31", "destdi32", "destdi34", "destu90", "Desti256", "targetpi31", "desti34", "destI256", "DestI32", "destI90", "destu32", "destic34", "destic31", "desti31", "targetpi32", "destpi31", "Desti90", "targeti34", "destic30", "destdi31", "targeti30", "DestI256", "destpi32", "destic32", "targetpi34", "destu256", "desti30", "targeti31", "destpi34", "targeti32", "destdi30", "DestI90", "desti90", "destpi30", "Desti32"]}}
{"id1": "11716816", "id2": "1097147", "code1": "    private void updateFile(File file) throws FileNotFoundException, IOException {\n        File destFile = new File(file.getPath().replace(URL_UNZIPPED_PREFIX + latestVersion, \"\"));\n        FileChannel in = null;\n        FileChannel out = null;\n        try {\n            if (!destFile.exists()) {\n                destFile.getParentFile().mkdirs();\n                destFile.createNewFile();\n            }\n            in = new FileInputStream(file).getChannel();\n            out = new FileOutputStream(destFile).getChannel();\n            in.transferTo(0, in.size(), out);\n        } finally {\n            if (out != null) out.close();\n            if (in != null) in.close();\n        }\n    }\n", "code2": "    public static String getMessageDigest(String[] inputs) {\n        if (inputs.length == 0) return null;\n        try {\n            MessageDigest sha = MessageDigest.getInstance(\"SHA-1\");\n            for (String input : inputs) sha.update(input.getBytes());\n            byte[] hash = sha.digest();\n            String CPass = \"\";\n            int h = 0;\n            String s = \"\";\n            for (int i = 0; i < 20; i++) {\n                h = hash[i];\n                if (h < 0) h += 256;\n                s = Integer.toHexString(h);\n                if (s.length() < 2) CPass = CPass.concat(\"0\");\n                CPass = CPass.concat(s);\n            }\n            CPass = CPass.toUpperCase();\n            return CPass;\n        } catch (NoSuchAlgorithmException e) {\n            throw new IllegalStateException(e.getMessage());\n        }\n    }\n", "label": 0, "substitutes": {"updateFile": ["updatePage", "updateSourceFile", "UpdateSourceFile", "archiveSourceFile", "downloadContent", "archiveFile", "archiveContent", "downloadFile", "downloadSourceFile", "updateContent", "UpdatePage", "downloadPage", "UpdateFile", "UpdateContent", "archivePage"], "file": ["type", "f", "rule", "report", "handle", "image", "output", "entry", "File", "FILE", "h", "resource", "fp", "page", "table", "t", "base", "port", "link", "attribute", "log", "document", "message", "db", "filename", "ile", "e", "format", "content", "url", "name", "le", "get", "input", "issue", "path", "null", "line", "use", "channel", "full", "local", "info", "io", "source", "p", "data", "title"], "IOException": [" IOProblem", " IOError", "SecurityError", "SecurityException", "IOError", "OperationError", "SecurityProblem", "OperationException", "IOProblem", "OperationProblem"], "destFile": ["DestSourceFile", "DestPlace", "DestPath", "destPath", "tempDir", "destSourceFile", " DestEmail", " destPlace", "declile", "destfile", "optPlace", "sourcePath", "sourceFile", "Destile", "destFolder", " destFolder", "destPlace", " destile", "DestPage", " destDir", "optFile", "targetFile", "tempPath", "destPage", "targetDir", "declFolder", "sourceDir", " destinationDir", "targetPath", " destinationEmail", " DestFile", "destile", " destinationFile", "DestDir", " DestDir", " DestDo", "destDir", "declSourceFile", "optFolder", "tempfile", " destDo", "destDo", " destEmail", "Destfile", "optPage", " destinationDo", " destPage", "DestFile", " destSourceFile", " destPath", "tempFile", "targetFolder", "sourceFolder", "destEmail", "DestFolder", "declFile", " destfile"], "in": ["f", "all", "mi", "rin", "en", "inn", "ini", "gin", "con", "ie", "IN", "ins", "im", "m", "ln", "oin", "on", "al", "raw", "In", "init", "inner", "inside", "net", "ic", "edIn", "ai", "re", "up", "i", "read", "bin", "act", "inc", "l", "input", "sin", "iter", "it", " IN", " din", "s", "ain", "ind", "r", "local", "mm", "n", "info", "io", "din", "inf", "is", "isin", "cin", "from", "ne", "pass"], "out": ["ion", "co", "en", "nt", "flush", "con", "output", "cos", "oe", "oss", "cn", "obj", "client", "sys", "conv", "t", "one", "chain", "net", "write", "log", "b", "to", "result", "up", "v", "cache", "os", " OUT", "or", "outer", "it", "OU", "ch", "gt", "note", "cmd", "conn", "null", "ou", "s", "outs", "g", "o", "aos", "at", "ex", "channel", "again", "n", "jp", "io", "msg", "no", "Out", "fn", "OUT", "can", "ne", "ot"]}}
{"id1": "8093133", "id2": "4016687", "code1": "    public static Object loadXmlFromUrl(URL url, int timeout, XML_TYPE xmlType) throws IOException {\n        URLConnection connection = url.openConnection();\n        connection.setConnectTimeout(timeout);\n        connection.setReadTimeout(timeout);\n        BufferedInputStream buffInputStream = new BufferedInputStream(connection.getInputStream());\n        return loadXml(buffInputStream, xmlType);\n    }\n", "code2": "    public static void main(String[] args) {\n        FTPClient client = new FTPClient();\n        String sFTP = \"ftp.miservidor.com\";\n        String sUser = \"usuario\";\n        String sPassword = \"password\";\n        try {\n            System.out.println(\"Conectandose a \" + sFTP);\n            client.connect(sFTP);\n            boolean login = client.login(sUser, sPassword);\n            if (login) {\n                System.out.println(\"Login correcto\");\n                boolean logout = client.logout();\n                if (logout) {\n                    System.out.println(\"Logout del servidor FTP\");\n                }\n            } else {\n                System.out.println(\"Error en el login.\");\n            }\n            System.out.println(\"Desconectando.\");\n            client.disconnect();\n        } catch (IOException ioe) {\n            ioe.printStackTrace();\n        }\n    }\n", "label": 0, "substitutes": {"loadXmlFromUrl": ["loadXmlWithFile", "loadXmlFormURL", "loadXmlAsWeb", "loadXmlAsFile", "loadXmlAsUrl", "loadXMLFormUrl", "loadXmlFromWeb", "loadXmlFromURL", "loadXMLFromFile", "loadXmlFormFile", "loadXmlAsURL", "loadXMLFromURL", "loadXmlFromFile", "loadXmlWithUrl", "loadXMLFromUrl", "loadXMLFormFile", "loadXmlFormWeb", "loadXmlFormUrl", "loadXmlWithWeb", "loadXMLFormURL", "loadXMLFromWeb", "loadXmlWithURL", "loadXMLFormWeb"], "url": ["address", "u", "res", "request", "bel", "page", "web", "ll", "in", "base", "char", "link", "build", "log", "sl", "open", "b", "document", "xml", "ur", "uri", "URL", "name", "str", "get", "l", "input", "nl", "path", "ssl", "domain", "n", "http", "location", "html", "id", "job", "file", "loc", "Url", "user", "host", "abs"], "timeout": ["type", "window", "policy", "time", "capacity", "wait", "Timeout", "seconds", "client", "exclusive", "t", "frequency", "limit", "directory", "buffer", "to", "max", "mode", "number", "resolution", "total", "out", "sleep", "delay", "it", "until", "length", "height", "term", "amount", "monitor", "blocking", "network", "padding", "course", "io", "size", "password", "latest", "version", "unit", "period", "OUT", "server", "duration"], "xmlType": ["fileStyle", " xmlTypes", " xmlStyle", " xmltype", "xmlBlock", "complextype", " xmlUnit", " xmlBlock", "imageType", "mltype", "mlType", "xmlTypes", "mlUnit", "fileType", "complexType", "imageBlock", "imageStyle", "fileBlock", "fileTypes", "complexTyp", "mlTyp", "xmltype", "xmlUnit", "xmlTyp", " xmlTyp", "xmlStyle", "imageTypes", "complexUnit"], "connection": ["ion", "generation", "computer", "response", "reference", "creator", "subject", "con", "connected", "entry", "pointer", "character", "city", "resource", "application", "internet", "builder", "client", "description", "opening", "directory", "link", "command", "c", "open", "to", "current", "system", "close", "number", "uri", "condition", "position", "statement", "Connection", "creation", "cone", "conn", "network", "connect", "channel", "database", "nc", "relation", "manager", "socket", "config", "usage", "io", "still", "communication", "user", "session", "established"], "buffInputStream": ["BuffOutputField", "buffEarStream", "buffInputForm", "buffEntityForm", "buffOutputChannel", "buffEntityStream", "buffOutputSteam", "buffInputChannel", "BuffOutputSteam", "buffInputField", "BuffOutputStream", "buffEntityChannel", "buffOutputField", "buffInputSteam", "buffIOField", "BuffInputStream", "buffOutputStream", "BuffOutputForm", "buffIOStream", "buffEarField", "BuffInputField", "buffOutputForm", "BuffInputForm", "BuffInputChannel", "BuffInputSteam", "BuffOutputChannel", "buffIOSteam", "buffIOForm", "buffEarSteam", "buffEarForm"]}}
{"id1": "7891509", "id2": "10547671", "code1": "    public PageLoader(String pageAddress) throws Exception {\n        URL url = new URL(pageAddress);\n        BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream()));\n        inputLine = \"\";\n        while (in.ready()) {\n            inputLine = inputLine + in.readLine();\n        }\n        in.close();\n    }\n", "code2": "    private String retrieveTemplate() throws Exception {\n        if (cachedTemplate == null) {\n            final URL url = new URL(blogEditor.getBlogInfo().getBlogUrl());\n            final BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream()));\n            final StringBuilder result = new StringBuilder();\n            String line;\n            while ((line = in.readLine()) != null) {\n                result.append(line);\n            }\n            in.close();\n            cachedTemplate = result.toString();\n        }\n        return cachedTemplate;\n    }\n", "label": 1, "substitutes": {"pageAddress": ["pageAdd", "Pageaddress", "pageaddress", "PageAddress", " pageName", "serveraddress", "serverUrl", "PageUrl", "PageName", " pageaddress", "resourceAdd", "serverName", " pageUrl", "resourceAddress", "PageAdd", "pageUrl", "resourceName", "pageName", " pageAdd", "serverAddress", "resourceaddress"], "url": ["browser", "window", "gl", "address", "sb", "google", "dl", "resource", "www", "client", "https", "bel", "ls", "web", "ll", "base", "char", "link", "pl", "build", "sl", "cert", "rel", "ur", "mount", "uri", "URL", "str", "l", "api", "nl", "ul", "mail", "github", "r", "ssl", "ret", "key", "http", "file", "acl", "Url", "p"], "in": ["all", "rin", "en", "inn", "and", "by", "gin", "IN", "vin", "ins", "reader", "on", "oin", "sum", "al", "In", "init", "inner", "ill", "inside", "one", "b", "ic", "re", "conf", "i", "read", "bin", "copy", "inc", "l", "input", "out", "it", " din", "again", "ind", "nin", "r", "ma", "mn", "mc", "n", "io", "din", "inf", "is", "isin", "cin", "check", "from"], "inputLine": ["outputLINE", "enumLine", " inputL", "inputL", " inputNet", " inputRow", "enumNet", "inputLINE", "inputNet", "outputline", "enumL", "focusNet", "InputLine", "responseLine", "inputRow", "submitBlock", " inputEntry", "InputEntry", " inputLINE", "inputline", "enumRow", " inputline", "focusLine", " inputBlock", "inputBlock", "submitEntry", "focusL", "outputBlock", "inputEntry", "responseBlock", "InputLINE", "submitLINE", "submitLine", "responseline", "focusRow", "InputBlock", "outputLine", "responseLINE"]}}
{"id1": "2465747", "id2": "4798332", "code1": "    public static String postRequest(String urlString, HashMap data) {\n        String returnData = \"\";\n        try {\n            URL url = new URL(urlString);\n            URLConnection connection = url.openConnection();\n            connection.setDoOutput(true);\n            connection.setDoInput(true);\n            PrintWriter out = new PrintWriter(connection.getOutputStream());\n            Object[] keySet = data.keySet().toArray();\n            Object[] values = data.values().toArray();\n            for (int count = 0; count < keySet.length; count++) {\n                out.print(URLEncoder.encode((String) keySet[count]) + \"=\" + URLEncoder.encode((String) values[count]));\n                if ((count + 1) < keySet.length) out.print(\"&\");\n            }\n            out.close();\n            BufferedReader in = new BufferedReader(new InputStreamReader(connection.getInputStream()));\n            String inputLine;\n            while ((inputLine = in.readLine()) != null) {\n                returnData += inputLine;\n            }\n            in.close();\n        } catch (Exception e) {\n            e.printStackTrace();\n            returnData = null;\n        }\n        return (returnData);\n    }\n", "code2": "    public static String SHA(String source) {\n        logger.info(source);\n        String result = null;\n        try {\n            MessageDigest digest = MessageDigest.getInstance(\"SHA\");\n            digest.update(source.getBytes());\n            byte[] bytes = digest.digest();\n            result = EncodeUtils.hexEncode(bytes);\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        }\n        logger.info(result);\n        return result;\n    }\n", "label": 0, "substitutes": {"postRequest": ["processrequest", "PostRequest", "processRequest", "PostQuery", "PostCommand", "postCommand", "postrequest", " postCommand", "processQuery", "processCommand", " postrequest", " postQuery", "postQuery", "Postrequest"], "urlString": ["urlName", "UrlString", "lRaw", "urlStr", "urlRaw", "uriName", "UrlStr", "lSeries", "lStr", "uriString", "uriSource", "sslSeries", "urlSource", "UrlSource", "sslString", " urlSeries", "lSource", " urlRaw", "sslRaw", "sslStr", "uriStr", "urlSeries", "UrlName", "lName", "lString", " urlStr"], "data": ["extra", "times", "response", "json", "value", "text", "DATA", "settings", "default", "params", "d", "dict", "resource", "details", "description", "ata", "table", "done", "store", "action", "to", "message", "missing", "post", "content", "none", "properties", "def", "format", "name", "cache", "state", "hash", "images", "meta", "resources", "metadata", "form", "dat", "batch", "record", "filter", "info", "user", "map", "p", "update", "results", "session"], "returnData": ["resultText", "resultLine", "saveDATA", " returnString", "saveData", " returnQuery", "saveText", "reportDATA", "saveQuery", "getData", "commentLine", "fullLine", "getString", "ReturnDATA", "getText", "returnQuery", "commentDat", "returnText", "commentData", "ReturnQuery", " returnText", "commentDATA", "ReturnText", "resultData", "returnString", "ReturnLine", "reportLine", "reportData", "returnLine", " returnLine", "returnDATA", "getDATA", "fullDATA", " returnDATA", "fullDat", "reportDat", "returnDat", "ReturnData", "ReturnString", "resultString", "fullData"], "url": ["f", "gl", "address", "u", "google", "dl", "client", "https", "bel", "ls", "ll", "base", "link", "build", "log", "sl", "open", "b", "call", "re", "ur", "mount", "org", "uri", "URL", "get", "str", "l", "nl", "ul", "mail", "conn", "r", "ssl", "http", "location", "job", "Url", "loader"], "connection": ["ion", "response", "creator", "subject", "con", "connected", "entry", "operation", "pointer", "character", "city", "service", "resource", "application", "description", "client", "https", "using", "general", "directory", "link", "command", "c", "open", "function", "to", "document", "message", "cert", "number", "uri", "condition", "position", "statement", "Connection", "l", "container", "creation", "cone", "conn", "network", "connect", "database", "relation", "nc", "channel", "n", "use", "manager", "socket", "io", "no", "communication", "online", "wrapper", "session", "established"], "out": ["all", "ion", "co", "flush", "con", "output", "console", "obj", "client", "can", "conv", "t", "inner", "net", "buffer", "write", "b", "to", "log", "list", "up", "v", "i", "writer", "os", "cm", "l", "outer", "pretty", "OU", "ch", "conn", "null", "ou", "at", "outs", "aos", "o", "g", "r", "screen", "auto", "ex", "n", "io", "Out", "OUT", "user", "p", "print", "w"], "keySet": ["keysSet", "KeyName", " keyMap", "numList", "keysName", "KEYSpec", "keysList", "KeySet", "KEYSet", "KEYName", "KEYMap", "KEYList", "verSet", " keyName", " keyList", "keySpec", "verset", "KeyMap", "keyList", "numName", " keySpec", "rowList", "KeyList", "verList", " keyset", "keyName", "keysMap", "rowSpec", "numSet", "Keyset", "rowSet", "keyset", "verMap", "numset", "keyMap"], "values": ["terms", "times", "services", "maps", "tags", "forms", "value", "vals", "settings", "options", "versions", "rows", "strings", "params", "users", "items", "keys", "windows", "modules", "sets", "bs", "tests", "roots", "views", "types", "fs", "names", "changes", "ves", "pins", "rules", "issues", "pes", "flows", "UES", "its", "properties", "lists", "blocks", "fields", "bes", "verts", "actions", "members", "events", "obs", "objects", "ports", "als", "Values", "vs", "groups", "files", "gets", "codes", "points", "results"], "count": ["first", "test", "next", "base", "c", "err", "call", "country", "mount", "number", "conf", "child", "state", "total", "continue", "amount", "found", "Count", "n", "size", "index", "loop", "all", "cycle", "handle", "nt", "cloud", "cont", "force", "currency", "sum", "consider", "ctr", "cell", "list", "name", "coll", "const", "cmd", "cd", "batch", "ind", "make", "check", "id", "unique", "and", "con", "\u00e7", "create", "table", "frequency", "code", "hold", "counter", "now", "ount", "last", "length", "group", "num", "account", "repeat", "empty", "find", "OUNT", "contact", "client", "sequence", "current", "ct", "ask", "valid", "month", "flag", "add", "title"], "in": ["mi", "rin", "en", "inn", "ini", "and", "gin", "IN", "ins", "reader", "on", "al", "raw", "In", "inside", "inner", "buffer", "ic", "re", "conf", "i", "read", "bin", "pi", "inc", "l", "input", "or", "it", " din", "form", "ind", "r", "ma", "mn", "io", "din", "inf", "is", "isin", "source", "body", "cin", "check", "from"], "inputLine": ["outputLINE", "InputRow", "InputData", "evalSet", " inputRow", "inputFile", "inputData", "inputLINE", "outputline", "evalFile", " inputData", "textData", "viewData", "InputLine", "textLine", "viewLine", "inputRow", " inputFile", "contextRow", "outputRow", "evalLine", "textSet", "evalData", "inputSet", " inputLINE", "inputline", "viewline", " inputline", "Inputline", " inputSet", "contextLINE", "textFile", "viewRow", "contextline", "contextLine", "outputLine"]}}
{"id1": "17786231", "id2": "12783713", "code1": "        private void downloadFile(final String downloadUrl, final String destinationFile) throws IOException {\n            HttpClient client = new DefaultHttpClient();\n            HttpGet httpGet = new HttpGet(downloadUrl);\n            final File outputFile = new File(destinationFile);\n            createParentDirectories(outputFile);\n            FileOutputStream outputStream;\n            outputStream = new FileOutputStream(outputFile);\n            final HttpResponse response = client.execute(httpGet);\n            if (isInterrupted()) {\n                outputStream.close();\n                return;\n            }\n            final HttpEntity entity = response.getEntity();\n            InputStream inputStream = null;\n            try {\n                if (entity != null) {\n                    inputStream = entity.getContent();\n                    CopyStreamStatusCallback callback = new CopyStreamStatusCallback() {\n\n                        @Override\n                        public long getSkipBetweenUpdates() {\n                            return entity.getContentLength() * 2 / PERCENTAGE_BASE;\n                        }\n\n                        @Override\n                        public void onUpdate(final long copiedLength) {\n                            int percentage = (int) (copiedLength * PERCENTAGE_BASE / entity.getContentLength());\n                            handleUpdate(STATUS_DOWNLOADING, percentage);\n                        }\n                    };\n                    copyStreams(inputStream, outputStream, callback);\n                }\n            } finally {\n                try {\n                    outputStream.close();\n                    if (inputStream != null) {\n                        inputStream.close();\n                    }\n                } catch (IOException e) {\n                    Log.v(DictionaryForMIDs.LOG_TAG, \"Exception while closing stream: \" + e);\n                }\n            }\n        }\n", "code2": "    @Override\n    public void sendErrorMessage(String message) throws EntriesException, StatementNotExecutedException, NotConnectedException, MessagingException {\n        if (query == null) {\n            throw new NotConnectedException();\n        }\n        ArrayList<String> recipients = query.getUserManager().getTecMail();\n        Mail mail = new Mail(recipients);\n        try {\n            ZipOutputStream zos = new ZipOutputStream(new FileOutputStream(\"log/ossobooklog.zip\"));\n            FileInputStream fis = new FileInputStream(\"log/ossobook.log\");\n            ZipEntry entry = new ZipEntry(\"ossobook.log\");\n            zos.putNextEntry(entry);\n            byte[] buffer = new byte[8192];\n            int read = 0;\n            while ((read = fis.read(buffer, 0, 1024)) != -1) {\n                zos.write(buffer, 0, read);\n            }\n            zos.closeEntry();\n            fis.close();\n            zos.close();\n            mail.sendErrorMessage(message, new File(\"log/ossobooklog.zip\"), getUserName());\n        } catch (Exception ex) {\n            ex.printStackTrace();\n        }\n    }\n", "label": 0, "substitutes": {"downloadFile": ["getfile", "loadResource", "loadfile", "getContent", "loadFile", "getResource", "loadContent", "transferFile", "transferResource", "downloadContent", "downloadfile", "getFile", "transferContent", "downloadResource", "transferfile"], "downloadUrl": [" downloadLink", "downloadLink", "DownloadWar", "linkUrl", "transferUr", "downloadURL", "transferURL", "installLink", "reportURL", "downloadWar", "downloadUr", "transferUrl", "installUrl", "reportUr", "transferWar", "DownloadUrl", "reportWar", "linkLink", "installUr", " downloadURL", "linkUr", "reportUrl", "installURL", "DownloadUr", "DownloadURL", " downloadUr", "linkURL"], "destinationFile": ["destarationName", "coordacementfile", "destarationfile", "coordacementFile", "coordinationName", " destinationPath", "destinationSourceFile", "destinationPath", "destarationFile", "destinatedFile", "destinationFolder", "coordacementFolder", "destarationSourceFile", " destificationPath", "destinationName", "destinatedFolder", "coordinationFolder", "destarationFolder", "destacementName", " destificationFile", "destinationfile", "coordacementName", "destarationPath", " destinationDir", "destiningFile", "destiningPath", "destiningDir", "coordinationfile", "destificationFile", "destificationSourceFile", "destificationDir", " destificationSourceFile", "destinatedName", "destarationDir", "destacementFile", "destiningSourceFile", "destinatedfile", "destacementfile", " destificationDir", "destinationDir", "destificationPath", "coordinationFile", " destinationSourceFile", "destacementFolder"], "client": ["co", "google", "console", "contact", "city", "service", "request", "resource", "Client", "force", "https", "context", "connection", "template", "net", "cli", "ci", "call", "system", "cache", "url", "uri", "phone", "cm", "api", "query", "conn", "tc", "network", "collection", "channel", "key", "http", "remote", "io", "pool", "wrapper", "server", "cl"], "httpGet": ["ttpPut", "Httpget", "ttpget", "HttpGet", "hGet", " httpGET", "httpget", "ttpGet", "HttpGET", "utilGET", "HttpPut", "utilQuery", "httpQuery", "httpGET", "utilPut", " httpPut", "utilGet", "hget", "HttpQuery", "httpPut", "hPut", " httpQuery"], "outputFile": ["newFile", "outputPlace", "newPlace", "betaFile", "outFile", "OutputPoint", "regionFile", "OutputStream", " outputFILE", "outputFILE", "regionFILE", "newStream", "seeFILE", "outPoint", "tempFILE", "newPoint", "OutputFile", "OutputPlace", "outStream", "outputPoint", "seeFile", "regionStream", "tempFile", "tempStream", "outPlace", "betaFILE"], "outputStream": ["coinStyle", "inputForm", "inputStreamer", "putStream", "printForm", " outputStyle", "inputFile", "coinStreamer", "printSteam", "outputView", "inputSteam", "outputForm", "printStream", "coinSteam", "Outputstream", "OutputStream", " outputView", "outputStyle", "printFile", "responseStyle", " outputForm", "OutputView", "putStyle", " outputStreamer", "responseSteam", "OutputStyle", "OutputSteam", " outputSteam", "outputSteam", "inputStyle", "outputstream", "putStreamer", "inputstream", "inputView", " outputstream", "putSteam", "responseStreamer", "coinStream", "outputStreamer", "responseStream"], "response": ["reply", "image", "json", "block", "output", "entry", "service", "request", "resource", "application", "description", "details", "yes", "Response", "status", "page", "connection", "attribute", "resp", "document", "message", "result", "onse", "post", "content", "example", "initial", "answer", "http", "remote", "server", "still", "body", "version", "data", "given"], "entity": ["event", "type", "unique", "json", "image", "ilo", "entry", "email", "comment", "resource", "details", "obj", "enc", "status", "profile", "associated", "existing", "attribute", "secure", "buffer", "document", "message", "result", "xml", "content", "detail", "e", "cache", "properties", "name", "person", "error", "total", "valid", "ent", "note", "metadata", "object", "component", "encrypted", "security", "group", "instance", "line", "el", "activity", "member", "info", "local", "account", "quote", "Entity", "iso", "ity", "body", "existent", "translation", "data", "pe", "peer"], "inputStream": ["readstream", "sourcestream", "inputForm", "thisForm", "sourceSteam", "inputStreamer", "sourceView", "InputStream", "imageView", "upSteam", " inputForm", "outputView", "thisStyle", "readForm", "outputForm", "inputSteam", " inputSteam", "activeSteam", "upstream", "thisStream", "outputStyle", "upStream", "evalView", " inputStreamer", "readSteam", "upForm", "imageStream", "evalSteam", "activeView", "evalStream", "inputStyle", "outputSteam", "outputstream", "inputstream", "readStream", "imageSteam", "inputView", "imagestream", "evalStreamer", "sourceStream", "InputSteam", "InputForm", "Inputstream", "thisSteam", " inputView", " inputstream", "activeStream", "InputStyle", "activeStreamer"], "callback": ["browser", "back", "window", "closure", "lambda", "creator", "actor", "alias", "policy", "func", "cb", "parser", "Callback", "builder", "processor", "update", "library", "finder", "CB", "function", "message", "call", "cell", "background", "gc", "token", "handler", "consumer", "continue", "soon", "filter", "pattern", "manager", "sound", "job", "binding", "wrapper", "backs", "facebook", "loader", "hook", "display", "cc"], "copiedLength": ["copiedNumber", "copedSize", "copiedDuration", "copifiedSize", "copIEDNumber", "CopedNumber", "copifiedDuration", "copyDuration", "copyLen", "copifiedLen", "copySize", "copifiedNumber", "CopiedLength", "copiedSize", "CopiedNumber", "CopedSize", "CopedLen", "CopiedSize", "CopiedLen", "copyLength", "copedLen", "CopedLength", "copiedLen", "copedLength", "copedDuration", "copIEDDuration", "copIEDLength", "copifiedLength", "CopedDuration", "copedNumber", "CopiedDuration"], "percentage": [" percentages", " percentale", "Percentaging", "Percentage", " percentaging", "CENTure", "Percenture", " percenture", "capages", "capale", "CENTage", "Percentages", "percenture", "percentaging", "percentale", "CENTages", "capaging", "percentages", "capage", "Percentale"]}}
{"id1": "1371265", "id2": "20210699", "code1": "    public void update(String channelPath, String dataField, String fatherDocId) {\n        String sqlInitial = \"select uri from t_ip_doc_res where doc_id = '\" + fatherDocId + \"' and type=\" + \" '\" + ces.platform.infoplat.core.DocResource.DOC_MAGAZINE_TYPE + \"' \";\n        String sqlsortURL = \"update t_ip_doc_res set uri = ? where doc_id = '\" + fatherDocId + \"' \" + \" and type = '\" + ces.platform.infoplat.core.DocResource.DOC_MAGAZINE_TYPE + \"' \";\n        Connection conn = null;\n        ResultSet rs = null;\n        PreparedStatement ps = null;\n        try {\n            dbo = (ERDBOperation) createDBOperation();\n            String url = \"\";\n            boolean flag = true;\n            StringTokenizer st = null;\n            conn = dbo.getConnection();\n            conn.setAutoCommit(false);\n            ps = conn.prepareStatement(sqlInitial);\n            rs = ps.executeQuery();\n            if (rs.next()) url = rs.getString(1);\n            if (!url.equals(\"\")) {\n                st = new StringTokenizer(url, \",\");\n                String sortDocId = \"\";\n                while (st.hasMoreTokens()) {\n                    if (flag) {\n                        sortDocId = \"'\" + st.nextToken() + \"'\";\n                        flag = false;\n                    } else {\n                        sortDocId = sortDocId + \",\" + \"'\" + st.nextToken() + \"'\";\n                    }\n                }\n                String sqlsort = \"select id from t_ip_doc where id in (\" + sortDocId + \") order by \" + dataField;\n                ps = conn.prepareStatement(sqlsort);\n                rs = ps.executeQuery();\n                String sortURL = \"\";\n                boolean sortflag = true;\n                while (rs.next()) {\n                    if (sortflag) {\n                        sortURL = rs.getString(1);\n                        sortflag = false;\n                    } else {\n                        sortURL = sortURL + \",\" + rs.getString(1);\n                    }\n                }\n                ps = conn.prepareStatement(sqlsortURL);\n                ps.setString(1, sortURL);\n                ps.executeUpdate();\n            }\n            conn.commit();\n        } catch (Exception e) {\n            e.printStackTrace();\n            try {\n                conn.rollback();\n            } catch (SQLException e1) {\n                e1.printStackTrace();\n            }\n        } finally {\n            close(rs, null, ps, conn, dbo);\n        }\n    }\n", "code2": "    public List<RTTicket> getTicketsForQueue(final String queueName, long limit) {\n        getSession();\n        final List<NameValuePair> params = new ArrayList<NameValuePair>();\n        params.add(new BasicNameValuePair(\"query\", \"Queue='\" + queueName + \"' AND Status='open'\"));\n        params.add(new BasicNameValuePair(\"format\", \"i\"));\n        params.add(new BasicNameValuePair(\"orderby\", \"-id\"));\n        final HttpGet get = new HttpGet(m_baseURL + \"/REST/1.0/search/ticket?\" + URLEncodedUtils.format(params, \"UTF-8\"));\n        final List<RTTicket> tickets = new ArrayList<RTTicket>();\n        final List<Long> ticketIds = new ArrayList<Long>();\n        try {\n            final HttpResponse response = getClient().execute(get);\n            int responseCode = response.getStatusLine().getStatusCode();\n            if (responseCode != HttpStatus.SC_OK) {\n                throw new RequestTrackerException(\"Received a non-200 response code from the server: \" + responseCode);\n            } else {\n                InputStreamReader isr = null;\n                BufferedReader br = null;\n                try {\n                    if (response.getEntity() == null) return null;\n                    isr = new InputStreamReader(response.getEntity().getContent());\n                    br = new BufferedReader(isr);\n                    String line = null;\n                    do {\n                        line = br.readLine();\n                        if (line != null) {\n                            if (line.contains(\"does not exist.\")) {\n                                return null;\n                            }\n                            if (line.startsWith(\"ticket/\")) {\n                                ticketIds.add(Long.parseLong(line.replace(\"ticket/\", \"\")));\n                            }\n                        }\n                    } while (line != null);\n                } catch (final Exception e) {\n                    throw new RequestTrackerException(\"Unable to read ticket IDs from query.\", e);\n                } finally {\n                    IOUtils.closeQuietly(br);\n                    IOUtils.closeQuietly(isr);\n                }\n            }\n        } catch (final Exception e) {\n            LogUtils.errorf(this, e, \"An exception occurred while getting tickets for queue \" + queueName);\n            return null;\n        }\n        for (final Long id : ticketIds) {\n            try {\n                tickets.add(getTicket(id, false));\n            } catch (final RequestTrackerException e) {\n                LogUtils.warnf(this, e, \"Unable to retrieve ticket.\");\n            }\n        }\n        return tickets;\n    }\n", "label": 0, "substitutes": {"update": ["edit", "process", "insert", "find", "select", "match", "updated", "UPDATE", "create", "set", "feed", "write", "replace", "load", "join", "touch", "up", "upload", "query", "add", "row", "save", "apply", "Update", "index", "delete", "move"], "channelPath": ["databaseRef", "channelRef", "entrypath", "entryPath", " channelRef", "databasePath", "entryRef", "channelDir", " channelDir", "databaseDir", " channelpath", "channelpath", "entryDir", "databasepath"], "dataField": ["datafield", "dataComponent", "formatTerm", "formatField", "DATAField", "formatFIELD", "dataFIELD", " dataMethod", " dataPath", "DataMethod", "Datafield", "dataPath", " dataComponent", "DATAPath", "contentMethod", "formatPath", "DataField", "DataComponent", " dataFIELD", "contentComponent", "DATAFIELD", "dataMethod", "contentfield", "dataTerm", "contentField", " dataTerm", "DATATerm", " datafield"], "fatherDocId": ["fatherDocumentById", "fatherdocid", " fatherDocumentById", "fatherDocumentid", "fatherDocumentPath", "motherdocById", "fatherPostID", "fatherdocById", "fatherFilePath", "fatherDocumentInfo", "motherdocInfo", "fatherDocID", "motherdocPath", "motherdocId", "fatherFileInfo", " fatherDocid", "motherDocPath", "fatherPostId", "fatherdocId", "fatherDocumentID", "fatherDocInfo", "fatherPostById", "motherDocId", "fatherdocID", "motherDocInfo", "fatherFileId", " fatherDocumentId", " fatherDocumentid", "fatherFileById", " fatherDocById", "fatherDocById", "motherDocById", " fatherDocID", "fatherDocPath", "fatherdocInfo", "fatherDocumentId", "fatherDocid", " fatherDocumentID", "fatherdocPath"], "sqlInitial": ["sqlinitial", "SQLInit", "sqlInit", "qlinitial", " sqlinitial", "qlInitial", " sqlInit", "SQLInitial", "SQLinitial", "qlInit"], "sqlsortURL": ["sqLSortURL", "sqlssortURL", "sqlsorterUR", "sqLSsortField", "sqlsorterURL", "sqlsaltUR", "sqlsaltUrl", "sqLSsortUR", "sqLSortSSL", "sqlsorterField", "sqlsordUR", "sqlsaltSSL", "sqLSortRL", "sqlsorterRL", "sqLSsortUrl", "sqlssortRL", "sqlsortUR", "sqlsourceUR", "sqlssortSSL", "sqlsordURL", "sqlsortSSL", "sqlssortUR", "sqLSsortRL", "sqLSortUrl", "sqlssortUrl", "sqlsortUrl", "sqLSsortSSL", "sqlsourceRL", "sqlsortRL", "sqlsaltURL", "sqLSortField", "sqlsourceURL", "sqlssortField", "sqLSsortURL", "sqlsordUrl", "sqlsourceField", "sqlsordSSL", "sqlsortField", "sqLSortUR"], "conn": ["canon", " con", "rc", "nt", "ctx", "con", "res", "pas", "oss", "comm", "cn", "cb", "sp", "js", "enc", "obj", "yn", "cur", "client", "https", "sys", "lang", "gate", "dn", "conv", "ann", "ns", "connection", "cons", "ca", "c", "addr", "open", "pkg", "pg", "cert", "ctr", "resp", "db", "close", "rel", "conf", "org", "adj", "ct", "cp", " Conn", "gc", "act", "Conn", " cx", "Connection", "ec", "apt", "ds", "wn", "pen", "ch", "cmd", "priv", "cfg", "connect", "mn", "nc", "n", "jp", "socket", "wp", "exec", "pool", "p", "cc"], "rs": ["mr", "rows", "rg", "ins", "qs", "lines", "irms", "sr", "aps", "acks", "fps", "ats", "ris", "rl", "sels", "ds", "ims", "ers", "ars", "vers", "ras", "RS", "abs", "times", "rc", "rt", "res", "pas", "asts", "bs", "ares", "hs", "icks", "wcs", "ctr", "caps", "vs", "vr", "rus", "rings", "ues", "xs", "ows", "rss", "usr", "rys", "ubs", "arts", "Rs", "ros", "ls", "ts", "ires", "rx", "ems", "s", "sts", "rates", "cs", "amps", "hr", "js", "fs", "stats", "oms", "rd", "its", "rr", "otes", "ys", "pers", "r", "cases", "ks", "arms", "ears"], "ps": ["amps", "pa", "pb", "ups", "pd", "PS", "tp", "ress", "pas", "ms", "gres", "sp", "params", "ins", "pse", "js", "Ps", "bps", "pp", "ws", "fs", "fp", "bs", "ls", "hs", "ns", "pl", "pins", "mp", "stats", "pg", "ts", "ping", "aps", "its", "ptr", "ips", "fps", "pc", "pt", "pps", "ats", "ys", "eps", "ds", "ops", "pots", "ons", "plays", "ims", "pres", "pers", "gs", "s", "ports", "als", "jp", "vs", "wp", "posts", "as", "pr", "p", "ies", "cs"], "dbo": ["Dbo", "jba", "cba", "doo", "DBO", "cBO", "jbo", " doo", "dbbo", "cbo", "Doo", "dboo", " dba", "jBO", "dbBO", " dBO", "dBO", "dba"], "url": ["browser", "hl", "gl", "json", "ref", "dl", "www", "https", "ls", "web", "ll", "link", "log", "sl", "impl", "lr", "rel", "xml", "ur", "org", "mount", "uri", "URL", "str", "rl", "external", "l", "nl", "ul", "len", "path", "mail", "norm", "r", "ssl", "href", "domain", "full", "n", "http", "location", "string", "html", "el", "ret", "server", "source", "loc", "Url", "id", "print", "host", "abs"], "st": ["ut", " sto", " sl", "nt", "ss", "bt", "sb", "sm", "step", "ist", " et", "ost", "rt", "sp", "rand", "et", "stop", "mt", "se", " std", " pat", "lt", "kt", "irst", "est", "fr", "t", "tt", "ST", " subst", "sl", "stable", "rest", "ts", " ut", " ty", "stack", "ct", "ste", "pt", "str", "St", " sp", " est", "std", "it", "stat", "sw", " ts", " St", "s", "sn", "ust", "stri", " superst", "utt", " mt", "r", "sty", "sta", "sts", " ST", "start", "ast", " ss", " rest", "ft", "nd", " str"], "sortDocId": ["submitDOCMid", "ortDocumentId", "orderDocId", "submitDocID", "sortWinMid", "sortDocOrig", "sortDocumentid", "ortDocId", "sortFileId", "sortDOCID", "sortdocById", "sortWinById", "sortDocumentOrig", "sortDocName", "sortLocId", "orderDocById", "sortFileID", "ortdocById", "sortdocId", "ortDocumentById", "sortDocumentEnd", "sortDirById", "sortFileById", "sortLocById", "submitDOCID", "orderDocName", "sortDirId", "sortdocName", "sortDocumentID", "orderDocID", " sortDocid", "orderdocId", "ortdocOrig", "sortDOCById", "submitDocId", "sortDocEnd", "sortdocid", "submitDOCById", "orderdocName", "sortdocEnd", "ortdocId", "submitDOCId", "sortFileName", "orderdocID", "ortDocumentID", " sortDocById", " sortDocumentID", "sortDocumentId", "sortDOCEnd", "sortFileMid", " sortDocID", " sortDocumentId", "sortWinID", "ortDocumentEnd", "sortFileid", "ortDocID", "submitDocById", "sortDOCMid", "submitDocMid", "orderdocById", "sortDirID", "sortLocID", "sortDocById", "sortDocMid", " sortDocumentById", "sortDocid", "sortDirName", "ortDocOrig", "sortDOCId", "sortWinId", "sortdocID", "sortLocOrig", "ortdocID", "ortDocById", "sortDocumentById", "ortDocEnd", "sortDocID", "sortdocOrig", " sortDocumentid"], "flag": ["event", "f", "cloud", "mask", "image", "dirty", "flags", "sync", "util", "fail", "sp", "func", "gd", "status", "tag", "set", "conv", "flat", "limit", "char", "debug", "store", "log", "bag", "fd", "used", "lv", "sun", "hold", "band", "list", "important", "cond", "stage", "cmd", "FLAG", "nl", "pic", "bool", "ground", "continue", "ind", "lag", "ret", "count", "Flag", "id", "bug", "ld", "compl", "lead", "needed", "fl"], "sqlsort": ["sqlessort", "qlesorter", "qlsorting", "sqlssort", "sqLSort", "sqcsort", "sqLSsort", "qlsorter", "sqcsorter", "qlsort", "sqllsort", "qlessort", "sqLSorting", "sqlsorting", "sqlsorter", "sqlesorter", "sqlesort", "sqLSorted", "qlesort", "sqlesorting", "sqllorted", "qlesorted", "sqllort", "sqLSorter", "qlsorted", "sqlesorted", "sqcsorting", "qlssort", "sqlsorted", "qlesorting", "sqllorter", "sqcssort"], "sortURL": ["orderURI", "searchURI", "SortBL", "ortUrl", "saveURL", "saveUID", "ortURL", "searchOUT", " sortURI", "scaleURL", "ortUR", "orderURL", "sortOUT", "ortBY", " sortOUT", " sortBY", "orderUR", "scaleBY", "ortBL", "saveUrl", "searchUrl", "sortUID", " sortBL", "scaleURI", "sortUR", "searchURL", " sortUrl", " sortUR", "SortUR", "ortUID", "ortURI", "orderUrl", "orderBL", "sortBL", "sortUrl", "sortBY", "saveURI", "saveOUT", "SortUrl", "SortURL", "sortURI", "orderUID", "scaleUR"], "sortflag": [" sortFlag", "filterflag", "ortfield", " sortbug", "ortbutton", "Sorturl", "sortflags", "sortFlag", "transformstatus", "transformwarning", "ortbug", "filterwarning", "sortwarning", "sortfield", "ortFlag", "transformflags", "filterbutton", "filterflags", "Sortfield", "sorturl", "orturl", "ortflag", "transformflag", "sortstatus", " sorturl", "ortflags", "sortbutton", "filterstatus", "sortbug", "filterbug", "ortstatus", " sortbutton", "Sortflag", "SortFlag", "ortwarning", "filterfield", " sortfield"]}}
{"id1": "21363911", "id2": "9996334", "code1": "    public void testTransactions() throws Exception {\n        con = TestUtil.openDB();\n        Statement st;\n        ResultSet rs;\n        con.setAutoCommit(false);\n        assertTrue(!con.getAutoCommit());\n        con.setAutoCommit(true);\n        assertTrue(con.getAutoCommit());\n        st = con.createStatement();\n        st.executeUpdate(\"insert into test_a (imagename,image,id) values ('comttest',1234,5678)\");\n        con.setAutoCommit(false);\n        st.executeUpdate(\"update test_a set image=9876 where id=5678\");\n        con.commit();\n        rs = st.executeQuery(\"select image from test_a where id=5678\");\n        assertTrue(rs.next());\n        assertEquals(9876, rs.getInt(1));\n        rs.close();\n        st.executeUpdate(\"update test_a set image=1111 where id=5678\");\n        con.rollback();\n        rs = st.executeQuery(\"select image from test_a where id=5678\");\n        assertTrue(rs.next());\n        assertEquals(9876, rs.getInt(1));\n        rs.close();\n        TestUtil.closeDB(con);\n    }\n", "code2": "    public String generateToken(String code) {\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"SHA1\");\n            md.update(code.getBytes());\n            byte[] bytes = md.digest();\n            return toHex(bytes);\n        } catch (NoSuchAlgorithmException e) {\n            throw new RuntimeException(\"SHA1 missing\");\n        }\n    }\n", "label": 0, "substitutes": {"testTransactions": ["testtransactions", " testtransactions", "testTransacts", " testtransaction", " testtransitions", " testTransaction", "testTransitions", "testtransitions", "testTactions", "testTransaction", "testTaction", " testTransacts", "testTitions", "testtransaction", " testtransacts", "testtransacts", " testTransitions", "testTacts"], "con": ["cv", "ctx", "enc", "sur", "ln", "bc", "dn", "gate", "cons", "connection", "c", "ic", "db", "re", "un", "conf", "xc", "gc", "pt", "cm", "ens", "cal", "ctrl", "tc", "config", "fn", "rc", "en", "win", "dial", "res", "util", "cont", "bo", "on", "conv", "pl", "fc", "cur", "ran", "cache", "act", "pc", "coll", "ch", "sc", "conn", "connect", "nc", "bn", "anc", "cc", "cn", "don", "open", "cp", "ain", "cf", "gen", "fl", "co", "console", "client", "po", "CON", "go", "com", "ct", "ac", "pen", "ren", "mc", "rec", "can", "Con"], "st": ["ut", "co", "nt", "bt", "sb", "step", "ist", "ost", "rt", "put", "stre", "sp", "et", "bo", "mt", "cr", "stan", "stop", "ln", "h", "fr", "obj", "est", "t", "tt", "ST", "rest", "sl", "th", "stra", "ts", "must", "ct", "ste", "pt", "str", "St", "statement", "nd", "std", "const", "l", "art", "it", "stat", "sol", "sc", "sw", "wt", "stage", "s", "sn", "ust", " superst", "sty", "sta", "sts", "start", "ld", "ast", "so", "ft", "inst", "irst", "sth", "cl"], "rs": ["mr", "rows", "ins", "ri", "qs", "ns", "irms", "ps", "sr", "rel", "re", "dds", "aps", "acks", "ats", "rl", "ris", "ds", "ims", "pres", "ars", "vers", "ras", "RS", "abs", "times", "rc", "ics", "ss", "ress", "rt", "res", "ws", "bs", "icks", "hs", "pc", "gs", "vs", "vr", "rus", "rings", "ues", "xs", "ows", "rss", "usr", "rys", "ges", "els", "ubs", "arts", "Rs", "ros", "sys", "ls", "ts", "ags", "ires", "rx", "ems", "s", "sts", "rates", "cs", "hr", "ms", "js", "stats", "dr", "rm", "rd", "its", "rr", "ys", "rets", "rots", "r", "cases", "ks", "arms"]}}
{"id1": "10361370", "id2": "2668853", "code1": "    public static byte[] hash(final byte[] saltBefore, final String content, final byte[] saltAfter, final int repeatedHashingCount) throws NoSuchAlgorithmException, UnsupportedEncodingException {\n        if (content == null) return null;\n        final MessageDigest digest = MessageDigest.getInstance(DIGEST);\n        if (digestLength == -1) digestLength = digest.getDigestLength();\n        for (int i = 0; i < repeatedHashingCount; i++) {\n            if (i > 0) digest.update(digest.digest());\n            digest.update(saltBefore);\n            digest.update(content.getBytes(WebCastellumFilter.DEFAULT_CHARACTER_ENCODING));\n            digest.update(saltAfter);\n        }\n        return digest.digest();\n    }\n", "code2": "    public static boolean decodeFileToFile(final String infile, final String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.DECODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            final byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (final java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (final Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (final Exception exc) {\n            }\n        }\n        return success;\n    }\n", "label": 0, "substitutes": {"hash": ["ashes", "handle", "ash", "Hash", "match", "test", "h", "sum", "tag", "profile", "code", "attribute", "print", "message", "array", "sign", "filter", "key", "html", "password", "version", "check", "index", "update", "header", "crypt", "render"], "saltBefore": [" sALTBefore", "sALTAfter", "SALTPrevious", "SaltAfter", " sALTStart", "saveBefore", "SALTBefore", "sadeAfter", "sALTPrevious", "sALTBefore", "sadeBefore", "SaltPrevious", "sashAfter", " sALTAfter", "saltPrevious", "sashBefore", "SaltBefore", "saltStart", "sALTStart", " saltStart", "SALTAfter", "sadeStart", "savePrevious", "saveAfter", "sadePrevious", "sashStart"], "content": ["txt", "image", "value", "text", "json", "subject", "output", "time", "cont", "comment", "word", "description", "sequence", "raw", "reason", "code", "c", "document", "current", "message", "xml", "format", "url", "media", "example", "str", "Content", "input", "initial", "entity", "expression", "object", "path", "present", "null", "record", "any", "html", "config", "string", "file", "source", "password", "body", "translation", "data", "license", "title"], "saltAfter": ["SALTResult", "valtafter", "soltAfter", "sintafter", "vintBody", "saveafter", "sALTResult", "sALTAfter", "SaltAfter", "saltPost", "valtAfter", "sALTBody", "saveBefore", "SALTBefore", "vintAfter", "soltResult", "sadeAfter", "vintafter", "SaltResult", "SaltPost", "sintBefore", "sALTBefore", "sintBody", "sadeBefore", "valtBefore", "vintBefore", "saveBody", "sALTafter", "sALTPost", "sadePost", "SaltBefore", "sintAfter", "soltPost", "SALTAfter", "soltBefore", "SALTPost", "saltBody", "sadeResult", "saveAfter", "saltafter", "valtBody", "saltResult"], "repeatedHashingCount": ["repeatedHashesLength", "repeatedHASHCount", "repeatedHASHcount", "repeatedRashCC", "repeatedHashescount", "repeatedHASHLength", "repeatedRashCode", "repeatedHashingCC", "repeatedHashesCounter", "repeatedRashingCC", "repeatedHashingLength", "repeatedHashesCode", "repeatedHashCount", "repeatedHachingCount", "repeatedRashesLength", "repeatedHashcount", "repeatedRashingCounter", "repeatedHashingcount", "repeatedHashLength", "repeatedHashingCounter", "repeatedHASHCounter", "repeatedRashLength", "repeatedHashingCode", "repeatedRashingCount", "repeatedHashCounter", "repeatedRashingcount", "repeatedRashescount", "repeatedHashesCount", "repeatedHashesCC", "repeatedRashesCount", "repeatedRashCount", "repeatedHashCC", "repeatedHachingCC", "repeatedRashesCounter", "repeatedHachingCode", "repeatedRashingCode", "repeatedHashCode", "repeatedRashingLength", "repeatedHachingLength"], "digest": ["fingerest", " digse", "comphash", "digist", "digute", "Digute", "extested", "hashEST", "dfested", "fifency", "commity", "digert", " dighest", "printhest", "debugEST", "algester", "fifitude", "digEST", " digert", "dighash", "descse", "extester", "Digist", "Digested", "hashhash", "commested", "fifest", "mdester", "algest", "argEST", "dfester", "designested", "dfesting", "dest", "digum", " Digest", "diagnests", "Digester", " Digested", "designest", "Digests", "debugency", "fingerEST", "dfest", " digist", " digester", "commse", "descest", "fingeresting", " digitude", "descity", " digency", "hashute", "argest", "DigEST", "Dighash", "extest", "debugest", "designester", "compEST", "designesting", " digum", "printEST", "compute", "diagnum", "argester", "Digum", " digests", "printest", "dert", "extse", "commest", "hashest", "mdse", "mdested", "diagnist", "digester", " digested", "debugitude", "dested", "descested", "printesting", "fingerhest", "digests", "digse", "compest", "algEST", " digity", " digesting", "diagnest", "dighest", "argested", "digesting", "Digse", "mdest", "digitude", " Digester", "digency", "fifEST", " digEST", "dse", "digested", "algested", "digity", " Digert", "dester", "Digest"], "digestLength": [" digesterType", "descesterOffset", "digesterOffset", "digestlength", "digesterLength", " digestData", "digesterLen", " digestType", "digesterlength", "digseLength", "digistData", "digestType", " digesterLen", "digestLen", "digesterType", "descestLen", "descesterLength", "digistType", "digistLength", "descestOffset", "digestOffset", "digesterData", "digestData", "digestedOffset", "descestLength", "digestedLen", "digselength", "digseOffset", "descesterlength", "digseLen", "digestedLength", "digistLen", "digestedType", " digesterData", "digestedlength", "digestedData", " digesterLength", " digestLen", "descesterLen", "descestlength"], "i": ["mi", "u", "ini", "ms", "j", "y", "ski", "I", "z", "qi", "di", "im", "ei", "m", "iq", "client", "init", "in", "ti", "iu", "me", "x", "q", "err", "bi", "cli", "ic", "multi", "ci", "ai", "sim", "gi", "ui", "v", "uri", "pi", "ix", "iter", "it", "uu", "sql", "li", "my", "xi", "si", "batch", "ind", "ip", "n", "gu", "is", "ii", "index", "mill", "print", "phi", "ex"]}}
{"id1": "18370075", "id2": "22338097", "code1": "    public static byte[] createPasswordDigest(String password, byte[] salt) throws Exception {\n        MessageDigest md = MessageDigest.getInstance(\"MD5\");\n        md.update(salt);\n        md.update(password.getBytes(\"UTF8\"));\n        byte[] digest = md.digest();\n        return digest;\n    }\n", "code2": "    private final String createMD5(String pwd) throws Exception {\n        MessageDigest md = (MessageDigest) MessageDigest.getInstance(\"MD5\").clone();\n        md.update(pwd.getBytes(\"UTF-8\"));\n        byte[] pd = md.digest();\n        StringBuffer app = new StringBuffer();\n        for (int i = 0; i < pd.length; i++) {\n            String s2 = Integer.toHexString(pd[i] & 0xFF);\n            app.append((s2.length() == 1) ? \"0\" + s2 : s2);\n        }\n        return app.toString();\n    }\n", "label": 1, "substitutes": {"createPasswordDigest": ["createPasswordDigester", "createPasswordDester", "createPassworddigests", "createPasswordDigum", "createPassworddigum", "createPasswordDests", "createPassworddigester", "createPassworddigest", "createPasswordDest", "createPasswordDigests", "createPasswordDum"], "password": ["phrase", "response", "address", "value", "reset", "entry", "email", "hello", "word", "description", "secret", "shadow", "command", "attribute", "Password", "message", "wd", "words", "name", "token", "hash", "login", "auth", "present", "sword", "database", "pattern", "padding", "key", "string", "user", "username", "data", "session", "pass"], "salt": ["talt", "tol", "sesig", "Save", "Salt", "taint", "pol", "Sol", "Saint", "palt", "SALT", "sesalt", "sig", " sig", "sesave", "sesALT", "sol", "paint", " save", " sALT", "sALT", "tALT", "saint", "pALT", "save", "Sig"], "md": ["nt", "sm", "pd", "ms", "and", "od", "di", "d", "der", "strong", "mt", "js", "amd", "m", "mod", "mg", "red", "mp", "dr", "rm", "det", "mode", "dm", "sd", "def", "ct", "td", "nd", "dd", "cmd", "mand", "metadata", "mb", "cd", "hd", "MD", "ind", "add", "ad", "mn", "desc", "mm", "mc", "pm", "mk", "ld", "sam", "pdf", "bd", "df"], "digest": ["mdester", "designester", "degested", "designested", "digist", "designesting", "digute", "Digute", "Digidate", " digum", "degester", "mdist", "digidate", "digum", "degesting", "designest", "mdesting", "Digum", "mdEST", "digesting", "signute", "mdum", "digEST", "mdest", "signum", " digidate", "signidate", " digist", "Digist", "mdested", " digute", " digEST", "digested", "digester", "signest", "DigEST", "Digest", "degest"]}}
{"id1": "8815137", "id2": "19322941", "code1": "    public void copyToDir(File dir) {\n        if (!dir.exists()) {\n            dir.mkdirs();\n        } else if (this.file.getParentFile() != null && this.file.getParentFile().equals(dir)) {\n            return;\n        }\n        File file = getEstimatedFileName(dir);\n        try {\n            file.createNewFile();\n            FileOutputStream fileOutputStream = new FileOutputStream(file);\n            FileInputStream fileInputStream = new FileInputStream(this.file);\n            int read = 0;\n            byte[] buffer = new byte[1024];\n            while (read != -1) {\n                fileOutputStream.write(buffer, 0, read);\n                read = fileInputStream.read(buffer);\n            }\n            fileInputStream.close();\n            fileOutputStream.close();\n            this.file = file;\n        } catch (IOException e) {\n            Logger.log(e);\n        }\n    }\n", "code2": "    @Test\n    public void test_lookupResourceType_FullSearch_TwoWordsInMiddle() throws Exception {\n        URL url = new URL(baseUrl + \"/lookupResourceType/armor+plates\");\n        HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n        connection.setRequestMethod(\"GET\");\n        connection.setRequestProperty(\"Accept\", \"application/json\");\n        assertThat(connection.getResponseCode(), equalTo(200));\n        assertThat(getResponse(connection), equalTo(\"[{\\\"itemTypeID\\\":25605,\\\"itemCategoryID\\\":4,\\\"name\\\":\\\"Armor Plates\\\",\\\"icon\\\":\\\"69_09\\\"},{\\\"itemTypeID\\\":25624,\\\"itemCategoryID\\\":4,\\\"name\\\":\\\"Intact Armor Plates\\\",\\\"icon\\\":\\\"69_10\\\"}]\"));\n        assertThat(connection.getHeaderField(\"Content-Type\"), equalTo(\"application/json; charset=utf-8\"));\n    }\n", "label": 0, "substitutes": {"copyToDir": ["transferToFile", "copyToPath", "copy2File", "copytoDirectory", "copytoDir", "copyFromPath", "copy2Directory", "copyFromDirectory", "copy2Dir", "transferToDir", "copyFromDir", "transferToDirectory", "copytoFile", "transfer2Path", "copytoPath", "transfer2File", "transferToPath", "copy2Path", "transfer2Dir", "copyFromFile", "copyToDirectory", "copyToFile", "transfer2Directory"], "dir": ["rec", "window", "div", "tr", "vol", "res", "d", "cont", "disk", "doc", "tmp", "init", "module", "base", "directory", "dis", "spec", "mod", "del", "md", "pkg", "old", "fd", "cur", "src", "dr", "db", "re", "wd", "rel", "det", "dm", "def", "ext", "req", "name", "lib", "out", "pos", "ds", "dd", "parent", "Dir", "ir", "path", "null", "DIR", "full", "desc", "local", "manager", "mk", "de", "dist", "fin", "folder", "loc", "root", "id", "data", "draft"], "file": ["rule", "play", "value", "output", "File", "FILE", "h", "page", "port", "base", "label", "to", "db", "filename", "state", "get", "out", "issue", "form", "model", "el", "domain", "info", "core", "io", "msg", "fn", "type", "f", "all", "handle", "lock", "resource", "foo", "force", "link", "log", "used", "ile", "cache", "name", "tree", "controller", "change", "line", "local", "http", "job", "report", "entry", "comment", "disk", "create", "table", "module", "limit", "open", "url", "le", "parent", "path", "field", "unit", "image", "task", "fp", "status", "init", "message", "current", "result", "format", "entity", "this", "project", "null", "flag", "use", "full", "source", "class", "il", "p", "print", "title"], "fileOutputStream": [" fileOutputstream", "fileSystemStream", " fileWriteSteam", "fileOutputstream", "fileWritestream", "fileControlStream", " fileOutputForm", "FileOutputSocket", "FileInputStream", "fileInputView", "filePutSteam", "fileInputForm", "fileInputSteam", " fileOutputSteam", "FileOutputView", "filePutstream", "fileOutputView", "fileOutputSocket", "FileInputSocket", "fileInputSocket", "fileWriteStream", "filePutStream", "FileInputView", "fileSystemView", "FileOutputStream", "fileLogSteam", "fileOutputSteam", "fileControlView", "fileInputstream", "fileOutputForm", "FileInputForm", " fileWritestream", "FileOutputSteam", "fileWriteSteam", "fileLogForm", "fileWriteForm", "filePutForm", " fileWriteForm", "FileInputSteam", "fileLogStream", "FileOutputForm", " fileWriteStream", "fileSystemSocket", "fileSystemSteam", "fileControlSocket", "fileControlSteam"], "fileInputStream": ["fileOutputSource", "fileInsertStream", "fileOutputstream", "fileinputRead", "fileinputSource", "fileInSteam", "fileInputList", "fileInputStreamer", "FileOutputRead", " fileInputController", "fileInsertList", "FILEOutputStream", "FileInputStream", "fileInputSteam", "fileInController", " fileOutputSteam", "fileInterstream", "fileOutputThread", " fileOutputSource", " fileOutputController", "FileInputList", "fileInputController", "fileInSource", " fileInputSteam", "fileInputRead", "fileInStream", "FileOutputStream", "fileinputList", "fileOutputStreamer", "fileinputController", "fileOutputController", "fileOutputSteam", "FILEInputStream", "fileOutputList", "FILEOutputThread", "fileInterStream", "fileInputstream", "FileOutputList", "fileInputSource", "fileInterThread", "fileinputSteam", " fileInputSource", "FileInputRead", "FILEInputstream", "fileInsertRead", "FileOutputSteam", "FILEOutputStreamer", "fileInsertSteam", "fileInputThread", "FILEOutputstream", "FILEInputThread", "fileinputStream", "FileInputSteam", "FILEInputStreamer", "fileOutputRead", "fileInterStreamer"], "read": ["report", "each", "find", "shift", " write", "reader", "wait", "raw", "stream", "set", "run", "x", "in", "write", "open", "readable", "load", "have", "shape", "reads", "seek", "hold", "close", "i", "req", "skip", "seen", "get", "trust", "ask", "input", "need", "READ", "last", "offset", "len", "pack", "parse", "length", "height", "Read", "ind", "add", "num", "r", "count", "n", "ready", "ok", "with", "start", "tell", "size", "send", "reading", "check", "index", "print", "end", "push"], "buffer": ["event", "phrase", "buf", "window", "block", "buff", "text", "sample", "capacity", "frame", "word", "sequence", "page", "table", "reason", "stream", "append", "template", "chain", "char", "command", "attribute", "document", "message", "available", "stack", "result", "cache", "variable", "Buffer", "initial", "iter", "history", "binary", "batch", "filter", "bar", "row", "button", "memory", "body", "print", "header"]}}
{"id1": "22993368", "id2": "22135199", "code1": "    public static boolean decodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.DECODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "code2": "    public void testCodingEmptyFile() throws Exception {\n        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n        WritableByteChannel channel = newChannel(baos);\n        HttpParams params = new BasicHttpParams();\n        SessionOutputBuffer outbuf = new SessionOutputBufferImpl(1024, 128, params);\n        HttpTransportMetricsImpl metrics = new HttpTransportMetricsImpl();\n        LengthDelimitedEncoder encoder = new LengthDelimitedEncoder(channel, outbuf, metrics, 16);\n        encoder.write(wrap(\"stuff;\"));\n        File tmpFile = File.createTempFile(\"testFile\", \"txt\");\n        FileOutputStream fout = new FileOutputStream(tmpFile);\n        OutputStreamWriter wrtout = new OutputStreamWriter(fout);\n        wrtout.flush();\n        wrtout.close();\n        FileChannel fchannel = new FileInputStream(tmpFile).getChannel();\n        encoder.transfer(fchannel, 0, 20);\n        encoder.write(wrap(\"more stuff\"));\n        String s = baos.toString(\"US-ASCII\");\n        assertTrue(encoder.isCompleted());\n        assertEquals(\"stuff;more stuff\", s);\n        tmpFile.delete();\n    }\n", "label": 1, "substitutes": {"decodeFileToFile": ["decodeFileTofile", "decodeStringToFile", "decodeFile2File", "decodeString2String", "decodeFileAsfile", "decodeString2Files", "decodeFile2file", "decodeFile2Files", "decodeFileAsFiles", "decodeFileToFiles", "decodeStringTofile", "decodeFileFilefile", "decodeFileAsFile", "decodeFile2String", "decodeFileAsString", "decodeFileFileFile", "decodeString2file", "decodeString2File", "decodeFileFileString", "decodeFileFileFiles", "decodeFileToString", "decodeStringToString", "decodeStringToFiles"], "infile": ["isinname", "infolder", "outfolder", "inputFile", "outbase", "outname", "isinfile", "inputfolder", "outFile", "fromfile", "isinfolder", "fromfilename", "inname", "outfilename", "inbase", "InFile", "inputname", "infilename", "inFile", "isinFile", "inputfile", "frombase", "Inbase", "Infilename", "fromFile", "Infile"], "outfile": ["outFILE", "outname", "indir", "Outdir", "Outfilename", " outname", "outFile", "tofilename", "outdir", "inname", "outfilename", "Outfile", "OutFile", "infilename", "todir", " outFILE", "inFILE", "inFile", "toFile", " outFile", "otFILE", "otFile", "tofile", "otfile", "otname"], "in": ["rin", "en", "inn", "ini", "by", "gin", "con", "IN", "ins", "pin", "im", "ar", "on", "oin", "al", "In", "t", "inner", "inside", "init", "re", "up", "i", "bin", "get", "inc", "input", "amin", "or", "iter", "it", "per", " din", "form", "conn", "ain", "ind", "nin", "info", "din", "inf", "is", "isin", "source", "cin", "id", "from"], "out": ["ion", "co", "en", "nt", "flush", "con", "output", "res", "oss", "cn", "on", "sys", "t", "inner", "net", "write", "print", "b", "to", "end", "opt", "writer", "os", "outer", "it", "OU", "gt", "null", "ou", "at", "aos", "outs", "o", "g", "ex", "auto", "n", "io", "Out", "file", "fn", "OUT", "can", "ne", "ot"], "buffer": ["phrase", "buf", "window", "bone", "block", "buff", "sample", "column", "frame", "comment", "view", "sequence", "append", "table", "pad", "library", "mem", "base", "template", "command", "attribute", "document", "message", "shape", "available", "stack", "number", "cache", "variable", "Buffer", "black", "total", "initial", "note", "history", "paste", "binary", "batch", "bar", "padding", "info", "row", "display", "temp", "button", "password", "memory", "print", "header", "character"], "read": ["first", "each", "text", "find", "select", "shift", "reader", "wait", "allow", "raw", "stream", "set", "run", "before", "range", "write", "open", "push", "readable", "load", "print", "reads", "hold", "seek", "close", "i", "req", "skip", "get", " Read", "give", "input", "need", "iter", "through", "query", "len", "length", "Read", "ind", "add", "connect", "count", "n", "ready", "start", "size", "send", "reading", "check", "index", "READ", "end", "ok"], "success": ["first", "same", "good", "response", "value", " succeed", "ceed", " succ", "cess", "positive", "fail", "city", "release", " successful", "summary", "please", "status", "accept", "Success", "danger", "exist", "ratulations", "done", "ccess", "growth", "scope", "primary", "result", "safe", " okay", "second", "unity", "crit", "condition", "successful", " failure", "sufficient", "error", "valid", "complete", "commit", " succeeds", "snap", "democracy", "continue", "photo", "surv", "successfully", "town", "submit", "support", " successes", "setup", "ok"]}}
{"id1": "17716716", "id2": "19147281", "code1": "    public static String plainToMD(LoggerCollection loggerCol, String input) {\n        byte[] byteHash = null;\n        MessageDigest md = null;\n        StringBuilder md5result = new StringBuilder();\n        try {\n            md = MessageDigest.getInstance(\"MD5\");\n            md.reset();\n            md.update(input.getBytes());\n            byteHash = md.digest();\n            for (int i = 0; i < byteHash.length; i++) {\n                md5result.append(Integer.toHexString(0xFF & byteHash[i]));\n            }\n        } catch (NoSuchAlgorithmException ex) {\n            loggerCol.logException(CLASSDEBUG, \"de.searchworkorange.lib.misc.hash.MD5Hash\", Level.FATAL, ex);\n        }\n        return (md5result.toString());\n    }\n", "code2": "    public boolean actualizarDatosPrevia(int idJugadorDiv, int idRonda, int idPareoRival, int color, int flotante) {\n        int intResult = 0;\n        String sql = \"UPDATE jugadorxdivxronda \" + \" SET idPareoRival = \" + idPareoRival + \" , color = \" + color + \" , flotante = \" + flotante + \" \" + \" WHERE jugadorxDivision_idJugadorxDivision = \" + idJugadorDiv + \" AND ronda_numeroRonda = \" + idRonda;\n        try {\n            connection = conexionBD.getConnection();\n            connection.setAutoCommit(false);\n            ps = connection.prepareStatement(sql);\n            intResult = ps.executeUpdate();\n            connection.commit();\n        } catch (SQLException ex) {\n            ex.printStackTrace();\n            try {\n                connection.rollback();\n            } catch (SQLException exe) {\n                exe.printStackTrace();\n            }\n        } finally {\n            conexionBD.close(ps);\n            conexionBD.close(connection);\n        }\n        return (intResult > 0);\n    }\n", "label": 0, "substitutes": {"plainToMD": [" stringAsDM", " convertTomd", " stringAsMD", " stringFromMC", " stringAsMC", " stringFromDM", " convertToDM", " stringAsmd", " convertAsmd", " convertAsMD", " convertAsMC", " convertAsDM", " convertToMC", " stringFromMD", " stringToMC", " stringToDM", " stringFrommd", " stringToMD", " convertToMD", " stringTomd"], "loggerCol": ["logiderColumn", "badinatorCol", "badinatorColl", "logiderCol", "logggerColl", "logGERCOL", " logggerCOL", " loggerCOL", "badgerCol", "loggeCol", "loginatorCl", "logggerCOL", "loggerCOL", "loggerColumn", "loginatorCol", " loggerColumn", " logggerColumn", "badgerColl", "badgerCOL", "loginatorColl", "loggeCl", "logggerCl", "badgerCl", "loggerColl", "logiderCOL", " logggerCol", "badinatorCOL", "logGERCol", "badinatorCl", "logGERColumn", "logggerCol", "loggeCOL", "loginatorCOL", "loggerCl", "logggerColumn", "loggeColl"], "input": ["active", "image", "value", "text", "subject", "output", "hello", " Input", "request", "raw", "context", "in", "base", "char", "q", "command", "buffer", "document", "Input", "result", "up", "background", "url", "example", "str", "hash", "out", "initial", "it", "this", "form", "pattern", "string", "config", "file", "source", " inputs", "from", "data", "prefix"], "byteHash": ["byteshash", " byteMap", " bytehash", "byteLength", "binaryHas", "ByteHash", "bytesMap", "byteMap", " byteHas", " byteTr", "ueTr", "ByteMap", "ByteTr", "ueHash", "Bytehash", "bytehash", "byteTr", "bytesHash", "binaryhash", "binaryHash", "ueLength", "ByteLength", "ByteHas", " byteLength", "bytesHas", "byteHas", "uehash"], "md": [" Md", " MD", " mc", "sm", "pd", "ms", "od", "ng", "di", "d", "der", "mt", "m", "mo", "doc", "mod", "met", "mg", "red", "mp", "dr", "rm", "det", "dm", "ct", "ded", "sd", "def", "nd", "hash", "cond", "ds", "gm", "comp", "dd", "cmd", "material", "cd", "mb", "hd", "MD", "dig", "add", "ind", "grad", "mn", "mc", "mm", "gr", "pm", "mk", "de", "msg", "ld", "mac", "sam", "med", "bd", "df"], "md5result": ["md2string", " md5Result", "MD5Result", " md8result", "md65Result", "md65proc", "md3Result", "MD5comment", "md3result", "MD2comment", "md3results", "md45comment", "MD5result", "md3proc", "MD2results", "md64comment", "md45results", "md64result", " md5proc", "md45response", "MD5results", " md5message", "md65result", "md2result", "md65message", "MD2Result", "md2results", "md5string", "md7string", "md5results", "MD2result", "md5proc", "MD5string", "md7result", "md3message", "md8proc", "md5Result", "md5response", "md2comment", "MD2string", "md8message", "md3string", "md5comment", "md64results", "md45result", "md8Result", " md8message", " md8Result", "md7Result", "md64response", "md7results", "md2Result", "md2response", "MD2response", " md8proc", "md5message", "md8result", "MD5response"], "i": ["mi", "span", "fi", "u", "j", "z", "us", "y", "I", "ie", "qi", "di", "im", "ei", "m", "init", "x", "ti", "in", "me", "q", "c", "bi", "b", "ic", "cli", "multi", "ci", "ai", "sim", "gi", "ui", "v", "uri", "pi", "l", "ix", "iter", "it", "ji", "li", "\u0438", "ims", "xi", "si", "my", "ind", "o", "ip", "n", "key", "io", "ii", "is", "gu", "index", "id", "a", "phi"]}}
{"id1": "6988216", "id2": "10266116", "code1": "    public void testSimpleQuery() throws Exception {\n        JCRNodeSource dummySource = (JCRNodeSource) resolveSource(BASE_URL + \"users/alexander.klimetschek\");\n        assertNotNull(dummySource);\n        OutputStream os = ((ModifiableSource) dummySource).getOutputStream();\n        assertNotNull(os);\n        String dummyContent = \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?><user><id>alexander</id><teamspace>cyclr</teamspace><teamspace>mindquarryTooLong</teamspace></user>\";\n        os.write(dummyContent.getBytes());\n        os.flush();\n        os.close();\n        JCRNodeSource source = (JCRNodeSource) resolveSource(BASE_URL + \"users/bastian\");\n        assertNotNull(source);\n        os = ((ModifiableSource) source).getOutputStream();\n        assertNotNull(os);\n        String content = \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?><user><id>bastian</id><teamspace>mindquarry</teamspace></user>\";\n        os.write(content.getBytes());\n        os.flush();\n        os.close();\n        QueryResultSource qResult = (QueryResultSource) resolveSource(BASE_URL + \"users?/*[.//user/teamspace='mindquarry']\");\n        assertNotNull(qResult);\n        Collection results = qResult.getChildren();\n        assertEquals(1, results.size());\n        Iterator it = results.iterator();\n        JCRNodeSource rSrc = (JCRNodeSource) it.next();\n        InputStream rSrcIn = rSrc.getInputStream();\n        ByteArrayOutputStream actualOut = new ByteArrayOutputStream();\n        IOUtils.copy(rSrcIn, actualOut);\n        rSrcIn.close();\n        assertEquals(content, actualOut.toString());\n        actualOut.close();\n        rSrc.delete();\n    }\n", "code2": "    public InputStream retrieveStream(String url) {\n        HttpGet getRequest = new HttpGet(url);\n        try {\n            HttpResponse getResponse = getClient().execute(getRequest);\n            final int statusCode = getResponse.getStatusLine().getStatusCode();\n            if (statusCode != HttpStatus.SC_OK) {\n                Log.w(getClass().getSimpleName(), \"Error \" + statusCode + \" for URL \" + url);\n                return null;\n            }\n            HttpEntity getResponseEntity = getResponse.getEntity();\n            return getResponseEntity.getContent();\n        } catch (Exception e) {\n            getRequest.abort();\n            Log.w(getClass().getSimpleName(), \"Error for URL \" + url, e);\n        }\n        return null;\n    }\n", "label": 0, "substitutes": {"testSimpleQuery": [" executeSimpleQuery", " testQueryQuestion", " testSimpleQ", " executeBasicQuestion", " testSimpleContent", " testRawQuestion", " testQueryContent", " testRawQuery", " executeBasicQuery", " testBasicQuery", " executeSimpleQuestion", " testSimpleQuestion", " testBasicQ", " testQueryQ", " executeSimpleContent", " testRawQ", " testQueryQuery", " executeBasicContent", " executeBasicQ", " executeSimpleQ", " testBasicQuestion", " testRawContent", " testBasicContent"], "dummySource": ["datalFile", "udeterminedParent", "daummyResource", "dummiesSource", "duffySourceFile", "duffyInput", "daummySource", " duffyContent", "udummySource", "determinedFile", "dummySourceFile", "datalParent", "determinedContent", "udeterminedSource", "datumSource", "dancyFile", "dancyParent", "dummSource", "daatumStore", "udummyContent", "daatumSource", "dummyParent", "udeterminedFile", " duffySourceFile", "udummyFile", "duffyContent", "dumpSource", "duffySource", "dancySource", "datumResource", "dummiesStore", "datalSource", "daummyStore", "dancyInput", " dummyInput", "determinedParent", "dummContent", " duffyInput", "dummyResource", "daatumResource", "dummiesResource", "dumpResource", "udummyParent", "datalContent", "dancyContent", "udeterminedContent", "dummInput", "dummiesInput", "dummyFile", "dummyInput", "dummSourceFile", "dumpInput", "dancySourceFile", "datumStore", "datumInput", "dummyStore", "dumpStore", "determinedSource", " duffySource", "daummyInput", "daatumInput", " dummySourceFile"], "os": ["ows", "oes", "dos", "Os", "ms", "ost", "om", "cos", "asis", "oss", "mos", "et", "osi", "js", "windows", "oses", "ros", "fs", "sys", "bs", "ants", "oa", "dis", "uts", "los", "ose", "ts", "ui", "ox", "ats", "ols", "pos", "out", "bos", "ops", "ds", "ys", "des", "ens", "or", "ori", "ims", "si", "obs", "s", "conn", "aos", "css", "o", "oS", "ors", "OS", "io", "socket", "is", "ios", "oids", "oos", "es", "ot"], "dummyContent": [" dummyTemplate", "deltaContent", " dummiesContent", "DummyMedia", " dummiesCode", "dumpText", "dummiesCode", "dynamicCode", "dumpingTemplate", "determinedContent", "dummyTemplate", "dummiesContent", "dumpMedia", "deltaText", "dumpInt", "dummiesContents", "dumpingCode", "dynamicContents", "dummiesTemplate", "determinedText", "dumpingContent", "dumpContent", "dummyMedia", "dynamicContent", "deltaInt", "DummyContent", "DumpContent", "dummyContents", "DummyInt", "deltaMedia", " dummyContents", "dummyInt", "dummyCode", " dummiesContents", "DumpInt", "determinedMedia", " dummyCode", "dummyText", "DumpText", "determinedInt", " dummiesTemplate", "dynamicTemplate", "DumpMedia", "dumpingContents", "DummyText"], "source": ["proxy", "series", "ser", "image", "google", "sample", "ie", "sp", "pse", "service", "resource", "se", "sys", "status", "site", "table", "in", "inner", "template", "spec", "store", "scope", "sr", "result", "src", "join", "Source", "ace", "uri", "sf", "SOURCE", "sin", "sql", "search", "seed", "ource", "space", "s", "instance", "use", "relation", "core", "user", "from", "server"], "content": ["license", "txt", "response", "layout", "json", "text", "value", "output", "tx", "cont", "comment", "resource", "application", "description", "summary", "sequence", "article", "status", "title", "quest", "context", "header", "script", "template", "code", "command", "editor", "action", "document", "message", "current", "result", "xml", "ext", "format", "cache", "node", "example", "Content", "section", " contents", "tree", "path", "activity", "key", "html", "config", "body", "version", "data", "expression", "ontent"], "qResult": ["iqReport", "qView", "dqRes", "QRes", "iqResponse", "QResult", "dqresult", "qReport", " qresult", "queryResults", "qresult", " qResponse", "dqView", "Qresult", " qReport", "iqResult", "queryResult", "queryResponse", "queryReport", "iqRes", " qResults", "qRes", "qResults", "queryRes", " qRes", "iqResults", "dqResult", "QView", "qResponse", " qView"], "results": ["terms", "times", "forms", "lections", " Results", "missions", "photos", "ms", "reports", "settings", "res", "assets", "RESULTS", "rows", "versions", "orders", "users", "items", "children", "details", "olds", "tests", "hips", "views", "runs", "result", "ults", "its", "roads", "blocks", "ries", "resources", "thumbnails", "actions", "members", "xes", "events", "chains", "s", "products", "objects", "Contents", "ULTS", "pages", "archives", "relations", "features", "values", "posts", "Results", "ands", "data"], "it": ["MIT", "iz", "pit", "IT", "h", "ite", "op", "et", "m", "mit", "t", "in", "init", "ic", "ci", "lit", "v", "i", "its", "read", "ait", "out", "they", "iter", "stat", "li", "ul", "hit", "st", "at", "rit", "ip", "info", "It", "is", "exec", "he", "id", "p"], "rSrc": ["rSourcesrc", "rSysource", "rSourcerc", "rSysRC", " rSrs", "crDessrc", "crSRC", "rDesrc", " rSource", "rSers", "crDesrc", "rSsrc", "rSecs", "rScs", "rSlrs", "rSource", "rSourceRC", "crDesrs", "rSeRC", "crSrs", "rSlRC", "rSerc", "rSlcs", " rScs", "rDessrc", " rSsrc", "rDesRC", "crSsrc", "rDesrs", "crSrc", "rSlrc", " rSRC", "rSyssrc", "rSourcers", "rSRC", "rSysrc", "crDesRC", "rSrs"], "rSrcIn": ["rSsrcin", "rSrsIN", "rSldOut", "rSldCon", "rSRCIn", "rSrcIN", "rSetrcIn", "rSRCin", "rSsrcIn", "rSetsrcIN", "rSrcOut", "rSldin", "rSetrcOut", "rSetsrcIn", "rSldInput", "rSsrcOut", "rSrcin", "rSetsrcOut", "rSRCCon", "rSncin", "rSncOut", "rSrcInput", "rSldIn", "rSsrcIN", "rSsrcInput", "rSRCIN", "rSrcCon", "rSrsOut", "rSncIn", "rSncCon", "rSetrcin", "rSetsrcin", "rSRCOut", "rSetrcIN", "rSldIN", "rSrsInput", "rSrsIn"], "actualOut": ["finalout", "realCopy", "finalOut", "actualout", "virtualOut", " actualIs", "actualEnd", " actualout", "actualCopy", "ualout", "realOut", "UALOut", "ualBytes", "actuallyOut", " actualIn", "ualEnd", "ualIn", "virtualIn", "actualIs", "UALEnd", " actualBytes", " actualCopy", " actualEnd", "realIn", "actuallyIn", "finalIn", "actuallyIs", "realIs", "ualOut", "actualIn", "actuallyCopy", "actualBytes", "UALIn", "UALBytes"]}}
{"id1": "10451698", "id2": "18433984", "code1": "    private void copy(File source, File destinationDirectory) throws IOException {\n        if (source.isDirectory()) {\n            File newDir = new File(destinationDirectory, source.getName());\n            newDir.mkdir();\n            File[] children = source.listFiles();\n            for (int i = 0; i < children.length; i++) {\n                if (children[i].getName().equals(\".svn\")) {\n                    continue;\n                }\n                copy(children[i], newDir);\n            }\n        } else {\n            File newFile = new File(destinationDirectory, source.getName());\n            if (newFile.exists() && source.lastModified() == newFile.lastModified()) {\n                return;\n            }\n            FileOutputStream output = new FileOutputStream(newFile);\n            FileInputStream input = new FileInputStream(source);\n            byte[] buff = new byte[2048];\n            int read = 0;\n            while ((read = input.read(buff)) > 0) {\n                output.write(buff, 0, read);\n            }\n            output.flush();\n            output.close();\n            input.close();\n        }\n    }\n", "code2": "    protected void doUpload(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        HttpSession reqSession = request.getSession();\n        ArrayList<File> uploadFiles = new ArrayList<File>();\n        LOG.info(\"UploadServlet Upload request received\");\n        if (ServletFileUpload.isMultipartContent(request)) {\n            LOG.debug(\"UploadServlet Received a multipart request.\");\n        } else {\n            LOG.debug(\"UploadServlet Received a non-multipart request.\");\n        }\n        String tempDirName = UUID.randomUUID().toString();\n        File tempUploadDir = new File(adapter.getRootPath() + File.separator + \"temp\" + File.separator + tempDirName);\n        tempUploadDir.getParentFile().mkdir();\n        while (tempUploadDir.exists()) {\n            tempDirName = UUID.randomUUID().toString();\n            tempUploadDir = new File(adapter.getRootPath() + File.separator + \"temp\" + File.separator + tempDirName);\n        }\n        tempUploadDir.mkdir();\n        File attachmentDir = (File) (reqSession.getAttribute(\"up2p:attachdir\"));\n        if (attachmentDir != null) {\n            LOG.info(\"UploadServlet: Copying provided attachment to upload dir from: \" + attachmentDir.getAbsolutePath());\n            tempUploadDir.delete();\n            attachmentDir.renameTo(tempUploadDir);\n            reqSession.removeAttribute(\"up2p:attachdir\");\n        }\n        LOG.info(\"UploadServlet: Using temporary directory: \" + tempUploadDir.getPath());\n        PairList paramMap = null;\n        if (ServletFileUpload.isMultipartContent(request)) {\n            paramMap = getMultipartParameters(request, uploadHandler, LOG, tempUploadDir.getPath());\n            if (paramMap.size() == 0) {\n                LOG.debug(\"UploadServlet Parsed multipart request and \" + \"found no parameters. Parsing as regular\" + \" request instead.\");\n                paramMap = copyParameters(request);\n                LOG.debug(\"UploadServlet Parsed as regular request and found \" + paramMap.size() + \" parameters.\");\n            }\n        } else {\n            paramMap = copyParameters(request);\n        }\n        String communityId = getCurrentCommunityId(request.getSession());\n        String newcommunity = paramMap.getValue(HttpParams.UP2P_COMMUNITY);\n        LOG.debug(\"UploadServlet: Got active community: \" + newcommunity);\n        if (newcommunity != null) {\n            communityId = newcommunity;\n            LOG.debug(\"switching to community\" + communityId);\n        }\n        if (communityId == null || communityId.length() == 0) {\n            LOG.warn(\"UploadServlet Current community ID is missing from\" + \"the user session.\");\n            writeError(request, response, \"The current community is unknown.\" + \" Please select a community before performing \" + \"any actions.\", paramMap);\n            for (File f : tempUploadDir.listFiles()) {\n                f.delete();\n            }\n            tempUploadDir.delete();\n            return;\n        }\n        LOG.info(\"UploadServlet Uploading to community \" + communityId + \".\");\n        uploadFiles.clear();\n        Iterator<String> uploadedFileIter = paramMap.getValues(HttpParams.UP2P_FILENAME);\n        String filename = \"\";\n        try {\n            if (uploadedFileIter.hasNext()) {\n                filename = uploadedFileIter.next();\n            } else {\n                throw new IOException(\"UploadServlet: No up2p:filename parameters were found.\");\n            }\n            if (filename.startsWith(\"file:\")) filename = filename.substring(5);\n            if (filename.length() == 0) {\n                throw new IOException(\"UploadServlet: An empty up2p:filename parameter was submitted.\");\n            }\n            File resourceFile = null;\n            resourceFile = new File(adapter.getStorageDirectory(communityId), filename);\n            File tempResFile = new File(tempUploadDir, filename);\n            if (!tempResFile.exists() && !resourceFile.exists()) {\n                throw new IOException(\"UploadServlet: The uploaded resource could not be found.\");\n            }\n            if ((tempResFile.exists() && resourceFile.exists()) || (tempResFile.exists() && !resourceFile.exists())) {\n                resourceFile = FileUtil.createUniqueFile(resourceFile);\n                LOG.info(\"UploadServlet: Direct upload, copying resource file.\\n\\tOriginal: \" + tempResFile.getPath() + \"\\n\\tNew: \" + resourceFile.getPath());\n                resourceFile.getParentFile().mkdir();\n                FileOutputStream resourceCopyStream = new FileOutputStream(resourceFile);\n                FileUtil.writeFileToStream(resourceCopyStream, tempResFile, true);\n                filename = resourceFile.getName();\n            }\n            LOG.info(\"UploadServlet: resource file name: \" + filename);\n            uploadFiles.add(resourceFile);\n        } catch (IOException e) {\n            LOG.error(\"UploadServlet: \" + e.getMessage());\n            writeError(request, response, e.getMessage(), paramMap);\n            return;\n        }\n        String editResourceId = paramMap.getValue(HttpParams.UP2P_EDIT_RESOURCE);\n        if (editResourceId != null && editResourceId.length() > 0) {\n            LOG.debug(\"UploadServlet: Got edit resource: \" + editResourceId);\n            File editAttach = new File(adapter.getAttachmentStorageDirectory(communityId, editResourceId));\n            if (editAttach.exists() && editAttach.isDirectory()) {\n                LOG.debug(\"UploadServlet: Copying additional attachments from: \" + editAttach.getAbsolutePath());\n                for (File oldFile : editAttach.listFiles()) {\n                    File newFile = new File(tempUploadDir, oldFile.getName());\n                    if (!newFile.exists()) {\n                        LOG.debug(\"UploadServlet: Copying attachment: \" + oldFile.getAbsolutePath() + \" to \" + newFile.getAbsolutePath());\n                        FileOutputStream attachCopyStream = new FileOutputStream(newFile);\n                        FileUtil.writeFileToStream(attachCopyStream, oldFile, true);\n                    } else {\n                        LOG.debug(\"UploadServlet: Attachment \" + newFile.getName() + \" explicitly replaced in new upload.\");\n                    }\n                }\n            }\n        }\n        String batchUploadString = paramMap.getValue(HttpParams.UP2P_BATCH);\n        boolean batchUpload = batchUploadString != null && batchUploadString.length() > 0;\n        if (batchUpload) {\n            LOG.info(\"UploadSerlvet Recieved batch upload request.\");\n            File batchFile = new File(adapter.getStorageDirectory(communityId), uploadFiles.get(0).getName());\n            uploadFiles.clear();\n            LOG.debug(\"UploadServlet resource file stored at: \" + batchFile.getPath());\n            XMLReader reader = TransformerHelper.getXMLReader();\n            reader.setContentHandler(new BatchCopyHandler(communityId, uploadFiles));\n            try {\n                FileInputStream batchInput = new FileInputStream(batchFile);\n                reader.parse(new InputSource(batchInput));\n                batchInput.close();\n            } catch (Exception e) {\n                LOG.error(\"UploadServlet: Error parsing batch upload file.\");\n                LOG.error(\"UploadServlet: \" + e.getMessage());\n                writeError(request, response, \"Uploaded content was not a valid batch resource file.\", paramMap);\n                return;\n            }\n            batchFile.delete();\n            adapter.addNotification(\"Batch file succesfully processed into \" + uploadFiles.size() + \" resources.\");\n        }\n        boolean pushUpload = paramMap.getValue(HttpParams.UP2P_PUSH) != null && paramMap.getValue(HttpParams.UP2P_PUSH).length() > 0;\n        String id = \"\";\n        boolean duplicateResource = false;\n        int uploadCount = 0;\n        for (int i = 0; i < uploadFiles.size(); i++) {\n            LOG.info(\"UploadServlet Publishing resource to WebAdapter: \" + uploadFiles.get(i).getName());\n            try {\n                id = adapter.publish(communityId, new File(uploadFiles.get(i).getName()), tempUploadDir);\n                uploadFiles.remove(i);\n                i--;\n                uploadCount++;\n                LOG.info(\"UploadServlet Resource published with id: \" + id);\n            } catch (IOException e) {\n                LOG.warn(\"UploadServlet IO Error occured in reading the uploaded file: \" + e.getMessage(), e);\n                uploadFilesCleanup(uploadFiles, tempUploadDir);\n                writeError(request, response, \"An error occured in reading the uploaded file: \" + e.getMessage(), paramMap);\n                return;\n            } catch (SAXParseException e) {\n                LOG.warn(\"UploadServlet SAX Parse Error occured in uploaded resource: \" + e.getMessage());\n                String errMsg = \"Invalid XML in the uploaded resource.<br/>\" + e.getMessage() + \"<br/><br/>File location: \" + uploadFiles.get(i).getAbsolutePath() + \"<br/>Line: \" + e.getLineNumber() + \" Column: \" + e.getColumnNumber();\n                uploadFilesCleanup(uploadFiles, tempUploadDir);\n                writeError(request, response, errMsg, paramMap);\n                return;\n            } catch (SAXException e) {\n                LOG.warn(\"UploadServlet Invalid XML in uploaded resource: \" + e.getMessage());\n                String errMsg = \"Invalid XML in uploaded resource<br/><i>\" + e.getMessage() + \"</i><br/>\" + \"File location: \" + uploadFiles.get(i).getAbsolutePath();\n                uploadFilesCleanup(uploadFiles, tempUploadDir);\n                writeError(request, response, errMsg, paramMap);\n                return;\n            } catch (DuplicateResourceException e) {\n                LOG.info(\"UploadServlet Duplicate Resource: \" + e.getResourceId() + \" Community: \" + e.getCommunityId());\n                if (batchUpload) {\n                    if (!duplicateResource) {\n                        adapter.addNotification(\"Warning: Batch upload contained previously published \" + \" resources which have been discarded.\");\n                        duplicateResource = true;\n                    }\n                } else {\n                    uploadFilesCleanup(uploadFiles, tempUploadDir);\n                    String respondWithXml = paramMap.getValue(HttpParams.UP2P_FETCH_XML);\n                    if (respondWithXml != null && respondWithXml.length() > 0) {\n                        writeError(request, response, \"This resource is already shared with resource \" + \" id: \" + e.getResourceId(), paramMap);\n                        return;\n                    }\n                    String redirect = response.encodeURL(\"/overwrite.jsp?up2p:community=\" + e.getCommunityId() + \"&up2p:resource=\" + e.getResourceId());\n                    LOG.info(\"UploadServlet Redirecting to \" + redirect);\n                    RequestDispatcher rd = request.getRequestDispatcher(redirect);\n                    rd.forward(request, response);\n                    return;\n                }\n            } catch (NetworkAdapterException e) {\n                LOG.info(\"UploadServlet Error in the Network Adapter for\" + \" community ID \" + communityId, e);\n                uploadFilesCleanup(uploadFiles, tempUploadDir);\n                writeError(request, response, \"Error in the Network Adapter for this community. <br/>\" + e.getMessage(), paramMap);\n                return;\n            } catch (ResourceNotFoundException e) {\n                LOG.info(\"UploadServlet Error Resource not found \" + e);\n                uploadFilesCleanup(uploadFiles, tempUploadDir);\n                writeError(request, response, \"Error : <br/>\" + e.getMessage(), paramMap);\n                return;\n            }\n        }\n        uploadFilesCleanup(uploadFiles, tempUploadDir);\n        String ajaxRequest = paramMap.getValue(HttpParams.UP2P_XMLHTTP);\n        String respondWithXml = paramMap.getValue(HttpParams.UP2P_FETCH_XML);\n        if (respondWithXml != null && respondWithXml.length() > 0) {\n            response.setContentType(\"text/xml\");\n            PrintWriter out = response.getWriter();\n            out.println(\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\");\n            out.println(\"<upload success=\\\"true\\\" >\");\n            out.println(\"<resid>\" + id + \"</resid>\");\n            out.println(\"</upload>\");\n        } else if (ajaxRequest != null && ajaxRequest.length() > 0) {\n            LOG.debug(\"UploadServlet Recieved xmlHttp request, responding with XML\");\n            response.setContentType(\"text/xml\");\n            PrintWriter out = response.getWriter();\n            out.println(\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\");\n            out.print(\"<resource id=\\\"\" + request.getParameter(HttpParams.UP2P_RESOURCE) + \"\\\" \");\n            if (request.getParameter(HttpParams.UP2P_PEERID) != null) {\n                out.print(\"peerid=\\\"\" + request.getParameter(HttpParams.UP2P_PEERID) + \"\\\" \");\n            }\n            out.println(\"/>\");\n        } else if (batchUpload) {\n            adapter.addNotification(uploadCount + \" resources were succesfully published.\");\n            request.setAttribute(\"up2p.display.mode\", \"view\");\n            String redirect = response.encodeURL(\"/view.jsp?up2p:community=\" + communityId);\n            LOG.info(\"UploadServlet Redirecting to \" + redirect);\n            RequestDispatcher rd = request.getRequestDispatcher(redirect);\n            rd.forward(request, response);\n        } else if (!pushUpload) {\n            request.setAttribute(\"up2p.display.mode\", \"view\");\n            String redirect = response.encodeURL(\"/view.jsp?up2p:resource=\" + id);\n            LOG.info(\"UploadServlet Redirecting to \" + redirect);\n            RequestDispatcher rd = request.getRequestDispatcher(redirect);\n            rd.forward(request, response);\n        }\n        return;\n    }\n", "label": 1, "substitutes": {"copy": ["proxy", "export", "co", "cop", "cat", "sync", "share", "remove", "create", "link", "Copy", "write", "transfer", "slice", "perm", "cp", "gc", "archive", "paste", "continue", "split", "opy", "zip", "Cop", "download", "core", "pixel", "crop", "file", "clip", "clone", "map", "delete", "move"], "source": ["origin", "empty", "style", "image", "subject", "entry", "ie", "sit", "sp", "original", "service", "resource", "se", "details", "force", "create", "raw", "status", "table", "site", "init", "in", "base", "directory", "template", "spec", "store", "ce", "inner", "scope", "secure", "current", "src", "Source", "none", "cache", "name", "get", "target", "SOURCE", "sin", "query", "note", "parent", "sql", "ource", "null", "space", "instance", "use", "local", "remote", "http", "config", "start", "file", "size", "shell", "body", "class", "unit", "from", "index"], "destinationDirectory": ["targetinationDirectory", "identinatorLocation", "destmentDir", "identinationInternal", "destinationsInternal", "destinatorLocation", "destationFolder", "destinationsdirectory", "destinationsLocation", "destarationInternal", "destinationInternal", "destineApplication", "targetinationsdirectory", "destineDirectory", "targetinationsDirectory", "identinatorDirectory", "destinationsFolder", "identinatorInternal", "destarationDirectory", "destinationFolder", "destinationApplication", " destationDirectory", "targetinationdirectory", "identinationLocation", "destinateDirectory", " destinationFolder", "targetinationsDir", "destarationLocation", "destinatorDirectory", "destmentdirectory", "destationdirectory", "destationApplication", "targetinationFolder", " destationApplication", "destinateFolder", "destmentDirectory", " destationdirectory", "destinationsDirectory", "destineFolder", "destinationsDir", "destinationLocation", "destinatorInternal", "destinatedirectory", " destinationdirectory", "identinationDirectory", "targetinationsFolder", "destinedirectory", "destinationdirectory", "targetinationDir", "destinationDir", "destmentFolder", "destationDirectory", "destinateApplication", " destinationApplication", " destationFolder"], "newDir": ["newDirectory", "newdir", "NewDir", "newFolder", " newdir", "Newdir", "nextDir", " newDirectory", "newsFile", "NewFolder", "nextFile", "newRel", "newsDirectory", "nextRel", "newsFolder", "NewDirectory", "newsdir", "nextdir", "NewRel", " newRel", "newsDir", " newFolder", "NewFile"], "children": ["parents", "times", "services", "apps", "all", "nil", "each", "these", "reports", "links", "users", "items", "keys", "his", "details", "Children", "modules", "jobs", "unknown", "lines", "ls", "bc", "packages", "classes", "names", "ml", "uploads", "its", "gc", "cache", "when", "cont", "child", "blocks", "images", "many", "ids", "resources", "members", "pres", "projects", "objects", "ports", "stories", "related", "ren", "desc", "groups", "pages", "files", "relations", "sub", "may", "kids", "follow"], "i": ["mi", "span", "json", "u", "j", "ms", "um", "y", "us", "I", "ski", "ini", "qi", "di", "ie", "im", "ri", "m", "iq", "ki", "client", "init", "x", "base", "t", "me", "in", "q", "iu", "hi", "ti", "chain", "bi", "ic", "multi", "ci", "ai", "sim", "you", "gi", "ui", "pi", "ij", "ix", "iter", "ji", "it", "uu", "li", "my", "ims", "point", "si", "xi", "g", "batch", "ip", "info", "key", "remote", "io", "gu", "is", "ii", "oi", "index", "id", "phi", "ex"], "newFile": ["ewLe", "newSourceFile", " newGlobal", "NEWDir", "NewDir", "NewLe", "createDir", "newfile", "NEWfile", "createFile", "newsGlobal", "nextDir", "newsfile", "createfile", "nextLe", " newfile", "newsFile", "NEWFile", "newLe", "NewGlobal", "nextFile", "NEWTh", "createSourceFile", "newTh", " newSourceFile", "ewDir", "newsTh", "newGlobal", "goodSourceFile", "goodFile", "Newfile", "goodDir", "ewfile", "NewTh", "goodfile", "newsDir", "nextfile", "NewFile", "ewFile"], "output": ["export", "admin", "response", "block", "text", "ilo", "put", "console", "next", "internal", "client", "stream", "web", "update", "Output", "connection", "four", "net", "write", "buffer", "open", "print", "document", "current", "message", "result", "format", "position", "writer", "enabled", "success", "outer", "out", "exit", "parent", "object", "batch", "network", "monitor", "connect", "auto", "cut", "io", "config", "blue", "file", "online", "body", "pretty", "display"], "input": ["back", "rc", "active", "image", "insert", "internal", "storage", "ink", "reader", "op", "raw", "init", "feed", "in", "inner", "before", "buffer", "open", "ic", "Input", "current", "unsigned", "child", "get", "error", "inc", "operator", "initial", "upload", "out", "iter", "it", "form", "ahead", "ip", "add", "local", "info", "io", "inf", "start", "exec", "from"], "buff": ["seq", "buf", "txt", "sb", "pb", "bf", "text", "cat", "img", "bl", "bg", "cb", " buf", "bo", "uff", "bound", "bs", "bed", "tt", "box", "mem", "buffer", "xff", "old", "b", "bb", "xx", "hold", "bin", "nb", "nd", "uf", "black", "tab", "qq", "cond", "comp", "ch", "data", "eb", "cmd", "mb", "batch", "ind", "Buff", "msg", "ff", "fb", "gb", "printf", "bytes"], "read": ["handle", "en", "each", "text", "find", "and", "select", "test", "hello", "d", " write", "ink", "wait", "raw", "stream", "set", "run", "t", "mem", "feed", "in", "before", "q", "print", "write", "old", "buffer", "readable", "load", "reads", "seek", "hold", "skip", "get", "str", " Read", "bind", "give", "need", "iter", " count", "query", "len", "length", "height", "ind", "Read", "add", "count", "ready", "config", "start", "tell", "send", "reading", "size", "check", "index", "READ", "end", "like", "push"]}}
{"id1": "5061606", "id2": "23246123", "code1": "    protected void createSettingsIfNecessary() throws IOException {\n        OutputStream out = null;\n        try {\n            final File fSettings = SettingsUtils.getSettingsFile();\n            if (!fSettings.exists()) {\n                fSettings.createNewFile();\n                final Path src = new Path(\"mvn/settings.xml\");\n                final InputStream in = FileLocator.openStream(getBundle(), src, false);\n                out = new FileOutputStream(SettingsUtils.getSettings(), true);\n                IOUtils.copy(in, out);\n            } else {\n                Logger.getLog().info(\"File settings.xml already exists at \" + fSettings);\n            }\n        } finally {\n            if (out != null) {\n                out.flush();\n                out.close();\n            }\n        }\n    }\n", "code2": "    protected Control createDialogArea(Composite parent) {\n        Composite composite = (Composite) super.createDialogArea(parent);\n        setTitle(DialogsMessages.getString(\"LicenseDialog.Caption\"));\n        setMessage(DialogsMessages.getString(\"LicenseDialog.Explanation\"));\n        Composite content = new Composite(composite, SWT.NONE);\n        content.setLayoutData(new GridData(GridData.FILL_BOTH));\n        final int ncol = 1;\n        GridLayout layout = new GridLayout(1, false);\n        layout.numColumns = ncol;\n        content.setLayout(layout);\n        Browser browser = null;\n        Text text = null;\n        try {\n            browser = new Browser(content, SWT.NONE);\n            browser.setLayoutData(new GridData(GridData.FILL_BOTH));\n        } catch (Throwable t) {\n            text = new Text(content, SWT.MULTI | SWT.WRAP | SWT.VERTICAL);\n            text.setLayoutData(new GridData(GridData.FILL_BOTH));\n        }\n        URL url = PalobrowserPlugin.getDefault().getBundle().getResource(browser != null ? \"license.html\" : \"license.txt\");\n        InputStream in = null;\n        BufferedReader r = null;\n        StringBuffer sb = new StringBuffer();\n        try {\n            in = url.openStream();\n            r = new BufferedReader(new InputStreamReader(in, \"ISO-8859-1\"));\n            String line;\n            while ((line = r.readLine()) != null) sb.append(line).append(\"\\r\\n\");\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            if (r != null) {\n                try {\n                    r.close();\n                } catch (IOException e) {\n                }\n            }\n            if (in != null) {\n                try {\n                    in.close();\n                } catch (IOException e) {\n                }\n            }\n        }\n        if (browser != null) browser.setText(sb.toString()); else text.setText(sb.toString());\n        return composite;\n    }\n", "label": 0, "substitutes": {"createSettingsIfNecessary": ["createSettingsIfNeccessible", "createSettingsIfNecessible", "createSettingsIfNecessar", "createSettingsIfNecessesary", "createSettingsIfNacessible", "createSettingsIfNecessesible", "createSettingsIfNacessary", "createSettingsIfNacessesary", "createSettingsIfNecessed", "createSettingsIfNeccessar", "createSettingsIfNeccessary", "createSettingsIfNacessar", "createSettingsIfNeccesary", "createSettingsIfNeccesar", "createSettingsIfNeccesed", "createSettingsIfNacessesed", "createSettingsIfNecessesed", "createSettingsIfNacessesible", "createSettingsIfNacessesar", "createSettingsIfNeccessed", "createSettingsIfNeccesible", "createSettingsIfNacessed", "createSettingsIfNecessesar"], "out": ["f", "ion", "report", "co", "nt", "flush", "that", "con", "output", "cos", "oe", "res", "oss", "cn", "bo", "comment", "obj", "client", "on", "can", "w", "sys", "yes", "conv", "t", "init", "one", "net", "log", "cho", "write", "to", "go", "end", "err", "max", "list", "up", "gc", "off", "writer", "os", "outer", "or", "ent", "it", "OU", "ch", "exit", "note", "conn", "null", "ou", "again", "outs", "aos", "o", "inv", "n", "io", "ne", "server", "Out", "file", "timeout", "OUT", "print", "ex", "ot"], "fSettings": ["cfsettings", " fOptions", " fChanges", "eSetting", " fsettings", "fChanges", "cfSettings", "bfSetting", " fSetting", "bfChanges", "sfSetting", "fsettings", " fSetup", "hsettings", "sfChanges", "sfOptions", "esettings", "fOptions", "cfSetup", "bfSettings", "hSettings", "cfSetting", "finalSetting", "bfsettings", "hSetting", "sfsettings", "finalsettings", "finalSettings", "sfSettings", "eSettings", "fSetup", "finalOptions", "fSetting", "sfSetup"], "src": ["ser", "attr", "rc", "txt", "sb", "img", "rt", "sit", "dest", "cont", "resource", "view", "sys", "tmp", "ls", "sq", "spec", "pkg", "th", "cur", "sr", "rel", "filename", "ur", "url", "rs", "sf", "rl", "upload", "sc", "rx", "dir", "syn", "desc", "config", "fn", "source", "loc", "root"], "in": ["rin", "en", "inn", "and", "gin", "IN", "vin", "ins", "ln", "In", "init", "inside", "inner", "i", "bin", "l", "input", "sin", "iter", " din", "ad", "r", "info", "n", "din", "inf", "is", "isin", "source", "cin", "id", "from"]}}
{"id1": "12389873", "id2": "13644375", "code1": "    private void load() throws SQLException {\n        Connection conn = null;\n        Statement stmt = null;\n        try {\n            conn = FidoDataSource.getConnection();\n            conn.setAutoCommit(false);\n            stmt = conn.createStatement();\n            ClearData.clearTables(stmt);\n            stmt.executeUpdate(\"insert into Objects (ObjectId, Description) values (100, 'Living Thing')\");\n            stmt.executeUpdate(\"insert into Objects (ObjectId, Description) values (200, 'Inanimate Object')\");\n            stmt.executeUpdate(\"insert into Objects (ObjectId, Description) values (300, 'Dog')\");\n            stmt.executeUpdate(\"insert into Objects (ObjectId, Description) values (400, 'Sheltie')\");\n            stmt.executeUpdate(\"insert into Objects (ObjectId, Description) values (500, 'Eskimo')\");\n            stmt.executeUpdate(\"insert into Objects (ObjectId, Description) values (600, 'Person')\");\n            stmt.executeUpdate(\"insert into Objects (ObjectId, Description) values (700, 'Collar')\");\n            stmt.executeUpdate(\"insert into Objects (ObjectId, Description) values (800, 'Ball')\");\n            stmt.executeUpdate(\"insert into Objects (ObjectId, Description) values (401, 'Fido')\");\n            stmt.executeUpdate(\"insert into Objects (ObjectId, Description) values (501, 'Samantha')\");\n            stmt.executeUpdate(\"insert into Objects (ObjectId, Description) values (801, 'A collar')\");\n            stmt.executeQuery(\"select setval('objects_objectid_seq', 1000)\");\n            stmt.executeUpdate(\"insert into ClassLinkTypes (LinkName, LinkType) values ('hasa', 2)\");\n            stmt.executeUpdate(\"insert into ClassLinkTypes (LinkName, LinkType) values ('partof', 2)\");\n            stmt.executeUpdate(\"insert into ObjectLinks (ObjectId, LinkName, LinkToObject) values (100, 'isa', 1)\");\n            stmt.executeUpdate(\"insert into ObjectLinks (ObjectId, LinkName, LinkToObject) values (200, 'isa', 1)\");\n            stmt.executeUpdate(\"insert into ObjectLinks (ObjectId, LinkName, LinkToObject) values (300, 'isa', 100)\");\n            stmt.executeUpdate(\"insert into ObjectLinks (ObjectId, LinkName, LinkToObject) values (400, 'isa', 300)\");\n            stmt.executeUpdate(\"insert into ObjectLinks (ObjectId, LinkName, LinkToObject) values (500, 'isa', 300)\");\n            stmt.executeUpdate(\"insert into ObjectLinks (ObjectId, LinkName, LinkToObject) values (600, 'isa', 100)\");\n            stmt.executeUpdate(\"insert into ObjectLinks (ObjectId, LinkName, LinkToObject) values (700, 'isa', 200)\");\n            stmt.executeUpdate(\"insert into ObjectLinks (ObjectId, LinkName, LinkToObject) values (800, 'isa', 200)\");\n            stmt.executeUpdate(\"insert into ObjectLinks (ObjectId, LinkName, LinkToObject) values (401, 'instance', 400)\");\n            stmt.executeUpdate(\"insert into ObjectLinks (ObjectId, LinkName, LinkToObject) values (501, 'instance', 500)\");\n            stmt.executeUpdate(\"insert into ObjectLinks (ObjectId, LinkName, LinkToObject) values (801, 'instance', 800)\");\n            stmt.executeUpdate(\"insert into ObjectLinks (ObjectId, LinkName, LinkToObject) values (401, 'hasa', 801)\");\n            stmt.executeUpdate(\"insert into AttributeCategories (CategoryName) values ('color')\");\n            stmt.executeUpdate(\"insert into AttributeCategories (CategoryName) values ('weight')\");\n            stmt.executeUpdate(\"insert into AttributeCategories (CategoryName) values ('length')\");\n            stmt.executeUpdate(\"insert into Attributes (AttributeName, Category) values ('green', 'color')\");\n            stmt.executeUpdate(\"insert into Attributes (AttributeName, Category) values ('blue', 'color')\");\n            stmt.executeUpdate(\"insert into Attributes (AttributeName, Category) values ('light', 'weight')\");\n            stmt.executeUpdate(\"insert into Attributes (AttributeName, Category) values ('heavy', 'weight')\");\n            stmt.executeUpdate(\"insert into Attributes (AttributeName, Category) values ('short', 'length')\");\n            stmt.executeUpdate(\"insert into Attributes (AttributeName, Category) values ('long', 'length')\");\n            stmt.executeUpdate(\"insert into ObjectAttributes (ObjectId, AttributeName) values (401, 'light')\");\n            stmt.executeUpdate(\"insert into ObjectAttributes (ObjectId, AttributeName) values (401, 'short')\");\n            stmt.executeUpdate(\"insert into ObjectAttributes (ObjectId, AttributeName) values (801, 'blue')\");\n            stmt.executeUpdate(\"insert into Dictionary (Word, SenseNumber, GrammarString, ObjectId) values ('LEFT-WALL', '1', 'AV+ | NP+', 1)\");\n            stmt.executeUpdate(\"insert into Dictionary (Word, SenseNumber, GrammarString, ObjectId) values ('the', '1', 'D+', 1)\");\n            stmt.executeUpdate(\"insert into Dictionary (Word, SenseNumber, GrammarString, ObjectId) values ('big', '1', 'ADJ+', 400)\");\n            stmt.executeUpdate(\"insert into Dictionary (Word, SenseNumber, GrammarString, ObjectId) values ('dog', '1', '[@ADJ-] & [D-] & (S+ | DO- | PO- | NP-)', 700)\");\n            stmt.executeUpdate(\"insert into Dictionary (Word, SenseNumber, GrammarString, ObjectId) values ('run', '1', '[S-] & AV- & [PREP+]', 800)\");\n            stmt.executeUpdate(\"insert into Dictionary (Word, SenseNumber, GrammarString, ObjectId) values ('across', '1', 'PREP- & PO+', 800)\");\n            stmt.executeUpdate(\"insert into Dictionary (Word, SenseNumber, GrammarString, ObjectId) values ('street', '1', '[@ADJ-] & [D-] & (S+ | DO- | PO- | NP-)', 800)\");\n            stmt.executeUpdate(\"insert into AdjectivePrepositions (PrepositionName, ObjectId, LinkName) values ('with', 100, 'hasa')\");\n            stmt.executeUpdate(\"insert into AdjectivePrepositions (PrepositionName, ObjectId, LinkName) values ('in', 200, 'partof')\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'superlative', 1, 'good', 'best', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'superlative', 2, '*y', '*iest', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'superlative', 3, '*e', '*est', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'superlative', 4, '*', '*est', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'comparative', 1, 'good', 'better', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'comparative', 2, '*y', '*ier', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'comparative', 3, '*e', '*er', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'comparative', 4, '*', '*er', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'possessive', 1, '*s', '*s\\\\'', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'possessive', 2, '*', '*\\\\'s', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'present perfect', 1, 'be', 'being', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'present perfect', 2, '*Vy', '*Vying', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'present perfect', 3, '*c', '*cking', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'present perfect', 4, '*VVC', '*VVCing', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'present perfect', 5, '*VC', '*VCCing', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'present perfect', 6, '*ie', '*ying', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'present perfect', 7, '*e', '*ing', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'present perfect', 8, '*', '*ing', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past', 1, 'sing', 'sang', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past', 2, 'give', 'gave', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past', 3, 'swim', 'swam', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past', 4, 'have', 'had', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past', 5, 'run', 'ran', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past', 6, 'do', 'did', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past', 7, 'be', 'was', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past', 8, 'throw', 'threw', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past', 9, 'sleep', 'slept', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past', 10, '*c', '*cked', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past', 11, '*VVC', '*VVCed', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past', 12, '*VC', '*VCCed', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past', 13, '*y', '*ied', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past', 14, '*oe', '*oed', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past', 15, '*e', '*ed', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past', 16, '*', '*ed', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past perfect', 1, 'sing', 'sung', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past perfect', 2, 'give', 'given', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past perfect', 3, 'swim', 'swum', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past perfect', 4, 'have', 'had', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past perfect', 5, 'do', 'done', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past perfect', 6, 'be', 'been', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past perfect', 7, 'sleep', 'slept', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past perfect', 8, '*e', '*ed', FALSE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past perfect', 9, '*', '*ed', FALSE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'first singular', 1, 'be', 'am', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'first singular', 2, 'have', 'have', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'first singular', 3, '*', '*', FALSE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'second singular', 1, 'be', 'are', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'second singular', 2, 'have', 'have', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'second singular', 3, '*', '*', FALSE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'third singular', 1, 'be', 'is', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'third singular', 2, 'have', 'has', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'third singular', 3, 'do', 'do', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'third singular', 4, '*ch', '*ches', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'third singular', 5, '*sh', '*shes', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'third singular', 6, '*x', '*xes', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'third singular', 7, '*z', '*zes', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'third singular', 8, '*Cy', '*Cies', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'third singular', 9, '*s', '*ses', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'third singular', 10, '*o', '*oes', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'third singular', 11, '*', '*s', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'first plural', 1, 'be', 'are', FALSE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'first plural', 2, 'have', 'have', FALSE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'first plural', 3, '*', '*', FALSE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'third plural', 1, 'be', 'are', FALSE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'third plural', 2, 'have', 'have', FALSE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'third plural', 3, '*', '*', FALSE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 1, 'leaf', 'leaves', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 2, 'knife', 'knives', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 3, 'elf', 'elves', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 4, 'half', 'halves', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 5, 'loaf', 'loaves', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 6, 'shelf', 'shelves', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 7, 'wife', 'wives', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 8, 'person', 'people', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 9, 'deer', 'deer', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 10, 'child', 'children', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 11, '*Co', '*Coes', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 12, '*s', '*ses', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 13, '*ch', '*ches', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 14, '*sh', '*shes', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 15, '*x', '*xes', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 16, '*z', '*zes', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 17, '*Cy', '*Cies', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 18, '*', '*s', TRUE)\");\n            stmt.executeUpdate(\"insert into WordClassifications (Rank, Pattern, GrammarString, ObjectId, Description) values (1, '$N[.N]', 'D+', 100, 'money')\");\n            stmt.executeUpdate(\"insert into WordClassifications (Rank, Pattern, GrammarString, ObjectId, Description) values (2, 'N/N/N', 'D+', 200, 'date')\");\n            stmt.executeUpdate(\"insert into WordClassifications (Rank, Pattern, GrammarString, ObjectId, Description) values (3, '[/](C/)C', 'D+', 300, 'unix path')\");\n            stmt.executeUpdate(\"insert into WordClassifications (Rank, Pattern, GrammarString, ObjectId, Description) values (4, '[A:](C\\\\\\\\)C', 'D+', 400, 'dos path')\");\n            stmt.executeUpdate(\"insert into WordClassifications (Rank, Pattern, GrammarString, ObjectId, Description) values (5, 'N:N', 'D+', 500, 'time')\");\n            stmt.executeUpdate(\"insert into WordClassifications (Rank, Pattern, GrammarString, ObjectId, Description) values (6, 'N.N.N.N', 'D+', 600, 'internet')\");\n            stmt.executeUpdate(\"insert into WordClassifications (Rank, Pattern, GrammarString, ObjectId, Description) values (7, 'E(.E)', 'D+', 700, 'hostname')\");\n            stmt.executeUpdate(\"insert into WordClassifications (Rank, Pattern, GrammarString, ObjectId, Description) values (8, '{+-}N[.N]', 'D+', 800, 'number')\");\n            stmt.executeUpdate(\"insert into Pronouns (Pronoun, Person, Gender, Plural) values ('i', 1, 3, FALSE)\");\n            stmt.executeUpdate(\"insert into Pronouns (Pronoun, Person, Gender, Plural) values ('we', 1, 3, TRUE)\");\n            stmt.executeUpdate(\"insert into Pronouns (Pronoun, Person, Gender, Plural) values ('they', 3, 3, TRUE)\");\n            stmt.executeUpdate(\"insert into Pronouns (Pronoun, Person, Gender, Plural) values ('he', 3, 1, FALSE)\");\n            stmt.executeUpdate(\"insert into Pronouns (Pronoun, Person, Gender, Plural) values ('she', 3, 2, FALSE)\");\n            stmt.executeUpdate(\"insert into Pronouns (Pronoun, Person, Gender, Plural) values ('it', 3, 3, FALSE)\");\n            stmt.executeUpdate(\"insert into Pronouns (Pronoun, Person, Gender, Plural) values ('you', 2, 3, FALSE)\");\n            stmt.executeUpdate(\"insert into FrameSlots (SlotName) values ('actor')\");\n            stmt.executeUpdate(\"insert into FrameSlots (SlotName) values ('origin')\");\n            stmt.executeUpdate(\"insert into FrameSlots (SlotName) values ('destination')\");\n            stmt.executeUpdate(\"insert into FrameSlots (SlotName) values ('object')\");\n            stmt.executeUpdate(\"insert into FrameSlots (SlotName) values ('instrument')\");\n            stmt.executeUpdate(\"insert into FrameSlots (SlotName) values ('beneficiary')\");\n            stmt.executeUpdate(\"insert into FrameSlots (SlotName) values ('location')\");\n            stmt.executeUpdate(\"insert into Verbs (VerbName, SubjectSlot, IndirectObjectSlot, PredicateNounSlot) values ('throw', 'actor', 'destination', 'object')\");\n            stmt.executeUpdate(\"insert into Verbs (VerbName, SubjectSlot, IndirectObjectSlot, PredicateNounSlot) values ('melt', 'actor', '', '')\");\n            stmt.executeUpdate(\"insert into Verbs (VerbName, SubjectSlot, IndirectObjectSlot, PredicateNounSlot) values ('kill', 'actor', '', 'object')\");\n            stmt.executeUpdate(\"insert into AdverbPrepositions (PrepositionName, ObjectId, FrameSlot) values ('with', 200, 'instrument')\");\n            stmt.executeUpdate(\"insert into AdverbPrepositions (PrepositionName, ObjectId, FrameSlot) values ('at', 1, 'location')\");\n            stmt.executeUpdate(\"insert into Articles (ArticleName, Dereference) values ('the', 1)\");\n            stmt.executeUpdate(\"insert into Articles (ArticleName, Dereference) values ('a', 2)\");\n            stmt.executeUpdate(\"insert into Articles (ArticleName, Dereference) values ('an', 2)\");\n            stmt.executeUpdate(\"insert into GrammarLinks (LinkName, LinkType) values ('S', 1)\");\n            stmt.executeUpdate(\"insert into GrammarLinks (LinkName, LinkType) values ('PN', 2)\");\n            stmt.executeUpdate(\"insert into GrammarLinks (LinkName, LinkType) values ('DO', 3)\");\n            stmt.executeUpdate(\"insert into GrammarLinks (LinkName, LinkType) values ('IO', 4)\");\n            stmt.executeUpdate(\"insert into GrammarLinks (LinkName, LinkType) values ('PO', 5)\");\n            stmt.executeUpdate(\"insert into GrammarLinks (LinkName, LinkType) values ('NP', 6)\");\n            stmt.executeUpdate(\"insert into GrammarLinks (LinkName, LinkType) values ('AV', 7)\");\n            stmt.executeUpdate(\"insert into GrammarLinks (LinkName, LinkType) values ('LV', 8)\");\n            stmt.executeUpdate(\"insert into GrammarLinks (LinkName, LinkType) values ('PREP', 9)\");\n            stmt.executeUpdate(\"insert into GrammarLinks (LinkName, LinkType) values ('D', 10)\");\n            stmt.executeUpdate(\"insert into GrammarLinks (LinkName, LinkType) values ('ADJ', 11)\");\n            stmt.executeUpdate(\"insert into GrammarLinks (LinkName, LinkType) values ('ADV', 12)\");\n            stmt.executeUpdate(\"insert into GrammarLinks (LinkName, LinkType) values ('CONJ', 13)\");\n            stmt.executeUpdate(\"insert into GrammarLinks (LinkName, LinkType) values ('INTJ', 14)\");\n            stmt.executeUpdate(\"insert into GrammarLinks (LinkName, LinkType) values ('PA', 15)\");\n            stmt.executeUpdate(\"insert into GrammarLinks (LinkName, LinkType) values ('HV', 16)\");\n            stmt.executeQuery(\"select setval('instructions_instructionid_seq', 1)\");\n            int next = 2;\n            stmt.executeUpdate(\"insert into Instructions (Type, ExecuteString, FrameSlot, Operator, LinkName, ObjectId, AttributeName) \" + \"values (3, 'throw', null, 0, null, null, null)\");\n            stmt.executeUpdate(\"insert into Instructions (Type, ExecuteString, FrameSlot, Operator, LinkName, ObjectId, AttributeName) \" + \"values (3, 'test', null, 0, null, null, null)\");\n            stmt.executeUpdate(\"insert into Instructions (Type, ExecuteString, FrameSlot, Operator, LinkName, ObjectId, AttributeName) \" + \"values (2, null, 'actor', 1, 'hasa', '300', '')\");\n            stmt.executeUpdate(\"insert into Instructions (Type, ExecuteString, FrameSlot, Operator, LinkName, ObjectId, AttributeName) \" + \"values (2, null, 'instrument', 3, null, null, 'blue')\");\n            stmt.executeUpdate(\"insert into Instructions (Type, ExecuteString, FrameSlot, Operator, LinkName, ObjectId, AttributeName) \" + \"values (1, null, null, 0, null, null, null)\");\n            stmt.executeUpdate(\"insert into Instructions (Type, ExecuteString, FrameSlot, Operator, LinkName, ObjectId, AttributeName) \" + \"values (3, 'get', null, 0, null, null, null)\");\n            stmt.executeUpdate(\"insert into Instructions (Type, ExecuteString, FrameSlot, Operator, LinkName, ObjectId, AttributeName) \" + \"values (3, 'drop', null, 0, null, null, null)\");\n            stmt.executeUpdate(\"insert into InstructionGroups (InstructionId, Rank, GroupInstruction) values (\" + (next + 2) + \", 1, \" + (next + 0) + \")\");\n            stmt.executeUpdate(\"insert into InstructionGroups (InstructionId, Rank, GroupInstruction) values (\" + (next + 2) + \", 2, \" + (next + 1) + \")\");\n            stmt.executeUpdate(\"insert into InstructionGroups (InstructionId, Rank, GroupInstruction) values (\" + (next + 3) + \", 1, \" + (next + 1) + \")\");\n            stmt.executeUpdate(\"insert into InstructionGroups (InstructionId, Rank, GroupInstruction) values (\" + (next + 3) + \", 2, \" + (next + 0) + \")\");\n            stmt.executeUpdate(\"insert into InstructionGroups (InstructionId, Rank, GroupInstruction) values (\" + (next + 4) + \", 1, \" + (next + 2) + \")\");\n            stmt.executeUpdate(\"insert into InstructionGroups (InstructionId, Rank, GroupInstruction) values (\" + (next + 4) + \", 2, \" + (next + 3) + \")\");\n            stmt.executeQuery(\"select setval('transactions_transactionid_seq', 1)\");\n            stmt.executeUpdate(\"insert into Transactions (InstructionId, Description) values (\" + (next + 4) + \", 'throw something')\");\n            stmt.executeUpdate(\"insert into Transactions (InstructionId, Description) values (\" + (next + 5) + \", 'get something')\");\n            stmt.executeUpdate(\"insert into Transactions (InstructionId, Description) values (\" + (next + 6) + \", 'drop something')\");\n            stmt.executeUpdate(\"insert into TransactionPreconditions (TransactionId, IfFrameSlot, Operator, LinkName, LinkFrameSlot, AttributeName, SatisfyTransactionId) \" + \"values (2, 'actor', 1, 'hasa', 'object', '', 3)\");\n            stmt.executeUpdate(\"insert into TransactionPreconditions (TransactionId, IfFrameSlot, Operator, LinkName, LinkFrameSlot, AttributeName, SatisfyTransactionId) \" + \"values (2, 'object', 4, '', '', 'heavy', 4)\");\n            stmt.executeUpdate(\"insert into TransactionSlots (TransactionId, FrameSlot, InstructionId) values (2, 'object', \" + (next + 6) + \")\");\n            stmt.executeUpdate(\"insert into TransactionSlots (TransactionId, FrameSlot, InstructionId) values (2, 'destination', \" + (next + 5) + \")\");\n            stmt.executeQuery(\"select setval('verbtransactions_verbid_seq', 1)\");\n            stmt.executeUpdate(\"insert into VerbTransactions (VerbString, MoodType, TransactionId) values ('throw', 2, 2)\");\n            stmt.executeUpdate(\"insert into VerbConstraints (VerbId, FrameSlot, ObjectId) values (2, 'object', 200)\");\n            stmt.executeUpdate(\"update SystemProperties set value = 'Play Data' where name = 'DB Data Version'\");\n            conn.commit();\n        } catch (SQLException e) {\n            if (conn != null) conn.rollback();\n            throw e;\n        } finally {\n            if (stmt != null) stmt.close();\n            if (conn != null) conn.close();\n        }\n    }\n", "code2": "    public String get(String url) {\n        try {\n            HttpGet get = new HttpGet(url);\n            HttpResponse response = this.getHttpClient().execute(get);\n            HttpEntity entity = response.getEntity();\n            if (entity == null) {\n                throw new RuntimeException(\"response body was empty\");\n            }\n            return EntityUtils.toString(entity);\n        } catch (RuntimeException ex) {\n            throw ex;\n        } catch (Exception ex) {\n            throw new RuntimeException(ex);\n        }\n    }\n", "label": 0, "substitutes": {"load": [" validate", " dump", " fetch", " parse", " build", " find", "insert", " read", " startup", " fill", " Init", " scan", " recover", "execute", " reload", "init", " refresh", " destroy", " cleanup", " ingest", " construct", " test", "construct", " search", " register", "save", " ping"], "conn": ["wr", "co", "en", "nt", "ctx", "con", "pas", "comm", "cn", "cb", "mt", "enc", "obj", "yn", "ln", "client", "gate", "dn", "conv", "col", "ann", "ns", "connection", "die", "c", "open", "pg", "cert", "cur", "ctr", "db", "close", "rel", "org", "conf", "com", "ct", "cp", "act", "Conn", "pt", "coll", "Connection", "ds", "pen", "ch", "ens", "cmd", "cfg", "connect", "mn", "nc", "mc", "n", "Con", "cc"], "stmt": ["STgt", " stgr", "ostmem", "estmt", " sttr", "stMT", " superstmt", "histtry", "constmt", "strmt", "restmg", "Sttry", " stmm", "restpt", "putmp", "putolt", "styMT", "istmt", "strmn", "stymg", "staddr", "stackpt", "puttx", " superstm", "stmb", "stcmd", "ostpt", "stackolt", " stmem", "histgt", "estmm", "constm", "stymt", "stymb", "Stmt", "ostgr", " stolt", "Stmsg", "constst", "styaddr", "stgr", " staddr", "histmt", "stm", "stytx", "constMT", "istMT", "esttx", "ostolt", "putmm", "stackMT", " superstmg", "restMT", "ststat", "Stst", " Sttr", "estgr", "stym", "stst", " stmb", "restmm", "restgt", "stackmm", "histcmd", "estmb", "STMT", " superststat", "restaddr", "stacktab", "stgt", "stpt", " sttry", "putmt", " stmn", "istgt", "ostmm", " Stm", "stmg", "Stgr", "stolt", "Stmem", "stmid", "ostmid", "Stm", "restmt", " Stmt", "Stcmd", "stopmt", "stmm", "ostmt", "stygt", "restmp", "restgr", " sttx", "STmb", "strmg", " stmsg", "estgt", "stmp", "resttx", "strm", "stymsg", "ostrm", " stm", " superstmn", " stcmd", "stymem", " stpt", " stmid", "stopmn", "stmsg", "stmem", " strm", "Stgt", "estm", "stackmid", " stst", "osttab", "ostmn", "ostgt", "stoprm", " stmp", "stackmt", " stgt", "sttx", "putMT", "estmg", "sttab", " superstMT", "puttab", "StMT", "STtx", " ststat", "strstat", "stopmm", "stackgt", " supersttr", "sttry", " StMT", "STmsg", " stmg", "sttr", "Stmm", " stMT", "Stmb", "stmn", "STmt"]}}
{"id1": "12171364", "id2": "8150996", "code1": "    private static FrameworkFactory getFrameworkFactory() throws Exception {\n        URL url = Main.class.getClassLoader().getResource(\"META-INF/services/org.osgi.framework.launch.FrameworkFactory\");\n        if (url != null) {\n            BufferedReader br = new BufferedReader(new InputStreamReader(url.openStream()));\n            try {\n                for (String s = br.readLine(); s != null; s = br.readLine()) {\n                    s = s.trim();\n                    if ((s.length() > 0) && (s.charAt(0) != '#')) {\n                        return (FrameworkFactory) Class.forName(s).newInstance();\n                    }\n                }\n            } finally {\n                if (br != null) br.close();\n            }\n        }\n        throw new Exception(\"Could not find framework factory.\");\n    }\n", "code2": "    private static boolean copyFile(File in, File out) {\n        boolean ok = true;\n        InputStream is = null;\n        OutputStream os = null;\n        try {\n            is = new FileInputStream(in);\n            os = new FileOutputStream(out);\n            byte[] buffer = new byte[0xFFFF];\n            for (int len; (len = is.read(buffer)) != -1; ) os.write(buffer, 0, len);\n        } catch (IOException e) {\n            System.err.println(e);\n            ok = false;\n        } finally {\n            if (is != null) {\n                try {\n                    is.close();\n                } catch (IOException e) {\n                    System.err.println(e);\n                }\n            }\n            if (os != null) {\n                try {\n                    os.close();\n                } catch (IOException e) {\n                    System.err.println(e);\n                }\n            }\n        }\n        return ok;\n    }\n", "label": 0, "substitutes": {"getFrameworkFactory": ["getFrameworkseworkService", "getFrameworkInterface", "getFramenceLoader", "getFramwareService", "getFramwareFactory", "getFrameworkswareLoader", "getFramernelFactory", "getFramernelLoader", "getFramenceInterface", "getFrameworkLoader", "getFrameworkService", "getFramwareInterface", "getFramernelInterface", "getFramenceFactory", "getFrameworkseworkLoader", "getFrameworkswareService", "getFramenceService", "getFrameworkswareInterface", "getFramwareLoader", "getFrameworkseworkInterface", "getFramernelService", "getFrameworkseworkFactory", "getFrameworkswareFactory"], "url": ["f", "browser", "hl", "gl", "address", "sb", "ref", "dl", "res", "resource", "lb", "bel", "ls", "web", "ll", "deb", "base", "char", "link", "pl", "sl", "b", "bb", "lr", "re", "rel", "ur", "org", "mount", "uri", "URL", "str", "rl", "l", "nl", "ul", "mail", "github", "r", "ssl", "el", "http", "html", "file", "loc", "Url", "user", "ml", "loader", "fl", "abs"], "br": ["browser", "wr", "buf", "hr", "bt", "tr", "block", "sb", "bl", "bro", "bg", "mr", "bridge", "cr", "bh", "fr", "bs", "bc", "BR", "ber", "b", "ctr", "bb", "dr", "lr", "rel", "rem", "bp", "gc", "bm", "sh", "rb", "str", "Br", "it", "eb", "r", "bar", "nr", "el", "gr", "jp", "io", "vr", "shr", "repl", "rob", "bn", "pr", "bd", "ab", "abs"], "s": ["series", "csv", "xs", "txt", "ss", "sb", "sm", "ms", "z", "y", "ins", "comm", "sp", "h", "js", "m", "ws", "qs", "ains", "set", "ls", "bs", "w", "raw", "t", "hs", "ns", "sq", "ves", "sl", "stats", "sym", "ps", "ts", "S", "v", "i", "less", "sv", "state", "ats", "str", "rs", "os", "sf", "has", "ys", "ds", "eps", "des", "tes", "sql", "sw", "gs", "ims", "search", "g", "syn", "full", "als", "n", "sts", "string", "gets", "is", "as", "sort", "es", "cs", "abs"]}}
{"id1": "20929570", "id2": "9738825", "code1": "    public static String toMd5(String str) {\n        MessageDigest messageDigest = null;\n        try {\n            messageDigest = MessageDigest.getInstance(\"MD5\");\n            messageDigest.reset();\n            messageDigest.update(str.getBytes(\"UTF-8\"));\n        } catch (NoSuchAlgorithmException e) {\n            System.out.println(\"NoSuchAlgorithmException caught!\");\n            System.exit(-1);\n        } catch (UnsupportedEncodingException e) {\n            e.printStackTrace();\n        }\n        byte[] byteArray = messageDigest.digest();\n        StringBuffer md5StrBuff = new StringBuffer();\n        for (int i = 0; i < byteArray.length; i++) {\n            if (Integer.toHexString(0xFF & byteArray[i]).length() == 1) md5StrBuff.append(\"0\").append(Integer.toHexString(0xFF & byteArray[i])); else md5StrBuff.append(Integer.toHexString(0xFF & byteArray[i]));\n        }\n        return md5StrBuff.toString();\n    }\n", "code2": "    public void load(URL url) throws IOException {\n        ResourceLocator locator = null;\n        try {\n            locator = new RelativeResourceLocator(url);\n        } catch (URISyntaxException use) {\n            throw new IllegalArgumentException(\"Bad URL: \" + use);\n        }\n        ResourceLocatorTool.addResourceLocator(ResourceLocatorTool.TYPE_TEXTURE, locator);\n        InputStream stream = null;\n        try {\n            stream = url.openStream();\n            if (stream == null) {\n                throw new IOException(\"Failed to load materials file '\" + url + \"'\");\n            }\n            logger.fine(\"Loading materials from '\" + url + \"'...\");\n            load(stream);\n        } finally {\n            if (stream != null) stream.close();\n            ResourceLocatorTool.removeResourceLocator(ResourceLocatorTool.TYPE_TEXTURE, locator);\n            locator = null;\n        }\n    }\n", "label": 0, "substitutes": {"toMd5": ["toMMD512", "toDd512", "toDd4", "toMmHash", "toMmd5", "toMm5", "toDdHash", "toMMD4", "toMMDHash", "toMmd4", "toMm512", "toMd4", "toDd5", "toDm4", "toMmd512", "toMm4", "toDm512", "toMd512", "toDm5", "toDmHash", "toMmdHash", "toMdHash", "toMMD5"], "str": ["wr", "txt", "br", "text", "sp", "cr", "enc", "obj", "t", "in", "char", "c", "print", "b", "ctr", "Str", "v", "e", "name", "input", "out", "it", "ch", "this", "st", "s", "utt", "r", "n", "string", "STR", "msg", "arr", "p", "a", "data", "w"], "messageDigest": [" messageDert", "MessageDigest", "messageDigester", "messageDester", "messagediger", "messageDest", "applicationDigester", "messageDecested", "messageDecests", "messageDigse", "MessageDigests", "MessageDigEST", "messageDefEST", "messagemdest", "messageDecester", "messagedigester", "messagedigested", "messageDigEST", "messageDigist", "MessageDiger", "messageDecse", "applicationDigse", "applicationdigse", " messageDester", "messageDefist", "messagedigEST", "messagedigest", "messageDefest", "applicationDigest", " messageDse", "messagedigert", "messagedigests", " messageDest", "messagemdert", "applicationdigest", "messageDse", "Messagedigest", "Messagedigests", "messageDesignse", "messageDesignester", "MessageDigse", "messageDefester", "messageDecest", "Messagediger", "messageDigested", "messagedigse", "MessagedigEST", "messagedigist", "applicationdigester", "Messagedigse", "applicationdigested", "messageDesignests", " messageDigert", " messageDigester", "Messagedigester", "messageDefer", " messageDigse", "messagemdester", "messageDesignest", "MessageDigester", "messageDiger", "messageDigert", " messageDiger", "messageDigests", " messageDigist", "applicationDigested", "messagemdse", "messageDesignested", "messageDert"], "byteArray": ["bytesArray", "bytesRAY", "byteLength", "viewBuffer", " byteStream", "viewArray", "bytesLength", "byteList", "bytesAddress", "fieldLength", "viewStream", "fieldArray", "seBuffer", "helloArray", " byteRAY", "entityArray", "byteRAY", "resourceArray", " bytearray", "seArray", "resourceBuffer", "helloBuffer", "basicAddress", "basicarray", "entityList", " byteList", " byteBuffer", " byteAddress", "bytearray", "basicArray", "basicList", "bytesString", "resourceStream", "byteString", "byteBuffer", "byteStream", "basicBuffer", "entityarray", " byteLength", "byteAddress", " byteString", "basicString", "entityBuffer", "fieldRAY"], "md5StrBuff": ["md5strBuff", "md5StringComp", "md5StComp", "md8StrBuffer", "md5strPref", "md8StrVert", "md5StBu", "md5StringBuff", "md4StrPref", "md5ObjComp", "md7StrBu", "md7StringBuff", "md5TextCop", "md5strBuffer", "md5StPref", "md5Buffbuff", "md5TextComp", "md7StringPref", "md5TextBuffer", "md5StrPref", "md65StrComp", "md8StrComp", "md5StrBu", "md8RatBuffer", "md5ObjBuffer", "md5TextBuff", "md8StrBuff", "md5StringBu", "md5RatComp", "md8RatComp", "md4Stringbuff", "md7StrBuff", "md8RatVert", "md7Stringbuff", "md5StringDb", "md5ObjVert", "md5BuffBuff", "md65TextComp", "md5strbuff", "md5StrVert", "md65TextBuffer", "md65StrBuff", "md5ObjBuff", "md5Stringbuff", "md5RatVert", "md5Stbuff", "md5strBu", "md5RatBuff", "md7StrPref", "md7Strbuff", "md8RatBuff", "md5StrCop", "md65TextBuff", "md5StCop", "md4StringPref", "md5strDb", "md5strComp", "md5BuffPref", "md5StringCop", "md5StrComp", "md5StringPref", "md7StringBu", "md65TextCop", "md4StringDb", "md5StringBuffer", "md5strVert", "md4StrDb", "md65StrCop", "md4StringBuff", "md5RatBuffer", "md5StBuffer", "md65StrBuffer", "md5StrBuffer", "md5StrDb", "md4StrBuff", "md5Strbuff", "md4Strbuff", "md5BuffDb", "md5StBuff"], "i": ["mi", "major", "json", "u", "ini", "j", "us", "y", "I", "di", "im", "h", "gravity", "ei", "m", "ki", "status", "conv", "t", "x", "in", "iu", "ti", "hi", "q", "chain", "c", "me", "bi", "cli", "ic", "cgi", "ci", "multi", "ai", "go", "slice", "gi", "ui", "e", "v", "list", "uri", "pi", "l", "ix", "it", "phi", "ji", "li", "xi", "my", "si", "s", "batch", "ind", "o", "ip", "info", "n", "io", "ii", "is", "index", "a", "gu", "ex"]}}
{"id1": "2676365", "id2": "17111859", "code1": "    public void reset(int currentPilot) {\n        try {\n            PreparedStatement psta = jdbc.prepareStatement(\"DELETE FROM component_prop \" + \"WHERE pilot_id = ? \");\n            psta.setInt(1, currentPilot);\n            psta.executeUpdate();\n            jdbc.commit();\n        } catch (SQLException e) {\n            jdbc.rollback();\n            log.debug(e);\n        }\n    }\n", "code2": "    private String getHash(String string) {\n        Monitor hashTime = JamonMonitorLogger.getTimeMonitor(Cache.class, \"HashTime\").start();\n        MessageDigest md5 = null;\n        try {\n            md5 = MessageDigest.getInstance(\"MD5\");\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        }\n        md5.reset();\n        md5.update(string.getBytes());\n        byte[] result = md5.digest();\n        StringBuffer hexString = new StringBuffer();\n        for (int i = 0; i < result.length; i++) {\n            hexString.append(Integer.toHexString(0xFF & result[i]));\n        }\n        String str = hexString.toString();\n        hashTime.stop();\n        return str;\n    }\n", "label": 0, "substitutes": {"reset": ["report", "flush", "release", "stop", "request", "remove", "clean", "set", "kill", "clear", "init", "command", "write", "replace", "ping", "alert", "close", "touch", "kick", "state", "exit", "destroy", "register", "config", "save", "quit", "update", "delete", "setup"], "currentPilot": ["currentpolly", "currentCane", " currentPane", "currentClan", "currentpolt", " currentPortane", "currentCail", "currentPane", " currentPortail", "currentPortane", "currentNlan", " currentPolly", " currentPortolly", "currentPortolly", "currentNane", "currentPortlan", "currentpail", "currentPortolt", "currentNail", " currentPolt", "currentPolt", " currentPortilot", " currentPlan", " currentPail", " currentPortlan", " currentPortolt", "currentCilot", "currentPail", "currentPolly", "currentPlan", "currentPortilot", "currentpilot", "currentPortail", "currentNilot"], "psta": ["Psa", "ppstan", "apstan", "pesta", "ppsa", "Pstan", "Pesta", "apsta", "pstan", "apsa", "psa", "ppsta", " psha", "apesta", "psha", "ppesta", " psa", "apsha", " pstan", "Psta", "Psha", " pesta"]}}
{"id1": "18793482", "id2": "4798332", "code1": "    public void modifyApplicationMessage(String locale, String messageName, String messageValue) {\n        Properties properties = new Properties();\n        try {\n            String i18nPath = ServerUtil.removelastResourceURL(ConfigurationServiceImpl.class.getResource(\"/es/ua/tranube/prototype/main/client/TranubeConstants_en.properties\").getPath()).toString();\n            File englishFile = new File(i18nPath + \"TranubeConstants_en.properties\");\n            if (!englishFile.exists()) throw new Exception(\"English file not found\");\n            String propertiesFilePath = i18nPath + \"TranubeConstants_\" + locale + \".properties\";\n            File file = new File(propertiesFilePath);\n            if (!file.exists()) {\n                FileReader in = new FileReader(englishFile);\n                FileWriter out = new FileWriter(file);\n                int c;\n                while ((c = in.read()) != -1) out.write(c);\n                in.close();\n                out.close();\n            }\n            InputStream is = ConfigurationServiceImpl.class.getResourceAsStream(\"/es/ua/tranube/prototype/main/client/TranubeConstants_\" + locale + \".properties\");\n            BufferedReader breader = new BufferedReader(new InputStreamReader(is));\n            String line = null;\n            StringBuilder strBuilder = new StringBuilder();\n            boolean found = false;\n            while ((line = breader.readLine()) != null) {\n                if (line.startsWith(\"#\")) strBuilder.append(line).append(\"\\n\"); else {\n                    String[] pieces = line.split(\"=\");\n                    if (pieces.length == 2) {\n                        if (pieces[0].trim().equals(messageName)) {\n                            strBuilder.append(pieces[0].trim() + \" = \" + messageValue + \"\\n\");\n                            found = true;\n                        } else strBuilder.append(line).append(\"\\n\");\n                    } else strBuilder.append(line).append(\"\\n\");\n                }\n            }\n            if (!found) strBuilder.append(messageName).append(\" = \").append(messageValue).append(\"\\n\");\n            breader.close();\n            is.close();\n            FileWriter writer = new FileWriter(file);\n            writer.write(strBuilder.toString());\n            writer.close();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n", "code2": "    public static String SHA(String source) {\n        logger.info(source);\n        String result = null;\n        try {\n            MessageDigest digest = MessageDigest.getInstance(\"SHA\");\n            digest.update(source.getBytes());\n            byte[] bytes = digest.digest();\n            result = EncodeUtils.hexEncode(bytes);\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        }\n        logger.info(result);\n        return result;\n    }\n", "label": 0, "substitutes": {"modifyApplicationMessage": ["modifyapplicationData", "modureAppData", "modifyapplicationMessage", "modifyAppmessage", "modureApplicationmessage", "modifyApplicationMsg", "modifyapplicationMsg", "modifyApplicationmessage", "modifyServerMessage", "modureAppMessage", "modifyServerMsg", "modureAppMsg", "modureApplicationData", "modureApplicationMsg", "modifyAppMsg", "modureAppmessage", "modifyServermessage", "modifyAppMessage", "modifyAppData", "modureApplicationMessage", "modifyApplicationData", "modifyServerData", "modifyapplicationmessage"], "locale": ["localaley", "locales", "LocALE", "locational", " locALE", "Locale", "Localey", "localales", "Locales", "localALE", "regational", " localey", " locales", "locALE", "regales", "localational", "localey", "regale", "Locational", "localale", " locational", "regALE"], "messageName": ["mediaKey", "MessageName", " messageNAME", "mediaNames", "MessageType", "msgValue", "msgType", "msgKey", "messageKey", "messageNames", "mediaNAME", "MessageKey", " messageNames", "mediaName", "MessageNAME", "MessageValue", "MessageNames", "messageNAME", "msgName", " messageType", " messageKey", "messageType"], "messageValue": ["msgvalue", " messageVal", "essageVal", "MessageVALUE", "messageVal", "MessageName", "essageName", "MessageType", "msgValue", "msgVALUE", "languagevalue", "languageName", "messageVALUE", "messagevalue", "Messagevalue", "languageVALUE", "MessageValue", "languageValue", "msgName", " messageType", "MessageVal", "essageValue", "essageType", "messageType"], "properties": ["report", "json", "prop", "settings", "options", "pid", "policy", "params", "parts", "utils", "details", "types", "profile", "ps", "message", "perties", "pro", "property", " props", "metadata", "project", " Properties", "config", "files", "pdf", "data", "results"], "i18nPath": ["i8lDir", "i8lUrl", "i18nyPath", "i18anDriver", "i18nUrl", "i8lStr", "i8nStr", "i18bStr", "i18lDir", "i18neUrl", "i18rDir", "i8lPath", "i18nDriver", "i18nePoints", "i18natP", "i18bUrl", "i18lUrl", "i18nyDir", "i18nePath", "i18anPath", "i18bPath", "i18nStr", "i18rIf", "i8nDir", "i18nIf", "i18natPoints", "i18bDir", "i18nP", "i18lStr", "i18neDriver", "i18neStr", "i18rDriver", "i18nyDriver", "i18anP", "i18natDriver", "i18neP", "i18anIf", "i18nPoints", "i18nDir", "i8nUrl", "i18lPath", "i18neDir", "i18nyIf", "i8nPath", "i18natPath", "i18rPath", "i18anPoints", "i18anDir"], "englishFile": ["enfile", "englishFilename", "ianafile", "languageFile", "ianaDir", " englishTable", "englishfile", "electricDir", "wikiTable", "ianaPort", "englishFiles", "ianaFile", "EnglishFiles", "ianaPath", "englishDir", "englishTable", "ianaTable", "electricDirectory", "languageFilename", "Englishfile", " englishfile", "EnglishFilename", "enFile", "electricFile", "enFilename", "electricPort", " englishPort", "languagefile", " englishDir", " englishDirectory", "wikifile", "wikiFile", "EnglishFile", "enFiles", "englishDirectory", "englishPath", " englishPath", "languageFiles", "englishPort", "wikiPath", "ianaDirectory"], "propertiesFilePath": ["pertiesfilepath", "pertiesfileName", "propertiesFileName", "propertiesFileType", "pertiesfileType", "propertiesFilesName", "settingsFileName", "propertiesfileLocation", "settingsFilepath", "propertiesFilepath", "settingsFileLocation", "pertiesFilepath", "propertiesfilepath", "propertiesFilenamepath", "propertiesfilePath", "propertiesFilenameType", "propertiesFilenameName", "propertiesfileType", "settingsFilePath", "settingsFilenamepath", "settingsFilenamePath", "pertiesFileType", "propertiesfileName", "propertiesFilesPath", "settingsFilenameName", "propertiesFilenameLocation", "propertiesFilenamePath", "propertiesFilespath", "pertiesFilePath", "propertiesFilesType", "pertiesfilePath", "propertiesFilesLocation", "settingsFilenameLocation", "pertiesFileName", "propertiesFileLocation"], "file": ["type", "f", "rule", "report", "handle", "style", "fi", "image", "output", "entry", "File", "console", "FILE", "comment", "resource", "application", "fp", "create", "page", "table", "run", "library", "module", "connection", "port", "base", "be", "attribute", "buffer", "write", "document", "message", "current", "result", "xml", "filename", "content", "format", "ile", "name", "complete", "os", "parent", "object", "path", "null", "language", "record", "model", "use", "channel", "domain", "local", "key", "info", "string", "files", "io", "class", "source", "pool", "print", "data"], "in": ["rin", "en", "inn", "ini", "gin", "IN", "ins", "ar", "ri", "reader", "oin", "al", "In", "init", "inner", "inside", "ic", "ai", "asin", "i", "read", "bin", "get", "inc", "input", "sin", "iter", "it", " din", "ir", "ain", "ind", "io", "din", "inf", "isin", "cin", "from"], "out": ["csv", "co", "nt", "con", "output", "cos", "put", "w", "set", "conv", "inner", "net", "write", "we", "log", "to", "print", "conf", "cache", "os", "external", "outer", "it", "sw", "ou", "at", "aos", "outs", "o", "again", "screen", "n", "io", "Out", "OUT", "check", "can", "end", "ex"], "c": ["rc", "co", "u", "con", "cos", "character", "\u00e7", "cb", "d", "cont", "cr", "C", "bc", "col", "t", "x", "ce", "cc", "code", "k", "ca", "char", "chain", "fc", "cu", "call", "v", "conf", "i", "ct", "cache", "ac", "gc", "pc", "cp", "cm", "l", "ec", "cod", "ch", "lc", "cd", "etc", "unc", "r", "nc", "count", "n", "mc", "arc", "cap", "cf", "dc", "cs", "cl"], "is": ["iris", "sit", "ins", "Is", "ri", "nis", "sys", "isa", "ais", "tis", "ic", "i", "its", "ris", "os", "IS", "it", "isc", "isl", "lis", "bis", "isf", "isi", "isin", "iso", "ios", "as", "iss", "\u00eds", "es", "sis"], "breader": ["brewe", " breadr", "bler", " breadder", "bbr", "breadr", " breadger", "bbar", " breade", " breadar", "breadder", "breadar", "browber", "bleder", "breade", "bleer", "browe", "brewer", "bbder", "brewger", "brewber", "breadber", "breadger", "bber", "browger", "brower", " breadber", "blear"], "line": ["phrase", "LINE", "lo", "rule", "handle", "block", "lin", "text", "eline", "entry", "ine", "sample", "email", "next", "column", "part", "comment", "frame", "lane", "se", "word", "ln", "left", "sequence", "lines", "page", "stroke", "port", "trace", "char", "chain", "range", "link", "log", "label", "code", "slice", "message", "cell", "ice", "detail", "node", "stay", "le", "liner", "entity", "l", "section", "iter", "query", "note", "nl", "parse", "point", "mail", "normal", "continue", "queue", "cmd", "record", "edge", "Line", "ip", "row", "string", "no", "inline", "online", "body", "shell", "side", "header"], "strBuilder": ["stringBuild", "strBuild", "stringParser", "objBuffer", "arrBuffer", "StrBuffer", "strBuilt", " strBu", "stringBuilder", " strbuilder", "arrbuilder", "Strbuilder", "frBuild", "strBu", "arrBu", " strParser", " strBuild", "objbuilder", "arrBuilder", "StrBuild", "objBuilder", "StrBuilder", "StrBu", "frBuilder", "strbuilder", "stringBuilt", " strBuffer", "strBuffer", "stringBuffer", "StrBuilt", "frBuilt", "strParser", "frParser", "StrParser", "arrBuild", "objBuild", "stringbuilder", "arrParser"], "pieces": ["terms", "maps", "services", "times", "cars", "links", "cuts", "strings", "feet", "parts", "piece", "items", "keys", "tools", "plates", "tips", "types", "lines", "letters", "finals", "bits", "pins", "fits", "places", "ps", "steps", "words", "its", "powers", "players", "knife", "Parts", "caps", "blocks", "eps", "ops", "ces", "xes", "fixes", "ctors", "groups", "sts", "sections", "pointers", "rings", "units", "bytes", "ties", "checks"], "found": ["first", "defined", "installed", "expected", "empty", "good", "focused", "Found", "opened", "find", "built", " Found", "finder", "changed", "finished", "done", "err", "old", "forced", "used", "available", "mounted", "supported", "read", "started", "released", "fixed", "printed", "successful", "success", "valid", "tested", "loaded", "search", "bool", "confirmed", " detected", "created", " founded", " caught", "sold", "ed", "sent", "count", "failed", "compl", "index", "needed", "identified", "filled", "given"]}}
{"id1": "14783950", "id2": "2461169", "code1": "    public static void compressWithZip(Vector fileList, String zipFileName) throws IOException {\n        if (fileList == null || fileList.size() == 0) return;\n        FileOutputStream fos = new FileOutputStream(zipFileName);\n        ZipOutputStream zos = new ZipOutputStream(fos);\n        Iterator iter = fileList.iterator();\n        while (iter.hasNext()) {\n            String fileName = (String) iter.next();\n            int ind = Math.max(fileName.lastIndexOf('/'), fileName.lastIndexOf('\\\\'));\n            String shortName = \"unknown\";\n            if (ind < fileName.length() - 1) shortName = fileName.substring(ind + 1);\n            zos.putNextEntry(new ZipEntry(shortName));\n            FileInputStream fis = new FileInputStream(fileName);\n            byte[] buf = new byte[10000];\n            int bytesRead;\n            while ((bytesRead = fis.read(buf)) > 0) zos.write(buf, 0, bytesRead);\n            fis.close();\n            zos.closeEntry();\n        }\n        zos.close();\n    }\n", "code2": "    public static boolean decodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.DECODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "label": 1, "substitutes": {"compressWithZip": ["compressByFiles", "composeWithoutExt", "compresswithZip", "composeWithoutzip", "composeWithFiles", "compresswithExt", "compressWithoutExt", "compressWithoutFiles", "composeWithzip", "composeWithZip", "compresswithzip", "compressWithFiles", "compressWithExt", "compresswithFiles", "compressByExt", "composeWithoutZip", "compressWithoutZip", "compressByZip", "compressWithoutzip", "composeWithExt", "compressByzip", "compressWithzip", "composeWithoutFiles"], "fileList": [" fileL", "resourceList", "tileIterator", "wordIterator", "fileLock", "fileCode", "pageList", "fileIterator", " fileIterator", "resourceNames", "itemLock", "pageL", "resourceLock", " fileLIST", "fileSet", "ileL", "ileList", "fileLIST", "filelist", "tileSet", "pagelist", "tileList", "wordList", "wordLIST", " FileCode", " fileSet", " FileLIST", "pageCode", "tileLIST", " filelist", "wordSet", " fileLock", "fileNames", " FileSet", " fileNames", "ilelist", " fileCode", "pageLIST", "fileL", "pageSet", " FileList", "ileLIST", "itemNames", "itemList"], "zipFileName": ["zipFilenamename", "zFileFilename", "zFilename", "zipDirNames", "zipileName", " zipFilePath", " zipfileFilename", "zipfilePath", " zipFileFilename", "zFilenamename", "zipFilenameName", "zFilenamePath", "zFilenameFilename", "zipFilenameNames", " zipfileName", " zipFileNames", "zipDirName", "zipfileNames", "zFilePath", "zipDirFilename", "zipileFilename", "zipFilenamePath", "zipFilename", "zipFileNames", "zipfileName", " zipfileNames", "zipfileFilename", "zipDirPath", "zipfilename", "zFileName", "zipFileFilename", "zFilenameName", "zipFilePath", " zipfilePath", "zipilename", "zipFilenameFilename", "zipilePath"], "fos": ["flis", "Foss", "foss", "loos", "flos", "foos", "los", "loss", "wOS", "wos", " foos", "fOS", "lfis", "Fos", "lOS", "lfoos", "floos", "woss", " fOS", "Foos", "lfOS", "FOS", "lfos", "flOS", "woos"], "zos": ["ze", "zag", "Sax", "ss", "nz", "ses", "zon", "z", "rys", "webkit", "zin", "oss", "js", "zb", "jas", "ws", "sbm", "zen", "ess", "zh", "hz", "los", "iaz", "ps", "zo", "ossus", "less", "enos", "zes", "han", "os", "ez", "za", "enz", "iners", "bes", "cz", "zan", "css", "zu", "eros", "zzle", "zip", "zers", "zar", "rez", "ippers", "hess", "zik", "zer", "zero", "zi", "es", "sis"], "iter": ["exp", "ser", "oper", "tr", "ee", "izer", "reader", "Iter", "inter", "here", "inner", "maker", "liter", "orient", "vis", "train", "Iterator", "list", "re", "i", "its", "ptr", "ator", "coll", "ait", "outer", "valid", "it", "former", "walker", "ver", "li", "order", "iver", "ir", "gener", "iv", "iner", "ip", "fer", "iterator", "el", "ger", "ner", "er", "is", "where", "loc", "cer", "user", "loop", "loader", "ter", "kit", "ipper"], "fileName": ["ilePath", "ileSet", " filename", " fileNumber", "getStore", "tableSet", "shortStore", "fileNAME", "shortname", "getSource", "FileName", "FileCurrent", " filePath", "fSource", "getName", " fileSource", "localList", "FileNames", "localName", "ileString", "fieldname", " fileCurrent", "fileSet", "ileList", "fieldNAME", "FileString", "shortSource", " fileString", "ileBody", "ileNumber", "tablePath", "fileStore", "fieldName", "fileCurrent", "filename", "ilename", "fName", " fileSet", "tableName", "localname", "ileNAME", " fileStore", "fString", "fBody", "fname", "fileBody", "localNAME", "Filename", "filePath", "fileNames", "ileCurrent", "ileName", "fNames", "fNumber", " fileNames", "FilePath", "ileSource", " fileBody", "getname", "fileSource", "fileString", "fileNumber", "fieldList"], "ind": ["pred", "div", "dj", "find", "j", "dial", "inn", "roll", "d", "draw", "IND", "mod", "md", "red", "pl", "Ind", "mind", "stick", "butt", "wind", "i", "req", "ded", "ptr", "td", "inc", "bind", "pos", "cand", "cond", "sign", "ent", "cod", "seed", "cd", "hend", "num", "kind", "typ", "count", "n", "att", "ld", "loc", "index", "inder", "med", "nd"], "shortName": [" shortname", "fullString", "recentname", "shortname", "shortFilename", "recentCode", "smallname", "smallName", "recentName", "Shortname", "ShortKey", "ShortType", "recentFilename", "quickName", " shortKey", "quickString", "ShortString", "ShortName", "fullName", " shortString", "quickKey", "smallFilename", "shortCode", "fullname", " shortType", "shortKey", "shortString", "smallCode", "fullType", "ShortFilename", "ShortCode", "quickname", "shortType"], "fis": ["fi", "Fis", "ufi", "cfis", "fris", " fris", "ufis", "sfi", "his", "Fris", "wis", "cfois", "hi", " fIs", "sfis", "ufois", "wois", "pi", "ufris", "sfIs", "wIs", "wi", "pris", "FIs", "fois", "sfois", "fIs", "pis", "pois", "hris", "hois", "cfris", "ufIs", "cfi"], "buf": ["seq", "cv", "tr", "block", "br", "buff", "var", "img", "cat", "ref", "orig", "bl", "cb", "bed", "bc", "conv", "box", "mem", "bus", "wb", "buffer", "pkg", "bag", "b", "fam", "cur", "db", "aka", "fg", "bin", "Buffer", "uf", "rb", "tab", "cmd", "mu", "batch", "bar", "Buff", "cap", "msg", "temp", "arr", "fb", "vec", "bytes"], "bytesRead": ["postsFind", "blocksRead", "secondsWritten", "blocksWrite", "bytesLength", "usersLoad", "secondsWrite", "linesNeed", "secondsLoad", "flowsFind", "usersFind", "flowsLoad", "blocksWritten", "secondsRead", " bytesLoad", "bytesLoad", "bytesFind", " bytesWritten", "flowsReady", "flowsRead", "bytesWritten", "BytesRead", "postsRead", " bytesWrite", "linesLength", "BytesLength", "usersRead", "linesWritten", " bytesLength", "bytesReady", "postsReady", "BytesWritten", "bytesNeed", "blocksLoad", " bytesNeed", "postsLoad", "bytesWrite", "BytesNeed", "linesRead", "usersReady"]}}
{"id1": "23273706", "id2": "14598566", "code1": "    public String[][] getProjectTreeData() {\n        String[][] treeData = null;\n        String filename = dms_home + FS + \"temp\" + FS + username + \"adminprojects.xml\";\n        String urlString = dms_url + \"/servlet/com.ufnasoft.dms.server.ServerGetAdminProjects\";\n        try {\n            String urldata = urlString + \"?username=\" + URLEncoder.encode(username, \"UTF-8\") + \"&key=\" + URLEncoder.encode(key, \"UTF-8\") + \"&filename=\" + URLEncoder.encode(username, \"UTF-8\") + \"adminprojects.xml\";\n            DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n            factory.setValidating(false);\n            DocumentBuilder parser = factory.newDocumentBuilder();\n            URL u = new URL(urldata);\n            DataInputStream is = new DataInputStream(u.openStream());\n            FileOutputStream os = new FileOutputStream(filename);\n            int iBufSize = is.available();\n            byte inBuf[] = new byte[20000 * 1024];\n            int iNumRead;\n            while ((iNumRead = is.read(inBuf, 0, iBufSize)) > 0) os.write(inBuf, 0, iNumRead);\n            os.close();\n            is.close();\n            File f = new File(filename);\n            InputStream inputstream = new FileInputStream(f);\n            Document document = parser.parse(inputstream);\n            NodeList nodelist = document.getElementsByTagName(\"proj\");\n            int num = nodelist.getLength();\n            treeData = new String[num][3];\n            for (int i = 0; i < num; i++) {\n                treeData[i][0] = new String(DOMUtil.getSimpleElementText((Element) nodelist.item(i), \"pid\"));\n                treeData[i][1] = new String(DOMUtil.getSimpleElementText((Element) nodelist.item(i), \"ppid\"));\n                treeData[i][2] = new String(DOMUtil.getSimpleElementText((Element) nodelist.item(i), \"p\"));\n            }\n        } catch (MalformedURLException ex) {\n            System.out.println(ex);\n        } catch (ParserConfigurationException ex) {\n            System.out.println(ex);\n        } catch (NullPointerException e) {\n        } catch (Exception ex) {\n            System.out.println(ex);\n        }\n        return treeData;\n    }\n", "code2": "    public static void copyFileByNIO(File in, File out) throws IOException {\n        FileChannel sourceChannel = new FileInputStream(in).getChannel();\n        FileChannel destinationChannel = new FileOutputStream(out).getChannel();\n        sourceChannel.transferTo(0, sourceChannel.size(), destinationChannel);\n        sourceChannel.close();\n        destinationChannel.close();\n    }\n", "label": 1, "substitutes": {"getProjectTreeData": ["getProjectTreeInfo", "getProjectNodeData", "getProjectListData", "getProjectNodedata", "getProjectListList", "getAppTreedata", "getApptreeList", "getProjectTreeList", "getProjecttreeInfo", "getAppTreeInfo", "getProjecttreeList", "getProjectListdata", "getApptreeData", "getApptreedata", "getProjectNodeList", "getProjecttreeData", "getProjecttreedata", "getProjectTreedata", "getApptreeInfo", "getAppTreeData", "getProjectListInfo", "getAppTreeList", "getProjectNodeInfo"], "treeData": ["reeList", "treeInfo", "towerValid", "treeList", " treeInfo", "TreeData", "TreeMap", "tableInfo", "statusDat", " treeValid", "listPart", "cacheData", "treeValid", "tableMap", "tableData", "statusData", "treeDat", "listDat", "TreeInfo", "tableDat", "reeMap", "cachePart", "reeData", "treePart", "treeMap", "listData", " treeMap", "tableValid", "tableList", "reeDat", " treeDat", "statusMap", " treeList", "cacheDat", "reeInfo", "towerDat", "towerData", " treePart"], "filename": ["txt", "nil", "generation", "json", "output", "original", "FILE", "uno", "URI", "fs", "fil", "fp", "river", "SourceFile", "directory", "fax", "jpg", "println", "ename", "lua", "ames", "url", "uri", "name", "URL", "fps", "ername", "localhost", "FN", "png", "sql", "metadata", "Filename", "path", "local", "key", "string", "location", "save", "temp", "file", "source", "fn", "root", "folder", "FIL", "latest", "username", "FS", "prefix", "title", "KEY"], "urlString": ["UrlSingle", "UrlString", "urlStr", "urlstring", "callService", "uriSite", " urlstring", "uristring", "lService", "urlSite", "lStr", "URLString", "uriString", "callString", "callStr", "urlSingle", " urlService", "Urlstring", "URLstring", "UrlSite", "callstring", "urlService", "lstring", "URLSingle", "uriSingle", "URLSite", "lString", " urlStr"], "urldata": ["udldatum", "urldatum", "urlenatum", "udlenATA", "urldeata", "udlenata", "urrdescription", "urldedata", "udldata", "urlfatum", " urldedata", " urldeata", " urldeATA", "urrdATA", "uriledATA", "uriledata", "udlenatum", "udldescription", "urldeATA", " urldatum", " urldATA", "urileddata", "urlfescription", "urledATA", "urlfATA", "uriledatum", "urldescription", "urlenescription", " urldeatum", " urlddata", "urledata", "udlenescription", "urlddata", "urldeatum", "urlenata", "urledatum", "urrdata", "udldATA", "urlenATA", "urlfata", "urrdatum", "urldATA", "urleddata"], "factory": ["Facter", "Fixture", "FFactory", "Factory", "votype", " fFactory", " facet", " frozen", "efacet", "vacter", "Facet", "efrozen", "facter", "affotype", "affFactory", "frozen", "fault", "vactory", "facixture", "Frozen", "facault", "affactory", "Fault", "facactory", "fFactory", "Fotype", "facacter", "fixture", "fotype", "vFactory", "affacter", " fault", "efFactory", "facet", " facter", " fixture", "efactory"], "parser": ["php", " parse", "au", "util", "policy", "bank", "utils", "builder", "reader", "processor", "fp", "conv", "x", "Reader", "command", "xml", " p", "sup", "writer", "arser", "sf", "jack", "dom", "pdf", "walker", "apache", "parse", "instance", " parsing", "manager", "actory", " df", "power", "io", "er", "fascist", "file", "Parser", "p", "loader", "df", "expression"], "u": ["ut", "su", "au", "us", "uv", "util", "h", "iu", "ue", "tu", "cu", "un", "ui", "ur", "lu", "url", "uri", "uf", "nu", "U", "ru", "l", "ua", "it", "uu", "mu", "ul", "ou", "uid", "o", "r", "io", "hu", "eu", "p", "fu"], "is": ["mis", "ist", "rys", "ms", "us", "iris", "ost", "oss", "ins", "Is", "im", "ar", "ri", "fs", "sys", "isa", "ais", "iu", "in", "dis", "abs", "ic", "ai", "ui", "its", "ires", "ris", "IS", "are", "ys", "has", "it", "isc", "ir", "ims", "si", "lis", "obs", "isl", "bis", "info", "io", "ists", "isi", "ios", "iso", "il", "iss", "ib", "es", "sis"], "os": ["ows", "oes", "dos", "ss", "Os", "ms", "us", "ost", "cos", "oss", "mos", "et", "osi", "oses", "ros", "fs", "sys", "bs", "ls", "oa", "uts", "ox", "pos", "out", "bos", "des", "ys", "ens", "ops", "or", "obs", "css", "s", "aos", "o", "osa", "OS", "io", "socket", "ios", "as", "oos", "so", "es", "ot"], "iBufSize": ["iLufSize", "iBufsize", "iBphSize", "iRufSIZE", "iBphSIZE", "iBuffCount", "iBuffLen", "iBuffSize", "iBufLength", "iRufLength", "iBbufLength", "iBulCount", "iBuffsize", "iBufCount", "iBuffLength", "iRbufLength", "iBbufCount", "iRbufCount", "iBbufSIZE", "iLbufsize", "iBbufLen", "iLufsize", "iRufSize", "iBulsize", "iBbufSize", "iLufLen", "iLbufCount", "iRbufSIZE", "iBufSIZE", "iBuffSIZE", "iBphCount", "iRbufSize", "iBulSize", "iLbufLen", "iRufCount", "iBulLen", "iBbufsize", "iBphLength", "iBufLen", "iLufCount", "iLbufSize"], "inBuf": ["InBuf", "inLbuff", "outBul", "outBBuff", "outBuf", "outRul", "InBuff", "inBigbuff", "inChbuf", "inRBuff", "outRBuff", "inBuc", " inRbuff", "inBlul", "InChuff", " inBbuff", "inBigbuf", "inLuc", "inBul", "inBbuf", " inRbuf", "inBufferBuff", "inLbuf", "InChbuf", "inBlBuff", "inRbuff", "inRbuf", "outRuf", "inRul", " inBbuf", "inChuf", " inBuc", "InBbuf", "inChuff", "inBiguf", "inRuc", "inBluf", "InChuf", "inBufferuff", "inBufferuf", "InChBuff", " inRuf", "inBufferul", "inChBuff", "inRuff", "inRuf", "inBbuff", "inLuf", "outBbuf", "inBlbuf", "inBBuff", "inBiguc", "outRbuf", "inBufferbuf", "inBuff", "InBBuff", " inRuc"], "iNumRead": ["inumRead", "iRemRead", "inumFind", "iNumWrite", "InumNeed", "iLenRun", "INumRun", "iRemWrite", "iinumRead", "aiNumberWrite", "aiNumberRead", "INumNeed", "inumDef", "iNUMRun", "iinumFind", "iNumPrint", "InumPrint", "INumRead", "InumRun", "iNumberFind", "iFatDef", "iFatFind", "aiNumberFind", "iFatRead", "iiNumDef", "InumRead", "iNumDef", "iiNumRead", "iLenNeed", "iRemFind", "inumRun", "aiNumFind", "inumPrint", "aiNumRead", "inumNeed", "iNUMRead", "iNumFind", "iNumberWrite", "iNumNeed", "iNUMNeed", "iNumRun", "iiNumFind", "iinumDef", "iLenPrint", "iNumberRead", "aiNumWrite", "iLenRead", "iNUMPrint", "INumPrint"], "f": ["fi", "fe", "bf", "y", "d", "af", "h", "fr", "fs", "fp", "fm", "fac", "t", "c", "b", "fd", "fc", "fax", "v", "e", "tf", "sf", "l", "fo", "g", "o", "n", "fa", "F", "cf", "file", "p", "df", "w"], "inputstream": ["iterstyle", "uploadform", " inputform", "InputStream", "Inputdraw", "inputdraw", "inputStream", "iterStream", "iterscreen", "uploadscreen", " inputStream", "uploaddraw", " inputdraw", "uploadstream", "iterstream", "Inputstyle", "inputscreen", "Inputscreen", "inputform", "inputstyle", "Inputstream", "uploadStream", "uploadstyle", "Inputform"], "document": ["browser", "window", "response", "application", "m", "doc", "article", "raw", "page", "ree", "context", "directory", "template", "command", "message", "Document", "result", "xml", "content", "number", "information", "node", "media", "complete", "dom", "tree", "apache", "object", "present", "ocument", "language", "collection", "model", "database", "n", "html", "file", "version", "ml", "df", "expression"], "nodelist": ["neodest", "nodeety", "nosteline", "nODist", "noyist", "nannodeemark", "nODelist", "nomelist", "nodeman", "nodeeline", "nondest", "nnodeelist", "nnodeemark", "nodeseline", "nannodeety", "nodeto", "nodeselist", " nodeseto", " nodeseline", "nodedemark", "neodeman", "snodeline", "nodeist", "nodeline", "nodeeman", "nodest", "nanodety", "nondelist", " nodeselist", "nnodeety", "nodeemark", "snodestyle", "neodeeman", "nodedety", " nodeline", "nodesist", "snodeeline", "snodemark", "nodeseto", "nodedeline", " nodeto", "nnodeist", "nodeestyle", " nodesist", "neodist", "nannodeist", "nodedestyle", "snodelist", "snodeestyle", "nostestyle", "snodeelist", "nondeman", "nomeman", "neodelist", "nodedelist", "nomist", "noyelist", "nanodist", "nodestyle", "nanodemark", "nODeto", "nodedist", "neodeist", "nodemark", "nostemark", "nodeelist", "nODeline", "neodeelist", "nomest", "noyeline", "nodety", "snodeemark", "nondist", "noyeto", "nanodelist", " nodist", "nodist", "nannodeelist", "nostelist", "neodeest", "nodeest"], "num": ["all", "coord", "nm", "su", "um", "con", "om", "m", "Number", "UM", "nam", "sum", "set", "mem", "net", "man", "mon", "perm", "multi", "current", "result", "max", "list", "uni", "un", "number", "NUM", "dim", "umer", "nu", "total", "alph", "proc", "mu", "cal", "np", "length", "mult", "nom", "mn", "count", "n", "no", "zero", "Num", "umi"], "i": ["mi", "major", "j", "ini", "us", "y", "z", "I", "ie", "them", "qi", "di", "im", "ri", "ei", "m", "iq", "ami", "ti", "x", "iu", "hi", "me", "in", "q", "init", "bi", "cli", "ic", "ci", "multi", "ai", "sim", "gi", "ui", "e", "pi", "ij", "l", "ix", "it", "ji", "this", "li", "xi", "\u0438", "history", "si", "my", "batch", "wi", "ip", "info", "n", "io", "ii", "index", "zi", "p", "a", "phi", "ex"]}}
{"id1": "9954926", "id2": "4562786", "code1": "    private void simulate() throws Exception {\n        BufferedWriter out = null;\n        out = new BufferedWriter(new FileWriter(outFile));\n        out.write(\"#Thread\\tReputation\\tAction\\n\");\n        out.flush();\n        System.out.println(\"Simulate...\");\n        File file = new File(trsDemoSimulationfile);\n        ObtainUserReputation obtainUserReputationRequest = new ObtainUserReputation();\n        ObtainUserReputationResponse obtainUserReputationResponse;\n        RateUser rateUserRequest;\n        RateUserResponse rateUserResponse;\n        FileInputStream fis = new FileInputStream(file);\n        BufferedReader br = new BufferedReader(new InputStreamReader(fis));\n        String call = br.readLine();\n        while (call != null) {\n            rateUserRequest = generateRateUserRequest(call);\n            try {\n                rateUserResponse = trsPort.rateUser(rateUserRequest);\n                System.out.println(\"----------------R A T I N G-------------------\");\n                System.out.println(\"VBE: \" + rateUserRequest.getVbeId());\n                System.out.println(\"VO: \" + rateUserRequest.getVoId());\n                System.out.println(\"USER: \" + rateUserRequest.getUserId());\n                System.out.println(\"SERVICE: \" + rateUserRequest.getServiceId());\n                System.out.println(\"ACTION: \" + rateUserRequest.getActionId());\n                System.out.println(\"OUTCOME: \" + rateUserResponse.isOutcome());\n                System.out.println(\"----------------------------------------------\");\n                assertEquals(\"The outcome field of the rateUser should be true: MESSAGE=\" + rateUserResponse.getMessage(), true, rateUserResponse.isOutcome());\n            } catch (RemoteException e) {\n                fail(e.getMessage());\n            }\n            obtainUserReputationRequest.setIoi(null);\n            obtainUserReputationRequest.setServiceId(null);\n            obtainUserReputationRequest.setUserId(rateUserRequest.getUserId());\n            obtainUserReputationRequest.setVbeId(rateUserRequest.getVbeId());\n            obtainUserReputationRequest.setVoId(null);\n            try {\n                obtainUserReputationResponse = trsPort.obtainUserReputation(obtainUserReputationRequest);\n                System.out.println(\"-----------R E P U T A T I O N----------------\");\n                System.out.println(\"VBE: \" + obtainUserReputationRequest.getVbeId());\n                System.out.println(\"VO: \" + obtainUserReputationRequest.getVoId());\n                System.out.println(\"USER: \" + obtainUserReputationRequest.getUserId());\n                System.out.println(\"SERVICE: \" + obtainUserReputationRequest.getServiceId());\n                System.out.println(\"IOI: \" + obtainUserReputationRequest.getIoi());\n                System.out.println(\"REPUTATION: \" + obtainUserReputationResponse.getReputation());\n                System.out.println(\"----------------------------------------------\");\n                assertEquals(\"The outcome field of the obtainUserReputation should be true: MESSAGE=\" + obtainUserReputationResponse.getMessage(), true, obtainUserReputationResponse.isOutcome());\n                assertEquals(0.0, obtainUserReputationResponse.getReputation(), 1.0);\n            } catch (RemoteException e) {\n                fail(e.getMessage());\n            }\n            obtainUserReputationRequest.setIoi(null);\n            obtainUserReputationRequest.setServiceId(null);\n            obtainUserReputationRequest.setUserId(rateUserRequest.getUserId());\n            obtainUserReputationRequest.setVbeId(rateUserRequest.getVbeId());\n            obtainUserReputationRequest.setVoId(rateUserRequest.getVoId());\n            try {\n                obtainUserReputationResponse = trsPort.obtainUserReputation(obtainUserReputationRequest);\n                System.out.println(\"-----------R E P U T A T I O N----------------\");\n                System.out.println(\"VBE: \" + obtainUserReputationRequest.getVbeId());\n                System.out.println(\"VO: \" + obtainUserReputationRequest.getVoId());\n                System.out.println(\"USER: \" + obtainUserReputationRequest.getUserId());\n                System.out.println(\"SERVICE: \" + obtainUserReputationRequest.getServiceId());\n                System.out.println(\"IOI: \" + obtainUserReputationRequest.getIoi());\n                System.out.println(\"REPUTATION: \" + obtainUserReputationResponse.getReputation());\n                System.out.println(\"----------------------------------------------\");\n                assertEquals(\"The outcome field of the obtainUserReputation should be true: MESSAGE=\" + obtainUserReputationResponse.getMessage(), true, obtainUserReputationResponse.isOutcome());\n                assertEquals(0.0, obtainUserReputationResponse.getReputation(), 1.0);\n            } catch (RemoteException e) {\n                fail(e.getMessage());\n            }\n            call = br.readLine();\n        }\n        fis.close();\n        br.close();\n        out.flush();\n        out.close();\n    }\n", "code2": "    private String GetResponse(URL url) {\n        String content = null;\n        try {\n            HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n            conn.setDoOutput(false);\n            conn.setRequestMethod(\"GET\");\n            if (conn.getResponseCode() == HttpURLConnection.HTTP_OK) {\n                BufferedReader br = new BufferedReader(new InputStreamReader(conn.getInputStream()));\n                String line;\n                while ((line = br.readLine()) != null) content += line;\n            } else {\n            }\n        } catch (MalformedURLException e) {\n            e.getStackTrace();\n        } catch (IOException e) {\n            e.getStackTrace();\n        }\n        return content;\n    }\n", "label": 0, "substitutes": {"simulate": ["simulates", "modulation", "smulate", "simure", "modulate", " simulation", "smure", "smulates", "smulation", "modure", "simulation", " simure", " simulates", "modulates"], "out": ["exp", "flush", "output", "ins", "t", "inner", "base", "c", "err", "print", "to", "up", "conf", "v", "gc", "state", "ent", "it", "ou", "nr", "n", "io", "Out", "f", "all", "handle", "nt", "res", "obj", "on", "sum", "conv", "buffer", "log", "net", "list", "cache", "name", "os", "tree", "hit", "cmd", "conn", "at", "batch", "ger", "manager", "gr", "store", "w", "report", "con", "put", "cn", "sys", "raw", "in", "write", "b", "e", "writer", "error", "last", "OU", "group", "outs", "aos", "o", "pool", "OUT", "pretty", "gen", "co", "client", "set", "help", "init", "go", "content", "copy", "outer", "null", "gov", "cfg", "inv", "screen", "p", "can", "ex"], "file": ["type", "f", "report", "handle", "play", "lock", "output", "File", "console", "FILE", "resource", "fp", "set", "table", "t", "port", "library", "base", "template", "connection", "buffer", "log", "b", "document", "message", "result", "db", "filename", "ile", "e", "format", "name", "le", "l", "input", "path", "model", "channel", "io", "source", "pool", "data"], "obtainUserReputationRequest": ["obtainUserReputionResponse", "obtainUserRepationError", "obtainUserRelutationQuery", "obtainUserReporationError", "obtainUserReputationsError", "obtainUserRepresentutationRequest", "obtainUserReputationTarget", "obtainUserReplutationResponse", "obtainUserReputionrequest", "obtainUserRepositoryRequest", "obtainUserRelutationsRequest", "obtainUserRelutationRequest", "obtainUserRepresentutationError", "obtainUserRepresentationResponse", "obtainUserReputionRequest", "obtainUserRepositoryTask", "obtainUserRepresentutationrequest", "obtainUserRepationQuery", "obtainUserRepresentationRequest", "obtainUserRepetitionRequest", "obtainUserReputationsResponse", "obtainUserReputationTask", "obtainUserRelutationsQuery", "obtainUserRepositoryResponse", "obtainUserReputationsTask", "obtainUserReputationsrequest", "obtainUserRepationTarget", "obtainUserRepositoryQuery", "obtainUserReputationError", "obtainUserRepresentutationTarget", "obtainUserRepetitionResponse", "obtainUserReputationsRequest", "obtainUserReputionQuery", "obtainUserRelutationTask", "obtainUserRepresentationrequest", "obtainUserRepresentationError", "obtainUserReputionTask", "obtainUserRepationrequest", "obtainUserReplutationRequest", "obtainUserReputationrequest", "obtainUserRepationRequest", "obtainUserRelutationResponse", "obtainUserRelutationsTask", "obtainUserReputationsTarget", "obtainUserReporationResponse", "obtainUserReporationRequest", "obtainUserRepetitionTarget", "obtainUserReporationQuery", "obtainUserRepresentationTarget", "obtainUserRepresentutationResponse", "obtainUserReplutationTarget", "obtainUserRepresentationQuery", "obtainUserReputionTarget", "obtainUserReputationsQuery", "obtainUserRelutationsResponse", "obtainUserRepationResponse", "obtainUserRepresentutationQuery", "obtainUserReputationQuery"], "obtainUserReputationResponse": ["obtainUserRepulationAnswer", "obtainUserRepulationResponse", "obtainUserReportutationResp", "obtainUserReputationResp", "obtainUserRepositoryResp", "obtainUserRepulationResp", "obtainUserRepulationService", "obtainUserReputationService", "obtainUserReportutationService", "obtainUserReputationsService", "obtainUserRepositoryResponse", "obtainUserReportositoryService", "obtainUserReportutationResponse", "obtainUserReportositoryAnswer", "obtainUserReportositoryResp", "obtainUserReputationAnswer", "obtainUserReputationsAnswer", "obtainUserRepositoryAnswer", "obtainUserRepositoryService", "obtainUserReportutationAnswer", "obtainUserReputationsResp", "obtainUserReputationsResponse", "obtainUserReportositoryResponse"], "rateUserRequest": ["rateOwnerAccess", "rateProxyResponse", "rateLineResponse", "rateuserCommand", "RateUserrequest", "rateLineCommand", "rateSampleRequ", "rateLineRequest", "rateUsersChange", " rateUserQuery", "rateUsersQuery", "rateJobResponse", "rateUserCommand", " rateUserrequest", "rateRowrequest", "rateSampleCommand", "scaleUserRequest", "RateUsersQUEST", "raceUserRequest", "rateOwnerResponse", "RateClientResponse", "RateLineQuery", "rateProxyRequest", "rateProxyQUEST", "RateUserResponse", "createuserRequest", "rateLineRequ", "rateDateResponse", "createuserrequest", "rateTimeRequest", "rateUserRecord", "RateUserChange", "raceRowRequest", "rateUsersResponse", "rateDateGrant", "rateuserQUEST", "scaleOwnerRequest", "RateUserQUEST", "rateUserrequest", "RateLineResponse", "rateClientrequest", "rateuserRequ", "rateProxyQuery", "rateJobChange", "rateClientResponse", "RateClientGrant", "RateUsersQuery", "createuserCommand", "rateTimerequest", "raceRowrequest", "raceUserrequest", "createUserCommand", "rateOwnerRecord", "rateUsersrequest", "rateUsersAccess", "rateuserResponse", "rateuserAccess", "RateUserGrant", "rateClientRequest", "createuserRequ", "scaleOwnerAccess", "rateTimeResponse", "rateuserrequest", "RateUsersrequest", "raceUserRecord", "createUserRequest", "rateSampleRequest", "raceRowRecord", "rateClientGrant", "rateLineGrant", "rateuserRequest", "rateUserRequ", "scaleUserResponse", "rateUserQUEST", "rateOwnerRequest", "rateRowJob", " rateUserJob", "RateUserQuery", "scaleUserAccess", "rateSamplerequest", "rateUsersRequest", "rateRowRequest", "createUserrequest", "rateOwnerrequest", "RateUsersResponse", "rateJobRequest", "rateLinerequest", "rateRowResponse", "rateUserChange", "scaleOwnerResponse", "rateUserAccess", "rateUsersQUEST", "RateUsersRequest", "rateLineQuery", "createUserRequ", "rateDateRequest", "rateUserGrant", "RateLinerequest", "RateLineRequest", "rateRowRecord", "rateUserQuery", "RateClientRequest", "rateuserQuery", "rateClientJob", "RateUserRequest", "rateUserJob", "RateUsersChange"], "rateUserResponse": [" rateUserresponse", "ratesClientMessage", "rateUserData", "RateUsersReply", "rateFileresponse", "rateFileResponse", "rateFileRequest", "ratesClientRequest", "rateControllerResponse", "rateFileReturn", "rateControllerResp", "RateUserResponse", "rateClientResp", "rateMethodResponse", " rateClientresponse", "rateDateResponse", "rateTimeRequest", "rateuserReply", "ratesUserRequest", "rateWordresponse", "rateClientReturn", "rateUsersStatus", "rateUsersResponse", "rateControllerRequest", "rateUserReturn", "ratesClientResponse", "rateDateVersion", " rateClientReturn", "rateWordRequest", "RateUserReply", "rateMemberReply", "rateTimeAnswer", "rateClientResponse", "rateClientresponse", "rateManagerResp", "rateUserReply", " rateClientResponse", "ratesClientResp", "rateMemberRequest", "rateMemberResponse", "rateuserResponse", "RateUsersresponse", " rateUserReturn", "ratesUserResponse", "rateClientRequest", "rateUserStatus", "rateTimeResponse", " rateUserAnswer", "rateuserRequest", "ratesUserMessage", "rateUsersresponse", "RateUserresponse", "rateClientMessage", "RateUserVersion", "rateWordReturn", "rateDateData", "rateControllerMessage", "rateManagerResponse", "rateUsersRequest", "ratesUserResp", "RateUsersResponse", "rateUserAnswer", "rateMethodRequest", "rateUserMessage", "rateMethodData", "RateUsersRequest", "rateManagerMessage", "rateuserresponse", "rateUsersReply", "rateUsersAnswer", "rateDateRequest", "rateTimeStatus", " rateUserStatus", "rateUserVersion", "rateManagerRequest", "rateWordResponse", "rateMemberresponse", "rateMethodVersion", "rateUserResp", "RateUserRequest", "RateUserData", "rateUserresponse", " rateClientRequest"], "fis": ["flis", "lIs", "fi", "Fis", "sfIS", " fisa", "fIS", "flisa", "liss", "lIS", "bi", " fi", "Fiss", "sfis", "fli", "fiss", "sfIs", "lis", "fisa", "bis", "sfiss", "FIs", "FIS", "fIs", "bisa"], "br": ["browser", "wr", "buf", "hr", "bt", "tr", "div", "bf", "bl", "bro", "mr", "bridge", "cr", "kr", "fr", "bh", "BR", "be", "ber", "bi", "gb", "ctr", "sr", "lr", "dr", "bp", "bm", "str", "Br", "ch", "nr", "adr", "ger", "gr", "vr", "shr", "bn", "pr", "bd"], "call": ["all", "report", "play", "block", "dial", "bridge", "test", "contact", "Call", "callback", "draw", "comment", "request", "execute", "frame", "word", "status", "trace", "ell", "code", "label", "command", "action", "c", "log", "function", "char", "message", "result", "called", "cell", "list", "url", "name", "str", "query", "cal", "continue", "line", "add", "inv", "use", "info", "n", "send", "cin", "check", "update"]}}
{"id1": "21425787", "id2": "18974466", "code1": "    private static void copyFile(File in, File out) {\n        try {\n            FileChannel sourceChannel = new FileInputStream(in).getChannel();\n            FileChannel destinationChannel = new FileOutputStream(out).getChannel();\n            sourceChannel.transferTo(0, sourceChannel.size(), destinationChannel);\n            sourceChannel.close();\n            destinationChannel.close();\n        } catch (IOException ex) {\n            ex.printStackTrace();\n        }\n    }\n", "code2": "    protected boolean copyFile(File sourceFile, File destinationFile) {\n        try {\n            FileChannel srcChannel = new FileInputStream(sourceFile).getChannel();\n            FileChannel dstChannel = new FileOutputStream(destinationFile).getChannel();\n            dstChannel.transferFrom(srcChannel, 0, srcChannel.size());\n            srcChannel.close();\n            dstChannel.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n            return false;\n        }\n        return true;\n    }\n", "label": 1, "substitutes": {"copyFile": ["CopyFiles", "copyFiles", " copyfile", "CopyByte", "transferFile", "copyfile", "transferByte", "copyByte", "CopyFile", "transferfile", " copyByte", "Copyfile", "transferFiles", " copyFiles"], "in": ["rin", "en", "inn", "gin", "ie", "IN", "vin", "ins", "ar", "on", "In", "old", "b", "ic", "up", "i", "inc", "l", "input", "it", "ind", "o", "el", "n", "din", "inf", "is", "isin", "source", "cin", "from"], "out": ["nt", "output", "oss", "w", "help", "t", "po", "net", "err", "c", "b", "to", "ot", "v", "i", "str", "os", "l", "ent", "it", "gt", "null", "ou", "at", "outs", "g", "o", "s", "n", "io", "Out", "source", "OUT", "p", "ne", "ex"], "sourceChannel": ["inputCh", "sourceMachine", "seedChannel", "srcCh", " sourceCh", "srcChan", "sourceCommand", "srcManager", "sourceConnection", "ourceClass", "srcClass", "seedPanel", "ourceChannel", "sourceManager", "seedCategory", "srcConnection", "sourceClass", "ourceConnection", "systemPanel", "startChannel", "startPanel", "sourceCategory", "inputChannel", "startMachine", "ourceChan", "systemChannel", "sourcePanel", "startCategory", "srcChannel", "inputConnection", "sourceCh", "inputChan", " sourceManager", "srcCommand", " sourceConnection", " sourceClass", "systemMachine", "sourceChan", "ourceCommand", "seedMachine", "ourceManager", " sourceChan", " sourceCommand", "systemCategory"], "destinationChannel": ["DestinationHandler", "destinochannel", "destinoChan", "restinationChan", "destensionChan", "restinoContext", "destinatedContext", "destinatorchannel", "destationContext", "restinochannel", "destationChannel", "DestensionConnection", "destinationsConnection", "destinationschannel", "destinatorHandler", "destinatorChan", "Destensionchannel", "destensionchannel", "destationHandler", "destensionConnection", "restinoChannel", "Destinationchannel", "destinationsChan", "destationChan", "DestensionChan", "DestinationChan", "destinationchannel", "restinoChan", "restinationContext", "DestationChannel", "destinationHandler", "destensionChannel", "destinationContext", "destinatedChan", "DestinationChannel", "destinationChan", "DestationHandler", "Destationchannel", "destationchannel", "destinatorChannel", "destinoChannel", "destinatedchannel", "destinatedChannel", "destinationConnection", "destationConnection", "DestensionChannel", "DestationChan", "destinationsChannel", "DestinationConnection", "destinoContext", "restinationChannel", "restinationchannel"]}}
{"id1": "841724", "id2": "732800", "code1": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "code2": "    public BufferedWriter createOutputStream(String inFile, String outFile) throws IOException {\n        int k_blockSize = 1024;\n        int byteCount;\n        char[] buf = new char[k_blockSize];\n        File ofp = new File(outFile);\n        ZipOutputStream zos = new ZipOutputStream(new FileOutputStream(ofp));\n        zos.setMethod(ZipOutputStream.DEFLATED);\n        OutputStreamWriter osw = new OutputStreamWriter(zos, \"ISO-8859-1\");\n        BufferedWriter bw = new BufferedWriter(osw);\n        ZipEntry zot = null;\n        File ifp = new File(inFile);\n        ZipInputStream zis = new ZipInputStream(new FileInputStream(ifp));\n        InputStreamReader isr = new InputStreamReader(zis, \"ISO-8859-1\");\n        BufferedReader br = new BufferedReader(isr);\n        ZipEntry zit = null;\n        while ((zit = zis.getNextEntry()) != null) {\n            if (zit.getName().equals(\"content.xml\")) {\n                continue;\n            }\n            zot = new ZipEntry(zit.getName());\n            zos.putNextEntry(zot);\n            while ((byteCount = br.read(buf, 0, k_blockSize)) >= 0) bw.write(buf, 0, byteCount);\n            bw.flush();\n            zos.closeEntry();\n        }\n        zos.putNextEntry(new ZipEntry(\"content.xml\"));\n        bw.flush();\n        osw = new OutputStreamWriter(zos, \"UTF8\");\n        bw = new BufferedWriter(osw);\n        return bw;\n    }\n", "label": 1, "substitutes": {"readAndRewrite": ["readAndResrite", "readAndResend", "readAndrewWrite", "readAndRepend", "readAndrewrites", "readAndRepWrite", "readAndResWrite", "readAndReprite", "readAndRewrites", "readAndrewrite", "readAndResrites", "readAndReprites", "readAndrewend", "readAndRewWrite", "readAndRewend"], "inFile": ["iFILE", " inFilename", "inputFilename", "inFilename", "INPlace", "inputFile", " infile", "INTime", "INFilename", "INFILE", "inPlace", "outfile", "initFilename", "INFace", "InFile", "outFilename", "inTime", "iFile", "iTime", "InFilename", "inputPlace", "inFILE", "inputFace", "docFile", "INFile", "initFile", "docTime", "docFILE", "initPlace", "docFilename", "initFace", "Infile", "infile", "iFilename", "inFace"], "outFile": ["reportFilename", "toFILE", "outFILE", "inFilename", "nameFILE", "reportfile", " outfile", "reportFile", "checkfile", "outfile", "checkFilename", "outFilename", "checkFile", "nameFilename", "toFilename", " outFILE", "reportFILE", "inFILE", " outFilename", "toFile", "namefile", "checkFILE", "tofile", "infile", "nameFile"], "iis": ["diiss", "iIs", "diIs", "Ii", "IIs", "iris", "aiIs", "liIs", "iiss", " iIs", "iisc", "iIS", "iiis", " ii", "liis", "eis", " iris", "iiisc", "dii", "Iiss", "diis", "aiIS", "aiis", "iiris", "liris", "Iis", "ii", " iiss", "eIs", " iIS", "liisc", " iisc", "iiIs", "eIS"], "dcmParser": ["dcrparser", " dcmReader", "dcommReader", " dpmListener", "DpmBuilder", "dfmLoader", "dromAssistant", "deromparser", "drumParser", "dpmAdapter", "Dpmparser", "dpmparser", "dpmAssistant", "drumReader", " dcmarser", " dpmarser", "dpmStatement", "DcmPar", "drumBuilder", "dcrParser", "decmReader", "dmmmReader", " dcmparser", "dfmReader", "dcomBuilder", "dpmParser", "dmoduleAssistant", "dpcPrivate", " dpmParser", "decmParser", "dcmPar", "deromParser", "dcmStatement", " dpmAssistant", "DpmReader", "dcmLoader", "dromListener", "dmoduleReader", "DpmPar", "dmmmAdapter", "dgrReader", "dpmPrivate", " dpmPar", "dcommParser", "dcomLoader", "dmmmParser", " dpmparser", "DcmBuilder", "dgrParser", "dcfReader", "dmReader", "dcmarser", "dromarser", " dcmAssistant", " dpmStatement", "dcrReader", "DcmReader", "dmmparser", " dcmLoader", "dcommListener", "dcmBuilder", "dromparser", "DpmAdapter", "dmmAdapter", "dcmListener", "dcomParser", " dpmReader", "dmmReader", "dpmListener", "dpmBuilder", " dpmBuilder", "dcmPrivate", " dcmStatement", "dcmReader", "dcfParser", "dfmParser", "dcmparser", " dcmPrivate", "dpmLoader", "dpmarser", "dmmarser", "dromReader", "dcmAssistant", "dcfStatement", "Dcmparser", "deromReader", "dmmParser", "dpcAssistant", "dpcReader", " dcmBuilder", "dgrStatement", "drumPar", "dmmmparser", "dpmReader", "decmarser", "deromarser", "dcrBuilder", "dgrPar", "dcfPar", "dmodulePrivate", " dpmLoader", "dcommAssistant", "dpcParser", "DcmAdapter", "dromParser", "dpmPar", "dmparser", "DcmParser", " dcmPar", " dcmListener", "dmarser", "DpmParser", "decmparser", "dmParser", "dcmAdapter", "dmoduleParser", "dfmBuilder", " dpmPrivate", "dcomReader"], "ds": ["services", "xs", "ss", "dos", "ads", "pd", "Ds", "dl", "DS", "ins", "d", "der", "js", "details", "ws", "fs", "sys", "bs", "gd", "sets", "ls", "qs", "hs", "ns", "in", "ps", "drivers", "db", "dds", "its", "sd", "sv", "rs", "os", "ys", "des", "eps", "dd", "dt", "data", "gs", "ims", " des", "pers", "s", "obs", " DS", "dx", "hd", "ods", "outs", "dat", "aos", "vs", "uds", "dq", "as", "da", "ils", "ks", "tes", "es", "bd", "df", "eds", "cs", "dh"], "pdReader": ["pdHelper", "hdReader", "hdParser", "vdReader", "dpCar", "pedCar", "dpRunner", "ddCar", "hdRead", "pdParser", "pedLoader", "hdWriter", "pdRunner", "pdLoader", "xdHelper", "ddRunner", "xdWriter", "pedRunner", "tdParser", "tdWriter", "ddRead", "vdHelper", "ddReader", "ddWriter", "ddParser", "pdCar", "vdWriter", "xdLoader", "pedReader", "tdReader", "xdReader", "pdRead", "dpLoader", "ddLoader", "ddHelper", "vdLoader", "dpReader", "tdRead"], "out": ["txt", "flush", "output", "ins", "cb", "tmp", "t", "inner", "err", "c", "to", "opt", "up", "v", "ent", "it", "gt", "ou", "nr", "n", "io", "msg", "Out", "all", "en", "nt", "res", "obj", "on", "sum", "conv", "one", "net", "log", "list", "over", "cache", "name", "os", "ch", "cmd", "conn", "at", "auto", "desc", "gr", " err", "id", "w", "con", "cn", "sys", "raw", "in", "we", "serv", "writer", "str", "s", "outs", "aos", "o", "pool", "OUT", "data", "gen", "co", "oss", "js", "client", "status", "inter", "go", "outer", "pos", "sw", "null", "cfg", "inv", "screen", "full", "p", "end", "ex"], "dcmEncParam": ["dmmEnParam", "dmmencMsg", "dcmEncCmd", "dcmEnNum", "dcmEnVal", "dcmencPar", "dcmEncMsg", "dcmEncVal", "dmmEncVal", "dmmencParam", "dcmEnPar", "dcmEscVal", "dmmencNum", "dcmencNum", "dmmEncPar", "dcmencParam", "dcmEscNum", "dcmEscPar", "dmmEnNum", "dmmEnPar", "dcmEncNum", "dcmDecCmd", "dmmEncNum", "dcmEnParam", "dcmEscParam", "dcmDecParam", "dmmencCmd", "dcmDecNum", "dmmEncCmd", "dmmEncMsg", "dcmDecMsg", "dcmEncPar", "dcmencCmd", "dcmencMsg", "dmmEncParam"], "pdWriter": ["pcWriting", "tdwriter", "pcwriter", "PDReader", "PDWrite", "pdEditor", "pdWrite", "PDWriter", "pidWrite", "pidWriter", "pcWriter", "dpEditor", "tdWriter", "dpWriter", "pdWriting", "tdEditor", "pidwriter", "pdwriter", "tdWrite", "tdWriting", "tdReader", "dpWrite", "pcWrite", "pidWriting", "PDEditor", "dpReader"]}}
{"id1": "19944975", "id2": "2461169", "code1": "    public void writeConfiguration(Writer out) throws IOException {\n        if (myResource == null) {\n            out.append(\"# Unable to print configuration resource\\n\");\n        } else {\n            URL url = myResource.getUrl();\n            InputStream in = url.openStream();\n            if (in != null) {\n                try {\n                    IOUtils.copy(in, out);\n                } finally {\n                    IOUtils.closeQuietly(in);\n                }\n            } else {\n                out.append(\"# Unable to print configuration resource\\n\");\n            }\n        }\n    }\n", "code2": "    public static boolean decodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.DECODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "label": 1, "substitutes": {"writeConfiguration": [" writeContent", "writeSettings", " writeConfig", "outputContent", "WriteContent", " writeSettings", "WriteSettings", "writeContent", "WriteConfig", "WriteConfiguration", "writeConfig", "outputSettings", "outputConfig", "outputConfiguration"], "out": ["all", "report", "nt", "con", "output", "res", "cast", "free", "h", "client", "set", "table", "help", "t", "log", "err", "c", "b", "to", "print", "result", "list", "up", "over", "v", "writer", "cm", " OUT", "outer", "ent", "OU", "ch", "this", "cmd", "conn", "null", "ou", "at", "outs", "aos", "o", "g", "group", "n", "io", "msg", "Out", "file", "pool", "OUT", "check", "p", "pretty", "w"], "url": ["f", "gl", "address", "ref", "dl", "service", "resource", "client", "bel", "ll", "base", "char", "link", "net", "sl", "cert", "rel", "mount", "uri", "URL", "name", "str", "rl", "l", "nl", "mail", "path", "rect", "r", "ssl", "pattern", "domain", "ret", "key", "http", "location", "file", "loc", "Url", "user", "abs"], "in": ["f", "rin", "en", "inn", "and", "gin", "con", "sample", "IN", "ins", "reader", "m", "on", "sum", "al", "In", "inner", "inside", "up", "i", "read", "bin", "none", "serv", "str", "l", "input", "sin", "it", " din", "st", "null", "ind", "r", "el", "ma", "mc", "io", "din", "is", "isin", "source", "file", "body", "cin", "user", "from"]}}
{"id1": "19335986", "id2": "9236363", "code1": "    public void uncaughtException(final Thread t, final Throwable e) {\n        final Display display = Display.getCurrent();\n        final Shell shell = new Shell(display);\n        final MessageBox message = new MessageBox(shell, SWT.OK | SWT.CANCEL | SWT.ICON_ERROR);\n        message.setText(\"Hawkscope Error\");\n        message.setMessage(e.getMessage() + \"\\nSubmit Hawkscope Error Report to Issue Tracker?\");\n        log.error(\"Uncaught exception\", e);\n        if (message.open() == SWT.OK) {\n            IOUtils.copyToClipboard(Version.getBugReport(e));\n            try {\n                Program.launch(Constants.HAWKSCOPE_URL_ROOT + \"issues/entry?comment=\" + URLEncoder.encode(\"Please paste the Hawkscope Error \" + \"Report here. It's currently copied to your \" + \"clipboard. Thank you for your support!\", Constants.ENCODING));\n            } catch (final Exception e1) {\n                Program.launch(Constants.HAWKSCOPE_URL_ROOT + \"issues/entry\");\n            }\n        }\n        shell.dispose();\n    }\n", "code2": "    private void unJarStart(String jarPath, String jarEntryStart) {\n        String path;\n        if (jarPath.lastIndexOf(\"lib/\") >= 0) path = jarPath.substring(0, jarPath.lastIndexOf(\"lib/\")); else path = jarPath.substring(0, jarPath.lastIndexOf(\"/\"));\n        String relPath = jarEntryStart.substring(0, jarEntryStart.lastIndexOf(\"/\"));\n        try {\n            new File(path + \"/\" + relPath).mkdirs();\n            JarFile jar = new JarFile(jarPath);\n            Enumeration<JarEntry> entries = jar.entries();\n            while (entries.hasMoreElements()) {\n                JarEntry entry = entries.nextElement();\n                String jarEntry = entry.getName();\n                if (jarEntry.startsWith(jarEntryStart)) {\n                    ZipEntry ze = jar.getEntry(jarEntry);\n                    File bin = new File(path + \"/\" + jarEntry);\n                    IOUtils.copy(jar.getInputStream(ze), new FileOutputStream(bin));\n                }\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n", "label": 1, "substitutes": {"uncaughtException": [" uncuredFailure", "uncurredError", " uncuredException", "uncaughtFailure", "uncaughtception", "uncurredException", "uncaughtError", "uncuredError", "uncuredception", "uncuredException", "uncappedException", " uncaughtFailure", "uncappedFailure", " uncaughtception", "uncurredception", "uncappedception", " uncaughtError", " uncuredError", "uncuredFailure", "uncappedError", "uncurredFailure", " uncuredception"], "t": ["f", "window", "Thread", "y", "task", "d", "h", " T", "m", "thread", " ti", "c", "b", "to", " tid", "tf", "l", "out", " th", " st", "g", "o", "n", "T", " title", "p", "title", "w"], "e": ["E", "event", "eeee", "f", "en", "fe", "u", "ie", "oe", "ee", "d", "et", "se", "a", "m", "x", "ce", "ae", "ea", "Error", "c", "err", "ef", "b", "i", "error", "ec", "it", "ele", "exc", "o", "ev", "r", "el", "ed", "eg", "te", "er", "de", "eu", "xe", "p", "es", "pe", "ex"], "display": ["browser", "report", "window", "lay", "style", "play", "layout", "DIS", "output", "console", "d", "draw", "details", "view", "table", "dis", "label", "link", "log", "b", "list", "scroll", "name", "position", "l", "Display", "this", "show", "present", "s", "screen", "session", "body", "print", "server", "render"], "shell": ["echo", "browser", "report", "window", "handle", "layout", "sb", "output", "console", "Shell", "storage", "view", "ro", "help", "library", "tool", "environment", "dis", "command", "buffer", "log", "scope", "b", "cli", "system", "ui", "program", "scroll", "sh", "hell", "l", "expression", "or", "tree", "nl", "form", "screen", "sound", "control", "ssh", "body", "quit", "board", "print", "server", "session"], "message": ["meter", "echo", "report", "window", "response", "Message", "layout", "essage", "image", "subject", "say", "email", "console", "hello", "comment", "request", "description", "application", "m", "summary", "view", "module", "trace", "template", "one", "label", "command", "log", "buffer", "open", "management", "menu", "document", "system", "result", "detail", "content", "position", "error", "payment", "metadata", "mail", "object", "show", "language", "question", "session", "manager", "member", "msg", "field", "button", "memory", "body", "translation", "title"], "e1": ["e2", "E0", "ee3", "E3", " e3", " e2", "e0", "ee0", "E1", "ee1", " e0", "E2", "ee2", "e3"]}}
{"id1": "12066447", "id2": "8932510", "code1": "    protected void truncate(final File file) {\n        LogLog.debug(\"Compression of file: \" + file.getAbsolutePath() + \" started.\");\n        if (FileUtils.isFileOlder(file, ManagementFactory.getRuntimeMXBean().getStartTime())) {\n            final File backupRoot = new File(this.getBackupDir());\n            if (!backupRoot.exists() && !backupRoot.mkdirs()) {\n                throw new AppenderInitializationError(\"Can't create backup dir for backup storage\");\n            }\n            SimpleDateFormat df;\n            try {\n                df = new SimpleDateFormat(this.getBackupDateFormat());\n            } catch (final Exception e) {\n                throw new AppenderInitializationError(\"Invalid date formate for backup files: \" + this.getBackupDateFormat(), e);\n            }\n            final String date = df.format(new Date(file.lastModified()));\n            final File zipFile = new File(backupRoot, file.getName() + \".\" + date + \".zip\");\n            ZipOutputStream zos = null;\n            FileInputStream fis = null;\n            try {\n                zos = new ZipOutputStream(new FileOutputStream(zipFile));\n                final ZipEntry entry = new ZipEntry(file.getName());\n                entry.setMethod(ZipEntry.DEFLATED);\n                entry.setCrc(FileUtils.checksumCRC32(file));\n                zos.putNextEntry(entry);\n                fis = FileUtils.openInputStream(file);\n                final byte[] buffer = new byte[1024];\n                int readed;\n                while ((readed = fis.read(buffer)) != -1) {\n                    zos.write(buffer, 0, readed);\n                }\n            } catch (final Exception e) {\n                throw new AppenderInitializationError(\"Can't create zip file\", e);\n            } finally {\n                if (zos != null) {\n                    try {\n                        zos.close();\n                    } catch (final IOException e) {\n                        LogLog.warn(\"Can't close zip file\", e);\n                    }\n                }\n                if (fis != null) {\n                    try {\n                        fis.close();\n                    } catch (final IOException e) {\n                        LogLog.warn(\"Can't close zipped file\", e);\n                    }\n                }\n            }\n            if (!file.delete()) {\n                throw new AppenderInitializationError(\"Can't delete old log file \" + file.getAbsolutePath());\n            }\n        }\n    }\n", "code2": "    @Override\n    public void doPost(HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {\n        InputStream is = null;\n        InputStream page = null;\n        OutputStream os = null;\n        String rootUrl = null;\n        try {\n            boolean isMultipart = ServletFileUpload.isMultipartContent(request);\n            if (!isMultipart) {\n                request.setAttribute(\"error\", \"Form isn't a multipart form\");\n                RequestDispatcher rd = request.getRequestDispatcher(\"/WEB-INF/error.jsp\");\n                rd.forward(request, response);\n            }\n            ServletFileUpload upload = new ServletFileUpload();\n            String webUrl = null;\n            FileItemIterator iter = upload.getItemIterator(request);\n            while (iter.hasNext()) {\n                FileItemStream item = iter.next();\n                String name = item.getFieldName();\n                if (name.equals(\"webpage\")) {\n                    is = item.openStream();\n                    ByteArrayOutputStream baos = new ByteArrayOutputStream();\n                    IOUtils.copy(is, baos);\n                    page = new ByteArrayInputStream(baos.toByteArray());\n                } else if (name.equals(\"weburl\")) {\n                    InputStream wpIs = null;\n                    try {\n                        webUrl = Streams.asString(item.openStream());\n                        URL u = new URL(webUrl);\n                        wpIs = new BufferedInputStream(u.openStream());\n                        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n                        IOUtils.copy(wpIs, baos);\n                        page = new ByteArrayInputStream(baos.toByteArray());\n                    } finally {\n                        IOUtils.closeQuietly(wpIs);\n                    }\n                } else if (name.equals(\"rooturl\")) {\n                    rootUrl = Streams.asString(item.openStream());\n                }\n            }\n            if (page == null) {\n                request.setAttribute(\"error\", \"Form doesn't have an html file\");\n                RequestDispatcher rd = request.getRequestDispatcher(\"/WEB-INF/error.jsp\");\n                rd.forward(request, response);\n            }\n            ToMailerDelegate delegate = new ToMailerDelegate(page, rootUrl);\n            os = new BufferedOutputStream(response.getOutputStream());\n            os.write(delegate.getMailer());\n            os.flush();\n        } catch (Exception e) {\n            streamException(request, response, e);\n        } finally {\n            IOUtils.closeQuietly(page);\n            IOUtils.closeQuietly(is);\n            IOUtils.closeQuietly(os);\n        }\n    }\n", "label": 1, "substitutes": {"truncate": ["trvalidize", "trculicate", "trvalidate", "trunicate", "extuncicate", "extuncation", "trunate", "trvalidation", "truncation", "extuncize", "extvalidation", "trunation", "extvalidate", "trvalidicate", "trculate", "extvalidize", "truncicate", "extuncate", "trunize", "trculation", "trculize", "truncize", "extvalidicate"], "file": ["event", "f", "type", "report", "handle", "image", "block", "lock", "File", "time", "FILE", "word", "frame", "resource", "foo", "fp", "create", "page", "table", "run", "port", "base", "work", "module", "spec", "be", "range", "log", "link", "attribute", "to", "template", "message", "current", "filename", "ile", "format", "e", "name", "le", "get", "out", "or", "tree", "this", "parent", "object", "path", "null", "dir", "line", "model", "use", "channel", "full", "local", "info", "zip", "io", "files", "class", "source", "user", "size", "from", "data"], "backupRoot": ["backuproot", "workupidBoot", "backureBoot", "backupsDir", " backupidDir", "backflowRoot", " backupDir", "backuperroot", "backupBoot", "BackupFolder", "backureDir", " backupidroot", "backupidroot", "backureRoot", " backupBox", "backupidBox", " backupidRoot", "backdownFolder", " backupidBox", "backumpBox", "backflowDir", "backupsRoot", "backuperRoot", "backmpRoot", "backupDir", "backupBox", "workupBoot", "backupHome", "backupidFolder", "backmpDir", "workupRoot", "backuperHome", "backupidBoot", " backuproot", "backumpRoot", "backdownDir", "workupidRoot", "backumproot", "backuperDir", "workupidHome", "workupidroot", "backmproot", "backupidHome", "backureHome", "backupidRoot", "BackupidRoot", "BackupidDir", "backupFolder", "workupDir", "backmpBoot", "workuproot", "backflowFolder", "backupidDir", "backdownRoot", "BackupidFolder", "backupsBox", "BackupRoot", "backupsroot", "BackupDir", "backumpDir", "workupHome", "backureroot", "workupidDir"], "df": ["f", "dp", "bf", "pd", "dl", "raf", "di", "d", "Def", "gd", "deb", "lf", "md", "dc", "fd", "dr", "db", "DF", "dm", "format", "def", "dim", "NF", "sd", "tf", "sf", "uf", "ds", "fun", " pdf", "dt", "dd", "dx", "cd", "hd", "mm", "cf", "dep", "tif", "pdf", "du"], "date": ["event", "year", "zone", "dates", "value", "today", "default", "output", "match", "future", "time", "frame", "resource", "daily", "dated", "create", "sum", "standard", "tag", "run", "day", "module", "range", "ate", "message", "content", "format", "number", "when", "name", "now", "down", "Date", "get", "days", "grade", "age", "dt", "note", "cal", "month", "dat", " day", "late", "string", "save", " Date", "start", "due", "version", "update", "data", "duration"], "zipFile": ["jsonfile", "pdffile", "zFilename", "logPath", "logfile", "ZipPath", "pdfFile", "zipfile", "ZipFile", "jsonFilename", "jsonStore", "zipFilename", "zipStream", "zStore", "logStore", "pdfPath", "zFile", "Zipfile", "jsonFile", "ZipStream", "logFile", "zipPath", "logFilename", "zfile", "zipStore", "logStream", "pdfStream"], "zos": ["ze", "Sax", "zag", "tz", "ss", "nz", "ses", "zon", "z", "ozo", "cos", "webkit", "zin", "oss", "js", "south", "zb", "jas", "oses", "ros", "bs", "sbm", "zen", "hs", "zona", "hz", "los", "asar", "esm", "zo", "stice", "enos", "zes", "os", "ez", "za", "shed", "enz", "bes", " sands", "sol", "cz", "zan", "sch", "ones", "css", "estro", "eros", "asio", "zzle", "zers", "rez", "zar", "hess", "zik", "zer", "zi", "sis"], "fis": ["lIs", "fi", "Fis", "dfIs", "fiis", "fiib", "foIs", "fisc", "if\u00eds", "cfis", "cfisc", "efisc", "dfis", "fiiss", "foia", "ofois", "sfits", "fier", "fib", " fiss", "Fisc", "ofisc", "fits", "ifIs", "f\u00eds", "cfiss", "Fiss", "dfiss", "sfis", "foi", " fois", "ifis", "sfisc", "fiss", "efis", "cfits", "Fia", "sfIs", "ofis", "Fier", "fia", "dfier", "li", "Fi", "fiois", "ef\u00eds", "lis", "sfier", " fib", "sfiss", "FIs", "F\u00eds", "fois", "lia", "efIs", "fIs", "ofib", "ofits", "ofiss", "ifisc"], "entry": ["event", "ion", "rance", "insert", "element", "and", "ie", "deep", "internal", "comment", "word", "resource", "office", "obj", "se", "option", "description", "set", "connection", "ce", "char", "ment", "command", "attribute", "delete", "zo", "cell", "tex", "xml", "e", "def", "ace", "entity", "section", "or", "ary", "ent", "ry", "object", "search", "record", "sheet", "add", "zip", "member", "Entry", "row", "key", "de", "data", "cue", "escape"], "buffer": ["phrase", "buf", "window", "block", "buff", "sample", "frame", "comment", "word", "view", "sequence", "page", "table", "category", "append", "library", "base", "template", "char", "code", "command", "attribute", "document", "message", "available", "stack", "letter", "cache", "variable", "Buffer", "iter", "length", "queue", "paste", "binary", "batch", "bar", "screen", "padding", "volume", "temp", "button", "memory", "zero", "header"], "readed": ["rededed", " readED", "READer", "READED", "readented", "redented", "readED", "findED", "reader", "READed", "readared", "indexED", "findared", "readableied", "readableared", "readableED", "Reader", "countd", "Readd", "reded", "counter", "indexented", " readented", "Readied", "indexeded", "Readared", "ReadED", "countED", "readied", "indexed", "READd", "readeded", "findied", "Readed", "redED", "finded", " readeded", "counted", "readableed", "readd"]}}
{"id1": "9796161", "id2": "11049257", "code1": "    public static String getMD5(String s) {\n        try {\n            MessageDigest m = MessageDigest.getInstance(\"MD5\");\n            m.update(s.getBytes(), 0, s.length());\n            return \"\" + new BigInteger(1, m.digest()).toString(16);\n        } catch (NoSuchAlgorithmException e) {\n            logger.error(\"MD5 is not supported !!!\");\n        }\n        return s;\n    }\n", "code2": "    public static String generate(boolean secure, boolean sep) throws UnknownHostException {\n        MessageDigest messagedigest;\n        StringBuilder stringbuffer = new StringBuilder();\n        try {\n            messagedigest = MessageDigest.getInstance(\"MD5\");\n        } catch (NoSuchAlgorithmException nosuchalgorithmexception) {\n            throw new RuntimeException(nosuchalgorithmexception);\n        }\n        StringBuffer stringbuffer2;\n        InetAddress inetaddress = InetAddress.getLocalHost();\n        long l = System.currentTimeMillis();\n        long l1 = 0L;\n        if (secure) l1 = _secureRand.nextLong(); else l1 = _rand.nextLong();\n        stringbuffer.append(inetaddress.toString());\n        stringbuffer.append(\":\");\n        stringbuffer.append(Long.toString(l));\n        stringbuffer.append(\":\");\n        stringbuffer.append(Long.toString(l1));\n        messagedigest.update(stringbuffer.toString().getBytes());\n        byte abyte0[] = messagedigest.digest();\n        StringBuffer stringbuffer1 = new StringBuffer();\n        for (int i = 0; i < abyte0.length; i++) {\n            int j = abyte0[i] & 0xff;\n            if (j < 16) stringbuffer1.append('0');\n            stringbuffer1.append(Integer.toHexString(j));\n        }\n        String s = stringbuffer1.toString();\n        stringbuffer2 = new StringBuffer();\n        if (sep) {\n            stringbuffer2.append(s.substring(0, 8));\n            stringbuffer2.append(\"-\");\n            stringbuffer2.append(s.substring(8, 12));\n            stringbuffer2.append(\"-\");\n            stringbuffer2.append(s.substring(12, 16));\n            stringbuffer2.append(\"-\");\n            stringbuffer2.append(s.substring(16, 20));\n            stringbuffer2.append(\"-\");\n            stringbuffer2.append(s.substring(20));\n            return stringbuffer2.toString();\n        } else {\n            return s;\n        }\n    }\n", "label": 1, "substitutes": {"getMD5": ["getMD7", "toSHA4", "toSHA7", "getMD4", "toSHA5", "toMD5", "getmd2", "getmd7", "getMD2", "toMD4", "toMD2", "getSHA2", "getmd5", "toMD7", "toSHA2", "getmd4", "getSHA4", "getSHA5", "getSHA7"], "s": ["f", "xs", "ss", "sb", "ses", "text", "ms", "y", " gets", "ends", "strings", "ins", "h", "js", "ws", "fs", "bs", "ls", "t", "ns", "sq", "c", "b", "ps", "ts", "S", "src", "v", "i", "its", "aws", "sv", "ats", "str", "rs", "os", "l", "data", "sql", "gs", "space", "g", "n", "sts", "string", "gets", "is", "source", "p", "es", "bytes", "ies", "abs"], "m": ["mi", "nm", "mask", "sm", "ms", "om", "y", "mr", "hm", "h", "mt", "managed", "fm", "mo", "mod", "mut", "me", "md", "em", "man", "perm", "rem", "rm", "made", "v", "dm", "e", "bm", "cm", "M", "l", "gm", "am", "mu", "g", "mc", "mm", "manager", "pm", "mk", "vm", "mac", "tm"]}}
{"id1": "1586662", "id2": "20414923", "code1": "    int doOne(int bid, int tid, int aid, int delta) {\n        int aBalance = 0;\n        if (Conn == null) {\n            bench.incrementFailedTransactionCount();\n            return 0;\n        }\n        try {\n            if (Benchmark.prepared_stmt) {\n                pstmt1.setInt(1, delta);\n                pstmt1.setInt(2, aid);\n                pstmt1.executeUpdate();\n                pstmt1.clearWarnings();\n                pstmt2.setInt(1, aid);\n                ResultSet RS = pstmt2.executeQuery();\n                pstmt2.clearWarnings();\n                while (RS.next()) {\n                    aBalance = RS.getInt(1);\n                }\n                pstmt3.setInt(1, delta);\n                pstmt3.setInt(2, tid);\n                pstmt3.executeUpdate();\n                pstmt3.clearWarnings();\n                pstmt4.setInt(1, delta);\n                pstmt4.setInt(2, bid);\n                pstmt4.executeUpdate();\n                pstmt4.clearWarnings();\n                pstmt5.setInt(1, tid);\n                pstmt5.setInt(2, bid);\n                pstmt5.setInt(3, aid);\n                pstmt5.setInt(4, delta);\n                pstmt5.executeUpdate();\n                pstmt5.clearWarnings();\n            } else {\n                Statement Stmt = Conn.createStatement();\n                String Query = \"UPDATE accounts\";\n                Query += \" SET Abalance = Abalance + \" + delta;\n                Query += \" WHERE Aid = \" + aid;\n                int res = Stmt.executeUpdate(Query);\n                Stmt.clearWarnings();\n                Query = \"SELECT Abalance\";\n                Query += \" FROM accounts\";\n                Query += \" WHERE Aid = \" + aid;\n                ResultSet RS = Stmt.executeQuery(Query);\n                Stmt.clearWarnings();\n                while (RS.next()) {\n                    aBalance = RS.getInt(1);\n                }\n                Query = \"UPDATE tellers\";\n                Query += \" SET Tbalance = Tbalance + \" + delta;\n                Query += \" WHERE Tid = \" + tid;\n                Stmt.executeUpdate(Query);\n                Stmt.clearWarnings();\n                Query = \"UPDATE branches\";\n                Query += \" SET Bbalance = Bbalance + \" + delta;\n                Query += \" WHERE Bid = \" + bid;\n                Stmt.executeUpdate(Query);\n                Stmt.clearWarnings();\n                Query = \"INSERT INTO history(Tid, Bid, Aid, delta)\";\n                Query += \" VALUES (\";\n                Query += tid + \",\";\n                Query += bid + \",\";\n                Query += aid + \",\";\n                Query += delta + \")\";\n                Stmt.executeUpdate(Query);\n                Stmt.clearWarnings();\n                Stmt.close();\n            }\n            if (Benchmark.transactions) {\n                Conn.commit();\n            }\n            return aBalance;\n        } catch (java.lang.Exception e) {\n            if (Benchmark.verbose) {\n                System.out.println(\"Transaction failed: \" + e.getMessage());\n                e.printStackTrace();\n            }\n            bench.incrementFailedTransactionCount();\n            if (Benchmark.transactions) {\n                try {\n                    Conn.rollback();\n                } catch (SQLException e1) {\n                }\n            }\n        }\n        return 0;\n    }\n", "code2": "    protected int deleteBitstreamInfo(int id, Connection conn) {\n        PreparedStatement stmt = null;\n        int numDeleted = 0;\n        try {\n            stmt = conn.prepareStatement(DELETE_BITSTREAM_INFO);\n            stmt.setInt(1, id);\n            numDeleted = stmt.executeUpdate();\n            if (numDeleted > 1) {\n                conn.rollback();\n                throw new IllegalStateException(\"Too many rows deleted! Number of rows deleted: \" + numDeleted + \" only one row should be deleted for bitstream id \" + id);\n            }\n        } catch (SQLException e) {\n            LOG.error(\"Problem deleting bitstream. \" + e.getMessage(), e);\n            throw new RuntimeException(\"Problem deleting bitstream. \" + e.getMessage(), e);\n        } finally {\n            cleanup(stmt);\n        }\n        return numDeleted;\n    }\n", "label": 1, "substitutes": {"doOne": [" DoApp", " Do1", "doApp", "DoOnce", " doApp", " DoOnce", " doOnce", "Do1", "doOnce", "do1", " do1", "DoApp", " DoOne", "DoOne"], "bid": ["bat", "wid", "bt", "sb", "bf", "pid", "tx", "bank", "based", "cb", "bh", "fed", "bs", "bc", "vid", "base", "sid", "bas", "bus", "bi", "buy", "mid", "b", "bb", "db", "berry", "hn", "bm", "bin", "oid", "sat", "rid", "hid", "wed", "batch", "uid", "ind", "bis", "did", "fin", "bn", "id", "bd"], "tid": ["ppid", " tpid", "ttbid", "tide", "tbid", "tId", "Tidem", "pids", "intid", "ttids", "pid", " tbid", "trid", "ttrid", "intide", "Tbid", "intId", "ttid", "Tide", " tId", "tidem", " tidem", "Tid", "intidem", "Tpid", "pId", " trid", "pbid", "tids", " tide", " tids", "tpid", "prid", "TId"], "aid": ["kid", "lay", "na", "pa", "alpha", "ance", "alias", "ant", "bank", "pid", "af", "said", "ar", "a", "ia", "sys", "authorized", "ared", "tt", "sha", "wan", "sid", "ae", "acc", "ca", "ay", "aud", "lan", "bb", "mid", "antis", "cas", "aka", "aa", "van", "ac", "ace", "oid", "ida", "sat", "Aid", "bind", "esa", "aida", "am", "dd", "aic", "med", "auth", "ard", "aw", "da", "sn", "uid", "hd", "ident", "ad", "ma", "did", "activity", "dev", "ity", "id", "card", "ta", "vid", "iat", "ab"], "delta": ["adacl", "rota", "sdota", "dbid", "Dota", "dapter", "adetime", "dota", "felta", "retime", "adelt", " delt", "dabid", "Dta", "sdelta", "relta", "sdelt", "Delta", "furation", "Dapter", " dta", "dta", "fota", "adota", "delt", " dota", " dapter", "Dbid", "Delt", "felt", "relt", "rta", "Duration", " dbid", " duration", "sdacl", "dacl", " detime", "adelta", "detime", "fapter", " dacl", "duration"], "aBalance": ["aaAmount", "aBal", "aaTransfer", "cabalance", " aStatus", " aStock", "caStock", "aTransfer", " abalance", "eAmount", " aTransfer", "aAmount", "ATransfer", "aStock", "eBalance", "sabalance", "ABal", "aaBal", "abalance", "ABalance", "aDelta", "caBalance", "aaBalance", " aAmount", "eBal", "eStatus", "aabalance", "aStatus", "caDelta", "saStock", "saBalance", " aBal", " aDelta", "saDelta", "Abalance", "aaStatus"], "RS": ["RO", "SS", "ERS", "RB", "PS", "VR", "OSS", "DS", "GC", "KS", "RD", "SR", "TS", "ILS", "Rs", "MS", "DR", "R", "GS", "NS", "ATS", "RW", "US", "USER", "JS", "VS", "Res", "YS", "RC", "RE", "rs", "WS", "IS", "RM", "RES", "CS", "PRES", "ARS", "RR", "HS", "MR", "NRS", "OS", "ADS", "ALS", "BS", "RP", "HR", "FS", "LS", "RT"], "Stmt": [" Stmm", "Stm", "stm", "stMT", " stmt", "STmp", " stmp", "stmm", "StMT", "Stmp", "stmp", "STm", " stm", "STMT", " StMT", " Stmp", "stmt", "STmm", "Stmm", " stMT", "STmt", " Stm"], "Query": ["Core", "Filter", "Clean", "Template", "Qu", "Call", "URI", "Term", "Code", "q", "Service", "Request", "Where", "Unit", "Fix", "Chain", " query", "Link", "Statement", "Report", "Make", "QL", "Update", "ERY", "Notice", "Body", "Init", "Test", "Message", "Module", "Host", "Find", "Format", "Function", "And", "SQL", "Check", "Activity", "Spec", "Question", "Description", "Rule", "Version", "Command", "Config", "Event", "query", "IQ", "Post", "Line", "When", "Remote", "Menu", "Policy", "Lock", "Send", "Wait", "Q", "Package", "Exp", "Str", "Conn", "Form", "General", "Comment", "Action", "Script", "Get", "Size", "Force", "Do"], "res": ["ows", "rc", "vals", "ress", "rows", "set", "ares", "ns", "cons", "resh", "resp", "result", "Res", "re", "VAL", "req", "ptr", "rs", "RES", "cond", "sol", "val", "conn", "ret", "Cons", "row", "rez", "results"]}}
{"id1": "6271502", "id2": "18570190", "code1": "    @Override\n    public InputStream getResourceByClassName(String className) {\n        URL url = resourceFetcher.getResource(\"/fisce_scripts/\" + className + \".class\");\n        if (url == null) {\n            return null;\n        } else {\n            try {\n                return url.openStream();\n            } catch (IOException e) {\n                return null;\n            }\n        }\n    }\n", "code2": "    public Processing getProcess(long processId) throws BookKeeprCommunicationException {\n        try {\n            synchronized (httpClient) {\n                HttpGet req = new HttpGet(remoteHost.getUrl() + \"/id/\" + Long.toHexString(processId));\n                HttpResponse resp = httpClient.execute(req);\n                if (resp.getStatusLine().getStatusCode() == HttpStatus.SC_OK) {\n                    try {\n                        XMLAble xmlable = XMLReader.read(resp.getEntity().getContent());\n                        if (xmlable instanceof Processing) {\n                            Processing p = (Processing) xmlable;\n                            return p;\n                        } else {\n                            throw new BookKeeprCommunicationException(\"BookKeepr returned the wrong thing for pointingID\");\n                        }\n                    } catch (SAXException ex) {\n                        Logger.getLogger(BookKeeprConnection.class.getName()).log(Level.WARNING, \"Got a malformed message from the bookkeepr\", ex);\n                        throw new BookKeeprCommunicationException(ex);\n                    }\n                } else {\n                    resp.getEntity().consumeContent();\n                    throw new BookKeeprCommunicationException(\"Got a \" + resp.getStatusLine().getStatusCode() + \" from the BookKeepr\");\n                }\n            }\n        } catch (HttpException ex) {\n            throw new BookKeeprCommunicationException(ex);\n        } catch (IOException ex) {\n            throw new BookKeeprCommunicationException(ex);\n        } catch (URISyntaxException ex) {\n            throw new BookKeeprCommunicationException(ex);\n        }\n    }\n", "label": 0, "substitutes": {"getResourceByClassName": ["getResourcebyclassType", "getResourcebyClassType", "getResourceByFileType", "getResourceByFileNames", "getResourcebyClassPath", "getResourceByPackagePath", "getResourcebyClassName", "getResourceByclassType", "getResourceByPackageName", "getResourceByclassPath", "getResourceByClassNames", "getResourceByPackageType", "getResourceByClassPath", "getResourceByclassName", "getResourceByFileName", "getResourcebyclassName", "getResourcebyclassPath", "getResourceByClassType", "getResourcebyClassNames", "getResourcebyclassNames", "getResourceByFilePath", "getResourceByclassNames", "getResourceByPackageNames"], "className": ["classesNAME", " classFamily", "classNAME", "CLASSNAME", "templateNAME", "classesType", " classType", "classType", " classNames", " classNAME", "classFamily", "ClassName", "templateName", "classesName", "Classname", "classNames", " classname", "templateFamily", "CLASSName", "classname", "ClassNames", "CLASSNames", "CLASSname", "ClassNAME", "templateType", "classesFamily"], "url": ["f", "browser", "gl", "address", "ref", "dl", "entry", "util", "service", "resource", "builder", "raw", "page", "ls", "web", "ll", "char", "abs", "link", "err", "sl", "log", "b", "bb", "impl", "lr", "result", "re", "rel", "mount", "uri", "URL", "name", "str", "rl", "get", "l", "or", "nl", "mail", "path", "rect", "mb", "ssl", "channel", "ret", "http", "location", "job", "button", "file", "loc", "Url", "user", "ml", "cl"]}}
{"id1": "62362", "id2": "3767903", "code1": "    public void convert(File src, File dest) throws IOException {\n        InputStream in = new BufferedInputStream(new FileInputStream(src));\n        DcmParser p = pfact.newDcmParser(in);\n        Dataset ds = fact.newDataset();\n        p.setDcmHandler(ds.getDcmHandler());\n        try {\n            FileFormat format = p.detectFileFormat();\n            if (format != FileFormat.ACRNEMA_STREAM) {\n                System.out.println(\"\\n\" + src + \": not an ACRNEMA stream!\");\n                return;\n            }\n            p.parseDcmFile(format, Tags.PixelData);\n            if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) {\n                System.out.println(\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n                return;\n            }\n            boolean hasPixelData = p.getReadTag() == Tags.PixelData;\n            boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12;\n            int pxlen = p.getReadLength();\n            if (hasPixelData) {\n                if (inflate) {\n                    ds.putUS(Tags.BitsAllocated, 16);\n                    pxlen = pxlen * 4 / 3;\n                }\n                if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) {\n                    System.out.println(\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                    return;\n                }\n            }\n            ds.putUI(Tags.StudyInstanceUID, uid(studyUID));\n            ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID));\n            ds.putUI(Tags.SOPInstanceUID, uid(instUID));\n            ds.putUI(Tags.SOPClassUID, classUID);\n            if (!ds.contains(Tags.NumberOfSamples)) {\n                ds.putUS(Tags.NumberOfSamples, 1);\n            }\n            if (!ds.contains(Tags.PhotometricInterpretation)) {\n                ds.putCS(Tags.PhotometricInterpretation, \"MONOCHROME2\");\n            }\n            if (fmi) {\n                ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian));\n            }\n            OutputStream out = new BufferedOutputStream(new FileOutputStream(dest));\n            try {\n            } finally {\n                ds.writeFile(out, encodeParam());\n                if (hasPixelData) {\n                    if (!skipGroupLen) {\n                        out.write(PXDATA_GROUPLEN);\n                        int grlen = pxlen + 8;\n                        out.write((byte) grlen);\n                        out.write((byte) (grlen >> 8));\n                        out.write((byte) (grlen >> 16));\n                        out.write((byte) (grlen >> 24));\n                    }\n                    out.write(PXDATA_TAG);\n                    out.write((byte) pxlen);\n                    out.write((byte) (pxlen >> 8));\n                    out.write((byte) (pxlen >> 16));\n                    out.write((byte) (pxlen >> 24));\n                }\n                if (inflate) {\n                    int b2, b3;\n                    for (; pxlen > 0; pxlen -= 3) {\n                        out.write(in.read());\n                        b2 = in.read();\n                        b3 = in.read();\n                        out.write(b2 & 0x0f);\n                        out.write(b2 >> 4 | ((b3 & 0x0f) << 4));\n                        out.write(b3 >> 4);\n                    }\n                } else {\n                    for (; pxlen > 0; --pxlen) {\n                        out.write(in.read());\n                    }\n                }\n                out.close();\n            }\n            System.out.print('.');\n        } finally {\n            in.close();\n        }\n    }\n", "code2": "    public static void copy(File source, File destination) throws FileNotFoundException, IOException {\n        if (source == null) throw new NullPointerException(\"The source may not be null.\");\n        if (destination == null) throw new NullPointerException(\"The destination may not be null.\");\n        FileInputStream sourceStream = new FileInputStream(source);\n        destination.getParentFile().mkdirs();\n        FileOutputStream destStream = new FileOutputStream(destination);\n        try {\n            FileChannel sourceChannel = sourceStream.getChannel();\n            FileChannel destChannel = destStream.getChannel();\n            destChannel.transferFrom(sourceChannel, 0, sourceChannel.size());\n        } finally {\n            try {\n                sourceStream.close();\n                destStream.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n", "label": 1, "substitutes": {"convert": ["Converting", "compvert", "converts", "unverted", "consvert", "Conprocess", "CONversion", "converted", "Conversion", "unprocess", "confer", "unfer", "Confer", "unvert", "unverts", "compverts", "ConVERT", "Converted", "CONvert", "conversion", "conprocess", "CONfer", "Convert", "CONverted", "unversion", "compversion", "compprocess", "consversion", "converting", "CONverting", "consVERT", "consverting", "conVERT", "CONVERT", "Converts"], "src": ["ser", "buster", "rc", "txt", "hl", "scan", "usr", "attr", "img", "orig", "func", "ins", "sit", "cont", "sys", "stream", "SourceFile", "sq", "addr", "rest", "pkg", "cur", "sr", "rel", "filename", "ur", "Source", "its", "req", "url", "uri", "RC", "rs", "str", "SOURCE", "inst", "input", "upload", "sin", "rx", "sc", "st", "path", "ource", "s", "iv", "scene", "href", "http", "config", "dist", "start", "file", "source", "loc", "ipl", "ebin", "from", "host", "cc"], "dest": ["txt", "img", " destinations", "gin", "orig", "test", "disk", "est", "table", "port", "rest", "write", " Dest", "result", " dst", "mat", "target", "foreign", " orig", " destination", "dir", "dat", "Dest", "dist", "temp", " Destination", "source", "tif"], "in": ["en", "rin", "inn", "res", "IN", "ins", "d", "ar", "reader", "m", "stream", "In", "inner", "b", "up", "i", "bin", "serv", "l", "input", "sql", "st", "ind", "r", "el", "ad", "io", "din", "inf", "is", "isin", "source", "as", "file", "cin", "from"], "p": ["f", "php", "pa", "pb", "dp", "j", "pd", "tp", "rep", "vp", "sp", "d", "py", "parser", "part", "h", "op", "pp", "m", "fp", "t", "pl", "c", "pkg", "b", "pg", "ps", "ping", "post", "pro", "i", "cp", "ph", "pc", "pt", "pi", "l", "it", "per", "parse", "P", "pers", "at", "lp", "pre", "g", "r", "jp", "pm", "er", "wp", "prot", "pe", "ap"], "ds": ["dates", "dp", "di", " ads", "scripts", "loads", "yes", "qs", "tests", "ns", "ps", "drivers", "db", "dds", "sd", "ats", "dt", " DS", "ports", "ras", "terms", "ss", "DS", "ws", "bs", "docs", "hs", "workers", "iffs", "lists", "os", "edes", "gs", " dd", "hd", "vs", " d", "uds", "ils", "eds", "xs", "tags", "Ds", "dl", "els", "sets", "gd", "ls", "ts", "ags", "rs", " des", "obs", "s", "outs", "ods", "sts", "posts", "ands", "tes", "cs", "amps", "dos", "ads", "pd", "tp", "mys", "d", "cks", "js", " os", "its", "aws", "ys", "des", "eps", "dd", "ks", "points", "df", "nas", "dh"], "format": ["type", "f", "style", "layout", "settings", "output", "policy", "MAT", "feature", "mt", "fm", "set", "status", "table", "tag", "t", "feat", " Format", "module", "template", "sche", "spec", "fc", "shape", "mode", "Format", "ct", "act", "mat", "name", "ats", "pi", "top", "l", "it", "parse", "form", "path", "at", "filter", "lat", "pattern", "id", "cf", "file", "source", "size", "unit", "version", "pretty", "title"], "hasPixelData": ["HaspixelDATA", "hasixelData", "hasPixelDATA", "Haspixeldata", "hasPixeldata", "HasPixelDATA", "HaspixelData", "hasFrameData", "hasFrameDATA", "haspixelDATA", "hasFramedata", "HasPixeldata", "haspixeldata", " hasPixelDATA", " hasPixeldata", "hasixeldata", "hasixelDATA", "HasPixelData", "haspixelData"], "inflate": ["inFLated", "Inflate", "invalidATE", "inFLat", "inFLocate", "incelate", " invalidicate", "infolat", "Inflat", "invalidate", "inFlicate", "inflATE", "inflated", "incelicate", " inflocate", "incelocate", "Informocate", "Informated", "incelATE", "inFlATE", " inflicate", "inFlate", " invalidate", "informat", "infolated", "Inflocate", "inflicate", "inFlocate", "infolocate", "informocate", "informate", "Informat", "invalidicate", "Inflated", " inflATE", "inflocate", "informated", "Informate", "inFLate", "invalidocate", " invalidATE", "inflat", " invalidocate", "infolate"], "pxlen": ["pxln", "mmlin", "packlen", "pxlength", "cpln", "xplength", "cplength", "phpln", "pixellength", "pxlin", "cpden", "mxlength", "cplen", "packlength", "pexlength", "xylen", "mmlen", "pxdec", "tmpln", "packdec", "phplength", "pexln", "mxdec", "packfun", "pexls", "mxlen", "pxls", "pxfun", "xylin", "xyln", "tmplin", "xpden", "mxln", "tmplen", "pexlen", "pxden", "phplen", "pexfun", "mmlength", "pixelfun", "packls", "xpln", "phpdec", "pixells", "pexden", "tmplength", "xplen", "packln", "mmln", "pixellen", "xylength"], "out": ["output", "res", "obj", "ln", "client", "sys", "sum", "inter", "init", "net", "log", "print", "err", "list", "up", "crit", "name", "writer", "outer", "cmd", "conn", "gov", "ou", "group", "aos", "outs", "dir", "cfg", "inv", "screen", "gr", "io", "msg", "temp", "Out", "OUT", "user", "store", "pretty", "prefix", "ex"]}}
{"id1": "293167", "id2": "8166767", "code1": "    public static void doVersionCheck(View view) {\n        view.showWaitCursor();\n        try {\n            URL url = new URL(jEdit.getProperty(\"version-check.url\"));\n            InputStream in = url.openStream();\n            BufferedReader bin = new BufferedReader(new InputStreamReader(in));\n            String line;\n            String version = null;\n            String build = null;\n            while ((line = bin.readLine()) != null) {\n                if (line.startsWith(\".version\")) version = line.substring(8).trim(); else if (line.startsWith(\".build\")) build = line.substring(6).trim();\n            }\n            bin.close();\n            if (version != null && build != null) {\n                if (jEdit.getBuild().compareTo(build) < 0) newVersionAvailable(view, version, url); else {\n                    GUIUtilities.message(view, \"version-check\" + \".up-to-date\", new String[0]);\n                }\n            }\n        } catch (IOException e) {\n            String[] args = { jEdit.getProperty(\"version-check.url\"), e.toString() };\n            GUIUtilities.error(view, \"read-error\", args);\n        }\n        view.hideWaitCursor();\n    }\n", "code2": "    public Object invoke(MethodInvocation invocation, int retryTimes) throws Throwable {\n        retryTimes--;\n        try {\n            String url = getServiceUrl() + \"/\" + invocation.getMethod().getName();\n            HttpPost postMethod = new HttpPost(url);\n            if (invocation.getMethod().getParameterTypes().length > 0) postMethod.setEntity(new StringEntity(JsonUtils.toJson(invocation.getArguments())));\n            HttpResponse rsp = HttpClientUtils.getDefaultInstance().execute(postMethod);\n            StatusLine sl = rsp.getStatusLine();\n            if (sl.getStatusCode() >= 300) {\n                throw new RuntimeException(\"Did not receive successful HTTP response: status code = \" + sl.getStatusCode() + \", status message = [\" + sl.getReasonPhrase() + \"]\");\n            }\n            HttpEntity entity = rsp.getEntity();\n            StringBuilder sb = new StringBuilder();\n            InputStream is = entity.getContent();\n            BufferedReader reader = new BufferedReader(new InputStreamReader(is, \"utf-8\"));\n            String line;\n            while ((line = reader.readLine()) != null) sb.append(line).append(\"\\n\");\n            reader.close();\n            is.close();\n            String responseBody = null;\n            if (sb.length() > 0) {\n                sb.deleteCharAt(sb.length() - 1);\n                responseBody = sb.toString();\n            }\n            Type t = invocation.getMethod().getGenericReturnType();\n            if (t.equals(Void.class) || responseBody == null) return null;\n            return JsonUtils.fromJson(responseBody, t);\n        } catch (ConnectTimeoutException e) {\n            if (retryTimes < 0) throw e;\n            if (urlFromDiscovery) {\n                String serviceUrl = discoverServiceUrl(getServiceInterface().getName());\n                if (!serviceUrl.equals(getServiceUrl())) {\n                    setServiceUrl(serviceUrl);\n                    log.info(\"relocate service url:\" + serviceUrl);\n                }\n            }\n            return invoke(invocation, retryTimes);\n        }\n    }\n", "label": 1, "substitutes": {"doVersionCheck": ["DoDatecheck", "doDateCheck", "doVersionsCheck", "DoDateFix", "doVersionFix", "doLicensecheck", "DoVersioncheck", "DoVersionCheck", "DoVersionFix", "DoDateCheck", "doDateUpdate", "doDateFix", "DoDateUpdate", "DoVersionUpdate", "doVersionsUpdate", "doVersionsFix", "doDatecheck", "doVersionUpdate", "doLicenseFix", "doVersionscheck", "doLicenseCheck", "doVersioncheck", "doLicenseUpdate"], "view": ["browser", "report", "window", "hl", "cv", "layout", "image", "block", "subject", "util", "console", "engine", "client", "doc", "VIEW", "tv", "views", "table", "help", "context", "web", "page", "update", "q", "buffer", "open", "document", "call", "cell", "v", "widget", "review", "see", "iew", "host", "get", "input", "out", "wrapper", "query", "this", "controller", "tree", "form", "show", "component", "blade", "eye", "model", "View", "manager", "self", "row", "http", "html", "server", "file", "check", "index", "print", "display"], "url": ["f", "browser", "hl", "gl", "address", "json", "dl", "lb", "client", "bel", "web", "ls", "ll", "char", "date", "link", "pl", "sl", "log", "b", "lr", "rel", "ur", "v", "mount", "org", "uri", "URL", "str", "rl", "l", "oul", "nl", "ul", "path", "null", "language", "github", "r", "ssl", "http", "html", "socket", "string", "location", "file", "loc", "Url", "id", "host"], "in": ["f", "rin", "inn", "gin", "IN", "vin", "ins", "reader", "ln", "stream", "In", "init", "inner", "b", "asin", "kin", "i", "mat", "inc", "l", "input", "out", "sin", " IN", " din", "ain", "mn", "info", "n", "din", "inf", "is", "isin", "source", "file", "body", "cin"], "bin": ["rin", " Bin", "win", "inn", "buff", "stock", "by", "gin", "con", "bl", "bg", "cos", "obin", "reader", "bur", "ln", "bed", "pipe", "inner", "mem", "bi", "spin", "buffer", "b", "mon", "thin", "ran", "nb", " bins", "lib", "abin", "cache", "rb", "out", "sin", "len", " din", "conn", "binary", "local", "din", "sam", "file", "bn", "cin", "ebin", "loader"], "line": ["LINE", "lo", "style", "lin", "block", "text", "cat", "eline", "entry", "ine", "sample", "column", "part", "comment", "frame", "lane", "se", "ln", "ide", "word", "lines", "page", "ls", "col", "level", "base", "trace", "char", "chain", "range", "link", "log", "code", "one", "err", "load", "port", "cell", "ice", "state", "le", "liner", "l", "section", "iter", "cmd", "point", "path", "record", "Line", "el", "channel", " Line", "row", "string", "job", "no", "field", "inline", "file", "body", "store", "print"], "version": ["type", "browser", "ion", "translation", "major", "video", "license", "image", "value", "virtual", "match", "test", "versions", "serial", "release", "feature", "resource", "description", "client", "sequence", "river", "status", "tag", "VER", "Version", "software", "spec", "date", "command", "v", "number", "format", "vision", "name", "position", "hash", "project", "form", "language", "info", "key", "volume", "string", "scale", "vers", "usage", "iso", "VERSION", "latest", "index", "ver", "update", "python", "title"], "build": ["building", "style", "built", "match", "test", "fail", "util", "release", "builder", "other", "update", "tag", "work", "date", "link", "round", "ship", "log", "th", "load", "b", "old", "be", "db", "hold", "lib", "hash", "last", "Build", "project", "boost", "binary", "add", "use", "bor", "ble", "full", "make", "uild", "arch", "dist", "bug", "develop", "install", "where", "latest", "ward", "ver", "unit", "dev", "print", "struct"]}}
{"id1": "9109613", "id2": "4164833", "code1": "    public static void fileCopy(String from_name, String to_name) throws IOException {\n        File fromFile = new File(from_name);\n        File toFile = new File(to_name);\n        if (fromFile.equals(toFile)) abort(\"cannot copy on itself: \" + from_name);\n        if (!fromFile.exists()) abort(\"no such currentSourcepartName file: \" + from_name);\n        if (!fromFile.isFile()) abort(\"can't copy directory: \" + from_name);\n        if (!fromFile.canRead()) abort(\"currentSourcepartName file is unreadable: \" + from_name);\n        if (toFile.isDirectory()) toFile = new File(toFile, fromFile.getName());\n        if (toFile.exists()) {\n            if (!toFile.canWrite()) abort(\"destination file is unwriteable: \" + to_name);\n        } else {\n            String parent = toFile.getParent();\n            if (parent == null) abort(\"destination directory doesn't exist: \" + parent);\n            File dir = new File(parent);\n            if (!dir.exists()) abort(\"destination directory doesn't exist: \" + parent);\n            if (dir.isFile()) abort(\"destination is not a directory: \" + parent);\n            if (!dir.canWrite()) abort(\"destination directory is unwriteable: \" + parent);\n        }\n        FileInputStream from = null;\n        FileOutputStream to = null;\n        try {\n            from = new FileInputStream(fromFile);\n            to = new FileOutputStream(toFile);\n            byte[] buffer = new byte[4096];\n            int bytes_read;\n            while ((bytes_read = from.read(buffer)) != -1) to.write(buffer, 0, bytes_read);\n        } finally {\n            if (from != null) try {\n                from.close();\n            } catch (IOException e) {\n                ;\n            }\n            if (to != null) try {\n                to.close();\n            } catch (IOException e) {\n                ;\n            }\n        }\n    }\n", "code2": "    public static void buildDeb(File debFile, File controlFile, File dataFile) throws IOException {\n        long now = new Date().getTime() / 1000;\n        OutputStream deb = new FileOutputStream(debFile);\n        deb.write(\"!<arch>\\n\".getBytes());\n        startFileEntry(deb, DEBIAN_BINARY_NAME, now, DEBIAN_BINARY_CONTENT.length());\n        deb.write(DEBIAN_BINARY_CONTENT.getBytes());\n        endFileEntry(deb, DEBIAN_BINARY_CONTENT.length());\n        startFileEntry(deb, CONTROL_NAME, now, controlFile.length());\n        FileInputStream control = new FileInputStream(controlFile);\n        byte[] buffer = new byte[1024];\n        while (true) {\n            int read = control.read(buffer);\n            if (read == -1) break;\n            deb.write(buffer, 0, read);\n        }\n        control.close();\n        endFileEntry(deb, controlFile.length());\n        startFileEntry(deb, DATA_NAME, now, dataFile.length());\n        FileInputStream data = new FileInputStream(dataFile);\n        while (true) {\n            int read = data.read(buffer);\n            if (read == -1) break;\n            deb.write(buffer, 0, read);\n        }\n        data.close();\n        endFileEntry(deb, dataFile.length());\n        deb.close();\n    }\n", "label": 1, "substitutes": {"fileCopy": ["FileCop", "Filecopy", "FileCopy", "doUpload", "fileCop", " fileCop", " fileUpload", "fileUpload", " filecopy", "doCopy", "docopy", "doCop", "filecopy", "FileUpload"], "from_name": ["fromptadmin", " from_base", " from_admin", "from_value", "from_type", "to_world", "to_case", " from_size", " from__names", "from_case", "from_user", "from__size", "fromptname", " from__name", " from_names", "from_admin", "from_client", " from__size", "from_names", "from__names", " from_client", " from_user", "from_size", "from__name", "fromptnames", "from_base", " from_no", " from_value", "from_no", "from_world", " from_type"], "to_name": ["toNamecode", "to_long", "toNamename", "into_num", "into_code", "to_num", "toNamenames", "intoNamecode", "to_Name", "into_name", "to_names", "to_path", " to_Name", "into_names", "into_path", "intoNamepath", "intoNamename", "intoNamenames", "to_code", "toNamepath", " to_long", " to_names"], "fromFile": ["onFile", "smallFiles", "entryfile", "fromPlace", "fromfile", "toField", "boundFiles", "onfile", "entryName", "normalTime", "normalfile", "sentFile", "startName", "tofile", "newPage", "fromTime", "fromFiles", "sentfile", " fromFILE", "formName", "newFile", "normalLine", "smallFile", "givenGlobal", "entryFile", " fromLine", "entryFilename", "sentField", "toPage", "oldLine", "normalFile", "newGlobal", "startFile", "FromFile", " fromPage", "orPage", " fromPlace", "formFilename", "startfile", "boundFile", "newfile", "givenfile", "onFILE", "fromFilename", "FromDo", "fromLine", "boundPlace", " fromTime", "oldfile", "formFile", "oldFile", "fromName", " fromFiles", "orLine", "startFilename", "fromPage", "formfile", "oldDo", " fromfile", "givenFile", " fromDo", "FromLine", "smallFILE", "boundFILE", "fromGlobal", "normalPage", "fromFILE", "fromField", "givenPage", "orFile", "Fromfile", " fromGlobal", "sentPage", "FromFILE", "orTime", "smallPlace", "fromDo", "normalField"], "toFile": ["targetModel", "ToFiles", "intoProcess", "toTime", "ToFILE", "thatfile", "toMessage", "toDo", "toFilename", "etoFile", "thatFILE", "toProcess", "toName", "targetTable", "tofile", "twoTime", "fromFiles", " tofile", " toFiles", "newFile", "toTable", "TOTime", "intoTable", "fromPort", "intoName", "toDefault", " toTime", "twofile", "TOPort", " toSourceFile", "targetPlace", "templateModel", "intoPort", "TOFiles", "twoPort", "Tofile", "toPort", "etoDefault", "intoMessage", "TOPath", "fromMessage", "intoFiles", " toPath", "twoSourceFile", "ToTable", "toPlace", " toDefault", "newfile", "etoMessage", "twoFiles", "toFiles", " toPlace", "TOPlace", "bySourceFile", "targetFile", "targetDo", "templateFile", " toFilename", "TOFile", "templateTable", "twoFile", "fromProcess", "ToModel", "TOSourceFile", "TOfile", "fromName", "etoFILE", "byfile", "toFILE", "etofile", "newSourceFile", "byPlace", "twoPath", "newPlace", "toModel", "intoFile", "byFile", " toPort", " toTable", " toDo", " toFILE", "targetFILE", "templateFILE", "ToFile", "toSourceFile", "ToFilename", "thatDefault", "etoName", "toPath", "thatFile", "etoProcess", "fromTable"], "parent": ["event", "parents", "exp", "rule", "origin", "central", "layout", "tip", "prop", "home", "pid", "sp", "params", "mt", "tar", "m", "page", "tmp", "module", "port", "directory", "chain", "spec", "man", "shape", "master", "form", "family", "up", "filename", "holder", "owner", "def", "child", "name", "position", "pi", "global", "pos", "timeout", "snap", "this", "my", "tree", "path", "mother", "null", "component", "per", "point", "uid", "instance", "ip", "ma", "desc", "remote", "temp", "server", "file", "folder", "Parent", "root", "pool", "source", "id", "unit", "p", "where", "host", "prefix", "peer", "paren"], "dir": ["good", "div", "tr", "dl", "vol", "di", "d", "dict", "cont", "tmp", "mod", "module", "init", "directory", "md", "red", "del", "addr", "dc", "fd", "cur", "dr", "db", "rel", "det", "wd", "dim", "def", "crit", "coll", "str", "out", "odd", "cond", "ds", "iter", "or", "dd", "Dir", "ir", "path", "cd", "ind", "DIR", "dist", "fin", "file", "folder", "loc", "dep", "rec", "direct", "dev"], "from": ["origin", "empty", "back", "window", "style", "en", "and", "by", "min", "reset", "con", "orig", "From", "vol", "entry", "left", "on", "bound", "fr", "clean", "create", "stream", "set", "client", "before", "in", "init", "ce", "inner", "base", "link", "c", "old", "only", "com", "false", "out", "or", "pos", "ent", "fun", "input", "initial", "query", "st", "form", "normal", "term", "sent", "local", "ra", "start", "no", "with", "source", "so", "check", "user", "store"], "to": ["lo", "co", "tg", "that", "by", "To", "output", "tto", "two", "test", "writer", "about", "toc", "tom", "client", "on", "can", "TO", "please", "table", "t", "base", "po", "done", "write", "go", "ts", "tty", "ta", "eto", "pi", "token", "top", "total", "out", "or", "too", "target", "phi", "tree", "into", "this", "null", "news", "o", "auto", "te", "ato", "no", "with", "so", "pretty", "title"], "buffer": ["event", "phrase", "buf", "window", "block", "buff", "sample", "entry", "frame", "word", "comment", "sequence", "page", "table", "append", "stroke", "base", "template", "char", "command", "attribute", "device", "document", "message", "result", "stack", "available", "number", "cache", "variable", "Buffer", "initial", "parse", "length", "queue", "paste", "binary", "batch", "database", "bar", "row", "temp", "button", "memory", "character"], "bytes_read": ["bytes2Read", "bytes_q", "bytes5need", "Bytes_write", "Bytes_find", "bytes2read", "Bytes_have", "bytes_need", "bytes_have", "bytes_Read", "bytes5read", "bytes2need", "bytes__q", "Bytes_need", "bytes_write", "bytes_find", "bytes5write", "bytes__read", "Bytes_read", "bytes__write", "bytes5Read", "bytes2write", "bytes__find", "Bytes_Read", "Bytes_q"]}}
{"id1": "20623709", "id2": "2324868", "code1": "    public Long split(File targetDirectory, String prefix, long maxUnitBases, long maxUnitEntries) throws Exception {\n        if (!targetDirectory.exists()) {\n            if (!targetDirectory.mkdirs()) throw new Exception(\"Could not create target directory \" + targetDirectory.getAbsolutePath());\n        }\n        if (!size.isUnknown() && size.getBases() < maxUnitBases && (maxUnitEntries <= 0 || size.getEntries() < maxUnitEntries)) {\n            FileInputStream fis = new FileInputStream(this);\n            FileChannel fci = fis.getChannel();\n            FileOutputStream fos = new FileOutputStream(new File(targetDirectory, prefix + \"_0\" + \".fasta\"));\n            FileChannel fco = fos.getChannel();\n            ByteBuffer buffer = ByteBuffer.allocate(64000);\n            while (fci.read(buffer) > 0) {\n                buffer.flip();\n                fco.write(buffer);\n                buffer.clear();\n            }\n            fci.close();\n            fco.close();\n            return (long) 1;\n        } else {\n            long currentBasesCount = 0;\n            long currentEntriesCount = 0;\n            int targetCount = 0;\n            FileChannel fastaChannel = new FileInputStream(this).getChannel();\n            int totalSeqCount = 0;\n            long totalResiduesCount = 0;\n            try {\n                long prevTime = System.currentTimeMillis();\n                long fastaFileSize = this.length();\n                long fastaFileReadOffset = 0L;\n                long partitionStartOffset = 0L;\n                final int bufferSize = 1024 * 1024;\n                ByteBuffer fastaBuffer = ByteBuffer.allocateDirect(bufferSize);\n                int fastaReadState = FASTAFileTokenizer.UNKNOWN;\n                for (; fastaFileReadOffset < fastaFileSize; ) {\n                    long nBytes = fastaChannel.read(fastaBuffer);\n                    if (nBytes <= 0) {\n                        fastaBuffer.limit(0);\n                        break;\n                    } else {\n                        fastaBuffer.flip();\n                        fastaFileReadOffset += nBytes;\n                    }\n                    for (; ; ) {\n                        if (!fastaBuffer.hasRemaining()) {\n                            fastaBuffer.clear();\n                            break;\n                        }\n                        int b = fastaBuffer.get();\n                        if (b == '\\r') {\n                        } else if (b == '\\n') {\n                            if (fastaReadState == FASTAFileTokenizer.DEFLINE) {\n                                fastaReadState = FASTAFileTokenizer.SEQUENCELINE;\n                            }\n                        } else if (b == '>') {\n                            if (fastaReadState == FASTAFileTokenizer.UNKNOWN) {\n                                fastaReadState = FASTAFileTokenizer.STARTDEFLINE;\n                            } else if (fastaReadState == FASTAFileTokenizer.SEQUENCELINE) {\n                                fastaReadState = FASTAFileTokenizer.STARTDEFLINE;\n                            }\n                            if (fastaReadState == FASTAFileTokenizer.STARTDEFLINE) {\n                                if (currentBasesCount >= maxUnitBases || maxUnitEntries > 0 && currentEntriesCount >= maxUnitEntries) {\n                                    fastaBuffer.position(fastaBuffer.position() - 1);\n                                    long currentTime = System.currentTimeMillis();\n                                    System.out.println(new java.util.Date() + \" Partition \" + targetCount + \" containing \" + currentEntriesCount + \" sequences and \" + currentBasesCount + \" residues ends at \" + (fastaFileReadOffset - fastaBuffer.remaining()) + \" and was created in \" + (currentTime - prevTime) + \" ms\");\n                                    prevTime = currentTime;\n                                    long partitionEndOffset = fastaFileReadOffset - fastaBuffer.remaining();\n                                    FileChannel partitionChannel = new FileOutputStream(new File(targetDirectory, prefix + \"_\" + targetCount + \".fasta\")).getChannel();\n                                    nBytes = fastaChannel.transferTo(partitionStartOffset, partitionEndOffset - partitionStartOffset, partitionChannel);\n                                    partitionChannel.force(true);\n                                    partitionChannel.close();\n                                    targetCount++;\n                                    partitionStartOffset += nBytes;\n                                    currentBasesCount = 0;\n                                    currentEntriesCount = 0;\n                                    fastaReadState = FASTAFileTokenizer.UNKNOWN;\n                                } else {\n                                    fastaReadState = FASTAFileTokenizer.DEFLINE;\n                                    currentEntriesCount++;\n                                }\n                                totalSeqCount++;\n                            }\n                        } else {\n                            if (fastaReadState == FASTAFileTokenizer.SEQUENCELINE) {\n                                totalResiduesCount++;\n                                currentBasesCount++;\n                            }\n                        }\n                    }\n                }\n                if (partitionStartOffset < fastaFileSize) {\n                    long currentTime = System.currentTimeMillis();\n                    System.out.println(new java.util.Date() + \" Partition \" + targetCount + \" containing \" + currentEntriesCount + \" sequences and \" + currentBasesCount + \" residues ends at \" + (fastaFileSize) + \" and was created in \" + (currentTime - prevTime) + \" ms\");\n                    FileChannel partitionChannel = new FileOutputStream(new File(targetDirectory, prefix + \"_\" + targetCount + \".fasta\")).getChannel();\n                    fastaChannel.transferTo(partitionStartOffset, fastaFileSize - partitionStartOffset, partitionChannel);\n                    partitionChannel.force(true);\n                    partitionChannel.close();\n                    targetCount++;\n                }\n                if (size.isUnknown()) {\n                    size.setBases(totalResiduesCount);\n                    size.setEntries(totalSeqCount);\n                }\n            } finally {\n                fastaChannel.close();\n            }\n            return (long) targetCount;\n        }\n    }\n", "code2": "            @Override\n            public void actionPerformed(ActionEvent e) {\n                try {\n                    Pattern delim = Pattern.compile(\"[ ]\");\n                    BufferedReader r = new BufferedReader(new InputStreamReader(new GZIPInputStream(new FileInputStream(\"/home/lindenb/jeter.txt.gz\"))));\n                    String line = null;\n                    URL url = new URL(\"http://eutils.ncbi.nlm.nih.gov/entrez/eutils/efetch.fcgi\");\n                    URLConnection conn = url.openConnection();\n                    conn.setDoOutput(true);\n                    OutputStreamWriter wr = new OutputStreamWriter(conn.getOutputStream());\n                    wr.write(\"db=snp&retmode=xml\");\n                    while ((line = r.readLine()) != null) {\n                        String tokens[] = delim.split(line, 2);\n                        if (!tokens[0].startsWith(\"rs\")) continue;\n                        wr.write(\"&id=\" + tokens[0].substring(2).trim());\n                    }\n                    wr.flush();\n                    r.close();\n                    InputStream in = conn.getInputStream();\n                    IOUtils.copyTo(in, System.err);\n                    in.close();\n                    wr.close();\n                } catch (IOException err) {\n                    err.printStackTrace();\n                }\n            }\n", "label": 1, "substitutes": {"split": ["scan", "process", "lock", "sync", "part", "disk", "share", "Split", "append", "write", "transfer", "open", "slice", "join", "seek", "format", "read", "copy", "align", "upload", "parse", "batch", "use", "count", "scale", "unit", "map"], "targetDirectory": [" targetMemory", "localdirectory", "localDir", "targetDirect", "localDirectory", "testLocation", "targetFile", "TargetDirect", "baseFile", "targetDir", "TargetFolder", "TargetDirectory", "Targetdirectory", "localFile", " targetDirect", " targetDir", " targetdirectory", "TargetDir", "baseDirectory", " targetLocation", "TargetMemory", "baseDir", "baseMemory", "testDirect", "testDir", " targetFile", "baseDirect", "targetFolder", "targetLocation", "testDirectory", "targetMemory", "baseFolder", " targetFolder", "TargetLocation", "basedirectory", "targetdirectory"], "prefix": ["type", " suffix", "p", "alias", "Pref", "FIX", "fix", "status", "tag", "PRE", "base", "directory", "template", "command", "pkg", "division", "filename", "format", "uri", "fixed", "name", "pi", "localhost", "ix", "this", "path", "fixes", "pres", "pre", "pattern", "padding", "key", "size", "password", "zero", "root", "index", "version", "username", "title"], "maxUnitBases": ["maxUnityAliias", "maxUnitChias", "maxUnitChades", "maxUnityBages", "maxUnitLages", "maxUnitBages", "maxUnitbades", "maxUnitAliases", "maxUnityLounds", "maxUnityAliounds", "maxUnitLounds", "maxUnitbias", "maxUnitBounds", "maxUnitLicas", "maxUnitAliounds", "maxUnityAliades", "maxUnitAliades", "maxUnitChicas", "maxUnitChages", "maxUnityAliases", "maxUnityBounds", "maxUnitBias", "maxUnityBades", "maxUnityBicas", "maxUnitLases", "maxUnityLases", "maxUnitChounds", "maxUnityLicas", "maxUnitBades", "maxUnityBias", "maxUnitChases", "maxUnitAliias", "maxUnityBases", "maxUnitReplases", "maxUnitReplicas", "maxUnitbases", "maxUnitBicas", "maxUnitReplounds", "maxUnitbounds", "maxUnityLages", "maxUnitReplages"], "maxUnitEntries": ["maxUnityentries", "maxUnitIntegrys", "maxUnitErries", "maxUnitEntryrys", "maxunitEntries", "maxunitEntrys", "maxUnityentrys", "maxUnitEntrys", "maxUnitEntryries", "maxUnitIntegries", "maxUnitEntires", "maxUnityEntrys", "maxUnitentires", "maxunitEntrs", "maxUnitentrs", "maxUnityEntries", "maxUnitEntryriers", "maxUnityEntrs", "maxUnitentries", "maxunitEntires", "maxUnityentrs", "maxUnitIntegriers", "maxUnityentires", "maxUnitentrys", "maxUnitErires", "maxUnitEntrs", "maxUnityEntires", "maxUnitErrys", "maxUnitEntriers", "maxUnitEntryires", "maxUnitIntegires", "maxUnitErrs"], "fis": ["fi", "Fis", "ifci", "fic", " fii", "Fic", "fii", "vis", " fi", " fic", "Fiss", "viss", "ifis", "fiss", "ific", "Fi", "Fci", "vi", "Fii", "vic", " fiss", "ifii"], "fci": ["mco", "cfai", " fico", "cfci", "Fis", "tco", "cfis", " fini", "Fico", " fai", "fcu", "fic", " fii", "mci", "cfic", "Fic", "Fco", "Fai", "fii", "cfini", " fic", "fai", "cfico", "tii", "tci", "fico", "fini", "cfco", "Fci", "mcu", "tcu", "Fini", "mii", " fcu"], "fos": ["Foss", "fbos", "yaos", " fbos", "wbos", "foss", " faos", "flos", "floss", "wios", "faos", "flaos", "yos", "wos", "fOS", "ybos", "Fos", " fOS", "fios", " fios", "Faos", " foss", "FOS", "waos", "flOS", "yios"], "fco": ["pco", "pci", "tco", "Fcon", " fcos", "foco", "fdo", "cco", "pso", "pcos", "Fco", "cso", "tdo", " fdo", " fso", "Fcos", "fso", "Fso", "cdo", " fcon", "Fdo", "tcos", "Fci", " foco", "fcon", "Foco", "toco", "ccon", "fcos"], "buffer": ["event", "phrase", "buf", "window", "pause", "block", "address", "buff", "flush", "match", "entry", "bridge", "sample", "reset", "callback", "comment", "sequence", "append", "table", "library", "limit", "template", "char", "command", "print", "function", "document", "message", "result", "stack", "read", "cache", "Buffer", "position", "black", "complete", "iter", "order", "note", "length", "queue", "binary", "batch", "record", "filter", "database", "channel", "padding", "row", "temp", "button", "source", "timeout", "memory", "index", "holder", "data"], "currentBasesCount": ["currentBasedCount", "currentBadesCount", "currentBasesLength", "currentBadesCode", "currentbasesLength", "currentbasesCount", "currentBasedCode", "currentBasesCode", "currentbaseLength", "currentBadesLength", "currentBaseCode", "currentBaseCount", "currentBaseLength", "currentBasedLength", "currentbaseCode", "currentbasesCode", "currentbaseCount"], "currentEntriesCount": ["currentEntrsFlag", "currentEntiesCount", "currentEntrysCount", "currentEntiesCode", "currentEntriesCode", "currentEntrsCount", "currentEntrysFlag", "currentEntriesFlag", "currentEntrsCode", "currentEntrysCode", "currentEntiesFlag"], "targetCount": ["TargetNum", "argetNum", "targetAmount", " targetAmount", " targetInfo", "argetCount", "targetInfo", " targetNum", "TargetCount", "argetAmount", "TargetInfo", "TargetAmount", "targetNum", "argetInfo"], "fastaChannel": ["fastaiChan", "fastaiStream", "fastityChan", "fastpaProvider", "fastityStream", "fastaStream", "fastoChannel", "fastpaChannel", "fastoProvider", "fastpaConnection", " fastaQueue", "fastoChan", " fastoChannel", "fastoStream", "fastityChannel", "fastaProvider", "fastaButton", " fastoChan", " fastoQueue", " fastoStream", "fastpaButton", " fastaButton", " fastaProvider", "fastaiChannel", "fastaConnection", " fastaConnection", "fastoConnection", " fastaChan", "fastoQueue", "fastityQueue", "fastoButton", "fastaQueue", "fastaChan", " fastaStream", "fastaiQueue"], "totalSeqCount": ["totalSeqCode", "totalSeqSize", "totalSegCount", "totalSeqsCount", "totalSeqsCounter", "totalSegSize", "totalSegCounter", "totalSeQSize", "totalSegCode", "totalSeqsCode", "totalSeQCode", "totalSeQCount", "totalSeQCounter", "totalSeqCounter", "totalSeqsSize"], "totalResiduesCount": ["totalResidueFlag", "totalResidusCount", "totalResidusFlag", "totalResiduesCode", "totalResIdueFlag", "totalResiduationsCount", "totalResIduesCount", "totalResidusCode", "totalResIduesFlag", "totalResIdueCount", "totalResiduationsFlag", "totalResidueCode", "totalResiduationsCode", "totalResidueCount", "totalResIduesCode", "totalResiduesFlag", "totalResIdueCode"], "prevTime": ["prevThread", "parTime", " prevT", "parThread", "parT", " previousTime", " previousThread", " prevThread", "prevT", " previousT"], "fastaFileSize": ["fastaChainSIZE", "fastaFilesSize", "fastATableName", "fastoTableSize", "fastaChainLength", "fastATableHeight", "fastaTableOwner", "fastaTableSIZE", "fastaTableHeight", "fastaTableSize", "fastoFileOwner", "fastoFileSIZE", "fastoTableOwner", "fastaFileHeight", "fastaChainSize", "fastaFileName", "fastaFilesHeight", "fastaReaderSize", "fastAFileSize", "fastafileOwner", "fastoFileLength", "fastaFilesName", "fastaChainOwner", "fastafileSIZE", "fastoFileSize", "fastaTableName", "fastaFileLength", "fastaTableLength", "fastaReaderLength", "fastaReaderName", "fastAFileName", "fastafileSize", "fastaFilesLength", "fastATableSize", "fastAFileHeight", "fastoTableSIZE", "fastoTableLength", "fastaReaderHeight", "fastATableLength", "fastaFileSIZE", "fastafileLength", "fastaFileOwner", "fastAFileLength"], "fastaFileReadOffset": ["fastaFileReadPos", "fastaFileLoadPos", "fastaFileWriteOffset", "fastaChainCurrentoffset", "fastaFileInputPosition", "fastaFileLoadAmount", "fastaFileReadLocation", "fastaFilesLoadLength", "fastaFileCurrentoffset", "fastaFileReadLength", "fastaFileInputoffset", "fastaFileCurrentOffset", "fastaChainReadOffset", "fastaFileReaderOffset", "fastaFileReadAmount", "fastaFileInputOrder", "fastaFilereadPos", "fastaChainReadPosition", "fastaFileLoadOrder", "fastaFilesReadOffset", "fastaFileInputLength", "fastaFileInputLocation", "fastaFileViewOffset", "fastaFileWriteLength", "fastaFileViewOrder", "fastaFileReadoffset", "fastaFileLoadLength", "fastaPageLoadOffset", "fastaFileReadOrder", "fastaFileCurrentPosition", "fastaPageLoadAmount", "fastaFileReaderPosition", "fastaFileInputAmount", "fastaChainCurrentPosition", "fastaFilesLoadOrder", "fastaFilereadAmount", "fastaPageReadPos", "fastaChainCurrentLocation", "fastaFileLoadOffset", "fastaFileReaderLocation", "fastaPageLoadOrder", "fastaFilesLoadAmount", "fastaFilereadOrder", "fastaChainReadoffset", "fastaFileCurrentLocation", "fastaFilereadOffset", "fastaFileViewPos", "fastaFilesReadOrder", "fastaFileWriteOrder", "fastaPageReadAmount", "fastaFileViewAmount", "fastaFileReaderoffset", "fastaFileReadPosition", "fastaPageReadOrder", "fastaChainReadLocation", "fastaFileInputOffset", "fastaFilesReadLength", "fastaFileWriteAmount", "fastaFilesReadAmount", "fastaPageReadOffset", "fastaFilesLoadOffset", "fastaChainCurrentOffset", "fastaPageLoadPos"], "partitionStartOffset": ["partitonStartOff", "partitonStartingPoint", "partitionStartPoint", "partitionDataOff", "partitionStartingPoint", "partitionEndPoint", "partitionStartingOff", "partitionStartPosition", "partitionEndPosition", "partitionStartingPosition", "partitionDataPoint", "partitionStartOff", "partitionDataOffset", "partitonStartOffset", "partitonStartPoint", "partitionEndOff", "partitonStartPosition", "partitionStartingOffset", "partitonStartingOffset", "partitonStartingOff", "partitonStartingPosition", "partitionDataPosition"], "bufferSize": ["BufferSize", "tableSIZE", "buffLength", "buffName", "BufferName", "BufferSIZE", " bufferLength", "bufferLength", "bufferName", "BufferLength", "bufSize", "bufSIZE", "tableSize", "sequenceLength", "bufferCode", "tableName", "sequenceCode", "tableLength", "buffSIZE", "sequenceSIZE", "sequenceSize", " bufferCode", " bufferSIZE", "buffSize", "bufferSIZE", "bufLength", "bufCode"], "fastaBuffer": ["fastcaCache", "FastaBuff", "fastasBuilder", "fastuBuff", "fastuBuffer", "wildanCache", " fastoQueue", "fastaMemory", "fastmaStore", "fastaDB", "FastmaRequest", "fastmaBuffer", "fastanCache", "fastasCache", "fastmaBuff", "fasteDB", "FastaRequest", "FastaBuffer", "fastsaBuff", " fastaBuilder", "fastasCounter", " fastaQueue", "fastasRequest", "fastasQueue", "fastoRequest", "fastaCounter", "wildanRequest", " fastoCounter", "FastmaBuffer", " fastaCache", "fastasStore", "FastaStore", "fastsaChannel", "fastalCounter", " fastaBuff", "FastmaStore", "fastuMemory", "wildaCache", "fastanBuff", "fastaBuff", " fastoBuff", "fastcaBuffer", " fastaCounter", "fastanRequest", "fastsaQueue", "fastoBuff", "wildanBuffer", "fastanBuffer", "wildaBuff", "fasteBuffer", "fastmaQueue", "fastoQueue", " fastaMemory", "fastoBuffer", "fastaCache", " fastoBuffer", "fastaQueue", "fastoCounter", "fastaRequest", "fastmaChannel", "FastmaBuff", "fastmaCache", "wildanBuff", "fasteMemory", "fastasBuffer", "fastuDB", "wildaRequest", "fastsaBuffer", "fastalBuffer", " fastaDB", "fasteBuff", "fastalQueue", "fastmaBuilder", "fastasBuff", "wildaBuffer", "fastmaRequest", "fastcaRequest", "fastaBuilder", "fastoStore", "fastcaBuff", "fastaStore", "fastalBuff"], "fastaReadState": ["fastaCurrentStatus", "fastaLoadState", "fastaCurrentSTATE", "fastaReaderSTATE", "fastoReaderState", "fastaReadType", "fastoReadStatus", "fastaReaderType", "fastoReadSTATE", "fastaLoadStatus", "fastoReaderSTATE", "fastaCurrentState", "fastaReadSTATE", "fastoReadState", "fastaReaderStatus", "fastaLoadSTATE", "fastoReaderStatus", "fastaReaderState", "fastoReadType", "fastaReadStatus", "fastaLoadType", "fastaCurrentType", "fastoReaderType"], "nBytes": ["nobytes", " nNs", "nBlocks", "noBytes", "noNs", "nsbytes", "nsBytes", " nKeys", "nKeys", "NItems", " nParts", "nNs", " nbytes", "Nbytes", " nBlocks", "numBlocks", "nsWords", "NParts", " nWords", "nbytes", " nItems", "nrBytes", "noBlocks", "NKeys", "NWords", "nWords", "nItems", "nrbytes", "numbytes", "nrItems", "nParts", "NBytes", "numBytes", "nrKeys", "numNs", "nsParts"]}}
{"id1": "18891988", "id2": "15445861", "code1": "    public static String getFile(String serviceName, String wsdlLocation, String endpoint) throws AxisFault {\n        mLog.debug(\"Downloading WSDL file from: \" + wsdlLocation);\n        mLog.debug(\"Received endpoint: \" + endpoint);\n        String fileLocation = null;\n        try {\n            String tempDir = System.getProperty(\"java.io.tmpdir\");\n            URL url = new URL(wsdlLocation);\n            String WSDLFile = tempDir + File.separator + serviceName + \".wsdl\";\n            String tmpWSDLFile = WSDLFile + \".tmp\";\n            File inputFile = new File(WSDLFile);\n            File tmpFile = new File(tmpWSDLFile);\n            if (!inputFile.exists() || inputFile.length() == 0) {\n                mLog.debug(\"Downloading the WSDL\");\n                inputFile.createNewFile();\n                InputStream in = url.openStream();\n                FileOutputStream out = new FileOutputStream(inputFile);\n                URLConnection con = url.openConnection();\n                int fileLength = con.getContentLength();\n                ReadableByteChannel channelIn = Channels.newChannel(in);\n                FileChannel channelOut = out.getChannel();\n                channelOut.transferFrom(channelIn, 0, fileLength);\n                channelIn.close();\n                channelOut.close();\n                out.flush();\n                out.close();\n                in.close();\n                Document tmpDocument = XMLUtils.newDocument(new FileInputStream(inputFile));\n                NodeList nl1 = tmpDocument.getElementsByTagName(\"wsdlsoap:address\");\n                for (int i = 0; i < nl1.getLength(); i++) {\n                    Node node1 = nl1.item(i);\n                    if (node1.getNodeName().equals(\"wsdlsoap:address\")) {\n                        ((Element) node1).setAttribute(\"location\", endpoint);\n                    }\n                }\n                FileOutputStream tmpOut = new FileOutputStream(tmpFile);\n                XMLUtils.DocumentToStream(tmpDocument, tmpOut);\n                tmpOut.flush();\n                tmpOut.close();\n                boolean retVal = inputFile.delete();\n                if (retVal) {\n                    retVal = tmpFile.renameTo(new File(WSDLFile));\n                }\n                mLog.debug(\"Return Value: \" + retVal);\n            } else {\n                mLog.debug(\"The WSDL is already at the ServiceProvider\");\n            }\n            fileLocation = WSDLFile;\n        } catch (MalformedURLException mx) {\n            mLog.error(\"MalformedURLException: \" + mx.getMessage() + \", cause: \" + mx.getCause().getMessage());\n            throw new AxisFault(mx.getMessage(), mx.getCause());\n        } catch (IOException ix) {\n            mLog.error(\"IOException: \" + ix.getMessage() + \", cause: \" + ix.getCause().getMessage());\n            throw new AxisFault(ix.getMessage(), ix.getCause());\n        } catch (ParserConfigurationException px) {\n            mLog.error(\"ParserConfigurationException: \" + px.getMessage() + \", cause: \" + px.getCause().getMessage());\n            throw new AxisFault(px.getMessage(), px.getCause());\n        } catch (SAXException sx) {\n            mLog.error(\"SAXException: \" + sx.getMessage() + \", cause: \" + sx.getCause().getMessage());\n            throw new AxisFault(sx.getMessage(), sx.getCause());\n        }\n        return fileLocation;\n    }\n", "code2": "    public static void copyFile(File srcFile, File destFile) throws IOException {\n        if (!(srcFile.exists() && srcFile.isFile())) throw new IllegalArgumentException(\"Source file doesn't exist: \" + srcFile.getAbsolutePath());\n        if (destFile.exists() && destFile.isDirectory()) throw new IllegalArgumentException(\"Destination file is directory: \" + destFile.getAbsolutePath());\n        FileInputStream in = new FileInputStream(srcFile);\n        FileOutputStream out = new FileOutputStream(destFile);\n        byte[] buffer = new byte[4096];\n        int no = 0;\n        try {\n            while ((no = in.read(buffer)) != -1) out.write(buffer, 0, no);\n        } finally {\n            in.close();\n            out.close();\n        }\n    }\n", "label": 1, "substitutes": {"getFile": ["createfile", "getString", "GetFile", "selectFile", "getfile", "selectFilename", "createString", "selectString", "GetFilename", "getFilename", "createFilename", "GetString", "Getfile", "selectfile", "createFile"], "serviceName": ["serviceNames", "serviceFamily", "serviceType", "serverCode", "serviceCode", "libraryName", "libraryFamily", "ServiceNames", "ServiceCode", "ServiceName", "serverName", "libraryNames", " serviceNames", "ServiceType", " serviceFamily", " serviceCode", "serverType", " serviceType", "libraryType", "ServiceFamily"], "wsdlLocation": ["awsdlocation", "wssdlocation", "wlLocation", "wlPath", "wslLoc", "wsdURL", "wsDLlocation", "wslPath", "wssdLoc", "wlFolder", "wsdlLoc", "wdlLoc", "awsdlLocation", "wsollocation", "wssdURL", "awsolURL", "wsdLoc", "wsDLURL", "awsdlLoc", "awsdURL", "wssdFolder", "wslFolder", "wsolURL", "awsolLoc", "awsolLocation", "awsdLocation", "wsdlFolder", "wsolLocation", "wsDLLoc", "wssdPath", "wslLocation", "wsdlocation", "wlLoc", "awsollocation", "wssdLocation", "wsDLLocation", "wsdllocation", "wsDLPath", "wdlPath", "wdlLocation", "wsdlPath", "awsdlURL", "wdlFolder", "wsolLoc", "wsdlURL", "awsdLoc", "wsDLFolder", "awsdllocation", "wsdLocation"], "endpoint": ["beginPoint", "Endport", "bindpoints", "idpoint", " endpoints", "Endword", "idpoints", " endline", "bindpoint", "bindport", "endpoints", "beginpoints", " endport", "startline", "Endpoint", "beginpoint", "idline", "endport", "startword", "startpoint", "beginword", "endword", "endPoint", "EndPoint", "endline", "bindPoint", " endPoint", "startPoint", "idPoint", "Endpoints", "startpoints"], "fileLocation": ["FileLocation", "fileLoc", "documentPosition", "FilePosition", "documentLoc", " filelocation", "Filelocation", " filePosition", "filelocation", " fileLoc", "FileLoc", "documentlocation", "documentLocation", "filePosition"], "tempDir": [" tempFolder", "TempPath", "TempUrl", "TempFolder", "TempDirectory", "tempDirectory", "tempPath", "Tempdir", " tempUrl", "tmpDir", "tempdir", " tempDirectory", "tempFolder", "tmpDirectory", "tmpFolder", " tempPath", "TempDir", "tmpdir", "tmpUrl", "tmpPath", "tempUrl", " tempdir"], "url": ["f", "browser", "window", "gl", "dl", "service", "cr", "sur", "m", "https", "bel", "web", "ls", "ll", "base", "char", "link", "pl", "build", "sl", "open", "cert", "rel", "up", "ur", "mount", "re", "cp", "un", "uri", "URL", "str", "l", "nl", "ul", "mail", "li", "conn", "ctrl", "github", "r", "ssl", "ret", "http", "location", "socket", "job", "loc", "il", "Url"], "WSDLFile": ["WSDDLFILE", "WSDELfile", "WSDDLString", "WSDLLFilename", "WSDLLFILE", "WHDLFile", "WSDLSfile", "WSDLFilename", "WNDDLFILE", "WHDLfile", "WSDELFile", "WSDMLFile", "WNDDLFilename", "WNDLFilename", "WSDDLType", "WSDMLfile", "WNDLFile", "WSDQLFILE", "WSDLSString", "WIDLFile", "WSDLLType", "WIDDLType", "WSDELFilename", "WNDLFILE", "WSDDLfile", "WSDQLFile", "WSDLType", "WSDELFILE", "WSDMLFILE", "WNDDLFile", "WIDDLString", "WSDLLFile", "WIDDLfile", "WSDLString", "WSDLfile", "WSDDLFilename", "WHDDLfile", "WSDDLFile", "WSDLSType", "WIDLString", "WNDDLfile", "WSDLLString", "WIDDLFile", "WSDLLfile", "WSDQLfile", "WHDDLFile", "WIDLType", "WSDLSFile", "WSDLFILE", "WHDLFILE", "WHDDLFILE", "WNDLfile", "WIDLfile"], "tmpWSDLFile": ["tmpWSDLFilename", "tmpWIDDLFilename", "tmpWSDLFILE", "tmpWIDLFilename", "tmpWIDLFile", "tmpWSDLfile", "tmpWSDlfile", "tmpWSDDLFILE", "tmpWSDDLFilename", "tmpWSDLDFile", "tmpWSDLLFiles", "tmpWSDLLFilename", "tmpWSDLFiles", "tmpWNDLfile", "tmpWIDLFILE", "tmpWIDDLfile", "tmpWNDDLFilename", "tmpWNDLFile", "tmpWSDLLfile", "tmpWSDDLfile", "tmpWIDDLFile", "tmpWSDLDfile", "tmpWSDDLFiles", "tmpWNDLFilename", "tmpWSDDLFile", "tmpWIDLfile", "tmpWIDDLFILE", "tmpWSDLDFilename", "tmpWSDLDFILE", "tmpWNDDLFile", "tmpWSDlFilename", "tmpWNDDLFiles", "tmpWSDLLFILE", "tmpWSDlFiles", "tmpWNDLFiles", "tmpWSDlFile", "tmpWNDDLfile", "tmpWSDLLFile"], "inputFile": ["tmpSourceFile", "tmpStream", " inputSourceFile", " inputfile", "InputStream", "inputStream", "interfacefile", "clientFile", "indexStream", "tmpFILE", " inputDo", "clientFiles", "outputfile", "errorfile", "tmpfile", "inputDo", "indexfile", "InputFiles", "outputFile", "errorStream", "indexFile", "InputDo", " inputPlace", "inputFILE", "intFiles", "inPath", " inputFiles", "inputFiles", "Inputfile", "outputFILE", " inputPath", "outputStream", "InputFile", "inputPlace", "inFile", "interfaceSourceFile", " inputFILE", "InputPath", "intFILE", "inputSourceFile", "indexFILE", "inputfile", "intFile", "clientFILE", "InputFILE", "clientPath", "inDo", "inputPath", "errorFILE", "interfacePlace", "errorFile", "tmpPlace", "interfaceFile", "infile", "intfile"], "tmpFile": ["inputFilename", "mpfile", " tmpfile", "tmpFILE", "tmpfile", "empFilename", "tempPath", "tempFilename", "empFile", "mpFile", "tmpFiles", "inputFILE", "mpFiles", "mpPath", "empFILE", "tempfile", "tempFILE", " tmpPath", " tmpFiles", "inputfile", "empfile", "tempFiles", "tempFile", "tmpPath", "tmpFilename"], "in": ["mi", "rin", "en", "inn", "ini", "IN", "ins", "cont", "ar", "ri", "ln", "client", "stream", "In", "t", "inner", "init", "c", "ic", "ai", "bin", "inc", "input", "sin", "it", "ch", "conn", "ain", "ind", "o", "r", "inv", "n", "io", "din", "inf", "is", "isin", "source", "file", "cin", "id", "from"], "out": ["all", "co", "en", "lock", "by", "output", "ao", "oss", "obj", "client", "on", "sys", "tmp", "conv", "t", "connection", "net", "we", "write", "c", "to", "log", "buffer", "conf", "cache", "writer", "os", "cm", "outer", "OU", "ch", "this", "conn", "null", "ou", "group", "outs", "at", "o", "aos", "inv", "auto", "ex", "n", "io", "Out", "file", "pool", "OUT", "can", "ne", "w"], "con": ["co", "acon", "win", "cos", "func", "cn", "ln", "ws", "conv", "connection", "cons", "CON", "c", "fc", "soc", "cur", "re", "un", "conf", "com", "cp", "ran", "sec", "Conn", "cm", "const", "login", "ch", "cone", "cal", "conn", "ain", "exc", "tc", "num", "connect", "nc", "mc", "cf", "fn", "cin", "can", "Con"], "fileLength": ["FILELen", "fileFontSize", "objectLength", "fileSize", "ileLen", "FILELength", "fileLen", "objectSize", "ileLength", "fileDuration", " fileLen", "channelSize", "channelFontSize", " fileDuration", " fileSize", "channelLength", "ileDuration", "objectFontSize", "channelDuration", " fileFontSize", "objectDuration", "FILEDuration", "FILESize", "ileSize"], "channelIn": ["Channelin", "ChannelIN", "chanIN", "channelIN", "ChanneledIn", "channelSet", "consoleIN", " channelIN", "channelin", " channeledIn", "clientIn", "channeledIn", "consoleOut", "chanOut", "chanSet", "ChannelSet", "clientSet", "clientin", " channelin", "clientIN", "chanIn", "clientOut", "consoleIn", "consoleedIn", "ChannelOut", "ChannelIn"], "channelOut": ["chanConn", "Channelout", "consoleout", "ChannelConn", " channelout", " channelConn", "ChannelOUT", "courseout", "consoleOut", "chanOut", "consoleOUT", "channelConn", " channelOUT", "channelout", "courseOUT", "chanIn", "courseOut", "courseIn", "consoleIn", "chanout", "channelOUT", "ChannelOut", "ChannelIn"], "tmpDocument": ["mkdocument", "cpdocument", "tmDocument", " tmpMedia", "mpdocument", "npMedia", "tmdocument", "mkDocument", "tmpDoc", "tmDoc", " tmpDocuments", "tpDocument", "npFile", "tmpDocuments", "mpDocument", "tempdocument", " tmpdocument", "tmpdocument", "tpMedia", " tmpDoc", "tmpMedia", "mkDoc", "tpDocuments", "tpFile", "npDocument", "cpDocument", "npDocuments", "tempDoc", "cpDoc", "tempDocument", "mpDoc"], "nl1": ["ln0", "sol9", "rn6", "nr1", "lnOne", "NL2", "nel1", "nrOne", "rn1", "nr01", "nel3", "pelOne", "ln3", "pel1", "nl6", "pel01", "rnOne", "nelOne", "sol0", "nl2", "NL0", "ln6", "NL1", "ln1", "ln9", "nl0", "ln01", "nl01", "rn3", "nl9", "nel6", "nlOne", "sol2", "NL9", "ln2", "nl3", "sol1"], "i": ["mi", "span", "u", "j", "ini", "us", "y", "ms", "I", "ie", "qi", "di", "ri", "m", "ami", "init", "x", "hi", "me", "ti", "k", "bi", "cli", "ic", "multi", "ci", "ai", "sim", "gi", "ui", "v", "pi", "ij", "it", "ji", "li", "xi", "mu", "ims", "si", "\u0438", "ori", "o", "ip", "info", "n", "key", "io", "ii", "is", "index", "id", "a", "ix"], "node1": ["Node2", "n0", "node91", "Node1", " node0", "node2", "nOne", "Node001", "nodeOne", "node0", "Node0", "layer91", " node2", "n1", "componentOne", "layer1", " nodeOne", "ode0", "n91", "ode1", "ode2", "ode001", "layer0", "layerOne", "component0", "NodeOne", "component2", "node001", " node91", " node001", "component1"], "tmpOut": ["tmpObj", "tmpIn", "mpIn", "npIn", "TempOut", "empout", "mpObj", "tempIs", " tmpIs", " tmpObj", "tmpOUT", "npOut", "tmpIs", "mpOut", "tempout", "TempObj", "cmpIn", "TempOUT", "cmpOut", "empIs", "npObj", "tempOUT", "empOut", "tmpout", " tmpIn", "mpout", " tmpOUT", "TempIn", "cmpout", "tempObj", " tmpout", "tempIn", "npout", "tempOut"], "retVal": ["RetTrue", "RetVal", " retValue", "returnTrue", "RetValue", "retValue", "retval", " retTrue", "returnval", "retTrue", "returnValue", "returnVal", "Retval", " retval"]}}
{"id1": "18504192", "id2": "411595", "code1": "    static void copyFile(File in, File out) throws IOException {\n        FileChannel source = new FileInputStream(in).getChannel();\n        FileChannel destination = new FileOutputStream(out).getChannel();\n        source.transferTo(0, source.size(), destination);\n        source.close();\n        destination.close();\n    }\n", "code2": "    private void displayDiffResults() throws IOException {\n        File outFile = File.createTempFile(\"diff\", \".htm\");\n        outFile.deleteOnExit();\n        FileOutputStream outStream = new FileOutputStream(outFile);\n        BufferedWriter out = new BufferedWriter(new OutputStreamWriter(outStream));\n        out.write(\"<html><head><title>LOC Differences</title>\\n\" + SCRIPT + \"</head>\\n\" + \"<body bgcolor='#ffffff'>\\n\" + \"<div onMouseOver=\\\"window.defaultStatus='Metrics'\\\">\\n\");\n        if (addedTable.length() > 0) {\n            out.write(\"<table border><tr><th>Files Added:</th>\" + \"<th>Add</th><th>Type</th></tr>\");\n            out.write(addedTable.toString());\n            out.write(\"</table><br><br>\");\n        }\n        if (modifiedTable.length() > 0) {\n            out.write(\"<table border><tr><th>Files Modified:</th>\" + \"<th>Base</th><th>Del</th><th>Mod</th><th>Add</th>\" + \"<th>Total</th><th>Type</th></tr>\");\n            out.write(modifiedTable.toString());\n            out.write(\"</table><br><br>\");\n        }\n        if (deletedTable.length() > 0) {\n            out.write(\"<table border><tr><th>Files Deleted:</th>\" + \"<th>Del</th><th>Type</th></tr>\");\n            out.write(deletedTable.toString());\n            out.write(\"</table><br><br>\");\n        }\n        out.write(\"<table name=METRICS BORDER>\\n\");\n        if (modifiedTable.length() > 0 || deletedTable.length() > 0) {\n            out.write(\"<tr><td>Base:&nbsp;</td><td>\");\n            out.write(Long.toString(base));\n            out.write(\"</td></tr>\\n<tr><td>Deleted:&nbsp;</td><td>\");\n            out.write(Long.toString(deleted));\n            out.write(\"</td></tr>\\n<tr><td>Modified:&nbsp;</td><td>\");\n            out.write(Long.toString(modified));\n            out.write(\"</td></tr>\\n<tr><td>Added:&nbsp;</td><td>\");\n            out.write(Long.toString(added));\n            out.write(\"</td></tr>\\n<tr><td>New & Changed:&nbsp;</td><td>\");\n            out.write(Long.toString(added + modified));\n            out.write(\"</td></tr>\\n\");\n        }\n        out.write(\"<tr><td>Total:&nbsp;</td><td>\");\n        out.write(Long.toString(total));\n        out.write(\"</td></tr>\\n</table></div>\");\n        redlinesOut.close();\n        out.flush();\n        InputStream redlines = new FileInputStream(redlinesTempFile);\n        byte[] buffer = new byte[4096];\n        int bytesRead;\n        while ((bytesRead = redlines.read(buffer)) != -1) outStream.write(buffer, 0, bytesRead);\n        outStream.write(\"</BODY></HTML>\".getBytes());\n        outStream.close();\n        Browser.launch(outFile.toURL().toString());\n    }\n", "label": 1, "substitutes": {"copyFile": ["CopyFiles", " transferFile", "copyFiles", "CopyStream", " transferFiles", " CopyStream", "copyStream", "copyfile", " Copyfile", " CopyFiles", "CopyFile", " transferStream", " CopyFile", "Copyfile", " transferfile"], "in": ["rin", "en", "inn", "gin", "IN", "vin", "ins", "on", "In", "old", "b", "ic", "edIn", "up", "i", "inc", "l", "input", "or", "it", "ind", "o", "el", "mm", "n", "din", "inf", "is", "isin", "as", "cin", "id", "from"], "out": ["nt", "output", "oss", "help", "t", "po", "k", "net", "log", "err", "b", "to", "ot", "v", "i", "serv", "os", "l", "it", "gt", "ou", "at", "outs", "g", "o", "s", "ex", "n", "io", "Out", "OUT", "ne", "w"], "source": ["origin", "back", "scan", "style", "access", "subject", "match", "sample", "ie", "service", "pse", "resource", "se", "reader", "comment", "sequence", "secret", "create", "force", "before", "init", "inner", "template", "me", "store", "inside", "spec", "scope", "open", "system", "src", "Source", "copy", "position", "SOURCE", "input", "sin", "query", "parse", "search", "seed", "ource", "space", "instance", "use", "iterator", "local", "info", "volume", "ources", "start", "file", "shell", "from"], "destination": ["Destation", "restinated", " destregation", " destation", "coordregation", " destification", "comification", "restinator", "destregation", " destension", "restation", "destension", "comato", "seeinator", "coordification", "destation", "comregation", "Destinated", " destinator", "Destinator", "coordato", " destato", "coordination", " destinated", "seeination", "seeension", "destification", "destinated", "seeinated", "destato", "Destination", "Destension", "destinator", "restination", "comination"]}}
{"id1": "8973505", "id2": "15810440", "code1": "    public static void writeFileType(String uriFile, String outputfile, int num) {\n        BufferedWriter writer = null;\n        String uri = null;\n        try {\n            int counter = 1;\n            writer = new BufferedWriter(new FileWriter(outputfile));\n            BufferedReader reader = new BufferedReader(new FileReader(uriFile));\n            uri = null;\n            while (counter < num) {\n                uri = reader.readLine();\n                counter++;\n            }\n            while ((uri = reader.readLine()) != null) {\n                try {\n                    System.err.println(\"working on the [\" + counter + \"]th document.\");\n                    counter++;\n                    URL url = new URL(uri);\n                    URLConnection myConnection = url.openConnection();\n                    BufferedReader myReader = new BufferedReader(new InputStreamReader(myConnection.getInputStream()));\n                    String line = null;\n                    boolean hasOWL = false;\n                    boolean hasRDFS = false;\n                    boolean hasRDF = false;\n                    int linecount = 0;\n                    while ((line = myReader.readLine()) != null) {\n                        if (line.indexOf(\"http://www.w3.org/2002/07/owl\") != -1) hasOWL = true; else if (line.indexOf(\"http://www.w3.org/2000/01/rdf-schema\") != -1) hasRDFS = true; else if (line.indexOf(\"http://www.w3.org/1999/02/22-rdf-syntax-ns\") != -1) hasRDF = true;\n                        linecount++;\n                        if (linecount > 100) break;\n                    }\n                    if (hasOWL) writer.write(uri + \"\\t\" + OWL); else if (hasRDFS) writer.write(uri + \"\\t\" + RDFS); else if (hasRDF) writer.write(uri + \"\\t\" + RDF); else writer.write(uri + \"\\t\" + UNKNOWN);\n                    writer.newLine();\n                    writer.flush();\n                } catch (Exception e) {\n                    e.printStackTrace();\n                    try {\n                        writer.write(uri + \"\\t\" + BROKEN);\n                        writer.newLine();\n                        writer.flush();\n                    } catch (Exception ex) {\n                        ex.printStackTrace();\n                    }\n                }\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n", "code2": "    public static void addRecipe(String name, String instructions, int categoryId, String[][] ainekset) throws Exception {\n        PreparedStatement pst1 = null;\n        PreparedStatement pst2 = null;\n        ResultSet rs = null;\n        int retVal = -1;\n        try {\n            pst1 = conn.prepareStatement(\"INSERT INTO recipes (name, instructions, category_id) VALUES (?, ?, ?)\");\n            pst1.setString(1, name);\n            pst1.setString(2, instructions);\n            pst1.setInt(3, categoryId);\n            if (pst1.executeUpdate() > 0) {\n                pst2 = conn.prepareStatement(\"SELECT recipe_id FROM recipes WHERE name = ? AND instructions = ? AND category_id = ?\");\n                pst2.setString(1, name);\n                pst2.setString(2, instructions);\n                pst2.setInt(3, categoryId);\n                rs = pst2.executeQuery();\n                if (rs.next()) {\n                    int id = rs.getInt(1);\n                    System.out.println(\"Lis\ufffdt\ufffd\ufffdn ainesosat\");\n                    String[] aines;\n                    for (int i = 0; i < ainekset.length; ++i) {\n                        aines = ainekset[i];\n                        addIngredient(id, aines[0], aines[1], Integer.parseInt(aines[2]), Integer.parseInt(aines[3]));\n                    }\n                    retVal = id;\n                } else {\n                    retVal = -1;\n                }\n            } else {\n                retVal = -1;\n            }\n            conn.commit();\n        } catch (Exception e) {\n            conn.rollback();\n            throw new Exception(\"Reseptin lis\ufffdys ep\ufffdonnistui. Poikkeus: \" + e.getMessage());\n        }\n    }\n", "label": 0, "substitutes": {"writeFileType": ["writePageName", "readFileName", "writePagetype", "writeContentName", "readFileInfo", "writePageInfo", "readfileName", "readFiletype", "writeFileName", "writefileInfo", "readFileType", "writeContenttype", "writefileType", "readfileType", "writefiletype", "writeFileInfo", "readfileInfo", "writeContentType", "readfiletype", "writefileName", "writePageType", "writeContentInfo", "writeFiletype"], "uriFile": ["rangeFile", "urifile", "irifile", "filefile", "fileFile", "rangeData", "rangefile", "fileFiles", "URIData", "iriFile", "URIfile", "uriFilename", "fileFilename", "filenamefile", "filenameFilename", "iriData", "URIFiles", "uriFILE", "iriFILE", "filenameFile", "uriData", "URIFILE", "URIFile", "rangeFILE", "filenameFiles", "uriFiles", "URIFilename"], "outputfile": ["OutputFILE", "outbase", "inputFile", "imageport", "Outputport", "outFile", "imageFile", "outputFile", "outputport", "outfile", "imageFILE", "outputf", "outputbase", "outf", "inputFILE", "outputFILE", "Outputfile", "inputbase", "OutputFile", "inputfile", "imagefile", " outputf", " outputFile", "inputport", " outputbase", "inputf"], "num": ["all", "nm", "um", "cmp", "con", "random", "Number", "m", "nam", "x", "done", "mon", "multi", "current", "max", "number", "NUM", "required", "nb", "total", "alph", "np", "mult", "nom", "add", "count", "n", "no", "zero", "index", "check", "Num", "end"], "writer": ["event", "author", "window", "worker", "creator", "flush", "writers", "test", "storage", "builder", "usher", "inner", "connection", "editor", "to", "liner", "term", "director", "record", "er", "riter", "player", "memory", "loader", "service", "driver", "resource", "writing", "processor", "maker", "RW", "link", "buffer", "function", "document", "timer", "manager", "file", "server", "w", "linger", "caster", "entry", "layer", "comment", "wright", "stream", "table", "Reader", "write", "writ", "journal", "read", "owner", "external", "written", "wire", "network", "ner", "width", "ender", "wrapper", "data", "runner", "Writer", "console", "ener", "thus", "utils", "client", "will", "widget", "format", "variable", "operator", "commit", "handler", "iterator"], "uri": ["origin", "hyper", "uno", "ri", "URI", "ei", "inner", "connection", "range", "filename", "ugi", "pi", "bid", "rid", "ni", "ir", "form", "uid", "ip", "channel", "href", "domain", "umi", "phrase", "browser", "address", "subject", "resource", "https", "general", "hi", "link", "uni", "ur", "i", " URI", "doi", "iri", "http", "file", "id", "username", "obo", "via", "ref", "reference", "chain", "basic", "multi", "ui", "uu", "query", "ource", "qu", "unit", "user", "du", "prefix", "phi", "mi", "wiki", "image", "qi", "description", "details", "directory", "result", "verb", "copy", "sofar", "queue", "iterator", "remote", "location", "source", "folder"], "counter": ["meter", "browser", "phrase", "ier", "creator", "money", "entry", "random", "pointer", "mr", "mer", "time", "mill", "ounter", "cover", "cms", "currency", "sequence", "processor", "machine", "context", "finder", "frequency", "inner", "conv", "editor", "another", "scope", "ctr", "buffer", "message", "timer", "system", "number", "coll", "total", "const", "container", "outer", "common", "order", "walker", "controller", "cookie", "TER", "continue", "term", "clock", "amount", "Counter", "instance", "norm", "book", "nr", "iterator", "manager", "count", "key", "memory", "index", "loop", "card", "loader", "ter"], "reader": ["runner", "rar", "address", "entry", "layer", "parser", "driver", "resource", "builder", "processor", "ro", "context", "inner", "Reader", "editor", "buffer", "document", "redo", "timer", "journal", "roller", "read", "rl", "liner", "method", "input", "iter", "dd", "rx", "upper", "handler", "iterator", "r", "row", "ner", "er", "file", "yer", "player", "older", "loader", "server"], "url": ["browser", "hl", "gl", "address", "ref", "google", "dl", "resource", "www", "client", "https", "bel", "web", "ll", "base", "char", "link", "build", "sl", "open", "rel", "re", "ur", "mount", "URL", "name", "str", "get", "l", "nl", "li", "mail", "github", "r", "ssl", "http", "location", "loc", "il", "Url"], "myConnection": ["myConn", "yourLink", "MyLink", "Myconnection", " myConn", "MyConnector", "thisConnect", "newConnection", "thisLink", "yourconnection", " myConnector", "myLink", "yourConnection", "myConnector", "newConn", "newConnect", "myconnection", "myConnect", " myLink", " myConnect", " myconnection", "yourConnector", "MyConnection", "thisConnection", "newLink", "thisConn"], "myReader": ["myParser", " myParser", "yReader", "myWriter", " myRead", "myFr", " myWriter", "yourParser", "mxSer", "mxFr", "myRead", " mySer", "ySer", "yFr", "mySer", "MyParser", "yourWriter", "MyReader", "yourRead", "MyRead", " myFr", "yWriter", "yourReader", "mxWriter", "mxReader", "MyWriter"], "line": ["rule", "LINE", "ode", "lo", "style", "block", "lin", "text", "eline", "entry", "ine", "email", "sample", "part", "comment", "frame", "word", "lane", "ln", "sequence", "raw", " LINE", "page", "stroke", "trace", "char", "one", "range", "link", "log", "label", "code", "cli", "message", "cell", "detail", "le", "liner", "definition", "l", "iter", "point", "normal", "edge", "Line", "ge", "channel", "ip", " Line", "row", "no", "inline", "ole", "online", "body", "side", "user"], "linecount": ["strokenumber", "elinecount", "LineCount", "elinelength", " linenumber", "linnumber", " lineCount", "linercount", "elineconst", " lineconfig", "Lineconfig", "lineamount", "inlinecount", "lineCount", " lineconst", "linefound", " linelength", " lineamount", "lineconst", " lineconsider", "linelength", "lincount", "linconsider", "inlinecounter", "linecounter", "inlineconst", "linamount", "strokecount", "inlinelength", "Linefound", "lineconfig", " linefound", "elinecounter", "strokeconsider", " linecounter", "linerCount", "Linecount", "linerconfig", "linenumber", "linerfound", "strokeamount", "lineconsider"], "hasOWL": ["HasOWSB", " hasEWR", "HasOWB", "hasEWLS", "hasOWNL", " hasOWSR", "hasOHL", "HasOWS", "hasROL", "hasOWSLP", "hasOWSL", "hasOWNNL", "hasOHS", "hasOWB", "hasROR", " hasOWSNL", "hasSOR", "hasROLP", "hasOWNR", "hasEWB", "hasSOL", "hasOHLP", "HasOWL", "hasOWSS", "hasOWSR", "hasSOLS", "HasOWLP", "hasOWSLS", " hasOWSLP", " hasOWNL", "hasEWLP", " hasOWLP", "hasOWNLP", "hasOWS", " hasEWLP", "hasSOLP", " hasOWSL", "hasOWLS", "hasOWSB", "HasOWSL", " hasOWLS", "hasRONL", "hasOWSNL", "hasEWS", "HasOWSLP", "hasEWR", "HasOWSS", " hasEWLS", "hasOWR", "hasEWL", " hasOWR", "hasOHB", "hasOWLP", " hasEWL"], "hasRDFS": ["hasRNFS", "hasRdfCS", "hasORDFS", "hasRDSDS", "hasXDFS", "hasORDSS", "hasORDSs", "hasORDFs", "hasRMLM", "hasSRDFs", "hasRdfDS", "hasSRDSCS", "hasRDFM", "hasSRDFB", "hasRDSB", "hasRMLs", "hasXDFs", "hasRMLDS", "hasRDFCS", "hasRNFM", "hasRNFDS", "hasXDFM", "hasRDSS", "hasRdfB", "hasRNFs", "hasRDFB", "hasSRDSs", "hasSRDFS", "hasXDSs", "hasXDSS", "hasORDFM", "hasRMLS", "hasXDSM", "hasRdfS", "hasRDSs", "hasRDSM", "hasRDFDS", "hasXDSDS", "hasRdfM", "hasSRDFCS", "hasRDSCS", "hasORDFDS", "hasRdfs", "hasRRIS", "hasORDSM", "hasRDFs", "hasRRICS", "hasSRDSB", "hasRRIB", "hasORDSDS", "hasRRIs", "hasSRDSS", "hasXDFDS"], "hasRDF": ["hasRCDF", "hasREDF", "hasDdf", "hasRCNF", " hasRRDF", "hasRRdf", "hasRRNF", "hasDCD", "hasRTNF", "hasREDS", "hasRCCD", "hasORDF", "hasRCD", "hasRDT", "hasORNF", "hasORDR", "hsRRDI", "hasRRDR", " hasRdf", "hasORDS", " hasRDS", " hasRCD", " hasDNF", "hasDNF", " hasRDR", "hasRADS", "hasRRDS", "hasRADT", " hasRNF", "hasDDF", "hsRRDS", "hasRNF", "hasRRDI", "hsRDT", "hasRADF", "hsRRDF", " hasRRDS", "hasRTDF", "hsRDS", "hasRTDS", " hasRRNF", "hsRDF", "hasRDS", " hasDDF", "hasRDR", "hasRADI", "hasRRCD", " hasDdf", "hasRRDF", " hasRRDR", "hasREDI", "hsRRDT", "hasREDT", "hasRCdf", "hasRTDR", "hsRDI", "hasRRDT", "hasRDI", "hasRdf", " hasDCD"]}}
{"id1": "13783898", "id2": "22536033", "code1": "    public static boolean encodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.ENCODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "code2": "    private boolean setPayload() throws IOException {\n        if (Index < Headers.length) {\n            FileOutputStream fos = new FileOutputStream(Headers[Index], true);\n            FileInputStream fis = new FileInputStream(HeadlessData);\n            FileChannel fic = fis.getChannel();\n            FileChannel foc = fos.getChannel();\n            fic.transferTo(0, fic.size(), foc);\n            fic.close();\n            foc.close();\n            setDestination(Destinations[Index]);\n            setPayload(Headers[Index]);\n            Index++;\n            return true;\n        }\n        return false;\n    }\n", "label": 1, "substitutes": {"encodeFileToFile": ["encodeStringAsFile", "encodeFileToFiles", "encodeFileToDisk", "encodeFileAsFile", "encodeStringToFile", "encodeFileToStream", "encodeFileFromFiles", "encodeStringAsDisk", "encodeStringAsStream", "encodeFiletoFile", "encodeFileAsStream", "encodeStringToDisk", "encodeFileAsDisk", "encodeFiletoDisk", "encodeFiletoFiles", "encodeStringToFiles", "encodeFileFromStream", "encodeFileAsFiles", "encodeFileFromDisk", "encodeStringAsFiles", "encodeFiletoStream", "encodeFileFromFile", "encodeStringToStream"], "infile": ["inputfilename", "inputFile", "outbase", "outFile", " inFile", "inpath", " inbase", " infilename", "outfilename", "inbase", "InFile", "infilename", "inFile", "inputfile", "Inbase", "inputpath", " inpath", "Inpath", "outpath", "Infile"], "outfile": ["outfp", "newFile", "outname", "newfile", "indir", " outname", "outFile", "outdir", "fromfile", "outfilename", "inname", "newname", " outfilename", "tofp", "infilename", "todir", "inFile", "infp", "toFile", "newfilename", "fromfp", " outFile", "fromdir", "tofile", "fromFile"], "in": ["rin", "en", "image", "inn", "ini", "by", "gin", "con", "IN", "ins", "pin", "im", "ar", "on", "oin", "ro", "al", "In", "t", "inner", "inside", "init", "re", "up", "i", "bin", "get", "inc", "input", "amin", "or", "iter", "it", "per", " din", "form", "conn", "ain", "ind", "nin", "info", "din", "inf", "is", "isin", "source", "cin", "id", "from"], "out": ["ion", "co", "en", "nt", "flush", "con", "output", "res", "oss", "cn", "on", "sys", "t", "inner", "net", "write", "print", "b", "to", "end", "opt", "up", "writer", "os", "outer", "it", "OU", "gt", "null", "ou", "at", "outs", "g", "o", "aos", "ex", "n", "io", "Out", "file", "fn", "OUT", "can", "ne", "ot"], "buffer": ["phrase", "buf", "window", "bone", "block", "buff", "sample", "column", "frame", "comment", "view", "sequence", "append", "table", "pad", "library", "mem", "base", "template", "command", "attribute", "document", "message", "available", "stack", "number", "cache", "Buffer", "variable", "black", "total", "initial", "note", "history", "paste", "queue", "length", "binary", "batch", "bar", "padding", "info", "row", "display", "temp", "button", "password", "memory", "print", "header", "character"], "read": ["first", "each", "text", "find", "select", "reader", "wait", "allow", "raw", "stream", "set", "run", "before", "range", "write", "open", "push", "readable", "load", "print", "reads", "hold", "seek", "close", "i", "req", "skip", "get", " Read", "give", "input", "need", "iter", "through", "query", "len", "length", "Read", "ind", "add", "connect", "count", "n", "ready", "start", "size", "reading", "send", "check", "index", "READ", "end", "ok"], "success": ["first", "same", "good", "response", "value", " succ", "ceed", "cess", "positive", "fail", "city", "release", " successful", "summary", "please", "status", " Success", "ith", "accept", "Success", "danger", "done", "ratulations", "ccess", "growth", "warning", "primary", "result", "safe", " okay", "second", "unity", "crit", "condition", "successful", " failure", "sufficient", "error", "valid", "complete", "commit", "snap", "democracy", "continue", "photo", "surv", "successfully", "town", "submit", "support", " successes", "setup", "ok"]}}
{"id1": "4531653", "id2": "18046717", "code1": "    public static String md5(String data) {\n        try {\n            MessageDigest md = MessageDigest.getInstance(MD);\n            md.update(data.getBytes(UTF8));\n            return encodeHex(md.digest());\n        } catch (Exception e) {\n            throw new RuntimeException(e);\n        }\n    }\n", "code2": "    private String getFullClassName(URL url, String className) throws Exception {\n        JarInputStream jis = new JarInputStream(url.openStream());\n        ZipEntry zentry = null;\n        while ((zentry = jis.getNextEntry()) != null) {\n            String name = zentry.getName();\n            int lastPos = name.lastIndexOf(\".class\");\n            if (lastPos < 0) {\n                continue;\n            }\n            name = name.replace('/', '.');\n            int pos = -1;\n            if (className != null) {\n                pos = name.indexOf(className);\n                if (pos >= 0 && name.length() == pos + className.length() + 6) {\n                    jis.close();\n                    return (name.substring(0, lastPos));\n                }\n            }\n        }\n        jis.close();\n        return (null);\n    }\n", "label": 0, "substitutes": {"md5": ["MD3", "sha4", "md3", " md3", "md7", "md4", "MD7", "MD4", "sha3", " md7", "sha5", " md4", "sha7", "MD5"], "data": ["type", "txt", "image", "value", "text", "DATA", "json", "block", "output", "hello", "serial", "d", "ata", "foo", "raw", "table", "sha", "command", "message", "result", "content", "format", "cache", "name", "now", "os", "input", "valid", "this", "mu", "dat", "batch", "any", "padding", "info", "string", "html", "msg", "no", "id", "a", "bytes"], "md": ["nt", "sm", "pd", "ms", "od", "di", "d", "der", "mt", "amd", "m", "managed", "mod", "mg", "red", "mp", "db", "rm", "det", "dm", "sd", "nd", "ds", "dd", "cmd", "mand", "da", "dir", "mb", "cd", "hd", "MD", "ind", "mn", "mc", "mm", "pm", "mk", "msg", "de", "ld", "pdf", "bd", "df", "dh"]}}
{"id1": "9236363", "id2": "23370621", "code1": "    private void unJarStart(String jarPath, String jarEntryStart) {\n        String path;\n        if (jarPath.lastIndexOf(\"lib/\") >= 0) path = jarPath.substring(0, jarPath.lastIndexOf(\"lib/\")); else path = jarPath.substring(0, jarPath.lastIndexOf(\"/\"));\n        String relPath = jarEntryStart.substring(0, jarEntryStart.lastIndexOf(\"/\"));\n        try {\n            new File(path + \"/\" + relPath).mkdirs();\n            JarFile jar = new JarFile(jarPath);\n            Enumeration<JarEntry> entries = jar.entries();\n            while (entries.hasMoreElements()) {\n                JarEntry entry = entries.nextElement();\n                String jarEntry = entry.getName();\n                if (jarEntry.startsWith(jarEntryStart)) {\n                    ZipEntry ze = jar.getEntry(jarEntry);\n                    File bin = new File(path + \"/\" + jarEntry);\n                    IOUtils.copy(jar.getInputStream(ze), new FileOutputStream(bin));\n                }\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n", "code2": "    private void downloadFile(File target, String s3key) throws IOException, S3ServiceException {\n        InputStream in = downloadData(s3key);\n        if (in == null) {\n            throw new IOException(\"No data found\");\n        }\n        in = new InflaterInputStream(new CryptInputStream(in, cipher, getDataEncryptionKey()));\n        File temp = File.createTempFile(\"dirsync\", null);\n        FileOutputStream fout = new FileOutputStream(temp);\n        try {\n            IOUtils.copy(in, fout);\n            if (target.exists()) {\n                target.delete();\n            }\n            IOUtils.closeQuietly(fout);\n            IOUtils.closeQuietly(in);\n            FileUtils.moveFile(temp, target);\n        } catch (IOException e) {\n            fetchStream(in);\n            throw e;\n        } finally {\n            IOUtils.closeQuietly(fout);\n            IOUtils.closeQuietly(in);\n        }\n    }\n", "label": 1, "substitutes": {"unJarStart": ["unZipStop", "unjarStop", "unJobStart", " unZipStart", "unZipEntry", "unjarStart", " unZipEntry", "unjarPart", "unJobStop", " unJarPart", "unJarEntry", "unZipStart", " unZipPart", " unJarEntry", "unJarStop", "unJobEntry", "unZipPart", " unZipStop", "unJarPart", "unJobPart", " unJarStop", "unjarEntry"], "jarPath": ["browserPath", "jarCore", " jarFile", "jobpath", "pkgHome", "jarFile", " jarUrl", "jarpath", "carPath", "certPath", " jarCore", "jPath", "fireUrl", "jobHome", "jobFile", "certpath", "carUrl", "browserName", " jarHost", "fireName", "javaPath", "certInfo", "javaUrl", "fireCore", "javaCh", "firePath", "pkgPath", "jarHost", "jobPath", " jarpath", "jTime", "javaCore", "javaTime", "javaInfo", "jarProject", " jarProject", "javaName", "browserUrl", "browserpath", "javapath", "pkgpath", "jName", " jarName", "javaProject", "certHost", "jarHome", " jarTime", "javaHost", "jarName", " jarCh", "jarCh", "jarUrl", "jarTime", "jarInfo", "jHost", " jarInfo", "carpath", "pkgFile", "carCh", "browserProject", " jarHome"], "jarEntryStart": ["jarEntryEnd", "jarEntStart", "elementEntityEnd", "jarNameBegin", "jarUrlstart", "carUrlstart", "jarEntryInit", "jarentryBegin", "carEntryEnd", "jarPathStart", "jarFilePart", "joentrystart", "jarEntityStart", "joentryStart", "jarFileStart", "joEntryStart", " jarFileStart", "carEntryName", " jarEntryStarting", "carUrlStart", "jarElementFinish", "jarPathFinish", "carUrlName", "jarPathEnd", "joentrySize", "jarRowstart", "jarFileStarting", " jarEntryPart", "elementEntityInit", "jarentrySize", "jarEntryPart", "jarentrystart", "jarRowStart", "jarNameName", "jarNameStart", "jarNameEnd", "joEntrystart", "jarNamestart", "jarEntityFinish", "jarentryStart", "elementEntityFinish", "elementEntityStart", "jarEntAdd", "jarEntryBegin", "elementEntryStart", " jarEntryAdd", "jarUrlEnd", "jarPathName", "jarEntryFinish", "jarPathstart", "jarEntityInit", "jarElementInit", "jarEntryStarting", "jarAddStart", " jarFilePart", "elementEntryEnd", "jarEntrySize", "jarPathInit", "jarEntPart", "carEntrystart", "jarAddPart", "jarUrlName", "jarFileAdd", "jarEntryName", "elementEntryFinish", "joEntrySize", "jarNameSize", "jarEntityEnd", "jarAddAdd", " jarFileAdd", "jarEntryAdd", "joentryBegin", "carUrlEnd", "jarAddStarting", "elementEntryInit", "joEntryBegin", "jarEntrystart", "carEntryStart", "jarEntStarting", "jarUrlStart", "jarElementStart", "jarRowSize", "jarRowBegin", "jarElementEnd", " jarFileStarting"], "path": ["exp", "empty", "transform", "ref", "prop", "text", "value", "select", "test", "dest", "client", "set", "ath", "context", "x", "trace", "port", "template", "chain", "log", "pkg", "PATH", "to", "message", "join", "system", "near", "mount", "program", "route", "url", "host", "name", "position", "pi", "method", "input", "api", "out", "hex", "order", "cmd", "history", "parent", "tree", "length", "point", "dir", "walk", "Path", "kind", "pattern", "self", "key", "core", "string", "location", "relative", "where", "loc", "folder", "root", "file", "index", "check", "p", "print", "data", "prefix", "phi"], "relPath": ["Relpath", "RELName", "relpath", "relatedName", "RelPort", "relPort", " relpath", " relName", "RelName", "relPos", "RELpath", " relPort", "RELPath", "RelPos", " relPos", "relatedPath", "RELPos", "relatedPort", "relatedpath", "relName", "RelPath"], "jar": ["browser", "report", "rar", "zone", "j", "war", "vol", "ie", "sp", "ar", "js", "keeper", "tar", "jet", "tmp", "library", "module", "be", "jj", "Jar", "pkg", "bag", "we", "ctr", "cert", "cur", "db", "ja", "cp", "jo", "jc", "lib", "le", "archive", "tab", "car", "pack", "true", "java", "dir", "batch", "bar", "zip", "session", "manager", "jp", "sea", "file", "gem", "bare"], "entries": ["entencies", "encrys", "Entrs", " entities", "Entires", "entrys", "Entrys", "Entities", " entencies", "Enties", "conties", "enries", "entents", "Entries", "enrees", "enires", "entsries", "enrys", "entsrys", "encarts", "encries", "Entarts", "encents", "entires", "entrees", "entrs", "entarts", "integarts", "entities", "encencies", "contries", "integries", "enrs", "Entrees", "contrees", " entrys", "integencies", "entsities", "contrs", "Entents", "encires", "integrys", "enies", "enents", "enties", "entsencies", "Entencies"], "entry": ["event", "ion", "nt", "address", "and", "element", "match", "ie", "word", "se", "resource", "office", "module", "ce", "char", "be", "attribute", "zo", "cell", "result", "e", "jo", "ace", "name", "archive", "entity", "ent", "ry", "component", "enter", "record", "instance", "add", "zip", "member", "Entry", "row", "info", "key", "de", "pe", "escape"], "jarEntry": ["jSlot", "browserEnt", "carEnt", "jarEnt", "searchentry", "joAddress", " jarElement", "jarEvent", "jarItem", "jarAdd", "joEntry", "jarSlot", "tarAdd", "searchEntry", " jarAddress", "fireAdd", "jEnt", "carentry", "jamSlot", "browserentry", "jarAddress", "tarEnt", "certentry", "certEnt", "javaItem", "browserEntry", "fireEnt", "certEntry", "jarElement", "jamentry", "jamEnt", "javaEvent", " jarItem", "tarElement", "certElement", "searchSlot", "browserElement", "javaAddress", "carElement", "javaEntry", "carEntry", "fireEntry", " jarAdd", "jarentry", "jentry", " jarEvent", " jarEnt", "searchEnt", "tarEntry", "jamEntry", "joItem", "joEvent", "jEntry", "fireElement"], "ze": ["ode", "z", "ie", "oe", "ee", "zed", "aze", "se", "ei", "ene", "zy", "ce", "ea", "me", "be", "ae", "zo", "je", "e", "sk", "zes", "le", "zie", "zz", "za", "enz", "sle", "ase", "li", "ge", "zip", "te", "zing", "ZE", "de", "zer", "so", "cin", "zi", "ke", "pe"], "bin": ["bat", " Bin", "dll", "win", "lock", "gin", "bl", "bg", "bank", "di", "pin", "pan", "bo", "obin", "ln", "bed", "in", "ebin", "bi", "spin", "b", "ic", "bb", "exe", "db", "kin", "nb", "bm", "lib", "bian", "sin", "bu", "pic", "binary", "zip", "din", "skin", "fin", "bn", "cin", "sam"]}}
{"id1": "11484416", "id2": "19335986", "code1": "    private void moveFile(File orig, File target) throws IOException {\n        byte buffer[] = new byte[1000];\n        int bread = 0;\n        FileInputStream fis = new FileInputStream(orig);\n        FileOutputStream fos = new FileOutputStream(target);\n        while (bread != -1) {\n            bread = fis.read(buffer);\n            if (bread != -1) fos.write(buffer, 0, bread);\n        }\n        fis.close();\n        fos.close();\n        orig.delete();\n    }\n", "code2": "    public void uncaughtException(final Thread t, final Throwable e) {\n        final Display display = Display.getCurrent();\n        final Shell shell = new Shell(display);\n        final MessageBox message = new MessageBox(shell, SWT.OK | SWT.CANCEL | SWT.ICON_ERROR);\n        message.setText(\"Hawkscope Error\");\n        message.setMessage(e.getMessage() + \"\\nSubmit Hawkscope Error Report to Issue Tracker?\");\n        log.error(\"Uncaught exception\", e);\n        if (message.open() == SWT.OK) {\n            IOUtils.copyToClipboard(Version.getBugReport(e));\n            try {\n                Program.launch(Constants.HAWKSCOPE_URL_ROOT + \"issues/entry?comment=\" + URLEncoder.encode(\"Please paste the Hawkscope Error \" + \"Report here. It's currently copied to your \" + \"clipboard. Thank you for your support!\", Constants.ENCODING));\n            } catch (final Exception e1) {\n                Program.launch(Constants.HAWKSCOPE_URL_ROOT + \"issues/entry\");\n            }\n        }\n        shell.dispose();\n    }\n", "label": 1, "substitutes": {"moveFile": ["copyImage", "MoveImage", "MoveDirectory", "copyFile", "movefile", " moveDirectory", "moveDirectory", " moveImage", "copyfile", "moveImage", "copyDirectory", "MoveFile", "Movefile", " movefile"], "orig": ["origin", "proxy", "exp", "coord", "rc", "good", "prop", "ord", "img", "ie", "imp", "internal", "original", "im", "dest", " ORIG", "create", "raw", "tmp", "init", "base", "existing", "old", "cur", "src", "org", "def", "act", "copy", "or", "was", "Original", "dom", "iter", "ori", "Origin", " original", "created", "ip", "inv", "ret", "lim", "ra", "temp", "Orig", "clip", "ex"], "target": ["origin", "output", "match", "test", "next", "dest", "goal", "sys", "tmp", "table", "t", "base", "template", "build", "replace", "touch", "src", "rel", "format", "Target", "copy", "top", "out", "png", "it", "gt", "parent", "path", "null", "local", "ret", "file", "source", "mac", "tile", "arget"], "buffer": ["phrase", "buf", "window", "block", "buff", "output", "sample", "bridge", "bank", "engine", "comment", "sequence", "stream", "table", "page", "mem", "base", "limit", "char", "chain", "attribute", "command", "bb", "message", "document", "available", "stack", "read", "cache", "Buffer", "variable", "scroll", "face", "bytes", "iter", "history", "length", "queue", "paste", "binary", "batch", "line", "filter", "screen", "bar", "display", "button", "password", "memory", "print", "data", "header"], "bread": ["oug", "bridge", "fee", "score", "bold", "bc", "bird", "print", "gear", "rown", "shield", "spoken", "fan", "bad", "brew", "good", "bush", "jing", "uckle", "broken", "log", "bb", "stay", "knife", "iber", "crafted", " ribs", "ig", "ble", "bill", "bn", "beat", "leen", " barely", "inn", "piece", "ful", "don", "rain", " Bread", "web", "lf", "bi", "neum", "cake", "less", "read", "robe", "nob", "fred", "eb", "beck", "blow", "fine", "boat", "bishop", "rew", "eric", "READ", "corruption", "wei", "billion", "middle", "brow", "bel", "level", "four", "scroll", "give", " breadth", "bled", "rik", "wake"], "fis": ["ufos", "freis", "fi", "Fis", "fris", " fris", "di", "ufis", "Fris", "ufiss", "liss", "freia", "dis", "dia", "los", "bi", "frei", " fi", "Fiss", "fiss", "ufris", "bos", "Fos", "fia", "li", "lis", "bis", " fia", "biss", " fiss"], "fos": ["eoes", "foes", "Fis", "vus", "Fot", "ooses", "tos", "fot", "foos", "foses", "Foes", "eoos", "vos", "tis", "fus", " foses", " foes", "eis", " foos", "pus", "pos", "Fos", "ooes", "poos", "voes", "eos", "Foses", "voos", " fot", "Foos", "poes", " fus", "toos", "oot", "oos", "toes"]}}
{"id1": "21821404", "id2": "596993", "code1": "    public static String getWebPage(URL urlObj) {\n        try {\n            String content = \"\";\n            InputStreamReader is = new InputStreamReader(urlObj.openStream());\n            BufferedReader reader = new BufferedReader(is);\n            String line;\n            while ((line = reader.readLine()) != null) {\n                content += line;\n            }\n            return content;\n        } catch (IOException e) {\n            throw new Error(\"The page \" + dbg.quote(urlObj.toString()) + \"could not be retrieved.\" + \"\\nThis is could be caused by a number of things:\" + \"\\n\" + \"\\n  - the computer hosting the web page you want is down, or has returned an error\" + \"\\n  - your computer does not have Internet access\" + \"\\n  - the heat death of the universe has occurred, taking down all web servers with it\");\n        }\n    }\n", "code2": "    private String makeLoginRequest(URL url) throws IOException {\n        HttpURLConnection urlConnection = (HttpURLConnection) url.openConnection();\n        urlConnection.setRequestMethod(\"POST\");\n        urlConnection.setDoInput(true);\n        urlConnection.setDoOutput(true);\n        urlConnection.setUseCaches(false);\n        urlConnection.setRequestProperty(\"Content-Type\", \"application/x-www-form-urlencoded\");\n        StringBuilder content = new StringBuilder();\n        content.append(\"Email=\").append(URLEncoder.encode(EMAIL, \"UTF-8\"));\n        content.append(\"&Passwd=\").append(URLEncoder.encode(PASSWORD, \"UTF-8\"));\n        content.append(\"&service=\").append(URLEncoder.encode(SERVICE, \"UTF-8\"));\n        content.append(\"&source=\").append(URLEncoder.encode(\"Google Base data API\", \"UTF-8\"));\n        OutputStream outputStream = urlConnection.getOutputStream();\n        outputStream.write(content.toString().getBytes(\"UTF-8\"));\n        outputStream.close();\n        int responseCode = urlConnection.getResponseCode();\n        InputStream inputStream;\n        if (responseCode == HttpURLConnection.HTTP_OK) {\n            inputStream = urlConnection.getInputStream();\n        } else {\n            inputStream = urlConnection.getErrorStream();\n        }\n        return toString(inputStream);\n    }\n", "label": 0, "substitutes": {"getWebPage": ["getLiveUrl", "getWebPages", "downloadWebPage", "getDebugPages", "getLivePage", "getDebugpage", "downloadwebPages", "getWebpage", "downloadwebUrl", "getwebUrl", "downloadwebpage", "getLivepage", "getwebPage", "getLivePages", "getWebUrl", "downloadWebUrl", "getDebugUrl", "getwebPages", "downloadWebPages", "getDebugPage", "downloadwebPage", "getwebpage", "downloadWebpage"], "urlObj": ["uriObj", " urlobj", "urlInfo", "httpOb", "UrlOnce", "UrlObject", "uriInd", " urlObject", "uriobj", " urlInd", "logObj", "httpObj", "httpObject", "logOb", "httpInfo", "UrlCtrl", "uriOnce", " urlInfo", "urlObject", "logObject", "uriObject", "urlOb", " urlCtrl", "urlCtrl", "urlInd", "urlobj", "urlOnce", " urlOnce", "UrlInd", "uriCtrl", "UrlObj", " urlOb", "Urlobj", "logInfo"], "content": ["empty", "txt", "layout", "response", "value", "text", "address", "output", "cont", "comment", "view", "sequence", "article", "clean", "raw", "page", "title", "reason", "context", "articles", "comments", "template", "code", "ce", "command", "buffer", "write", "load", "document", "message", "current", "result", "ext", "read", "format", "cm", "complete", "Content", "str", "section", "object", "continue", "core", "html", "string", "temp", "display", "source", "body", "wrapper", "data", "header", "ontent", "equ"], "is": ["ois", "sit", "ri", "other", "not", "be", "err", "c", "re", "ris", "sels", "or", "out", "ir", "ists", "isin", "more", "mis", "iris", "res", "se", "nis", "net", "i", "when", "name", "os", "has", "was", "bis", "isf", "job", "\u00eds", "ios", "where", "being", "id", "ire", "es", "sis", "ist", "rys", "and", "sys", "web", "in", "chain", "e", "rs", "IS", "are", "isl", "s", "ese", "iso", "were", "a", "does", "ms", "by", "Is", "internet", "his", "fs", "ians", "isa", "ais", "tis", "ism", "its", "plays", "isc", "lis", "string", "isi", "as", "iss", "ot"], "reader": ["runner", "ser", "rar", "parser", "anger", "ri", "ro", "stream", "in", "inner", "dra", "Reader", "buffer", "editor", "dr", "roller", "read", "writer", "liner", "rr", "iter", "ocker", "per", "handler", "ader", "iterator", "r", "iper", "row", "ner", "io", "er", "file", "reading", "loader", "ipper"], "line": ["LINE", "lo", "zone", "lin", "block", "text", "eline", "entry", "ine", "sample", "email", "piece", "column", "part", "comment", "frame", "word", "lane", "ln", "sequence", "page", "stroke", "char", "range", "label", "link", "message", "cell", "e", "detail", "le", "liner", "l", "section", "nl", "lined", "point", "record", "Line", "el", "row", "string", "inline", "file", "online", "print"]}}
{"id1": "18370075", "id2": "3375724", "code1": "    public static byte[] createPasswordDigest(String password, byte[] salt) throws Exception {\n        MessageDigest md = MessageDigest.getInstance(\"MD5\");\n        md.update(salt);\n        md.update(password.getBytes(\"UTF8\"));\n        byte[] digest = md.digest();\n        return digest;\n    }\n", "code2": "    public void importarEmissoresDosTitulosFinanceiros(File pArquivoTXT, Andamento pAndamento) throws FileNotFoundException, SQLException {\n        int numeroDoRegistro = -1;\n        Scanner in = null;\n        Statement stmtLimpezaInicialDestino = conDestino.createStatement();\n        String sql = \"TRUNCATE TABLE TMP_TB_EMISSOR_TITULO\";\n        stmtLimpezaInicialDestino.executeUpdate(sql);\n        sql = \"INSERT INTO TMP_TB_EMISSOR_TITULO(SIGLA, NOME, CNPJ, DATA_CRIACAO) VALUES(:SIGLA, :NOME, :CNPJ, :DATA_CRIACAO)\";\n        OraclePreparedStatement stmtDestino = (OraclePreparedStatement) conDestino.prepareStatement(sql);\n        stmtDestino.setExecuteBatch(COMANDOS_POR_LOTE);\n        final int TAMANHO_DO_CABECALHO_DO_ARQUIVO = 0;\n        final int TAMANHO_DO_RODAPE_DO_ARQUIVO = 0;\n        final int TAMANHO_DOS_METADADOS_DO_ARQUIVO = TAMANHO_DO_CABECALHO_DO_ARQUIVO + TAMANHO_DO_RODAPE_DO_ARQUIVO;\n        final int TAMANHO_MEDIO_POR_REGISTRO = 81;\n        long tamanhoDosArquivos = pArquivoTXT.length();\n        int quantidadeDeRegistrosEstimada = (int) (tamanhoDosArquivos - TAMANHO_DOS_METADADOS_DO_ARQUIVO) / TAMANHO_MEDIO_POR_REGISTRO;\n        String registro;\n        String[] campos;\n        try {\n            in = new Scanner(new FileInputStream(pArquivoTXT), Constantes.CONJUNTO_DE_CARACTERES_DOS_ARQUIVOS_TEXTO_DA_BOVESPA.name());\n            int quantidadeDeRegistrosImportada = 0;\n            numeroDoRegistro = 0;\n            String vSIGLA, vNOME;\n            BigDecimal vCNPJ;\n            java.sql.Date vDATA_CRIACAO;\n            final int QTDE_CAMPOS = CampoDoArquivoDosEmissoresDeTitulosFinanceiros.values().length;\n            final String SEPARADOR_DE_CAMPOS_DO_REGISTRO = \",\";\n            final String DELIMITADOR_DE_CAMPOS_DO_REGISTRO = \"\\\"\";\n            while (in.hasNextLine()) {\n                ++numeroDoRegistro;\n                registro = in.nextLine();\n                stmtDestino.clearParameters();\n                registro = registro.substring(1, registro.length() - 1);\n                if (registro.endsWith(DELIMITADOR_DE_CAMPOS_DO_REGISTRO)) {\n                    registro = registro + \" \";\n                }\n                campos = registro.split(DELIMITADOR_DE_CAMPOS_DO_REGISTRO + SEPARADOR_DE_CAMPOS_DO_REGISTRO + DELIMITADOR_DE_CAMPOS_DO_REGISTRO);\n                int quantidadeDeCamposEncontradosIncluindoOsVazios = campos.length;\n                if (quantidadeDeCamposEncontradosIncluindoOsVazios != QTDE_CAMPOS) {\n                    throw new CampoMalDelimitadoEmRegistroDoArquivoImportado(registro);\n                }\n                vSIGLA = campos[CampoDoArquivoDosEmissoresDeTitulosFinanceiros.SIGLA.ordinal()];\n                vNOME = campos[CampoDoArquivoDosEmissoresDeTitulosFinanceiros.NOME.ordinal()];\n                String cnpjTmp = campos[CampoDoArquivoDosEmissoresDeTitulosFinanceiros.CNPJ.ordinal()];\n                if (cnpjTmp != null && cnpjTmp.trim().length() > 0) {\n                    vCNPJ = new BigDecimal(cnpjTmp);\n                } else {\n                    vCNPJ = null;\n                }\n                String dataDaCriacaoTmp = campos[CampoDoArquivoDosEmissoresDeTitulosFinanceiros.DATA_CRIACAO.ordinal()];\n                if (dataDaCriacaoTmp != null && dataDaCriacaoTmp.trim().length() > 0) {\n                    int dia = Integer.parseInt(dataDaCriacaoTmp.substring(6, 8)), mes = Integer.parseInt(dataDaCriacaoTmp.substring(4, 6)) - 1, ano = Integer.parseInt(dataDaCriacaoTmp.substring(0, 4));\n                    Calendar calendario = Calendar.getInstance();\n                    calendario.clear();\n                    calendario.set(ano, mes, dia);\n                    vDATA_CRIACAO = new java.sql.Date(calendario.getTimeInMillis());\n                } else {\n                    vDATA_CRIACAO = null;\n                }\n                stmtDestino.setStringAtName(\"SIGLA\", vSIGLA);\n                stmtDestino.setStringAtName(\"NOME\", vNOME);\n                stmtDestino.setBigDecimalAtName(\"CNPJ\", vCNPJ);\n                stmtDestino.setDateAtName(\"DATA_CRIACAO\", vDATA_CRIACAO);\n                int contagemDasInsercoes = stmtDestino.executeUpdate();\n                quantidadeDeRegistrosImportada++;\n                double percentualCompleto = (double) quantidadeDeRegistrosImportada / quantidadeDeRegistrosEstimada * 100;\n                pAndamento.setPercentualCompleto((int) percentualCompleto);\n            }\n            conDestino.commit();\n        } catch (Exception ex) {\n            conDestino.rollback();\n            ProblemaNaImportacaoDeArquivo problemaDetalhado = new ProblemaNaImportacaoDeArquivo();\n            problemaDetalhado.nomeDoArquivo = pArquivoTXT.getName();\n            problemaDetalhado.linhaProblematicaDoArquivo = numeroDoRegistro;\n            problemaDetalhado.detalhesSobreOProblema = ex;\n            throw problemaDetalhado;\n        } finally {\n            pAndamento.setPercentualCompleto(100);\n            in.close();\n            if (stmtLimpezaInicialDestino != null && (!stmtLimpezaInicialDestino.isClosed())) {\n                stmtLimpezaInicialDestino.close();\n            }\n            if (stmtDestino != null && (!stmtDestino.isClosed())) {\n                stmtDestino.close();\n            }\n        }\n    }\n", "label": 0, "substitutes": {"createPasswordDigest": ["createPasswordDigester", "createPasswordDester", "createPassworddigests", "createPasswordDigum", "createPassworddigum", "createPasswordDests", "createPassworddigester", "createPassworddigest", "createPasswordDest", "createPasswordDigests", "createPasswordDum"], "password": ["phrase", "response", "address", "value", "reset", "entry", "email", "hello", "word", "description", "secret", "shadow", "command", "attribute", "Password", "message", "wd", "words", "name", "token", "hash", "login", "auth", "present", "sword", "database", "pattern", "padding", "key", "string", "user", "username", "data", "session", "pass"], "salt": ["talt", "tol", "sesig", "Save", "Salt", "taint", "pol", "Sol", "Saint", "palt", "SALT", "sesalt", "sig", " sig", "sesave", "sesALT", "sol", "paint", " save", " sALT", "sALT", "tALT", "saint", "pALT", "save", "Sig"], "md": ["nt", "sm", "pd", "ms", "and", "od", "di", "d", "der", "strong", "mt", "js", "amd", "m", "mod", "mg", "red", "mp", "dr", "rm", "det", "mode", "dm", "sd", "def", "ct", "td", "nd", "dd", "cmd", "mand", "metadata", "mb", "cd", "hd", "MD", "ind", "add", "ad", "mn", "desc", "mm", "mc", "pm", "mk", "ld", "sam", "pdf", "bd", "df"], "digest": ["mdester", "designester", "degested", "designested", "digist", "designesting", "digute", "Digute", "Digidate", " digum", "degester", "mdist", "digidate", "digum", "degesting", "designest", "mdesting", "Digum", "mdEST", "digesting", "signute", "mdum", "digEST", "mdest", "signum", " digidate", "signidate", " digist", "Digist", "mdested", " digute", " digEST", "digested", "digester", "signest", "DigEST", "Digest", "degest"]}}
{"id1": "6403868", "id2": "9109613", "code1": "    private File extractUninstallFiles(File _destPath, boolean upgrade, String lastVer) {\n        File oldlog = null;\n        try {\n            boolean oldClassCopied = false;\n            File destPath = new File(_destPath, \"vai_\" + VAGlobals.APP_NAME + \"_\" + VAGlobals.APP_VERSION);\n            if (upgrade) {\n                File lastVerPath = new File(_destPath, \"vai_\" + VAGlobals.APP_NAME + \"_\" + lastVer);\n                if (destPath.equals(lastVerPath)) {\n                    File bkdir = new File(destPath.getAbsolutePath() + \".bak\");\n                    if (!destPath.renameTo(bkdir)) {\n                        throw new IOException(VAGlobals.i18n(\"Setup_NotCreateDirectory\") + \" \" + destPath);\n                    }\n                    oldlog = new File(bkdir.getAbsolutePath() + System.getProperty(\"file.separator\") + \"uninstall.vai\");\n                    lastVerPath = bkdir;\n                } else {\n                    oldlog = new File(lastVerPath.getAbsolutePath() + System.getProperty(\"file.separator\") + \"uninstall.vai\");\n                }\n                if ((!destPath.exists()) && (!destPath.mkdirs())) {\n                    throw new IOException(VAGlobals.i18n(\"Setup_NotCreateDirectory\") + \" \" + destPath);\n                }\n                if (uInfo_.module) oldClassCopied = copyOldSetupClass(lastVerPath, destPath);\n            } else {\n                if ((!destPath.exists()) && (!destPath.mkdirs())) {\n                    throw new IOException(VAGlobals.i18n(\"Setup_NotCreateDirectory\") + \" \" + destPath);\n                }\n            }\n            dirty_ = true;\n            File[] ls = destPath.listFiles();\n            for (int i = 0; i < ls.length; i++) {\n                if (!oldClassCopied) ls[i].delete(); else if (!ls[i].getPath().equals(destPath.getAbsolutePath() + File.separator + installClassName_ + \".class\")) ls[i].delete();\n            }\n            byte[] buf = new byte[0];\n            int read = 0;\n            if (!oldClassCopied && (installClassSize_ > 0 || jarOffset_ > 0)) {\n                final File outClassFile = new File(destPath.getAbsolutePath() + File.separator + installClassName_ + \".class\");\n                if (outClassFile.exists() && !outClassFile.delete()) {\n                    ui_.showError(new Exception(VAGlobals.i18n(\"Setup_FileNotCreated\") + \":\\n\" + outClassFile.getName()));\n                }\n                final FileOutputStream out = new FileOutputStream(outClassFile);\n                final FileInputStream in = new FileInputStream(fileWithArchive_);\n                if (installClassOffset_ > 0) {\n                    in.skip(installClassOffset_);\n                }\n                buf = new byte[0];\n                if (installClassSize_ < 0) buf = new byte[(int) jarOffset_]; else buf = new byte[(int) installClassSize_];\n                read = in.read(buf, 0, buf.length);\n                out.write(buf, 0, read);\n                out.close();\n                in.close();\n            }\n            final FileInputStream in = new FileInputStream(fileWithArchive_);\n            if (jarOffset_ > 0) {\n                in.skip(jarOffset_);\n            }\n            JarInputStream jar = new JarInputStream(in);\n            final File outJarFile = new File(destPath.getAbsolutePath() + File.separator + \"install.jar\");\n            if (outJarFile.exists() && !outJarFile.delete()) {\n                ui_.showError(new Exception(VAGlobals.i18n(\"Setup_FileNotCreated\") + \":\\n\" + outJarFile.getName()));\n            }\n            JarOutputStream outJar = new JarOutputStream(new FileOutputStream(outJarFile));\n            ZipEntry entry = jar.getNextEntry();\n            final int bufSize = 32768;\n            buf = new byte[bufSize];\n            while (entry != null) {\n                String entryName = entry.getName();\n                if (entryName.equals(\"com/memoire/vainstall/resources/vainstall.properties\")) {\n                } else if (entryName.equals(installClassName_ + \".class\") && !oldClassCopied) {\n                    FileOutputStream out = null;\n                    try {\n                        out = new FileOutputStream(destPath.getAbsolutePath() + File.separator + installClassName_ + \".class\");\n                        VAGlobals.copyStream(jar, out, buf);\n                    } catch (IOException e) {\n                        throw e;\n                    } finally {\n                        if (out != null) out.close();\n                    }\n                } else if (!entryName.endsWith(\".zip\")) {\n                    if (VAGlobals.DEBUG) VAGlobals.printDebug(\"jar entry name \" + entryName);\n                    ZipEntry outEntry = new ZipEntry(entryName);\n                    CRC32 crc = new CRC32();\n                    outJar.putNextEntry(outEntry);\n                    int size = 0;\n                    while ((read = jar.read(buf, 0, bufSize)) >= 0) {\n                        size += read;\n                        if (read == 0) {\n                            Thread.yield();\n                        } else {\n                            outJar.write(buf, 0, read);\n                            crc.update(buf, 0, read);\n                        }\n                    }\n                    outEntry.setSize(size);\n                    outEntry.setCrc(crc.getValue());\n                    outJar.flush();\n                    outJar.closeEntry();\n                }\n                jar.closeEntry();\n                entry = jar.getNextEntry();\n            }\n            InputStream pin = getClass().getResourceAsStream(\"resources/vainstall.properties\");\n            Properties prop = new Properties();\n            try {\n                prop.load(pin);\n            } catch (IOException exc) {\n            }\n            if (language == null) language = \"default\";\n            prop.setProperty(\"vainstall.destination.language\", language);\n            ZipEntry outEntry = new ZipEntry(\"com/memoire/vainstall/resources/vainstall.properties\");\n            CRC32 crc = new CRC32();\n            outEntry.setCrc(crc.getValue());\n            outEntry.setSize(prop.size());\n            outJar.putNextEntry(outEntry);\n            prop.store(outJar, VAGlobals.NAME + \" \" + VAGlobals.VERSION);\n            outEntry.setCrc(crc.getValue());\n            outJar.closeEntry();\n            jar.close();\n            outJar.close();\n            in.close();\n        } catch (IOException e) {\n            String message = e.getLocalizedMessage();\n            message += \"\\n\" + VAGlobals.i18n(\"Setup_ErrorUninstallScripts\");\n            e.printStackTrace();\n            exitOnError(new IOException(message));\n        }\n        return oldlog;\n    }\n", "code2": "    public static void fileCopy(String from_name, String to_name) throws IOException {\n        File fromFile = new File(from_name);\n        File toFile = new File(to_name);\n        if (fromFile.equals(toFile)) abort(\"cannot copy on itself: \" + from_name);\n        if (!fromFile.exists()) abort(\"no such currentSourcepartName file: \" + from_name);\n        if (!fromFile.isFile()) abort(\"can't copy directory: \" + from_name);\n        if (!fromFile.canRead()) abort(\"currentSourcepartName file is unreadable: \" + from_name);\n        if (toFile.isDirectory()) toFile = new File(toFile, fromFile.getName());\n        if (toFile.exists()) {\n            if (!toFile.canWrite()) abort(\"destination file is unwriteable: \" + to_name);\n        } else {\n            String parent = toFile.getParent();\n            if (parent == null) abort(\"destination directory doesn't exist: \" + parent);\n            File dir = new File(parent);\n            if (!dir.exists()) abort(\"destination directory doesn't exist: \" + parent);\n            if (dir.isFile()) abort(\"destination is not a directory: \" + parent);\n            if (!dir.canWrite()) abort(\"destination directory is unwriteable: \" + parent);\n        }\n        FileInputStream from = null;\n        FileOutputStream to = null;\n        try {\n            from = new FileInputStream(fromFile);\n            to = new FileOutputStream(toFile);\n            byte[] buffer = new byte[4096];\n            int bytes_read;\n            while ((bytes_read = from.read(buffer)) != -1) to.write(buffer, 0, bytes_read);\n        } finally {\n            if (from != null) try {\n                from.close();\n            } catch (IOException e) {\n                ;\n            }\n            if (to != null) try {\n                to.close();\n            } catch (IOException e) {\n                ;\n            }\n        }\n    }\n", "label": 1, "substitutes": {"extractUninstallFiles": ["extractuninstallFile", "extractUnpackItems", "extractuninstallFiles", "extractUnInstallFiles", "extractUninstallFile", "extractUnpackFiles", "extractUnInstallItems", "extractunInstallFile", "extractunInstallFiles", "extractUninstallItems", "extractuninstallItems", "extractunInstallItems", "extractUnInstallFile", "extractUnpackFile"], "_destPath": ["_tempDir", "_DestPath", "_destDir", "_DestDir", "_sourcePath", "_restKey", "_restPath", "_privPoint", "_privPath", "_sourceDir", "_combPath", "_destFormat", "_privDir", "_restDir", "_DestTh", "_tempPath", "_restPoint", "_srcKey", "_destTh", "_tempFormat", "_tempTh", "_srcPath", "_srcDir", "_privTh", "_DestKey", "_destKey", "_tempPoint", "_sourceFormat", "_combDir", "_srcPoint", "_combFormat", "_destPoint", "_DestPoint"], "upgrade": ["downgrades", "exgrades", "upgrad", "downgrade", "ungrade", "exchange", "upate", "downcheck", "unate", "equate", "upcp", "uncp", " upcp", "equgrade", "excheck", " upgrades", "upgrades", " upchange", " upgrad", " upcheck", "equgrad", "upcheck", "downchange", "exgrade", "upchange", "ungrad", " upate", "equcp"], "lastVer": ["latestServ", "nextVer", "lastVers", " lastver", "oldver", " lastVersion", "Lastver", " lastRes", "LastVersion", "LastVer", "oldVersion", "nextServ", "lastServ", "lastVersion", " lastVers", "latestVers", "oldVer", "LastVers", "latestVer", " lastServ", "nextRes", "oldVers", "lastRes", "latestRes", "lastver", "nextVers"], "oldlog": ["Oldpath", "OldLog", " olderr", "oldpath", "OLDLog", "oldog", " oldog", "oldLog", "olderog", "Oldlog", "Oldog", "oldererr", " oldLog", " oldpath", "olderLog", "OLDpath", "OLDlog", "olderlog", "OLDog", "olderr", "olderpath", "OLDerr"], "destPath": ["DestRoot", "descTime", "destFont", "sortFont", " destLog", "identPort", "locPath", "foreignStream", " destRoot", " destNode", "DestPoint", "DestLog", "locDisk", "destHost", "sortFull", "restPath", "potStream", "gestHost", "potPath", "destDir", "destTh", "destPos", "potPod", "destFile", " destHost", "destNode", "destFull", "foreignDir", "identPath", "altHost", "destPort", "privDir", "privRoot", " destPoint", "DestPath", "descPath", "sortPath", "DestFull", "gestNode", "estDir", "originPoint", "destDisk", "estRef", "srcPath", " destDir", "descName", "privPos", "destStream", "estKey", "srcPort", " destKey", " destRef", "identTh", " destName", "DestDir", "declFull", "DestPos", "foreignPod", "destKey", "privPath", "potDir", "DestPort", "altDir", "restFile", "declFont", "originTh", " destFile", "foreignPath", "destTime", "declDir", " destPos", "declPath", "DestFont", "gestName", "gestPath", "descKey", "srcLog", "srcDir", "DestParent", "gestTime", "restDir", "destRoot", "destLog", "destParent", "altPoint", "DestRef", "destDirectory", "DestDirectory", "descDisk", "sortDir", "altPath", " destTh", "originPort", "estName", "DestStream", "altParent", " destDirectory", "altNode", "originPath", "destRef", "DestFile", "DestPod", "destPoint", "destPod", "descNet", "DestName", "estPath", "srcFile", "destNet", "altName", " destParent", "gestNet", "estPos", "descPos", "gestDisk", "identPoint", "restPoint", "destName", "srcDirectory", "locNet", " destPort", "locTime"], "lastVerPath": ["lastverPath", "lastverDir", "lastVerForm", "lastVERVal", "highestVERFile", " lastVerFile", "lastRespath", " lastVerCh", "highestVERpath", "highestVerVal", "lastResPath", " lastverpath", "lastVERFile", " lastVerName", "lastVERpath", "lastVERPath", "lastResForm", "highestVERVal", "lastVersPath", "lastVersionFile", "lastVerpath", "lastverForm", " lastVerLog", "lastverVal", "lastResDir", "lastverpath", " lastverForm", "lastverFile", "highestVerPath", "lastVersVal", " lastVerDir", " lastVersPath", "lastVERForm", "lastVerFile", "lastVerLog", " lastVersCh", " lastverPath", "lastVersLog", "lastVersName", "highestVERPath", "lastVersionCh", " lastVersLog", " lastVerpath", "lastverLog", "lastVersionpath", "highestVerpath", "lastverCh", "lastverName", "highestVerFile", "lastVerVal", "lastVersCh", "lastVERDir", "lastVersFile", "lastVersionPath", " lastverDir", " lastVerForm", "lastVerDir", "lastVerspath", "lastVerName", "lastVerCh", " lastVersFile"], "bkdir": ["bukgroup", " bakdi", "Bkdir", "BckDir", " bkkDir", "bakdi", "bakDir", "Bkpath", "bckDir", "bukpath", "bckDIR", "bckfolder", "Bckdir", "BkDir", "blkjdir", "bkpath", "Bckpath", "bqfd", "blkjgroup", " bkfolder", "bkkpath", "BkDIR", " bkrel", "blkdir", "blkjfd", "bkkDIR", "bkjdir", " bkkfolder", "bkgDir", "bakrel", "bkjgroup", "bukdi", "bqdi", "bukDIR", "bqdir", "BckDIR", " bkdi", "bkrel", "bkkfolder", "bkgfolder", "bkjfd", "bkkdir", "bkfolder", "bkDir", "bkkdi", "blkfd", "bkgrel", "bkkDir", "bkdi", "bukfd", "bukdir", "bkkrel", "bkjdi", "bakfolder", " bakfolder", "bckdi", "bkDIR", " bakDir", " bakdir", "bckdir", "blkgroup", "blkjdi", "bqgroup", "bukDir", " bkkrel", "bkfd", " bkDir", "bkgroup", "bkgdir", " bkkdir", "bckpath", "bakdir", "blkdi"], "oldClassCopied": ["oldDirCopried", "oldDirCopiated", "oldClassReplaced", "oldclasscopied", "oldClasscopried", "oldClassCopie", "oldClassColified", "oldClasscopies", "oldclassCopaced", "oldClassCopyie", "oldDirReplied", "oldClasscopie", "oldClassReplies", "oldclasscopified", "oldClassRepliated", "oldDirRepliated", "oldClassChiated", "oldClasscopied", "oldClassChied", "oldclassCopified", "oldClassReplried", "oldClasscopified", "oldClassCopyied", "oldClassReplified", "oldClassCopified", "oldClassColaced", "oldClasscopiated", "oldClassReplied", "oldDirCopied", "oldDirReplies", "oldclasscopie", "oldClassCopaced", "oldDirReplried", "oldClassColied", "oldClassCopies", "oldDirCopies", "oldclasscopies", "oldClassCopiated", "oldClassCopyies", "oldClassCopyified", "oldClassChried", "oldclassCopie", "oldClassCopried", "oldclassCopied", "oldClassColies", "oldclassCopies", "oldClassChies"], "ls": ["xs", "ics", "els", "dl", "ms", "irs", "es", "la", "ln", "ws", "fs", "lt", "lines", "bs", "les", "qs", "lf", "ns", "acts", "los", "ps", "ts", "lv", "its", "less", "ats", "lists", "rs", "rl", "ols", "l", "sels", "ds", "las", "gs", "lis", "lc", "ars", "vs", "ists", "lbs", "ks", "ils", "tl", "LS", "cs", "abs"], "i": ["mi", "u", "j", "ini", "us", "y", "ski", "I", "qi", "di", "im", "ri", "ei", "m", "iq", "ki", "ami", "init", "x", "hi", "me", "ti", "chain", "fire", "bi", "b", "ic", "cli", "multi", "ci", "sim", "gi", "ui", "pi", "ij", "l", "ix", "ji", "it", "xi", "li", "ims", "si", "batch", "ip", "zi", "key", "io", "gu", "is", "ii", "oi", "eu", "index", "id", "a", "phi"]}}
{"id1": "12428013", "id2": "4118412", "code1": "    public static void polishOff(IProgressMonitor monitor, String from, String to, String renameTo) {\n        if (monitor != null && monitor.isCanceled()) {\n            return;\n        }\n        try {\n            ftpClient = new FTPClient();\n            ftpClient.setRemoteAddr(InetAddress.getByName(PrefPageOne.getValue(CONSTANTS.PREF_HOST)));\n            ftpClient.setControlPort(PrefPageOne.getIntValue(CONSTANTS.PREF_FTPPORT));\n            ftpClient.connect();\n            try {\n                Thread.sleep(1000);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n            ftpClient.login((PrefPageOne.getValue(CONSTANTS.PREF_USERNAME)), FTPUtils.decrypt(PrefPageOne.getValue(CONSTANTS.PREF_PASSWORD)));\n            try {\n                Thread.sleep(1000);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n            if (from != null) {\n                FTPHolder ftpHolder = new FTPHolder(from, to, renameTo, false);\n                synchedSet.add(ftpHolder);\n            }\n            JobHandler.aquireFTPLock();\n            for (Iterator iter = synchedSet.iterator(); iter.hasNext(); ) {\n                if (monitor != null && monitor.isCanceled()) {\n                    JobHandler.releaseFTPLock();\n                    ftpClient.quit();\n                    return;\n                }\n                Thread.yield();\n                FTPHolder element = (FTPHolder) iter.next();\n                ftpClient.setType(FTPTransferType.ASCII);\n                ftpClient.put(element.from, element.to);\n                if (element.renameTo != null) {\n                    try {\n                        ftpClient.delete(element.renameTo);\n                    } catch (Exception e) {\n                    }\n                    ftpClient.rename(element.to, element.renameTo);\n                    log.info(\"RENAME: \" + element.to + \"To: \" + element.renameTo);\n                }\n            }\n            JobHandler.releaseFTPLock();\n            ftpClient.quit();\n        } catch (UnknownHostException e) {\n            e.printStackTrace();\n        } catch (FTPException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        synchedSet.clear();\n    }\n", "code2": "    private void compress(String outputFile, ArrayList<String> inputFiles, PrintWriter log, boolean compress) throws Exception {\n        String absPath = getAppConfig().getPathConfig().getAbsoluteServerPath();\n        log.println(\"Concat files into: \" + outputFile);\n        OutputStream out = new FileOutputStream(absPath + outputFile);\n        byte[] buffer = new byte[4096];\n        int readBytes;\n        for (String file : inputFiles) {\n            log.println(\" Read: \" + file);\n            InputStream in = new FileInputStream(absPath + file);\n            while ((readBytes = in.read(buffer)) != -1) {\n                out.write(buffer, 0, readBytes);\n            }\n            in.close();\n        }\n        out.close();\n        if (compress) {\n            long normalSize = new File(absPath + outputFile).length();\n            ProcessBuilder builder = new ProcessBuilder(\"java\", \"-jar\", \"WEB-INF/yuicompressor.jar\", outputFile, \"-o\", outputFile, \"--line-break\", \"4000\");\n            builder.directory(new File(absPath));\n            Process process = builder.start();\n            process.waitFor();\n            long minSize = new File(absPath + outputFile).length();\n            long diff = normalSize - minSize;\n            double percentage = Math.floor((double) diff / normalSize * 1000.0) / 10.0;\n            double diffSize = (Math.floor(diff / 1024.0 * 10.0) / 10.0);\n            log.println(\"Result: \" + percentage + \" % (\" + diffSize + \" KB)\");\n        }\n    }\n", "label": 0, "substitutes": {"polishOff": ["finISHoff", " swishExec", " swISHOff", " swishersExec", " swishoff", "finishOff", " swishingExec", "finishExec", " swISHoff", "finISHOff", " swishingOff", " swishersoff", "finISHExec", " swishingoff", " swishersOff", " swISHExec", " swishOff", "finishoff"], "monitor": ["meter", "runner", "report", "video", "that", "pai", "mr", "problem", "test", "minimum", "Monitor", "driver", "mate", "execute", "description", "m", "summary", "processor", " monitoring", " Monitor", "status", "thread", "monkey", "mx", "trace", "profile", "directory", "menu", "log", "spin", "man", "mon", "hover", "message", "timer", "ai", "sim", "master", "detail", "dm", "number", "bm", "when", "progress", "state", "cm", "writer", "stat", "note", "handler", "batch", "network", "healthy", "tim", "manager", "info", "member", "watch", "pool", "timeout", "check", "username", "umi"], "from": ["origin", "back", "address", "text", "by", "about", "reset", "From", "original", "part", "a", "bound", "fr", "create", "set", "what", "before", "base", "code", "range", "link", "old", "un", "org", "off", "url", "name", "host", "str", "os", "input", "or", "pos", "query", "st", "rom", "normal", "form", "path", "term", "add", "local", "remote", "string", "html", "with", "no", "as", "source", "low", "file", "user", "id", "data"], "to": ["type", "tr", "address", "value", "by", "To", "about", "output", "test", "two", "toc", "on", "client", "TO", "tmp", "table", "tt", "t", "port", "po", "done", "template", "range", "tu", "pro", "org", "number", "format", " too", "name", "eto", "token", "os", "top", "total", "target", "too", "tab", " TO", "data", "into", "path", "term", "o", "oto", "auto", "html", "no", "size", "source", "file", "body", "zero", "id", "user", "ta", "delete"], "renameTo": ["renowOr", "renadeTo", "renenameBody", "reameOr", "renAMETo", "denamT", "denamTO", "renewFrom", "renAMEto", "renAMETO", "renokeTO", "renameFor", "denamTarget", "denameTo", "penAMEFrom", "penAMETo", "renowTO", "renameto", "renamiT", "reennameFrom", "renamiTo", "denameTO", "rennameFrom", "rennameTO", "rennameto", "renateto", "reameTarget", "renenameTO", "reameTO", "renAMEFrom", "renowTarget", "reameTo", "denameT", "renamiTarget", "renowTo", "rennamTo", "reennameTO", "denamTo", "penameFrom", "renamT", "penAMEFor", "renamesTO", "renateTarget", "renadeFor", "renenameTo", "renAMEFor", "renadeFrom", "renokeTo", "renateFrom", "renamTO", "renateTO", "renewTO", "reenameTO", "reameto", "renameT", "reameFrom", "renenameTarget", "renokeOr", "rennamFor", "reenameFrom", "renateTo", "renamesBody", "renameFrom", "reenameOr", "renamTo", "renewBody", "rennameTo", "renenameT", "renamesFrom", "rennamto", "denameTarget", "penAMEto", "renamTarget", "reameBody", "rennameTarget", "penameTo", "renamiTO", "reennameTarget", "renokeTarget", "renamesTo", "renameTO", "renameTarget", "renenameOr", "renewTo", "renadeto", "reenameBody", "renenameFrom", "renAMETarget", "reennameTo", "penameto", "rennamFrom", "renameOr", "reenameTarget", "renameBody", "penameFor", "reenameTo"], "ftpClient": ["ftpcConnection", "aftpRemote", "ftPClient", "afttpConnect", "ftPclient", "ftwpAPI", "fttpConn", "aftpEntry", "aftcpclient", "ftwpClient", "ftapStore", "aftpControl", "aftpPlayer", "ftcControl", "fttpEntry", "ftpStore", "ftpcClient", "aftcpEntry", "fttpConnect", "aftcpStore", "ftpConnection", "aftcpClient", "fttRemote", "ftpiControl", "ftapAPI", "ftcpConnection", "fttpStore", "ftapClient", "ftpControl", "ftPConnection", "afttpConnection", "ftcclient", "aftPClient", "fttpConnection", "ftpConnect", "ftcpStore", "ftcpClient", "aftpClient", "ftpiClient", "aftpConnection", "ftpEntry", "ftwpControl", "aftpConnect", "ftpAPI", "fttpclient", "fttclient", "afttpPlayer", "ftcpclient", "afttpControl", "ftphpclient", "ftcpConn", "afttpAPI", "ftapControl", "fttClient", "fttpRemote", "ftpcclient", "aftcpControl", "ftlpclient", "ftcpConnect", "afttpRemote", "afttpclient", "ftcpControl", "ftpPlayer", "ftpConn", "aftpAPI", "ftcClient", "ftcpPlayer", "afttpClient", "ftpclient", "aftPControl", "ftpcPlayer", "ftlpClient", "fttpPlayer", "aftcpConn", "aftpclient", "ftapclient", "ftPControl", "aftpStore", "ftphpEntry", "aftPclient", "fttpClient", "fttpControl", "ftcpEntry", "fttConn", "ftphpClient", "ftpRemote", "ftlpConnect", "fttpAPI", "ftcpRemote", "ftpiclient", "ftwpclient", "aftpConn"], "ftpHolder": ["ftpHoster", "ftphander", "ftpHeolder", "ftpHholder", "ftPHholder", "ftPHoster", "ftpHeander", "ftpHaver", "ftpHeoster", "ftphaver", "ftpHeholder", "ftPHander", "ftpNolder", "ftcpHolder", "ftcpHaver", "ftcpHoster", "ftpHander", "ftpNholder", "ftpNoster", "ftphoster", "ftcpHholder", "ftpNaver", "ftPHolder", "ftphholder", "ftpholder"], "iter": ["exp", "ser", "oper", "tr", "actor", "altern", "test", "ite", "reader", "other", "Iter", "inter", "thread", "mem", "inner", "orient", "loop", "impl", "Iterator", "list", "ptr", "counter", "ator", "itter", "writer", "coll", "ait", "outer", "valid", "it", "former", "walker", "per", "upper", "order", "ir", "enter", "iner", "iterator", "inv", "ner", "er", "cer", "ver", "store", "ne", "ter", "ipper"], "element": ["event", "empty", "style", "worker", "pair", "actor", "address", "item", "match", "entry", "test", "option", "sequence", "article", "air", "append", "finder", "module", "environment", "atom", "ment", "attribute", "action", "editor", "document", "message", "result", "cell", "letter", "e", "number", "detail", "variable", "le", "section", "container", "former", "lem", "ele", "object", "component", "Element", "lement", "search", "record", "instance", "xxx", "model", "iterator", "relation", "activity", "manager", "info", "member", "er", "field", "button", "lements", "folder", "elt", "data", "peer"]}}
{"id1": "4618237", "id2": "11049257", "code1": "    public static void writeFileToFile(File fin, File fout, boolean append) throws IOException {\n        FileChannel inChannel = new FileInputStream(fin).getChannel();\n        FileChannel outChannel = new FileOutputStream(fout, append).getChannel();\n        try {\n            inChannel.transferTo(0, inChannel.size(), outChannel);\n        } finally {\n            if (inChannel != null) try {\n                inChannel.close();\n            } catch (IOException ex) {\n            }\n            if (outChannel != null) try {\n                outChannel.close();\n            } catch (IOException ex) {\n            }\n        }\n    }\n", "code2": "    public static String generate(boolean secure, boolean sep) throws UnknownHostException {\n        MessageDigest messagedigest;\n        StringBuilder stringbuffer = new StringBuilder();\n        try {\n            messagedigest = MessageDigest.getInstance(\"MD5\");\n        } catch (NoSuchAlgorithmException nosuchalgorithmexception) {\n            throw new RuntimeException(nosuchalgorithmexception);\n        }\n        StringBuffer stringbuffer2;\n        InetAddress inetaddress = InetAddress.getLocalHost();\n        long l = System.currentTimeMillis();\n        long l1 = 0L;\n        if (secure) l1 = _secureRand.nextLong(); else l1 = _rand.nextLong();\n        stringbuffer.append(inetaddress.toString());\n        stringbuffer.append(\":\");\n        stringbuffer.append(Long.toString(l));\n        stringbuffer.append(\":\");\n        stringbuffer.append(Long.toString(l1));\n        messagedigest.update(stringbuffer.toString().getBytes());\n        byte abyte0[] = messagedigest.digest();\n        StringBuffer stringbuffer1 = new StringBuffer();\n        for (int i = 0; i < abyte0.length; i++) {\n            int j = abyte0[i] & 0xff;\n            if (j < 16) stringbuffer1.append('0');\n            stringbuffer1.append(Integer.toHexString(j));\n        }\n        String s = stringbuffer1.toString();\n        stringbuffer2 = new StringBuffer();\n        if (sep) {\n            stringbuffer2.append(s.substring(0, 8));\n            stringbuffer2.append(\"-\");\n            stringbuffer2.append(s.substring(8, 12));\n            stringbuffer2.append(\"-\");\n            stringbuffer2.append(s.substring(12, 16));\n            stringbuffer2.append(\"-\");\n            stringbuffer2.append(s.substring(16, 20));\n            stringbuffer2.append(\"-\");\n            stringbuffer2.append(s.substring(20));\n            return stringbuffer2.toString();\n        } else {\n            return s;\n        }\n    }\n", "label": 0, "substitutes": {"writeFileToFile": ["writeFile2Disk", "writeFilesToStream", "writeFiles2File", "writeFiles2Disk", "writeFileToFiles", "writeFile2Stream", "writeFiles2Files", "writeFileAndFile", "writeFilesToFile", "writeFileToDisk", "writeFiles2Stream", "writeFilesToFiles", "writeFile2File", "writeFile2Files", "writeFileAndFiles", "writeFileAsFiles", "writeFileAsStream", "writeFileToStream", "writeFilesToDisk", "writeFileAndDisk", "writeFileAndStream", "writeFileAsFile", "writeFileAsDisk"], "fin": ["f", "lo", "en", "fi", "rin", "lin", "ini", "irm", "raf", "details", "ln", "fur", "fr", "fil", "fp", "FIN", "init", "lf", "in", "fc", "fd", "ic", "mid", "kin", "ran", "rf", "han", "fw", "jen", "normal", "Fin", "focus", "syn", "inv", "fre", "mn", "n", "fa", "din", "mil", "fn", "fl"], "fout": ["fpo", "Fou", "kOut", " fpo", "FOut", "ffOut", "kpo", "kout", "fou", "ffou", "Fout", "tin", "fOut", "fbOut", "ffout", "fbout", " fOut", "tOut", " foutput", "fboutput", "tout", "fbpo", "koutput", "Fin", "tou", "ffin", "foutput"], "append": ["csv", "include", "buff", "insert", "ends", "fail", "bold", "force", "allow", "pend", "animate", "flat", "app", "command", "printf", "replace", "absolute", "join", "vert", "grow", "equal", "ext", "note", "seed", "batch", "ended", "ind", "add", "express", "string", "send", "folder", "apply", "update", "end", "push"], "inChannel": [" inListener", "InConnection", "sinMachine", "iCommand", "insideClient", "iChannel", "intSession", "inChan", "sinCategory", "intChannel", "innMachine", "insideChannel", "inListener", "outCommand", "pinButton", "outConnection", "insideChan", "inSession", " inClient", "pinMachine", "InChannel", "innChannel", "inCommand", "InStream", "inputListener", "rinListener", "inputChannel", "intClient", " inConnection", "intChan", " inchannel", "pinCategory", "rinChan", "innCategory", " inCategory", "innButton", "iChan", " inSession", " inStream", "inputChan", "inCategory", "iStream", "outStream", " inChan", "inputCategory", "inConnection", "rinCategory", "inchannel", "outChan", "sinChannel", "insideSession", "pinChannel", " inCommand", "sinButton", "outchannel", "inMachine", "Inchannel", "rinChannel", "inButton", "inClient", "inStream"], "outChannel": ["outputScope", "outputConnection", "invChannel", "nameChannel", "inChan", " outScope", "OUTChan", "userMember", "invCh", "outputchannel", "outConnection", " outCh", "outScope", "OUTchannel", " outChan", "netChannel", "nameChan", "userChannel", "netCh", "inCh", "userCh", "nameConnection", "OUTController", "nameScope", "netController", "outController", "netchannel", "invMember", "OUTChannel", " outController", "outMember", " outchannel", " outConnection", "inchannel", "outChan", "outputChannel", "outputCh", "netChan", "netMember", "outchannel", "outCh", "outputChan"]}}
{"id1": "4593011", "id2": "20275821", "code1": "    private void loadDDL() throws IOException {\n        try {\n            conn.createStatement().executeQuery(\"SELECT * FROM overrides\").close();\n        } catch (SQLException e) {\n            Statement stmt = null;\n            if (!e.getMessage().startsWith(ERR_MISSING_TABLE)) {\n                LOG.fatal(SQL_ERROR, e);\n                throw new IOException(\"Error on initial data store read\", e);\n            }\n            String[] qry = { \"CREATE TABLE monitor (id INTEGER PRIMARY KEY NOT NULL, status VARCHAR(32) NOT NULL, next_update TIMESTAMP NOT NULL)\", \"CREATE TABLE overrides (id INT NOT NULL, title VARCHAR(255) NOT NULL, subtitle VARCHAR(255) NOT NULL, enable BOOLEAN NOT NULL DEFAULT TRUE, PRIMARY KEY(id))\", \"CREATE TABLE settings (var VARCHAR(32) NOT NULL, val VARCHAR(255) NOT NULL, PRIMARY KEY(var))\", \"INSERT INTO settings (var, val) VALUES ('schema', '1')\" };\n            try {\n                conn.setAutoCommit(false);\n                stmt = conn.createStatement();\n                for (String q : qry) stmt.executeUpdate(q);\n                conn.commit();\n            } catch (SQLException e2) {\n                try {\n                    conn.rollback();\n                } catch (SQLException e3) {\n                    LOG.fatal(SQL_ERROR, e3);\n                }\n                LOG.fatal(SQL_ERROR, e2);\n                throw new IOException(\"Error initializing data store\", e2);\n            } finally {\n                if (stmt != null) {\n                    try {\n                        stmt.close();\n                    } catch (SQLException e4) {\n                        LOG.fatal(SQL_ERROR, e4);\n                        throw new IOException(\"Unable to cleanup data store resources\", e4);\n                    }\n                }\n                try {\n                    conn.setAutoCommit(true);\n                } catch (SQLException e3) {\n                    LOG.fatal(SQL_ERROR, e3);\n                    throw new IOException(\"Unable to reset data store auto commit\", e3);\n                }\n            }\n        }\n        return;\n    }\n", "code2": "    public FileAttribute getAttribute(URL url) throws VFSException {\n        try {\n            con = (HttpURLConnection) url.openConnection();\n            con.setInstanceFollowRedirects(false);\n            int response = con.getResponseCode();\n            if (response >= 400) {\n                return new DefaultFileAttribute(false, 0, null, FileType.NOT_EXISTS);\n            }\n            boolean redirect = (response >= 300 && response <= 399);\n            if (redirect) {\n                String location = con.getHeaderField(\"Location\");\n                return getAttribute(new URL(url, location));\n            }\n            return new DefaultFileAttribute(true, con.getContentLength(), new Date(con.getLastModified()), url.toString().endsWith(\"/\") ? FileType.DIRECTORY : FileType.FILE);\n        } catch (MalformedURLException e) {\n            e.printStackTrace();\n            throw new WrongPathException(file.getAbsolutePath());\n        } catch (IOException e) {\n            throw new VFSIOException(\"IOException opening \" + file.getAbsolutePath(), e);\n        } finally {\n            if (con != null) {\n                con.disconnect();\n            }\n        }\n    }\n", "label": 0, "substitutes": {"loadDDL": ["loadDDLS", "loadSDDL", "readDDl", "readPDDL", "loadDSDL", "loadSDL", "readPDl", "loadPDL", "loadDSL", "loadSDl", "loadDSl", "readDDL", "loadDDl", "loadSDLS", "readDDLS", "readPDL", "loadPDLS", "loadPDl", "readDDDL", "loadPDDL", "loadDDDL", "loadDSLS", "readPDLS"], "stmt": ["Sttx", " sttr", "Stm", "stm", " Stmt", "stMT", "steMT", "stedo", "Stmn", " superstmt", "stemt", "strmt", "Sttr", "ttr", "stmm", "sttx", " stmm", "tmt", " sttx", " superstMT", "tMT", "StMT", "strmn", "STtx", " stmb", " Stpt", "STm", " stm", "STMT", " superstm", "stem", "stmb", " stpt", "strmb", " StMT", "Stdo", " stdo", "tmm", "stpt", "stdo", "Stmm", "sttr", " stMT", "Stmt", "Stmb", " stmn", "stmn", " superstpt", "STmt", "strMT", " Stm"], "qry": ["Qri", "qury", "qries", "sqries", "qrys", "qutry", " qtry", " qries", " qri", "sqry", "sqri", "qri", "quri", "quries", "Qries", "Qrys", "qtry", "sqrys", "Qry", "sqtry", " qrys"], "q": ["f", "u", "j", "z", "y", "qi", "d", "h", "m", "iq", "qs", "quest", "Q", "t", "sq", "k", "c", "pkg", "v", "i", "e", "qq", " sq", "ql", "l", "ry", "query", "qv", "g", "o", "qu", "n", "dq", "qt", "p", "qa", "w"]}}
{"id1": "339517", "id2": "4921631", "code1": "    ClassFile getClassFile(String name) throws IOException, ConstantPoolException {\n        URL url = getClass().getResource(name);\n        InputStream in = url.openStream();\n        try {\n            return ClassFile.read(in);\n        } finally {\n            in.close();\n        }\n    }\n", "code2": "    public int create(BusinessObject o) throws DAOException {\n        int insert = 0;\n        int id = 0;\n        Item item = (Item) o;\n        try {\n            PreparedStatement pst = connection.prepareStatement(XMLGetQuery.getQuery(\"INSERT_ITEM\"));\n            pst.setString(1, item.getDescription());\n            pst.setDouble(2, item.getUnit_price());\n            pst.setInt(3, item.getQuantity());\n            pst.setDouble(4, item.getVat());\n            pst.setInt(5, item.getIdProject());\n            pst.setInt(6, item.getIdCurrency());\n            insert = pst.executeUpdate();\n            if (insert <= 0) {\n                connection.rollback();\n                throw new DAOException(\"Number of rows <= 0\");\n            } else if (insert > 1) {\n                connection.rollback();\n                throw new DAOException(\"Number of rows > 1\");\n            }\n            Statement st = connection.createStatement();\n            ResultSet rs = st.executeQuery(\"select max(id_item) from item\");\n            rs.next();\n            id = rs.getInt(1);\n            connection.commit();\n        } catch (SQLException e) {\n            Log.write(e.getMessage());\n            throw new DAOException(\"A SQLException has occured\");\n        } catch (NullPointerException npe) {\n            Log.write(npe.getMessage());\n            throw new DAOException(\"Connection null\");\n        }\n        return id;\n    }\n", "label": 0, "substitutes": {"getClassFile": [" getAppFactory", "getMethodFactory", "getAppClass", " getAppClass", " getAppFile", "getPackageFile", "getMethodClass", "getClassPage", " getClassPage", "getAppFile", "getPackageClass", "getAppFactory", "getAppPage", "getPackageFactory", " getAppPage", " getClassClass", "getClassClass", "getClassFactory", "getMethodFile", "getMethodPage", "getPackagePage", " getClassFactory"], "name": ["type", "address", "value", "named", "word", "resource", "description", "names", "base", "command", "message", "missing", "filename", "uri", "str", "initial", "NAME", "search", "path", "ame", "full", "key", "n", "string", "file", "class", "password", "id", "Name", "data", "prefix", "title"], "url": ["f", "browser", "gl", "address", "ref", "dl", "service", "resource", "client", "bel", "ls", "web", "ll", "char", "q", "link", "log", "sl", "open", "b", "build", "lr", "rel", "mount", "uri", "URL", "str", "l", "ch", "nl", "ul", "mail", "path", "null", "ret", "http", "io", "file", "loc", "Url", "user", "abs"], "in": ["f", "all", "rin", "en", "inn", "and", "gin", "con", "IN", "ins", "reader", "ln", "oin", "sum", "stream", "al", "In", "inner", "lit", "asin", "i", "read", "bin", "act", "mat", "serv", "inc", "l", "input", "out", "sin", "or", "cond", "it", " din", "s", "ind", "add", "mn", "mc", "io", "din", "is", "isin", "body", "cin", "data"]}}
{"id1": "12306305", "id2": "2668634", "code1": "    private static void doCopyFile(File srcFile, File destFile, boolean preserveFileDate) throws IOException {\n        if (destFile.exists() && destFile.isDirectory()) {\n            throw new IOException(\"Destination '\" + destFile + \"' exists but is a directory\");\n        }\n        FileChannel input = new FileInputStream(srcFile).getChannel();\n        try {\n            FileChannel output = new FileOutputStream(destFile).getChannel();\n            try {\n                output.transferFrom(input, 0, input.size());\n            } finally {\n                IOUtil.closeQuietly(output);\n            }\n        } finally {\n            IOUtil.closeQuietly(input);\n        }\n        if (srcFile.length() != destFile.length()) {\n            throw new IOException(\"Failed to copy full contents from '\" + srcFile + \"' to '\" + destFile + \"'\");\n        }\n        if (preserveFileDate) {\n            destFile.setLastModified(srcFile.lastModified());\n        }\n    }\n", "code2": "    public WebmillDeploy(String inputName, String outputName, boolean stripLoggers) throws Exception {\n        File tempFile = null;\n        JarFile jin = null;\n        JarOutputStream jout = null;\n        FileChannel srcChannel = null;\n        FileChannel dstChannel = null;\n        try {\n            String portletApplicationName = getPortletApplicationName(outputName);\n            System.out.println(\"portletApplicationName = \" + portletApplicationName);\n            tempFile = File.createTempFile(\"webmill-delpoy-\", \"\");\n            tempFile.deleteOnExit();\n            jin = new JarFile(inputName);\n            jout = new JarOutputStream(new FileOutputStream(tempFile));\n            Document webXml = null;\n            Document portletXml = null;\n            Document contextXml = null;\n            ZipEntry src;\n            InputStream source;\n            Enumeration zipEntries = jin.entries();\n            while (zipEntries.hasMoreElements()) {\n                src = (ZipEntry) zipEntries.nextElement();\n                source = jin.getInputStream(src);\n                try {\n                    String target = src.getName();\n                    if (WEB_INF_WEB_XML.equals(target)) {\n                        System.out.println(\"Found web.xml\");\n                        webXml = parseXml(source);\n                    } else if (WEB_INF_PORTLET_XML.equals(target)) {\n                        System.out.println(\"Found WEB-INF/portlet.xml\");\n                        portletXml = parseXml(source);\n                    } else if (META_INF_CONTEXT_XML.equals(target)) {\n                        System.out.println(\"Found META-INF/context.xml\");\n                        contextXml = parseXml(source);\n                    }\n                } finally {\n                    source.close();\n                }\n            }\n            if (webXml == null) {\n                throw new IllegalArgumentException(\"WEB-INF/web.xml not found\");\n            }\n            if (portletXml == null) {\n                throw new IllegalArgumentException(\"WEB-INF/portlet.xml not found\");\n            }\n            WebmillWebApplicationRewriter webRewriter = new WebmillWebApplicationRewriter(webXml);\n            webRewriter.processWebXML();\n            WebmillContextRewriter contextRewriter = new WebmillContextRewriter(contextXml, portletApplicationName);\n            contextRewriter.processContextXML();\n            jin = new JarFile(inputName);\n            zipEntries = jin.entries();\n            while (zipEntries.hasMoreElements()) {\n                src = (ZipEntry) zipEntries.nextElement();\n                source = jin.getInputStream(src);\n                try {\n                    String target = src.getName();\n                    String fullTarget = '/' + target;\n                    if (stripLoggers && target.endsWith(\".jar\") && (target.startsWith(\"WEB-INF/lib/commons-logging\") || target.startsWith(\"WEB-INF/lib/log4j\"))) {\n                        System.out.println(\"Skip logger \" + target);\n                        continue;\n                    } else {\n                        if (webRewriter.getRealPortletTldFile() != null && fullTarget.equals(webRewriter.getRealPortletTldFile())) {\n                            System.out.println(\"Skip portlet tld file \" + fullTarget);\n                            continue;\n                        } else if (target.equals(WEB_INF_WEB_XML)) {\n                            System.out.println(\"Skip web.xml file \" + target);\n                            continue;\n                        } else if (target.equals(WEB_INF_PORTLET_XML)) {\n                            System.out.println(\"Skip portlet.xml file \" + target);\n                            continue;\n                        } else if (target.equals(META_INF_CONTEXT_XML)) {\n                            System.out.println(\"Skip context.xml file \" + target);\n                            continue;\n                        }\n                        System.out.println(\"Add file \" + target);\n                    }\n                    addFile(target, source, jout);\n                } finally {\n                    source.close();\n                }\n            }\n            addFile(WEB_INF_WEB_XML, webXml, jout);\n            addFile(WEB_INF_PORTLET_XML, portletXml, jout);\n            addFile(META_INF_CONTEXT_XML, contextXml, jout);\n            System.out.println(\"Attempting to add portlet.tld to war...\");\n            InputStream is = this.getClass().getResourceAsStream(\"/org/riverock/webmill/container/tags/portlet.tld\");\n            if (is == null) {\n                System.out.println(\"Failed to find portlet.tld in classpath\");\n            } else {\n                String portletTldFile = webRewriter.getRealPortletTldFile();\n                if (portletTldFile.charAt(0) == '/') {\n                    portletTldFile = portletTldFile.substring(1);\n                }\n                System.out.println(\"Adding file \" + portletTldFile);\n                try {\n                    addFile(portletTldFile, is, jout);\n                } finally {\n                    is.close();\n                }\n            }\n            jout.close();\n            jin.close();\n            jin = null;\n            jout = null;\n            System.out.println(\"Creating war \" + outputName + \" ...\");\n            System.out.flush();\n            srcChannel = new FileInputStream(tempFile).getChannel();\n            dstChannel = new FileOutputStream(outputName).getChannel();\n            dstChannel.transferFrom(srcChannel, 0, srcChannel.size());\n            srcChannel.close();\n            srcChannel = null;\n            dstChannel.close();\n            dstChannel = null;\n            tempFile.delete();\n            tempFile = null;\n            System.out.println(\"War \" + outputName + \" created\");\n            System.out.flush();\n        } finally {\n            if (srcChannel != null && srcChannel.isOpen()) {\n                try {\n                    srcChannel.close();\n                } catch (IOException e1) {\n                }\n            }\n            if (dstChannel != null && dstChannel.isOpen()) {\n                try {\n                    dstChannel.close();\n                } catch (IOException e1) {\n                }\n            }\n            if (jin != null) {\n                try {\n                    jin.close();\n                    jin = null;\n                } catch (IOException e1) {\n                }\n            }\n            if (jout != null) {\n                try {\n                    jout.close();\n                    jout = null;\n                } catch (IOException e1) {\n                }\n            }\n            if (tempFile != null && tempFile.exists()) {\n                tempFile.delete();\n            }\n        }\n    }\n", "label": 1, "substitutes": {"doCopyFile": [" doCopyfile", "doMoveFile", " doCopFile", "docopyByte", " doCopyFiles", "doCopyfile", "doCopyFiles", "docopyFiles", " doCopfile", "doMovefile", "docopyFile", "docopyfile", " doCopByte", "doCopfile", " doCopFiles", "doCopFiles", " doCopyByte", "doCopByte", "doCopFile", "doMoveFiles", "doMoveByte", "doCopyByte"], "srcFile": ["rcile", "destfile", "sourceFile", "sourcefile", "rbFILE", "srcModel", "srcFilename", "srcPath", "destFilename", " srcDir", "sourceLine", "destPage", " srcFILE", "selFile", "srcDir", "selfile", " srcFilename", "rbFilename", "sourceDir", " srcPage", "srcLine", "srcFILE", "srcPage", " srcModel", "rbPath", "locFilename", "rcFilename", "destile", "locModel", "rcFile", "locFile", "rcPage", "rcDir", "selPage", "srcfile", "rbFile", "selFilename", "locPage", " srcile", "rcLine", "rcPath", " srcLine", "rcfile", "destLine", "srcile", "rcFILE", " srcPath", "destModel", " srcfile"], "destFile": [" destGrid", "DestFiles", "litFile", "memFILE", "srcOnly", "critfile", "destfile", "memFiles", "origDir", "critGrid", "descFile", "origOnly", "srcFiles", "srcFilename", "DestPage", " destDir", "DestMail", "DestGrid", "destFilename", "critDir", "distFile", "foreignOnly", "destFILE", "destPage", "declFILE", "destGrid", "srcDir", " destFILE", "distDir", " destFiles", "srcFILE", "srcPage", "origFile", "destDirectory", "DestDirectory", "srcGrid", "litMail", "litFILE", "origFILE", "DestDir", " destFilename", "DestFILE", "critFile", "destOnly", "descGrid", "destDir", "descPage", "declfile", "foreignFILE", "foreignFile", "memFile", "Destfile", "srcfile", " destDirectory", "memfile", "distfile", "foreignDir", " destPage", "destMail", "DestFile", "descDir", "distFilename", "srcDirectory", "destFiles", "litfile", "DestFilename", "declFile", "declMail", " destfile"], "preserveFileDate": ["presoreFileSize", "preserveSetDate", "preserveFilesSize", "preservesFileDay", "preservesFileTime", "preserveFilesdate", "preserveSetDay", "preservesfileTime", "preserveLinedate", "preserveFilenameDay", "preserveLineDate", "presoreLotSize", "preservesfileDuration", "preserveLotdate", "preserveFileSize", "preserveFileDay", "preserveLineSize", "presoreLotDate", "presoreFiledate", "preserveLotSize", "preserveFileTime", "preservesfileDate", "preservesFileDate", "preserveFiledate", "presoreLotDay", "preserveLineDay", "preservefileTime", "preserveFilenameTime", "preserveFilenameDate", "preserveFilenameDuration", "preservefileDay", "preserveSetTime", "preserveSetDuration", "presoreFileDate", "preservesfileDay", "preserveLotDate", "preserveFileDuration", "preserveFilesDate", "preservefileDuration", "preservefileDate", "presoreFileDay", "preserveFilesDay", "presoreLotdate", "preserveLotDay", "preservesFileDuration"], "input": ["installed", "image", "json", "alpha", "entry", "internal", "request", " Input", "reader", "op", "client", "raw", "stream", "context", "init", "feed", "accept", "in", "inner", "before", "q", "command", "buffer", "open", "current", "Input", "xml", "up", "read", "get", "partial", "hidden", "archive", "initial", "upload", "iter", "it", "history", "parse", "audio", "focus", "ip", "add", "auto", "pattern", "local", "info", "http", "io", "start", "exec", "source", "index", "from"], "output": ["response", "image", "block", "text", "ilo", "put", "console", "next", "client", "stream", "web", "page", "module", "Output", "connection", "port", "four", "generated", "net", "write", "open", "buffer", "message", "result", "format", "hidden", "writer", "success", "outer", "section", "out", "exit", "ou", "group", "network", "o", "auto", "cut", "channel", "remote", "icon", "file", "latest", "body", "print", "data", "display"]}}
{"id1": "11477906", "id2": "13886238", "code1": "    private static void loadDefaultSettings(final String configFileName) {\n        InputStream in = null;\n        OutputStream out = null;\n        try {\n            in = Thread.currentThread().getContextClassLoader().getResourceAsStream(META_INF_DEFAULT_CONFIG_PROPERTIES);\n            out = new FileOutputStream(configFileName);\n            IOUtils.copy(in, out);\n        } catch (final Exception e) {\n            log.warn(\"Unable to pull out the default.\", e);\n            throw new RuntimeException(e);\n        } finally {\n            IOUtils.closeQuietly(in);\n            IOUtils.closeQuietly(out);\n        }\n    }\n", "code2": "    public void init() throws GateException {\n        if (reportFile == null) throw new GateException(\"No report file set!\");\n        boolean restarting = false;\n        if (!reportFile.getParentFile().exists() && !reportFile.getParentFile().mkdirs()) {\n            throw new GateException(\"Could not create directories for \" + reportFile.getAbsolutePath());\n        }\n        File backupFile = new File(reportFile.getAbsolutePath() + \".bak\");\n        if (reportFile.exists()) {\n            restarting = true;\n            logger.info(\"Existing report file found at \\\"\" + reportFile.getAbsolutePath() + \"\\\", attempting to restart\");\n            if (!reportFile.renameTo(backupFile)) {\n                try {\n                    byte[] buff = new byte[32 * 1024];\n                    InputStream in = new BufferedInputStream(new FileInputStream(reportFile));\n                    try {\n                        OutputStream out = new BufferedOutputStream(new FileOutputStream(backupFile));\n                        try {\n                            int read = in.read(buff);\n                            while (read != -1) {\n                                out.write(buff, 0, read);\n                                read = in.read(buff);\n                            }\n                        } finally {\n                            out.close();\n                        }\n                    } finally {\n                        in.close();\n                    }\n                } catch (IOException e) {\n                    throw new GateException(\"Could not restart batch\", e);\n                }\n            }\n        }\n        try {\n            reportWriter = staxOutputFactory.createXMLStreamWriter(new BufferedOutputStream(new FileOutputStream(reportFile)));\n            reportWriter.writeStartDocument();\n            reportWriter.writeCharacters(\"\\n\");\n            reportWriter.setDefaultNamespace(Tools.REPORT_NAMESPACE);\n            reportWriter.writeStartElement(Tools.REPORT_NAMESPACE, \"cloudReport\");\n            reportWriter.writeDefaultNamespace(Tools.REPORT_NAMESPACE);\n            reportWriter.writeCharacters(\"\\n\");\n            reportWriter.writeStartElement(Tools.REPORT_NAMESPACE, \"documents\");\n        } catch (XMLStreamException e) {\n            throw new GateException(\"Cannot write to the report file!\", e);\n        } catch (IOException e) {\n            throw new GateException(\"Cannot write to the report file!\", e);\n        }\n        if (restarting) {\n            try {\n                Set<String> completedDocuments = new HashSet<String>();\n                logger.debug(\"Processing existing report file\");\n                InputStream bakIn = new BufferedInputStream(new FileInputStream(backupFile));\n                XMLEventReader xer = staxInputFactory.createXMLEventReader(bakIn);\n                try {\n                    XMLEvent event;\n                    while (xer.hasNext()) {\n                        event = xer.nextEvent();\n                        if (event.isStartElement() && event.asStartElement().getName().getLocalPart().equals(\"documents\")) {\n                            break;\n                        }\n                    }\n                    List<XMLEvent> events = new LinkedList<XMLEvent>();\n                    String currentReturnCode = null;\n                    String currentDocid = null;\n                    while (xer.hasNext()) {\n                        event = xer.nextEvent();\n                        events.add(event);\n                        if (event.isStartElement() && event.asStartElement().getName().getLocalPart().equals(\"processResult\")) {\n                            currentReturnCode = event.asStartElement().getAttributeByName(new QName(XMLConstants.NULL_NS_URI, \"returnCode\")).getValue();\n                            currentDocid = event.asStartElement().getAttributeByName(new QName(XMLConstants.NULL_NS_URI, \"id\")).getValue();\n                        }\n                        if (event.isEndElement() && event.asEndElement().getName().getLocalPart().equals(\"processResult\")) {\n                            if (currentReturnCode.equals(\"SUCCESS\") && currentDocid != null) {\n                                completedDocuments.add(currentDocid);\n                                for (XMLEvent evt : events) {\n                                    Tools.writeStaxEvent(evt, reportWriter);\n                                }\n                            }\n                            events.clear();\n                            currentReturnCode = null;\n                            currentDocid = null;\n                        }\n                        if (event.isEndElement() && event.asEndElement().getName().getLocalPart().equals(\"documents\")) {\n                            break;\n                        }\n                    }\n                } catch (Exception e) {\n                    logger.debug(\"Exception while parsing old report file - probably \" + \"reached the end of old report\", e);\n                } finally {\n                    xer.close();\n                    bakIn.close();\n                    backupFile.delete();\n                }\n                List<String> unprocessedDocs = new ArrayList<String>();\n                unprocessedDocs.addAll(Arrays.asList(documentIDs));\n                unprocessedDocs.removeAll(completedDocuments);\n                unprocessedDocumentIDs = unprocessedDocs.toArray(new String[unprocessedDocs.size()]);\n            } catch (XMLStreamException e) {\n                throw new GateException(\"Cannot write to the report file!\", e);\n            } catch (IOException e) {\n                throw new GateException(\"Cannot write to the report file!\", e);\n            }\n        } else {\n            unprocessedDocumentIDs = documentIDs;\n        }\n    }\n", "label": 1, "substitutes": {"loadDefaultSettings": ["readdefaultValues", "readdefaultsettings", "readDefaultsettings", "readDefaultSetting", "readDefaultValues", "loadDefaultSetting", "loaddefaultSetting", "loaddefaultsettings", "loadFAULTValues", "loaddefaultValues", "loadFAULTSetting", "readDefaultSettings", "loadFAULTsettings", "loadDefaultValues", "loaddefaultSettings", "readdefaultSetting", "loadFAULTSettings", "loadDefaultsettings", "readdefaultSettings"], "configFileName": ["confFilenameLocation", "configFileLocation", "confFilenamename", "configFILEname", "configfileName", "confFileName", "confFilePath", "confFilename", "confFilenameName", "confFilenamePath", "configfileNames", "configFilenamePath", "configFilenamename", "configFILEName", "configFILELocation", "configfilePath", "conffilename", "configPagename", "conffileName", "confFileNames", "configStreamName", "configPagePath", "configFilenameName", "configPageNames", "configStreamPath", "configStreamname", "configFileNames", "configStreamLocation", "configFilePath", "conffileNames", "configFilenameNames", "configfilename", "conffilePath", "configFILEPath", "configFilenameLocation", "configFilename", "confFileLocation", "configPageName"], "in": ["ze", "mi", "rin", "en", "inn", "ini", "con", "gin", "IN", "ins", "im", "ar", "m", "on", "doc", "al", "ro", "ls", "In", "run", "t", "inner", "init", "ai", "re", "up", "i", "e", "bin", "l", "input", "or", "it", " din", "ain", "ind", "o", "ad", "ma", "mc", "info", "n", "id", "din", "inf", "is", "isin", "source", "cin", "user", "check", "from"], "out": ["output", "ins", "not", "t", "port", "to", "up", "v", "gc", "or", "ent", "it", "gt", "ou", "n", "io", "Out", "update", "ne", "all", "handle", "en", "nt", "res", "obj", "conv", "net", "log", "over", "off", "cache", "os", "at", "ind", "ge", "auto", "file", "check", "store", "server", "w", "ion", "con", "cn", "sys", "raw", "une", "read", "writer", "are", "OU", "aos", "outs", "o", "de", "OUT", "user", "ex", "ing", "co", "oss", "m", "client", "init", "po", "copy", "des", "null", "can", "ot"]}}
{"id1": "1508161", "id2": "8047989", "code1": "    public void conMail(MailObject mail) throws NetworkException, ContentException {\n        HttpClient client = HttpConfig.newInstance();\n        String url = HttpConfig.bbsURL() + HttpConfig.BBS_MAIL_CON + mail.getId() + \"&\" + HttpConfig.BBS_MAIL_N_PARAM_NAME + \"=\" + mail.getNumber();\n        HttpGet get = new HttpGet(url);\n        try {\n            HttpResponse response = client.execute(get);\n            HttpEntity entity = response.getEntity();\n            if (HTTPUtil.isXmlContentType(response)) {\n                Document doc = XmlOperator.readDocument(entity.getContent());\n                BBSBodyParseHelper.parseMailContent(doc, mail);\n            } else {\n                String msg = BBSBodyParseHelper.parseFailMsg(entity);\n                throw new ContentException(msg);\n            }\n        } catch (ClientProtocolException e) {\n            e.printStackTrace();\n            throw new NetworkException(e);\n        } catch (IOException e) {\n            e.printStackTrace();\n            throw new NetworkException(e);\n        }\n    }\n", "code2": "    protected byte[] getHashedID(String ID) {\n        try {\n            MessageDigest md5 = MessageDigest.getInstance(\"MD5\");\n            md5.reset();\n            md5.update(ID.getBytes());\n            byte[] digest = md5.digest();\n            byte[] bytes = new byte[WLDB_ID_SIZE];\n            for (int i = 0; i < bytes.length; i++) {\n                bytes[i] = digest[i];\n            }\n            return bytes;\n        } catch (NoSuchAlgorithmException exception) {\n            System.err.println(\"Java VM is not compatible\");\n            exit();\n            return null;\n        }\n    }\n", "label": 0, "substitutes": {"conMail": [" parseMsg", "parseLink", " convertMail", " convertLink", "parseMail", " convertEmail", " parseLink", " sendLink", "parseEmail", " parseMail", " convertMsg", " parseEmail", " sendEmail", "parseMsg", " sendMsg", " sendMail"], "mail": ["report", "mi", "Mail", "gmail", "item", "email", "hello", "comm", "mt", "m", "mo", "al", "mit", "mun", "em", "mod", "mem", "box", "met", "char", "md", "del", "log", "man", "fax", "mon", "pl", "multi", "message", "mobile", "old", "hold", "xml", "detail", "dm", "le", "l", "Email", "gm", "mand", "cmd", "my", "form", "news", "mails", "model", "add", "el", "local", "info", "forge", "gun", "mil", " mailed", "send", "body", "il", "user", "mill", "ml", "print", "data"], "client": ["google", "con", "contact", "cn", "city", "service", "request", "resource", "Client", "force", "web", "context", "connection", "ca", "c", "net", "secure", "cli", "call", "conf", "ct", "cache", "cp", "cm", "api", "query", "cmd", "conn", "network", "connect", "http", "remote", "config", "io", "control", "wrapper", "server", "cl"], "url": ["ref", "dl", "request", "resource", "ls", "web", "ll", "base", "q", "build", "link", "sl", "pl", "b", "xml", "ur", "i", "org", "uri", "URL", "str", "l", "api", "kl", "nl", "ul", "path", "term", "pattern", "domain", "full", "key", "http", "string", "id", "server", "Url", "user", "print", "host"], "get": ["handle", "find", "select", "put", "service", "request", "execute", "getting", "set", "open", "call", "post", "list", "read", "give", "api", "gm", "it", "query", "parse", "show", "GET", "pre", "g", "info", "Get", "make", "http", "gets", "exec", "send", "check", "print"], "response": ["report", "reply", "json", "image", "process", "output", "entry", "res", "next", "resource", "application", "then", "description", "sequence", "Response", "status", "page", "connection", "attribute", "resp", "document", "message", "result", "onse", "xml", "re", "content", "e", "example", "successful", "success", "out", "pos", "respond", "object", "line", "channel", "info", "http", "still", "body", "data", "given"], "entity": ["event", "image", "json", "om", "entry", "oe", "email", "ee", "ities", "comment", "details", "obj", "m", "status", "ce", "em", "net", "attribute", "document", "message", "xml", "detail", "content", "e", "node", "eme", "error", "ent", "note", "metadata", "object", "line", "model", "el", "activity", "info", "quote", "html", "Entity", "iso", "ity", "user", "unit", "data", "pe"], "doc": ["exp", "good", "div", "dec", "json", "text", "cam", "di", "dict", "m", "oc", "sum", "po", "date", "md", "man", "document", "Document", "dr", "db", "xml", "content", "mat", "coll", "Doc", "study", "DOC", "ent", "dom", "proc", "tree", "pic", "dat", "desc", "html", "mk", "file", "body", "map", "data"], "msg": ["good", "tip", "Message", "sm", "text", "ms", "cmp", "bg", "comm", "comment", "m", "ag", "reason", "mess", "urg", "char", "sg", "mg", "md", "err", "label", "pkg", "message", "Msg", "mag", "str", "error", "out", "gm", "med", "cmd", "gs", "gov", "group", "g", "cfg", "ge", "warn", "desc", "info", "html", "bug", "body", "print", "title"]}}
{"id1": "16079868", "id2": "5049453", "code1": "    private void readIntoList(URL url, Map<String, JMenuItem> list) {\n        try {\n            BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream()));\n            String inputLine;\n            while ((inputLine = in.readLine()) != null) {\n                int commandNameBegin = inputLine.indexOf(\">\") + 1;\n                int commandNameEnd = inputLine.indexOf(\"</a>\");\n                JMenuItem item = new JMenuItem(\"<html>\" + inputLine + \"</html>\");\n                if (list == allRooms) {\n                    item.setActionCommand(\"/room \" + inputLine.substring(commandNameBegin, commandNameEnd));\n                } else {\n                    item.setActionCommand(\"/\" + inputLine.substring(commandNameBegin, commandNameEnd) + \" \");\n                }\n                item.addActionListener(new ActionListener() {\n\n                    public void actionPerformed(ActionEvent e) {\n                        jTextField1.setText(e.getActionCommand());\n                        popup.setVisible(false);\n                    }\n                });\n                list.put(inputLine.substring(commandNameBegin, commandNameEnd), item);\n            }\n            in.close();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n", "code2": "    private BingResponse queryBing(BingRequest request) throws BingException {\n        try {\n            if (logger.isDebugEnabled()) {\n                logger.debug(\"Searching through bing...\");\n            }\n            String query = request.getQuery();\n            query = URLEncoder.encode(query, \"UTF-8\");\n            URL url = new URL(\"http://api.bing.net/json.aspx?\" + \"AppId=\" + request.getAppId() + \"&Query=\" + query + \"&Sources=\" + request.getType().toString());\n            URLConnection connection = null;\n            if (useProxy) {\n                if (proxyType == null) {\n                    throw new BingException(\"Please set a proxy first before trying to connect through a proxy\", new Throwable());\n                }\n                connection = ProxyWrapper.getURLConnection(url.toString(), proxyType.toString(), proxyHost, proxyPort);\n            } else {\n                connection = new URL(url.toString()).openConnection();\n            }\n            String line;\n            StringBuilder builder = new StringBuilder();\n            BufferedReader reader = new BufferedReader(new InputStreamReader(connection.getInputStream()));\n            while ((line = reader.readLine()) != null) {\n                builder.append(line);\n            }\n            String response = builder.toString();\n            ResponseParser parser = new ResponseParser();\n            parser.getError(response);\n            return parser.getResults(response);\n        } catch (MalformedURLException e) {\n            logger.error(e);\n            throw new ConnectionException(\"Could not connect to host\", e);\n        } catch (IOException e) {\n            logger.error(e);\n            throw new ConnectionException(\"Could not connect to host\", e);\n        }\n    }\n", "label": 0, "substitutes": {"readIntoList": ["readintintolist", "readIntIntMap", "readIntTolist", "readintintoMap", "readIntoMap", "readintintoList", "readIntintoList", "readintolist", "readIntToMenu", "readIntolist", "readintoMap", "readIntintoMap", "readIntIntList", "readIntintolist", "readIntoMenu", "readIntIntlist", "readintoMenu", "readIntintoMenu", "readintintoMenu", "readIntToMap", "readIntToList", "readIntIntMenu", "readintoList"], "url": ["browser", "f", "window", "address", "image", "ref", "dl", "resource", "bel", "web", "ll", "char", "link", "log", "open", "mol", "cert", "b", "xml", "ur", "mount", "uri", "URL", "name", "str", "l", "input", "nl", "mail", "rect", "hub", "r", "ssl", "el", "domain", "ret", "http", "location", "string", "file", "loc", "Url", "id", "from"], "list": ["type", "all", "LIST", "block", "test", "dict", "part", "view", "summary", "m", "set", "status", "table", "t", "module", "level", "port", "label", "only", "listed", "rm", "v", "detail", "format", "cache", "state", "lists", "name", "get", "top", "l", "out", "tree", "parent", "st", "show", "group", "batch", "network", "record", "collection", "relation", "add", "info", "n", "is", "pool", "map", "p", "print"], "in": ["all", "rin", "en", "inn", "and", "by", "gin", "con", "IN", "ins", "pin", "reader", "on", "doc", "sum", "In", "inner", "ill", "ic", "re", "up", "conf", "i", "read", "bin", "get", "inc", "input", "out", "val", " din", "line", "add", "r", "mn", "din", "inf", "er", "is", "isin", "source", "file", "cin", "check", "from"], "inputLine": ["outputLINE", "commandLine", " inputRow", "formline", "helloL", "inputLINE", "inputLin", "textLINE", "InputLine", "inputRow", "textL", " inputline", "selectLINE", "actline", "InputLINE", "inputText", "htmlBlock", "httpLine", "activeLINE", "inputL", "htmlLINE", "textLin", "outputline", "nextText", "formLINE", "textLine", "nameLine", "helloLine", "dataLINE", "inputBlock", "formLine", "nextLine", "InputBlock", "httpL", "nextRow", "selectRow", "selectLine", "attLINE", "commandLINE", "nameline", "latLine", "helloLin", "htmlLine", "contextLINE", "attLine", "contextline", "outputLine", "helloLINE", "selectText", "dataLine", "httpLINE", "httpLin", "nameBlock", "formBlock", "latLINE", "nextLINE", "commandline", " inputLINE", "inputline", "actLINE", "Inputline", " inputBlock", "nameLINE", " inputText", "activeLine", "htmlline", "actLine", "contextLine"], "commandNameBegin": ["CommandNamesBeginning", "commandOrderbegin", "commandOrderBegin", "commandNAMEInitial", " commandNameInitial", "commandNameMorning", "commandSizeEGIN", "commandTypeBegin", " commandOrderBegin", "commandnameStart", "commandnameEGIN", "commandNameInitial", "commandFamilyMorning", "commandOrderStart", "commandnameBeg", "commandNamebegin", "CommandNamesbegin", "commandLineStart", " commandNameBeg", "commandTypeBeginning", "commandNAMEBeginning", "CommandNameBeginning", "commandSizeBeg", "commandFamilyBeginning", "commandNameMon", "commandNameStart", "commandSizeMorning", "commandNAMEMon", " commandSizeBeg", "commandNameBeginning", " commandNameStart", " commandSizeEGIN", "commandnameBegin", "commandNameBeg", " commandNamebegin", " commandOrderStart", "CommandNamesBegin", "CommandNameStart", "commandFamilyInitial", "commandFamilyBeg", "commandFamilyBegin", "commandSizeBegin", "commandnameMorning", "commandFamilyEGIN", "commandNAMEBegin", "CommandNameBegin", " commandNameMorning", " commandNameMon", " commandNameEGIN", " commandNameBeginning", "commandNamesBeginning", "commandLinebegin", "commandTypeStart", " commandSizeMorning", "commandnamebegin", "CommandNamesStart", "commandOrderBeginning", "commandLineBegin", "commandnameBeginning", " commandOrderbegin", "commandNamesBegin", "CommandNamebegin", "commandNamesStart", "commandNameEGIN", "commandLineBeginning", "commandTypebegin", "commandNamesbegin", " commandSizeBegin", "commandFamilyMon", " commandOrderBeginning"], "commandNameEnd": ["commandNamesEnd", " commandNameend", "commandNameEND", "cmdTimeEnd", "commandTypeEND", " commandNamesStart", "cmdTimeend", "formNameStart", "cmdNameEnd", "commandTimeEnd", " commandLineend", "commandTypeEnd", "commandSizeEND", "commandNameend", "cmdNameend", "formNameEnd", "commandNameStart", "commandNamesBegin", "commandLineEND", "commandTypeBegin", "commandTimeEND", "cmdNameEND", "formNameEND", " commandNamesEND", "formSizeend", "commandNamesStart", "formNameend", "commandSizeStart", "formSizeEND", "commandnameend", "commandTypeStart", " commandNameEND", " commandNamesEnd", "commandnameEND", "commandLineEnd", " commandLineEND", " commandLineEnd", "commandSizeEnd", "commandnameEnd", "commandSizeend", "commandTypeend", "commandNamesEND", "cmdTimeEND", "commandLineend", "commandStringBegin", " commandNameStart", "commandStringEND", "commandStringEnd", "commandTimeend", "formSizeStart", "formSizeEnd", " commandNamesBegin", "commandNamesend", "commandStringStart"], "item": ["event", "rule", "exp", "type", "image", "element", "match", "entry", "task", "im", "items", "obj", "other", "m", "option", "article", "page", "module", "app", "inner", "template", "base", "label", "em", "command", "link", "menu", "store", "sim", "i", "widget", "owner", "or", "iter", "it", "tree", "li", "hit", "object", "Item", "handler", "this", "mem", "group", "question", "mix", "instance", "monitor", "add", "el", "related", "local", "mm", "row", "member", "key", "info", "bar", "button", "index", "check", "unit", "p", "title"], "e": ["event", "E", "f", "ze", "eeee", "en", "fe", "u", "one", "ie", "oe", "ee", "d", "h", "es", "et", "se", "m", "t", "x", "ae", "ea", "ce", "q", "ve", "c", "ue", "ef", "b", "err", "end", "eur", "be", "re", "v", "i", "le", "error", "l", "ec", "ent", "eb", "g", "ev", "o", "r", "el", "ed", "eg", "ge", "n", "te", "ne", "er", "de", "eu", "p", "a", "ex", "pe", "w"]}}
{"id1": "3046085", "id2": "17974661", "code1": "    public Song(String s) {\n        StringTokenizer tokenizer = new StringTokenizer(s, \";\");\n        free = false;\n        title = tokenizer.nextToken();\n        artist = tokenizer.nextToken();\n        location = tokenizer.nextToken();\n        rating = Integer.parseInt(tokenizer.nextToken());\n        overplay = Integer.parseInt(tokenizer.nextToken());\n        String temp = tokenizer.nextToken();\n        tokenizer = new StringTokenizer(temp, \",[] \");\n        tags = new ArrayList<String>();\n        while (tokenizer.hasMoreTokens()) {\n            tags.add(tokenizer.nextToken());\n        }\n        byte[] bytes = new byte[40];\n        try {\n            MessageDigest hasher = MessageDigest.getInstance(\"SHA-1\");\n            hasher.update(title.getBytes());\n            hasher.update(artist.getBytes());\n            bytes = hasher.digest();\n        } catch (Exception e) {\n            System.out.println(e);\n        }\n    }\n", "code2": "    public boolean requestServerModifications(UUID sessionId, OutputStream out) throws SynchronizationException {\n        HttpClient client = new SSLHttpClient();\n        StringBuilder builder = new StringBuilder(url).append(\"?\" + SESSION_PARAM + \"=\" + sessionId).append(\"&\" + CMD_PARAM + \"=\" + CMD_SERVERMODIF);\n        HttpGet method = httpGetMethod(builder.toString());\n        try {\n            HttpResponse response = client.execute(method);\n            Header header = response.getFirstHeader(HEADER_NAME);\n            if (header != null && HEADER_VALUE.equals(header.getValue())) {\n                int code = response.getStatusLine().getStatusCode();\n                if (code == HttpStatus.SC_OK) {\n                    long expectedLength = response.getEntity().getContentLength();\n                    InputStream is = response.getEntity().getContent();\n                    FileUtils.writeInFile(is, out, expectedLength);\n                    return true;\n                } else {\n                    throw new SynchronizationException(\"Command 'receive' : HTTP error code returned.\" + code, SynchronizationException.ERROR_RECEIVE);\n                }\n            } else {\n                throw new SynchronizationException(\"HTTP header is invalid\", SynchronizationException.ERROR_RECEIVE);\n            }\n        } catch (Exception e) {\n            throw new SynchronizationException(\"Command 'receive' -> \", e, SynchronizationException.ERROR_RECEIVE);\n        }\n    }\n", "label": 0, "substitutes": {"s": ["f", "ss", "text", "strings", "h", "es", "js", "m", "ls", "t", "ns", "q", "c", "b", "ps", "S", "v", "i", "e", "its", "name", "str", "rs", "os", "gs", " ts", "g", "r", "n", "string", "is", "p", "a", "data", "w"], "tokenizer": ["terminazer", "templateer", "tokenitor", "okenoser", "terminize", "okenzie", "webize", " tokenization", " tokenzer", "nodeisher", "templateisher", " tokenifier", "kinizer", "nodeized", "terminitor", "Tokenzer", "valueisher", "operatorazer", "Tokenized", "Tokenizers", "datezer", "operatorisher", "tokenisher", "operatorizer", "templateizable", "operatorzie", "tokenener", "Tokenize", "dateize", "operatoriner", "dateizable", "tokenization", "serializer", "tokenizable", "webisher", "dateizer", "okeniner", "terminiser", "tokeniner", "kinzer", "tokenazer", "tokenize", "tokeniter", "okenner", " tokenner", "Tokenization", "okenifier", "serialzer", "Tokenner", "okenitor", "okenzer", "tokenized", "Tokenisher", "tokenzer", "terminisher", "kinize", "operatorized", "terminizer", "kinizers", " tokenener", "templateization", "terminization", "okenisher", "okeniter", "webitor", "toolizer", "tokenifier", "Tokenener", "nodeization", "webizable", "webization", " tokeniner", " tokenizable", "webizer", "tokenzie", " tokenzie", "okenizable", "templateizer", "tokener", "valueizable", "serialize", "okenazer", "serializable", "tokenner", " tokenisher", "tokenizers", "Tokener", "okenener", "Tokenizer", "operatoriter", " tokenoser", "terminiter", "templatezer", "toolize", "valueizer", "tokenoser", "okenize", "toolzer", "operatoriser", "tokeniser", "toolizers", "Tokenifier", "operatorization", "okenizer", "okeniser", "valueoser", " tokener", "terminizable", "nodeizer"], "title": ["type", "phrase", "author", "lead", "tip", "text", "displayText", "itled", "part", "description", "summary", "article", "table", "tag", "t", "horse", "profile", "template", "label", "primary", "story", "filename", "name", "itle", "position", "important", "total", "meta", "art", "note", "metadata", "term", "holiday", "source", "Title", "version", "id", "prefix"], "artist": ["author", "track", "gallery", "creator", "image", "item", "picture", "part", "adult", "music", "tag", "rank", "directory", "attribute", "associated", "song", "album", "position", "archive", "person", "art", "audio", "metadata", "component", "project", "object", "photo", "assisted", "volume", "chapter", "voice", "Artist", "source", "folder", "player", "user", "username"], "location": ["origin", "zone", "layout", "address", "gallery", "reference", "time", "feature", "comment", "area", "description", "direction", "directory", "shape", "Location", "country", "near", "media", "phone", "position", "language", "activity", "local", "place", "loc", "folder", "source", "translation"], "rating": ["playing", "movie", "boarding", "score", "music", "credit", "erate", "genre", "library", "frequency", "rank", "profile", "average", "confidence", "rated", "media", "fps", "race", "meta", "training", "Rating", "rate", "metadata", "ranking", "scoring", "weight", "rates", "scale"], "overplay": ["Override", " override", "override", "Overplay", "overgrade", "appcast", " overgrade", " overcast", "appgrade", "Overgrade", "overcast", "appplay", "Overcast", "appride"], "temp": ["type", "empty", "output", "orig", "test", "time", "set", "Temp", "tmp", " tmp", "base", "flash", "template", "mem", "generated", "buffer", " Temp", "fake", "current", "cache", "name", "now", "partial", " temporary", "stem", "encrypted", "null", "term", "created", "porary", "tem", "emp", "local", "key", "texture", "source", "loc", "memory", "Temperature", "unit", "tm", "prefix"], "tags": ["terms", "tracks", "dates", "Tags", "options", "links", "assets", "flags", "reports", "strings", "parts", "keys", "details", "types", "lines", "packages", "marks", "names", "lights", "comments", "stats", "words", "ags", "weights", "styles", "lists", "images", "fields", "atts", "thumbnails", "stars", "balls", "groups", "pages", "files", "relations", "nets"], "bytes": ["terms", "services", "vals", "Bytes", "frames", "rows", "parts", "keys", "bps", "seconds", "loads", "lines", "bs", "classes", "comments", "bits", "gb", "uploads", "words", "ips", "ids", "images", "blocks", "tes", "fields", "len", "gs", "mb", "groups", "pages", "files", "gets", "values", "videos", "es"], "hasher": ["haser", " hasest", " hadher", " hasDR", "HasDR", "havehers", "hasger", "hydHer", "hahers", "hadher", "Haser", " hader", " hashers", "hashed", "haveter", "Hasher", " haster", "haveest", " hashed", " hasger", "hydher", "hasest", " hadDR", "haveher", "Haspher", "Hashed", "hydger", "haspher", " hadter", "hater", "hadger", "haest", "haher", " hascher", "hadHer", "hasDR", " hasHer", "Haster", "hydcher", " haspher", "haster", "hascher", "hasHer", "hadcher", "hadpher", "hadhed", "hadter", " haser", "hashers"]}}
{"id1": "9275622", "id2": "2642914", "code1": "    private boolean copyFile(File _file1, File _file2) {\n        FileInputStream fis;\n        FileOutputStream fos;\n        try {\n            fis = new FileInputStream(_file1);\n            fos = new FileOutputStream(_file2);\n            FileChannel canalFuente = fis.getChannel();\n            canalFuente.transferTo(0, canalFuente.size(), fos.getChannel());\n            fis.close();\n            fos.close();\n            return true;\n        } catch (FileNotFoundException e) {\n        } catch (IOException e) {\n        }\n        return false;\n    }\n", "code2": "    private static void addFileToTarGz(TarArchiveOutputStream taro, String path, String base) throws IOException {\n        File f = new File(path);\n        String entryName = base + f.getName();\n        FileInputStream goIn = new FileInputStream(f);\n        TarArchiveEntry tarEntry = new TarArchiveEntry(f, entryName);\n        taro.setLongFileMode(TarArchiveOutputStream.LONGFILE_GNU);\n        taro.putArchiveEntry(tarEntry);\n        if (f.isFile()) {\n            IOUtils.copy(goIn, taro);\n            taro.closeArchiveEntry();\n        } else {\n            taro.closeArchiveEntry();\n            File[] children = f.listFiles();\n            if (children != null) {\n                for (File child : children) {\n                    addFileToTarGz(taro, child.getAbsolutePath(), entryName + \"/\");\n                }\n            }\n        }\n        taro.close();\n        goIn.close();\n    }\n", "label": 1, "substitutes": {"copyFile": [" cpfile", "copyFiles", " copyfile", " copyStream", " duplicatefile", " duplicateFiles", " cpFile", " duplicateFile", "copyStream", "copyfile", " copyFiles", " cpFiles", " cpStream", " duplicateStream"], "_file1": ["_FileInit", "_files1", "_ileOne", "_fileOne", "_linkInit", "_link2", "_fileInit", "_files2", "_link1", "_ile2", "_ileInit", "_File2", "_ile1", "_FileFirst", "_linkOne", "_File1", "_ileFirst", "_FileOne", "_filesOne", "_fileFirst", "_filesFirst"], "_file2": [" _file02", "_FILEb", "_FILE1", "_File02", "_file02", "_Fileb", "_image1", "_link2", "_linkTwo", "_link1", " _fileb", "_File2", " _File1", "_fileb", " _fileTwo", "_FILE2", " _FILEb", "_linktwo", "_fileTwo", "_image2", "_image02", "_Filetwo", "_FILE02", " _FileTwo", "_File1", " _File2", "_imageb", " _FILE2", " _filetwo", " _FILE02", " _Filetwo", "_filetwo", " _FILE1", "_FileTwo"], "fis": ["flis", "fais", "kis", "fi", "Fis", "ufi", "cfis", "qiss", "cos", "fris", " fris", "ufis", "Fris", "ufiss", "cfois", "cis", " fi", "ufios", "Fiss", "qis", "qios", "Fios", "cfiss", " fais", " fois", "kios", "fliss", "fli", "fiss", "Fos", "flios", "cios", "cais", "Fois", " fios", "fios", "qos", "fois", "kos", "cfris", " fiss", "kais"], "fos": ["flis", "ffos", "foes", "woes", "hose", "mos", "foss", "fose", "flos", " faos", " fows", "wis", "floss", "sfoss", "mows", "faos", " foes", "fows", "wos", "moes", "ffis", "hos", "wows", " fose", "hoes", "sfos", "floes", "ffoss", "woss", "sfoes", "maos", " foss", "sfose", "hoss", "ffoes", "waos"], "canalFuente": ["canalFalperor", "canallfuestro", "canallfuenza", "canalUteree", "canalTenente", "canalKuperor", "canalFalje", "canalfuent", "canalUtestro", "canallFuperor", "canalFuje", "canalFalestro", "canalUtente", "canalFiente", "canallFuent", "canalFueree", "canallfuperor", "canalfuenza", "canalKuje", "canallfuje", "canallFuestro", "canalTenent", "canalFuestro", "canalTenperor", "canalFient", "canalFalente", "canallFuenza", "canallFuje", "canallFueree", "canallFuente", "canallfuent", "canalFienza", "canalfuperor", "canalFuenza", "canalFalent", "canalfuente", "canallfuente", "canalfuje", "canalfuestro", "canalTenenza", "canalFiperor", "canalKuent", "canalFuperor", "canalKuente", "canalFuent", "canalFaleree", "canalUtent", "canallfueree", "canalfueree"]}}
{"id1": "10131427", "id2": "8747840", "code1": "    public static void copyFile(File in, File out) throws IOException {\n        FileChannel sourceChannel = new FileInputStream(in).getChannel();\n        FileChannel destinationChannel = new FileOutputStream(out).getChannel();\n        sourceChannel.transferTo(0, sourceChannel.size(), destinationChannel);\n        sourceChannel.close();\n        destinationChannel.close();\n    }\n", "code2": "    public static void copy(File src, File dest) throws FileNotFoundException, IOException {\n        FileInputStream in = new FileInputStream(src);\n        FileOutputStream out = new FileOutputStream(dest);\n        try {\n            byte[] buf = new byte[1024];\n            int c = -1;\n            while ((c = in.read(buf)) > 0) out.write(buf, 0, c);\n        } finally {\n            in.close();\n            out.close();\n        }\n    }\n", "label": 1, "substitutes": {"copyFile": [" cpfile", "CopyImage", " copyfile", "CopyStream", " copyStream", " cpFile", " CopyStream", " cpImage", " Copyfile", " copyImage", "CopyFile", " CopyFile", "Copyfile", " cpStream", " CopyImage"], "in": ["rin", "en", "inn", "gin", "IN", "vin", "ins", "ar", "on", "In", "old", "b", "ic", "edIn", "up", "i", "inc", "l", "input", "it", "st", "s", "ind", "o", "r", "el", "mm", "n", "din", "inf", "is", "isin", "source", "cin", "from"], "out": ["nt", "output", "oss", "w", "help", "t", "po", "log", "net", "err", "b", "to", "v", "i", "serv", "str", "os", "l", "it", "ch", "gt", "ou", "s", "outs", "o", "ex", "n", "io", "Out", "file", "OUT", "check", "ne", "ot"], "sourceChannel": ["ourceButton", "seedChannel", "matchApplication", " sourceButton", "sourceChuck", "sourceConnection", "resourcechannel", "ourceChannel", "resourceChannel", "srcchannel", "ourceConnection", "sourceApplication", "srcStream", "sourcechannel", "ourceStream", "seedApplication", "ourceChain", "sourceChain", "inputChannel", " sourceChain", " sourcechannel", "resourceConnection", "matchChuck", "inputChain", "ourceChan", "sourceButton", "SourceChannel", "matchButton", "singleApplication", "singleChannel", "srcChannel", "inputConnection", "ourcechannel", "singleChuck", "SourceConnection", "inputChan", " sourceConnection", "singleButton", " sourceStream", "seedChuck", "Sourcechannel", "SourceStream", "sourceChan", "srcButton", "sourceStream", "matchChannel", "resourceStream", " sourceChan", "seedButton"], "destinationChannel": ["desticationChan", "destinatoryBlock", "destensionChan", "destinatedContext", "destinationBlock", "DestinationContext", "destinatoryChan", "destationContext", "destroyConnection", "destationChannel", "DestensionConnection", "DestationContext", "destinationsConnection", "destinationsContext", "DestationCow", "destationBlock", "destroyClient", "destensionConnection", "destinationsChan", "destationChan", "DestensionChan", "DestinationChan", "DestinationBlock", "DestinationCow", "desticationBlock", "DestationChannel", "destinationCow", "destroyChannel", "destensionChannel", "destinationContext", "destinatedChan", "destroyChan", "DestinationChannel", "destinationChan", "destinatoryCow", "DestationConnection", "destinatedConnection", "DestensionClient", "destinatedChannel", "destinationConnection", "DestinationClient", "destationConnection", "destationCow", "DestationChan", "desticationCow", "destationClient", "DestensionChannel", "destinationClient", "DestationBlock", "destinatoryChannel", "destinationsChannel", "DestinationConnection", "destensionClient", "desticationChannel"]}}
{"id1": "21033686", "id2": "1235538", "code1": "    public File read() throws IOException {\n        URLConnection conn = url.openConnection();\n        conn.setConnectTimeout(5000);\n        conn.setReadTimeout(5000);\n        conn.connect();\n        int length = conn.getContentLength();\n        String tempDir = System.getProperty(\"java.io.tmpdir\");\n        if (tempDir == null) {\n            tempDir = \".\";\n        }\n        File tempFile = new File(tempDir + \"/\" + new GUID() + \".dat\");\n        tempFile.deleteOnExit();\n        InputStream in = null;\n        OutputStream out = null;\n        ProgressMonitor monitor = new ProgressMonitor(parentComponent, \"Downloading \" + url, null, 0, length);\n        try {\n            in = conn.getInputStream();\n            out = new BufferedOutputStream(new FileOutputStream(tempFile));\n            int buflen = 1024 * 30;\n            int bytesRead = 0;\n            byte[] buf = new byte[buflen];\n            ;\n            long start = System.currentTimeMillis();\n            for (int nRead = in.read(buf); nRead != -1; nRead = in.read(buf)) {\n                if (monitor.isCanceled()) {\n                    return null;\n                }\n                bytesRead += nRead;\n                out.write(buf, 0, nRead);\n                monitor.setProgress(bytesRead);\n            }\n        } finally {\n            if (in != null) {\n                in.close();\n            }\n            if (out != null) {\n                out.close();\n            }\n            monitor.close();\n        }\n        return tempFile;\n    }\n", "code2": "    public static String encrypt(final String pass) {\n        try {\n            final MessageDigest md = MessageDigest.getInstance(\"SHA\");\n            md.update(pass.getBytes(\"UTF-8\"));\n            return new String(Base64.encodeBase64(md.digest()));\n        } catch (final Exception e) {\n            throw new RuntimeException(\"No se pudo encriptar el password.\", e);\n        }\n    }\n", "label": 0, "substitutes": {"read": ["all", "find", "select", "shift", "poll", "next", "request", "reader", "view", "wait", "create", "stream", "run", "feed", "print", "write", "open", "transfer", "readable", "load", "end", "buffer", "close", "seek", "reads", "content", "skip", "url", "copy", "get", " Read", "input", "upload", "pull", "iter", "query", "take", "GET", "Read", "add", "connect", "count", "download", "gets", "send", "reading", "size", "index", "READ", "data"], "conn": ["canon", "co", "access", "nt", "handle", "j", "ctx", "dial", "con", "cmp", "pas", "res", "comm", "cb", "cn", "cont", "enc", "obj", "client", "gate", "conv", "init", "ann", "ns", "connection", "addr", "c", "net", "open", "ca", "pg", "cert", "cur", "resp", "close", "aj", "conf", "com", "cp", "ct", "url", "act", "Conn", "ait", "cm", "ch", "cmd", "sql", "ctrl", "syn", "connect", "ssl", "nc", "jp", "socket", "msg", "exec", "fin"], "length": ["default", "ENGTH", "Length", "sequence", "rest", "load", "message", "available", "result", "family", "number", "position", "total", "l", "history", "len", "present", "height", "ength", "amount", "count", "L", "size", "data", "duration", "phi"], "tempDir": ["tempEar", " tempFolder", "templateFolder", "empdir", "tempDirectory", "tempPath", "empFile", "tmpServ", "templateDirectory", "tempServ", "tmpDir", "tmpFile", "templateEar", "templateDir", "empDir", "tmpStart", "empFolder", "tempdir", "empStart", "poraryEar", "poraryDir", "tempFolder", "tmpEar", "poraryServ", "tempStart", "empPath", "poraryStart", "tmpDirectory", "poraryDirectory", "tmpFolder", "poraryFolder", " tempPath", "nullPath", "nullDir", "tmpdir", "tmpPath", "nulldir", "empServ"], "tempFile": ["currentB", "currentPlace", "TempPath", "tmpfile", "tmpB", "poraryPlace", "tempPath", "empFile", "tempB", "empB", "tmpFile", "Tempfile", "empDir", "poraryfile", " tempfile", "tempField", "empFolder", "tempFolder", "TempFile", "tempfile", "TempField", "tmpFolder", "poraryFile", "poraryFolder", " tempPath", "currentfile", "empfile", "empPlace", "TempDir", "tmpPath", "tmpPlace", "empField", "tempPlace", " tempField", "currentFile"], "in": ["all", "mi", "rin", "en", "image", "inn", "ini", "irm", "gin", "con", "IN", "internal", "ins", "on", "client", "al", "raw", "In", "t", "inside", "inner", "init", "log", "net", "ai", "re", "up", "conf", "i", "bin", "str", "inc", "l", "input", "or", "iter", "it", "form", "st", "ain", "ind", "o", "nin", "add", "el", "ssl", "local", "n", "io", "din", "inf", "is", "isin", "source", "body", "cin", "from", "ex"], "out": ["all", "co", "na", "con", "output", "oe", "oss", "ins", "cn", "op", "obj", "a", "m", "client", "on", "sys", "sum", "conv", "t", "inner", "dis", "ns", "net", "write", "b", "to", "end", "ot", "up", "com", "writer", "os", "external", "l", "outer", "or", "it", "OU", "null", "ou", "at", "outs", "aos", "o", "nin", "boot", "ex", "s", "again", "n", "io", "Out", "an", "OUT", "p", "can", "ne", "w"], "monitor": ["meter", "report", "sm", "lock", "process", "match", "console", "im", "Monitor", "m", "summary", "rain", "processor", "status", "thread", "stream", "monkey", "mx", "trace", "profile", "menu", "log", "buffer", "spin", "mon", "message", "timer", "system", "alert", "sim", "ai", "chron", "detail", "dm", "program", "bm", "progress", "state", "umi", "cm", "stat", "history", "handler", "batch", "network", "gray", "tem", "manager", "member", "info", "config", "watch", "pool", "timeout", "memory", "loader", "display"], "buflen": ["buglength", "bupllen", "bullength", "buflun", "bullen", "bulllen", "bucollen", "buplun", " buplens", "bufllen", "buclength", "buplength", "buglen", "buplen", "bucollength", "bucolleng", "buclens", " buflength", " buplun", "buclen", "bufleng", "bupleng", " bupllen", " bufllen", " bupleng", "buflength", "bucolllen", "buglun", "buglens", "buclun", " buflens", "bulleng", " buplen", "buplens", "buflens", " buplength", " buflun", " bufleng"], "bytesRead": ["tesWritten", "BytesFound", " bytesSend", "blocksRead", "blocksNeed", "blocksWrite", "tesNeed", "bytesFound", "itemsWrite", " bytesReader", "tesWrite", "itemsSend", "linesNeed", " bytesread", "bytesReader", "bytesread", "tesread", "blocksWritten", "BytesReader", " bytesWrite", "BytesWrite", "bytesWritten", "BytesRead", "bytesSend", "linesWritten", "tesRead", "bytesNeed", "bytesWrite", "itemsRead", "itemsReader", "linesWrite", "BytesSend", "tesFound", "linesRead", " bytesFound", "Bytesread"], "buf": ["seq", "window", "txt", "cv", "tr", "block", "br", "buff", "prop", "img", "ctx", "cat", "orig", "bl", "cam", "cb", "ob", "bed", "conv", "wb", "box", "mem", "buffer", "pkg", "bag", "b", "log", "ctr", "cur", "db", "bin", "Buffer", "act", "uf", "rb", "tab", "bu", "cmd", "mu", "batch", "bar", "row", "Buff", "cap", "lim", "msg", "arr", "fb", "vec", "bytes"], "start": ["first", "step", "sample", "time", "sp", "stop", "tmp", "t", "init", "base", "rest", "ST", "open", "Start", "ptr", "state", "name", "art", "delay", "offset", "len", "st", "size", "p", "end", "duration"], "nRead": ["onWrite", "nnRequest", "numWrite", " nView", "pnReader", " nRequest", "nWritten", "NRequest", "ncWrite", "onCopy", " nDisplay", "onRead", "nsDisplay", "ncRead", " nReader", "dnRead", "dnReader", "numView", "cnWrite", "onReader", "pnRead", "NRead", "cnRead", "nsRead", "numReader", "cnDisplay", "nnUpdate", "nUpdate", "nWrite", "cnWritten", "nnReader", "nRequest", " nWrite", "numRead", " nWritten", "nReader", "nnRead", "nCopy", "pnCopy", "ncView", "nDisplay", "nsWrite", " nUpdate", "dnWrite", "dnUpdate", "NWrite", "ncReader", "nView", "nnWrite", "pnWrite", "nsWritten", " nCopy"]}}
{"id1": "293167", "id2": "5951961", "code1": "    public static void doVersionCheck(View view) {\n        view.showWaitCursor();\n        try {\n            URL url = new URL(jEdit.getProperty(\"version-check.url\"));\n            InputStream in = url.openStream();\n            BufferedReader bin = new BufferedReader(new InputStreamReader(in));\n            String line;\n            String version = null;\n            String build = null;\n            while ((line = bin.readLine()) != null) {\n                if (line.startsWith(\".version\")) version = line.substring(8).trim(); else if (line.startsWith(\".build\")) build = line.substring(6).trim();\n            }\n            bin.close();\n            if (version != null && build != null) {\n                if (jEdit.getBuild().compareTo(build) < 0) newVersionAvailable(view, version, url); else {\n                    GUIUtilities.message(view, \"version-check\" + \".up-to-date\", new String[0]);\n                }\n            }\n        } catch (IOException e) {\n            String[] args = { jEdit.getProperty(\"version-check.url\"), e.toString() };\n            GUIUtilities.error(view, \"read-error\", args);\n        }\n        view.hideWaitCursor();\n    }\n", "code2": "    public static void main(String[] args) {\n        try {\n            URL url = new URL(args[0]);\n            HttpURLConnection httpCon = (HttpURLConnection) url.openConnection();\n            httpCon.setDoOutput(true);\n            httpCon.setRequestMethod(\"PUT\");\n            OutputStreamWriter out = new OutputStreamWriter(httpCon.getOutputStream());\n            out.write(\"fatal error\");\n            out.close();\n            System.out.println(\"end\");\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n", "label": 0, "substitutes": {"doVersionCheck": ["DoDatecheck", "doDateCheck", "doVersionsCheck", "DoDateFix", "doVersionFix", "doLicensecheck", "DoVersioncheck", "DoVersionCheck", "DoVersionFix", "DoDateCheck", "doDateUpdate", "doDateFix", "DoDateUpdate", "DoVersionUpdate", "doVersionsUpdate", "doVersionsFix", "doDatecheck", "doVersionUpdate", "doLicenseFix", "doVersionscheck", "doLicenseCheck", "doVersioncheck", "doLicenseUpdate"], "view": ["browser", "report", "window", "hl", "cv", "layout", "image", "block", "subject", "util", "console", "engine", "client", "doc", "VIEW", "tv", "views", "table", "help", "context", "web", "page", "update", "q", "buffer", "open", "document", "call", "cell", "v", "widget", "review", "see", "iew", "host", "get", "input", "out", "wrapper", "query", "this", "controller", "tree", "form", "show", "component", "blade", "eye", "model", "View", "manager", "self", "row", "http", "html", "server", "file", "check", "index", "print", "display"], "url": ["f", "browser", "hl", "gl", "address", "json", "dl", "lb", "client", "bel", "web", "ls", "ll", "char", "date", "link", "pl", "sl", "log", "b", "lr", "rel", "ur", "v", "mount", "org", "uri", "URL", "str", "rl", "l", "oul", "nl", "ul", "path", "null", "language", "github", "r", "ssl", "http", "html", "socket", "string", "location", "file", "loc", "Url", "id", "host"], "in": ["f", "rin", "inn", "gin", "IN", "vin", "ins", "reader", "ln", "stream", "In", "init", "inner", "b", "asin", "kin", "i", "mat", "inc", "l", "input", "out", "sin", " IN", " din", "ain", "mn", "info", "n", "din", "inf", "is", "isin", "source", "file", "body", "cin"], "bin": ["rin", " Bin", "win", "inn", "buff", "stock", "by", "gin", "con", "bl", "bg", "cos", "obin", "reader", "bur", "ln", "bed", "pipe", "inner", "mem", "bi", "spin", "buffer", "b", "mon", "thin", "ran", "nb", " bins", "lib", "abin", "cache", "rb", "out", "sin", "len", " din", "conn", "binary", "local", "din", "sam", "file", "bn", "cin", "ebin", "loader"], "line": ["LINE", "lo", "style", "lin", "block", "text", "cat", "eline", "entry", "ine", "sample", "column", "part", "comment", "frame", "lane", "se", "ln", "ide", "word", "lines", "page", "ls", "col", "level", "base", "trace", "char", "chain", "range", "link", "log", "code", "one", "err", "load", "port", "cell", "ice", "state", "le", "liner", "l", "section", "iter", "cmd", "point", "path", "record", "Line", "el", "channel", " Line", "row", "string", "job", "no", "field", "inline", "file", "body", "store", "print"], "version": ["type", "browser", "ion", "translation", "major", "video", "license", "image", "value", "virtual", "match", "test", "versions", "serial", "release", "feature", "resource", "description", "client", "sequence", "river", "status", "tag", "VER", "Version", "software", "spec", "date", "command", "v", "number", "format", "vision", "name", "position", "hash", "project", "form", "language", "info", "key", "volume", "string", "scale", "vers", "usage", "iso", "VERSION", "latest", "index", "ver", "update", "python", "title"], "build": ["building", "style", "built", "match", "test", "fail", "util", "release", "builder", "other", "update", "tag", "work", "date", "link", "round", "ship", "log", "th", "load", "b", "old", "be", "db", "hold", "lib", "hash", "last", "Build", "project", "boost", "binary", "add", "use", "bor", "ble", "full", "make", "uild", "arch", "dist", "bug", "develop", "install", "where", "latest", "ward", "ver", "unit", "dev", "print", "struct"]}}
{"id1": "21754659", "id2": "16549995", "code1": "    private JButton getButtonSonido() {\n        if (buttonSonido == null) {\n            buttonSonido = new JButton();\n            buttonSonido.setText(Messages.getString(\"gui.AdministracionResorces.15\"));\n            buttonSonido.setIcon(new ImageIcon(getClass().getResource(\"/es/unizar/cps/tecnoDiscap/data/icons/view_sidetree.png\")));\n            buttonSonido.addActionListener(new java.awt.event.ActionListener() {\n\n                public void actionPerformed(java.awt.event.ActionEvent e) {\n                    JFileChooser fc = new JFileChooser();\n                    fc.addChoosableFileFilter(new SoundFilter());\n                    int returnVal = fc.showDialog(AdministracionResorces.this, Messages.getString(\"gui.AdministracionResorces.17\"));\n                    if (returnVal == JFileChooser.APPROVE_OPTION) {\n                        File file = fc.getSelectedFile();\n                        String rutaGlobal = System.getProperty(\"user.dir\") + \"/\" + rutaDatos + \"sonidos/\" + file.getName();\n                        String rutaRelativa = rutaDatos + \"sonidos/\" + file.getName();\n                        try {\n                            FileInputStream fis = new FileInputStream(file);\n                            FileOutputStream fos = new FileOutputStream(rutaGlobal, true);\n                            FileChannel canalFuente = fis.getChannel();\n                            FileChannel canalDestino = fos.getChannel();\n                            canalFuente.transferTo(0, canalFuente.size(), canalDestino);\n                            fis.close();\n                            fos.close();\n                            imagen.setSonidoURL(rutaRelativa);\n                            System.out.println(rutaGlobal + \" \" + rutaRelativa);\n                            buttonSonido.setIcon(new ImageIcon(getClass().getResource(\"/es/unizar/cps/tecnoDiscap/data/icons/view_sidetreeOK.png\")));\n                            gui.getAudio().reproduceAudio(imagen);\n                        } catch (IOException ex) {\n                            ex.printStackTrace();\n                        }\n                    } else {\n                    }\n                }\n            });\n        }\n        return buttonSonido;\n    }\n", "code2": "    public static String mysqlPasswordHash(String string) {\n        try {\n            MessageDigest digest = MessageDigest.getInstance(HashAlgorithms.SHA1);\n            try {\n                digest.update(string.getBytes(\"UTF-8\"));\n            } catch (UnsupportedEncodingException e) {\n                throw new RuntimeException(e);\n            }\n            byte[] encodedPassword = digest.digest();\n            digest.update(encodedPassword);\n            encodedPassword = digest.digest();\n            String hash = new BigInteger(1, encodedPassword).toString(16).toUpperCase();\n            while (hash.length() < 40) {\n                hash = \"0\" + hash;\n            }\n            return \"*\" + hash;\n        } catch (NoSuchAlgorithmException e) {\n            throw new RuntimeException(e);\n        }\n    }\n", "label": 0, "substitutes": {"getButtonSonido": ["getbuttonSonilo", "getButtonLeonido", "getButtonDonida", "getButtonSonida", "getButtonDonido", "getButtonSonilo", "getButtonLeonilo", "getbuttonSonico", "getButtonSonico", "getButtonDonico", "getButtonLeonico", "getbuttonSonida", "getButtonLeonida", "getButtonDonilo", "getbuttonSonido"], "buttonSonido": ["buttonBonico", "secondSonicho", "labelSonila", "buttonJonidable", "buttonJonilo", "buttonSonila", "keySon\u00ed", "fieldSonano", "labelSONphp", "ButtonSonao", "buttonSon\u00ed", "buttonsonano", "buttonsonido", "secondSonito", "keySonido", "buttonSONito", "buttonNorthingo", "buttonsonardo", "keyson\u00ed", "buttonSONila", "buttonBonilo", "labelSonido", "labelSONila", "buttonSonilo", "buttonJonao", "positionSonido", "fieldSonido", "buttonBonida", "buttonSonata", "buttonNorthido", "buttonSONido", "buttonDenicho", "buttonBonao", "buttonSunata", "positionJonilo", "positionSonilo", "buttonSonicho", "buttonBoningo", "ButtonSunata", "buttonSonphp", "positionJonico", "buttonHon\u00ed", "secondSonidable", "fieldsonida", "buttonBonido", "buttonsoningo", "fieldSoningo", "buttonDenido", "buttonSONico", "buttonNorthano", "secondSynido", "buttonJonico", "keysonilo", "buttonSunilo", "buttonSynito", "buttonHonilo", "buttonSonidable", "positionJonido", "secondSonido", "positionSonito", "buttonDenidable", "fieldsonido", "buttonJonido", "fieldSonida", "buttonSynida", "buttonJonata", "buttonsonida", "buttonNorthida", "fieldsoningo", "labelSonida", "labelSONido", "buttonSoningo", "keySonardo", "buttonSONphp", "buttonSynido", "buttonJonicho", "buttonSonao", "keysonido", "buttonBon\u00ed", "positionJonito", "ButtonSonata", "ButtonSonico", "buttonHonardo", "buttonson\u00ed", "buttonBonata", "buttonJonida", "secondSynito", "buttonSunao", "buttonSONilo", "buttonSunido", "buttonSONida", "fieldsonano", "ButtonSunico", "ButtonSunao", "labelSONida", "keySonilo", "buttonJonito", "keysonardo", "buttonSunito", "buttonSonano", "buttonJonphp", "secondSynicho", "buttonSunico", "buttonSynidable", "buttonDenito", "secondSynidable", "buttonSonico", "ButtonSunido", "buttonBonardo", "buttonSynila", "buttonHonido", "buttonSonito", "buttonsonilo", "positionSonico", "buttonSonardo", "labelSonphp", "ButtonSonido", "buttonBonano", "buttonSynicho", "buttonSonida", "buttonJonila", "buttonSynphp"], "e": ["E", "event", "ing", "AE", " ve", " fe", "ie", "ee", "es", "a", "t", "ae", "me", " ate", "act", " pe", " ke", "ED", "ev", "ese", " ge", "ed", " ie", "te", "er", " who", " sent", "pe"], "fc": ["f", "ifa", "rc", "fi", "cv", "FC", "bf", "con", "abc", "fs", "fm", "fp", "bc", "WC", "conv", "lf", "cc", "c", "soc", "fd", "ic", "irc", "gc", "pc", "vc", "rl", "inc", "tf", "coll", "ec", "isc", "ctrl", "lc", "tc", "etc", "fab", "mc", "nc", "uc", "fa", "icc", "cf", "fn", "mac", "RFC", "fb", "anc", "dc", "fl"], "returnVal": ["resultval", "ReturnVal", "retval", "retVAL", " returnVAL", "ReturnVAL", "ReturnValue", "returnVAL", "resultVAL", "returnValue", " returnval", " returnValue", "resultValue", "resultVal", "retValue", "Returnval", "returnval", "retVal"], "file": ["type", "f", "handle", "fe", "image", "block", "output", "File", "time", "FILE", "word", "disk", "resource", "single", "create", "fp", "page", "table", "base", "template", "spec", "link", "buffer", "to", "document", "message", "ile", "format", "url", "uri", "name", "get", "input", "valid", "stat", "this", "parent", "tree", "form", "path", "show", "null", "dir", "channel", "full", "local", "info", "http", "io", "files", "source", "user", "data"], "rutaGlobal": ["rutiLocal", "redutaGlobal", "rutaFile", "rutoglobal", "rontoGlobal", "redutanDefault", "rutenLocal", "rontoGeneral", "rutaglobal", "redutaGeneral", "rutaRemote", "RutoGlobal", "rutenGlobal", "rutoRemote", "rutoFile", "rutiGeneral", "rutenglobal", "rutaGeneral", "rutoLocal", "rutanLocal", "rutiglobal", "rutiGlobal", "RutoFile", "rutiRemote", "rutaDefault", "rutanGeneral", "redutaDefault", "redutanGeneral", "rutenRemote", "redutaLocal", "RutaGlobal", "rutoGlobal", "rutoStatic", "RutoLocal", "RutaFile", "rutiFile", "RutaLocal", "rontoDefault", "rutanDefault", "Rutaglobal", "redutanGlobal", "rontoLocal", "RutaRemote", "rutanGlobal", "RutoRemote", "Rutoglobal", "RutoStatic", "rutenStatic", "rutiDefault", "rutaLocal", "rutaStatic", "RutaStatic", "redutanLocal", "rutenFile", "rutiStatic"], "rutaRelativa": ["rutaRelantiva", "rutaRelativ", "rutaRELitivas", "rutaRELATivas", "rutaRelatiiv", "rutaRelatiivas", "rutaRELitiv", "rutaRelativas", "rutaRelantivas", "rutaRELativ", "rutaRELitivo", "rutaRELATiv", "rutaRelantiv", "rutaRelitiv", "rutaRelativo", "rutaRELATivo", "rutaRelitivas", "rutaRELativo", "rutaRelATiv", "rutaRelATiva", "rutaRELativa", "rutaRELATiva", "rutaRelitiva", "rutaRelATivo", "rutaRelitivo", "rutaRELitiva", "rutaRELativas", "rutaRelantivo", "rutaRelatiivo", "rutaRelatiiva", "rutaRelATivas"], "fis": ["flis", "fais", " fys", "fisc", "rys", "lfiss", "fys", "vois", "dfis", " fisa", "flos", "ros", " f\u00eds", "df\u00eds", "vais", "risc", "vis", "f\u00eds", "dfiss", "lf\u00eds", "viss", "dfais", " fais", " fois", "fiss", "ris", "lfis", "dfisa", "lfisa", "fisa", " fisc", "fois", "flisc", "dfois", "flys", " fiss"], "fos": ["foes", "woes", "mos", "foss", " fops", " faos", "vops", " fows", "foses", "vos", "mows", "woses", "wios", "faos", "fdaos", "hoses", "fdoss", " foes", "fows", "wos", "moes", "hos", "hios", "mops", "voes", "ioses", "iios", "woss", "vows", "fios", "fdoes", "fops", "ioss", " foss", "hoss", "ios", "waos", "fdos"], "canalFuente": ["canallfuestro", "canallFumelon", "canalFraencia", "canalfuent", "canallfucer", "canalfuante", "canelFuente", "canelFuelia", "canalFiente", "canalPotente", "canalFUente", "canalFUent", "canallFuent", "canallfumelon", "canallfuper", "canalFraper", "canalFramelon", "canallFuestro", "canalFuelia", "canalFUelia", "canelFuante", "canelFaelia", "canalFuestro", "canalFraente", "canelFaent", "canalFient", "canalfumelon", "canallfuencia", "canalFumelon", "canelFaante", "canalfuencia", "canalFUante", "canalFicer", "canallFuper", "canalPotencia", "canallFucer", "canallFuente", "canelFaente", "canallfuent", "canelFuent", "canalPotmelon", "canalFaente", "canalFuante", "canalPotper", "canalFaestro", "canalFacer", "canalfuente", "canalFiestro", "canallfuente", "canalFuper", "canalfuper", "canalfuestro", "canalFuencia", "canalFaante", "canalFuent", "canalFaent", "canalfucer", "canalFucer", "canalfuelia", "canalFaelia", "canallFuencia"], "canalDestino": ["canalDestine", "canalsdestino", "canalDescino", "canalOrigine", "canalsDestination", "canalsDestina", "canaldOrigine", "canalsdestina", "canalNegino", "canalNegina", "canalDescina", "canaldDestine", "canalsDestino", "canalOrigino", "canaldOrigina", "canaldDestino", "canaldOrigino", "canalDestination", "canaldestino", "canalNegination", "canalsdestination", "canalDescination", "canaldOrigination", "canalDescine", "canaldDestination", "canalDestina", "canalOrigina", "canalsdestinian", "canaldestina", "canalNeginian", "canalsDestinian", "canalOrigination", "canaldDestina", "canaldestination", "canalDestinian", "canaldestinian"]}}
{"id1": "11556231", "id2": "12766394", "code1": "    public static Document ByURL(String urlstr) throws IOException {\n        String uri = urlstr;\n        URL url = new URL(uri);\n        URLConnection connection = url.openConnection();\n        InputStream in = connection.getInputStream();\n        Reader reader = new InputStreamReader(in);\n        InputSource is = new InputSourceImpl(reader, uri);\n        System.out.println(is.toString());\n        Document document = new Document() {\n\n            @Override\n            public Node adoptNode(Node source) throws DOMException {\n                return null;\n            }\n\n            @Override\n            public Attr createAttribute(String name) throws DOMException {\n                return null;\n            }\n\n            @Override\n            public Attr createAttributeNS(String namespaceURI, String qualifiedName) throws DOMException {\n                return null;\n            }\n\n            @Override\n            public CDATASection createCDATASection(String data) throws DOMException {\n                return null;\n            }\n\n            @Override\n            public Comment createComment(String data) {\n                return null;\n            }\n\n            @Override\n            public DocumentFragment createDocumentFragment() {\n                return null;\n            }\n\n            @Override\n            public Element createElement(String tagName) throws DOMException {\n                return null;\n            }\n\n            @Override\n            public Element createElementNS(String namespaceURI, String qualifiedName) throws DOMException {\n                return null;\n            }\n\n            @Override\n            public EntityReference createEntityReference(String name) throws DOMException {\n                return null;\n            }\n\n            @Override\n            public ProcessingInstruction createProcessingInstruction(String target, String data) throws DOMException {\n                return null;\n            }\n\n            @Override\n            public Text createTextNode(String data) {\n                return null;\n            }\n\n            @Override\n            public DocumentType getDoctype() {\n                return null;\n            }\n\n            @Override\n            public Element getDocumentElement() {\n                return null;\n            }\n\n            @Override\n            public String getDocumentURI() {\n                return null;\n            }\n\n            @Override\n            public DOMConfiguration getDomConfig() {\n                return null;\n            }\n\n            @Override\n            public Element getElementById(String elementId) {\n                return null;\n            }\n\n            @Override\n            public NodeList getElementsByTagName(String tagname) {\n                return null;\n            }\n\n            @Override\n            public NodeList getElementsByTagNameNS(String namespaceURI, String localName) {\n                return null;\n            }\n\n            @Override\n            public DOMImplementation getImplementation() {\n                return null;\n            }\n\n            @Override\n            public String getInputEncoding() {\n                return null;\n            }\n\n            @Override\n            public boolean getStrictErrorChecking() {\n                return false;\n            }\n\n            @Override\n            public String getXmlEncoding() {\n                return null;\n            }\n\n            @Override\n            public boolean getXmlStandalone() {\n                return false;\n            }\n\n            @Override\n            public String getXmlVersion() {\n                return null;\n            }\n\n            @Override\n            public Node importNode(Node importedNode, boolean deep) throws DOMException {\n                return null;\n            }\n\n            @Override\n            public void normalizeDocument() {\n            }\n\n            @Override\n            public Node renameNode(Node n, String namespaceURI, String qualifiedName) throws DOMException {\n                return null;\n            }\n\n            @Override\n            public void setDocumentURI(String documentURI) {\n            }\n\n            @Override\n            public void setStrictErrorChecking(boolean strictErrorChecking) {\n            }\n\n            @Override\n            public void setXmlStandalone(boolean xmlStandalone) throws DOMException {\n            }\n\n            @Override\n            public void setXmlVersion(String xmlVersion) throws DOMException {\n            }\n\n            public Node appendChild(Node arg0) throws DOMException {\n                return null;\n            }\n\n            public Node cloneNode(boolean arg0) {\n                return null;\n            }\n\n            public short compareDocumentPosition(Node arg0) throws DOMException {\n                return 0;\n            }\n\n            public NamedNodeMap getAttributes() {\n                return null;\n            }\n\n            public String getBaseURI() {\n                return null;\n            }\n\n            public NodeList getChildNodes() {\n                return null;\n            }\n\n            public Object getFeature(String arg0, String arg1) {\n                return null;\n            }\n\n            public Node getFirstChild() {\n                return null;\n            }\n\n            public Node getLastChild() {\n                return null;\n            }\n\n            public String getLocalName() {\n                return null;\n            }\n\n            public String getNamespaceURI() {\n                return null;\n            }\n\n            public Node getNextSibling() {\n                return null;\n            }\n\n            public String getNodeName() {\n                return null;\n            }\n\n            public short getNodeType() {\n                return 0;\n            }\n\n            public String getNodeValue() throws DOMException {\n                return null;\n            }\n\n            public Document getOwnerDocument() {\n                return null;\n            }\n\n            public Node getParentNode() {\n                return null;\n            }\n\n            public String getPrefix() {\n                return null;\n            }\n\n            public Node getPreviousSibling() {\n                return null;\n            }\n\n            public String getTextContent() throws DOMException {\n                return null;\n            }\n\n            public Object getUserData(String arg0) {\n                return null;\n            }\n\n            public boolean hasAttributes() {\n                return false;\n            }\n\n            public boolean hasChildNodes() {\n                return false;\n            }\n\n            public Node insertBefore(Node arg0, Node arg1) throws DOMException {\n                return null;\n            }\n\n            public boolean isDefaultNamespace(String arg0) {\n                return false;\n            }\n\n            public boolean isEqualNode(Node arg0) {\n                return false;\n            }\n\n            public boolean isSameNode(Node arg0) {\n                return false;\n            }\n\n            public boolean isSupported(String arg0, String arg1) {\n                return false;\n            }\n\n            public String lookupNamespaceURI(String arg0) {\n                return null;\n            }\n\n            public String lookupPrefix(String arg0) {\n                return null;\n            }\n\n            public void normalize() {\n            }\n\n            public Node removeChild(Node arg0) throws DOMException {\n                return null;\n            }\n\n            public Node replaceChild(Node arg0, Node arg1) throws DOMException {\n                return null;\n            }\n\n            public void setNodeValue(String arg0) throws DOMException {\n            }\n\n            public void setPrefix(String arg0) throws DOMException {\n            }\n\n            public void setTextContent(String arg0) throws DOMException {\n            }\n\n            public Object setUserData(String arg0, Object arg1, UserDataHandler arg2) {\n                return null;\n            }\n        };\n        return document;\n    }\n", "code2": "    public void testReadHelloWorldTxt() throws Exception {\n        final InputStream helloWorldIS = this.getClass().getClassLoader().getResourceAsStream(BASE_DIR + \"/HelloWorld.txt\");\n        FileUtils.forceMkdir(new File(this.testDir.getAbsolutePath() + \"/org/settings4j/contentresolver\"));\n        final String helloWorldPath = this.testDir.getAbsolutePath() + \"/org/settings4j/contentresolver/HelloWorld.txt\";\n        final FileOutputStream fileOutputStream = new FileOutputStream(new File(helloWorldPath));\n        IOUtils.copy(helloWorldIS, fileOutputStream);\n        IOUtils.closeQuietly(helloWorldIS);\n        IOUtils.closeQuietly(fileOutputStream);\n        LOG.info(\"helloWorldPath: \" + helloWorldPath);\n        final FSContentResolver contentResolver = new FSContentResolver();\n        contentResolver.setRootFolderPath(this.testDir.getAbsolutePath());\n        byte[] content = contentResolver.getContent(\"org/settings4j/contentresolver/HelloWorld.txt\");\n        assertNotNull(content);\n        assertEquals(\"Hello World\", new String(content, \"UTF-8\"));\n        content = contentResolver.getContent(\"file:org/settings4j/contentresolver/HelloWorld.txt\");\n        assertNotNull(content);\n        assertEquals(\"Hello World\", new String(content, \"UTF-8\"));\n        content = contentResolver.getContent(\"file:/org/settings4j/contentresolver/HelloWorld.txt\");\n        assertNotNull(content);\n        assertEquals(\"Hello World\", new String(content, \"UTF-8\"));\n        content = contentResolver.getContent(\"file:laksjdhalksdhfa\");\n        assertNull(content);\n        content = contentResolver.getContent(\"/org/settings4j/contentresolver/HelloWorld.txt\");\n        assertNotNull(content);\n        assertEquals(\"Hello World\", new String(content, \"UTF-8\"));\n    }\n", "label": 0, "substitutes": {"ByURL": ["ByUrl", "createURL", "createString", " byURL", "createHTTP", "byUrl", "byURL", " byHTTP", " byString", " byUrl", "byString", "ByString", "ByHTTP", "byHTTP", "createUrl"], "urlstr": ["uristr", "ulStr", "lSTR", "urlStr", "urlstring", "UrlStr", "uristring", "uriobj", "lStr", "ulSTR", "Urlstr", "lstr", "Urlstring", "ulstring", "urlobj", "UrlSTR", "ulstr", "lstring", "uriStr", "urlSTR", "Urlobj", "lobj"], "uri": ["origin", "address", "reference", "u", "subject", "ri", "URI", "resource", "description", "https", "context", "init", "directory", "q", "range", "link", "system", "ur", "filename", "ui", "i", "URL", " URI", "pi", "doi", "iri", "query", "uu", "path", "term", "uid", "database", "href", "http", "string", "html", "io", "file", "Url", "id", "du", "prefix", "phi"], "url": ["browser", "f", "address", "sb", "parser", "resource", "client", "ls", "ll", "base", "char", "link", "build", "sl", "open", "impl", "ur", "mount", "URL", "str", "l", "nl", "ul", "li", "mail", "conn", "parse", "hub", "r", "ssl", "http", "location", "socket", "job", "file", "loc", "Url", "host"], "connection": ["ion", "response", "con", "connected", "console", "engine", "service", "resource", "application", "client", "using", "opening", "context", "directory", "link", "command", "c", "open", "i", "number", "condition", "position", "Connection", "handler", "conn", "network", "connect", "database", "relation", "channel", "http", "socket", "io", "session", "established"], "in": ["f", "en", "rin", "inn", "us", "IN", "ins", "client", "stream", "In", "inner", "i", "bin", "mat", "get", "l", "input", "out", "sin", " din", "ind", "r", "ma", "mc", "mm", "info", "din", "inf", "isin", "file", "body", "cin", "id", "from"], "reader": ["runner", "rar", "handle", "parser", "resource", "builder", "ri", "ro", "stream", "context", "inner", "Reader", "buffer", "dr", "read", "ator", "writer", "input", "iter", "rx", "handler", "iterator", "r", "row", "ner", "io", "er", "reading", "body", "loader"], "is": ["mis", "ms", "iris", "res", "ins", "im", "Is", "ri", "nis", "se", "fs", "sys", "isa", "ais", "ism", "sim", "i", "its", "serv", "rs", "os", "ris", "IS", "input", "has", "are", "isc", "lis", "s", "bis", "info", "isi", "isin", "as", "ios", "iss", "sam", "es", "sis"], "document": ["response", " Document", "element", "output", "application", "m", "doc", "page", "context", "library", "template", "message", "Document", "result", "xml", "content", "node", "information", "media", "dom", "tree", "object", "ocument", "record", "collection", "file"], "source": ["event", "element", "select", "dest", "resource", "se", "set", " src", "site", "context", "result", "src", "content", "Source", "number", "node", "SOURCE", "input", "or", "out", "tree", "handler", "object", "ource", "sn", "instance", "location"], "name": ["type", "event", "attr", "value", "default", "named", "comment", "description", "tag", "names", "code", "label", "attribute", "property", "format", "node", "variable", "param", "NAME", "object", "path", "key", "string", "location", "file", "class", "version", "id", "Name", "prefix", "title"], "namespaceURI": ["namespaceUID", "namesacementURI", "nspaceuri", "namesacementIX", "namesetID", "namesacementUI", "nsplaceID", "namesetURL", "namesaceURI", "namesplaceID", "resourcesacementIX", "namesenterUID", "workspaceuri", "namesystemuri", "nameseturi", "namespaceUI", "namesificationRI", "namespaceuri", "namesaceUI", "namesenteruri", "namesificationuri", "namespaceRI", "workspaceRI", "namespaceIX", "worksystemuri", "nspaceID", "nspaceURL", "namespaceID", "workspaceURI", "nsplaceuri", "namesplaceuri", "resourcesacementUI", "namespaceURL", "namesplaceURL", "namesenterURI", "resourcespaceUI", "namesystemURI", "nsplaceURL", "resourcespaceURI", "nsplaceURI", "namesificationUID", "worksystemRI", "namesystemUID", "nspaceURI", "resourcesacementURI", "namesenterRI", "worksystemUID", "namesplaceURI", "worksystemURI", "namesificationURI", "namesaceIX", "namesystemRI", "resourcespaceIX", "namesetURI", "workspaceUID"], "qualifiedName": ["fullNames", "localNames", "qualifiedname", "friendlyname", "commonname", "friendlyName", "friendlyNames", "fullValue", "localType", "relativeName", "fullName", "relativename", "friendlyType", "relativeValue", "localname", "fullname", "qualifiedValue", "commonName", "qualifiedType", "commonType", "commonNames", "relativeNames", "qualifiedNames", "localValue"], "data": ["type", "event", "response", "address", "value", "text", "DATA", "image", "element", "output", "comment", "resource", "description", "ata", "command", "action", "buffer", "message", "result", "mode", "xml", "content", "format", "def", "media", "str", "error", "definition", "input", "object", "dat", "pattern", "info", "key", "string", "password", "body", "version", "expression"], "tagName": ["localname", "qualifiedname", "TagValue", "localData", "Tagname", "localValue", "qualifiedValue", "tagValue", "TagName", "tagData", "TagData", "qualifiedData"], "target": ["ref", "subject", "alias", "context", "link", "command", "action", "result", "src", "property", "format", "content", "node", "owner", "Target", "error", "object", "handler", "path", "language", "instance", "ip", "role", "location", "binding", "class", "prefix", "title"], "elementId": ["objectid", "objectId", "nodeID", "elementid", "nodeId", "objectIndex", "documentId", "objectID", "documentIndex", "documentID", "nodeid", "nodeIndex", "documentid", "elementID", "elementIndex"], "tagname": ["Tagnum", "Tagid", "localname", "tagnum", "shortnum", "shortName", "localnum", "tagid", "shortname", "TagName", "Tagname", "localid", "shortid"], "localName": ["componentname", "componentName", "fixedNAME", "localNames", "localname", "supportedName", "fixedNames", "localNAME", "fixedname", "componentNames", "supportedNAME", "supportedNames", "supportedname", "fixedName", "componentNAME"]}}
{"id1": "21316706", "id2": "19687456", "code1": "    @Override\n    protected URLConnection openConnection(URL url, Proxy proxy) throws IOException {\n        if ((url == null) || (proxy == null)) {\n            throw new IllegalArgumentException(Messages.getString(\"luni.1B\"));\n        }\n        return new HttpsURLConnectionImpl(url, getDefaultPort(), proxy);\n    }\n", "code2": "    public void testReadPerMemberSixSmall() throws IOException {\n        GZIPMembersInputStream gzin = new GZIPMembersInputStream(new ByteArrayInputStream(sixsmall_gz));\n        gzin.setEofEachMember(true);\n        for (int i = 0; i < 3; i++) {\n            int count2 = IOUtils.copy(gzin, new NullOutputStream());\n            assertEquals(\"wrong 1-byte member count\", 1, count2);\n            gzin.nextMember();\n            int count3 = IOUtils.copy(gzin, new NullOutputStream());\n            assertEquals(\"wrong 5-byte member count\", 5, count3);\n            gzin.nextMember();\n        }\n        int countEnd = IOUtils.copy(gzin, new NullOutputStream());\n        assertEquals(\"wrong eof count\", 0, countEnd);\n    }\n", "label": 0, "substitutes": {"openConnection": [" openChannel", " openconnection", " obtainConnect", "doChannel", " obtainConnection", "openChannel", "doConnection", "doconnection", "doConnect", " obtainconnection", "openConnect", " obtainChannel", " openConnect", "openconnection"], "url": ["browser", "all", "access", "address", "util", "ls", "web", "ll", "char", "link", "addr", "build", "log", "sl", "b", "q", "re", "xml", "ur", "mount", "un", "uri", "URL", "name", "str", "l", "parse", "ul", "mail", "path", "r", "ssl", "el", "domain", "ret", "key", "http", "location", "string", "config", "job", "server", "file", "loc", "Url", "id", "host"], "proxy": ["browser", "report", "via", "zone", "address", "pointer", "policy", "service", "slave", "pse", "resource", "client", "force", "pipe", "library", "port", "module", "connection", "po", "profile", "shadow", "link", "one", "cas", "ping", "pro", "property", "none", "cache", "uri", "token", "project", "roxy", "ssl", "Proxy", "manager", "http", "socket", "password", "timeout", "version", "server", "pe"]}}
{"id1": "20091126", "id2": "4599372", "code1": "    static File copy(File in, File out) throws IOException {\n        FileChannel inChannel = new FileInputStream(in).getChannel();\n        FileChannel outChannel = new FileOutputStream(out).getChannel();\n        try {\n            inChannel.transferTo(0, inChannel.size(), outChannel);\n            return out;\n        } catch (IOException e) {\n            throw e;\n        } finally {\n            if (inChannel != null) inChannel.close();\n            if (outChannel != null) outChannel.close();\n        }\n    }\n", "code2": "    @Override\n    public String readFixString(final int len) {\n        if (len < 1) {\n            return StringUtils.EMPTY;\n        }\n        final StringWriter sw = new StringWriter();\n        try {\n            IOUtils.copy(createLimitedInputStream(len), sw, null);\n        } catch (IOException e) {\n            throw createRuntimeException(e);\n        }\n        return sw.toString();\n    }\n", "label": 1, "substitutes": {"copy": ["cat", "y", "sync", "create", "Transfer", " Copy", "store", "Copy", "transfer", "write", "open", "delete", "load", "call", "to", "system", "cp", "get", "upload", "paste", "Cop", "download", "io", "save", "file", "map", "clone", "move"], "in": ["rin", "en", "inn", "ini", "gin", "IN", "ins", "In", "init", "inner", "old", "b", "up", "i", "inc", "l", "input", " din", "ck", " input", "ain", "ind", "r", "el", "mm", "n", "info", "io", "din", "inf", "isin", "source", "file", "cin", "id", "from"], "out": ["co", "_", "nt", "y", "output", "res", "w", "tmp", "t", "x", "one", "err", "log", "net", "b", "to", "c", " os", "write", "result", "ot", "end", "v", "e", "os", "l", "or", "it", "ch", "gt", "null", "ou", "s", "outs", "o", "at", " it", "channel", "self", "n", "io", "msg", "Out", "file", "as", "OUT", "p", "bytes", " output", "ex"], "inChannel": ["cinChannel", " inListener", "ginChain", "InConnection", "conChannel", "INChan", "cinCommand", "binCommand", "InChan", "inChan", "INConnection", "insideChannel", "outBlock", "inListener", "inChain", "binSection", "incChain", "insideCommand", "outCommand", "cinBlock", "insideRow", "inChuck", "incChannel", "InChannel", "innChan", "innChannel", "inCommand", "conListener", "binChannel", " inSection", " inConnection", "ginChannel", " inchannel", "INListener", " inRow", "innConnection", "incChuck", "binRow", "innchannel", "INChannel", "cinchannel", "conConnection", "ginChuck", "insideSection", "binChain", "inPanel", "incPanel", "binChuck", "inBlock", " inChan", " inBlock", "inConnection", "inchannel", "conChan", "inRow", " inCommand", "outchannel", "Inchannel", "inSection", "ginPanel", "binPanel"], "outChannel": ["Outchannel", " outMany", "outMany", "inChan", "inUser", "cmdChannel", "cosChannel", "OUTChan", "modulePassword", "skyGate", "cmdMany", "outGate", "outSlot", "OUTUser", "OutChannel", " outCh", " outGate", " outChan", "OutChan", "cosChan", "moduleManager", "cosSlot", "inCh", "skyChannel", "cosUser", " outManager", "skyMany", "OUTSlot", "outUser", "skyChan", "cmdChan", "outputManager", "outputPassword", "cmdGate", "inSlot", "OUTChannel", "moduleChannel", " outchannel", "inchannel", "outChan", "outputChannel", " outPassword", "moduleChan", "outManager", "outchannel", "OutCh", "outPassword", "outCh", "outputChan"]}}
{"id1": "3330944", "id2": "21979717", "code1": "    public void extractImage(String input, String output, DjatokaDecodeParam params, IWriter w) throws DjatokaException {\n        File in = null;\n        String dest = output;\n        if (input.equals(STDIN)) {\n            try {\n                in = File.createTempFile(\"tmp\", \".jp2\");\n                input = in.getAbsolutePath();\n                in.deleteOnExit();\n                IOUtils.copyFile(new File(STDIN), in);\n            } catch (IOException e) {\n                logger.error(\"Unable to process image from \" + STDIN + \": \" + e.getMessage());\n                throw new DjatokaException(e);\n            }\n        }\n        BufferedImage bi = extractImpl.process(input, params);\n        if (bi != null) {\n            if (params.getScalingFactor() != 1.0 || params.getScalingDimensions() != null) bi = applyScaling(bi, params);\n            if (params.getTransform() != null) bi = params.getTransform().run(bi);\n            try {\n                BufferedOutputStream os = new BufferedOutputStream(new FileOutputStream(new File(dest)));\n                w.write(bi, os);\n                os.close();\n            } catch (FileNotFoundException e) {\n                logger.error(\"Requested file was not found: \" + dest);\n                throw new DjatokaException(e);\n            } catch (IOException e) {\n                logger.error(\"Error attempting to close: \" + dest);\n                throw new DjatokaException(e);\n            }\n        }\n        if (in != null) in.delete();\n    }\n", "code2": "    @ActionMethod\n    public void upload() throws IOException {\n        final int fileResult = fileChooser.showOpenDialog(frame);\n        if (fileResult != JFileChooser.APPROVE_OPTION) {\n            return;\n        }\n        final InputStream in = new FileInputStream(fileChooser.getSelectedFile());\n        try {\n            final URL url = new URL(\"http://127.0.0.1:\" + testPort + \"/databases/\" + fileChooser.getSelectedFile().getName());\n            final HttpURLConnection con = (HttpURLConnection) url.openConnection();\n            con.setRequestMethod(\"PUT\");\n            con.setDoOutput(true);\n            con.setRequestProperty(Http11Header.AUTHORIZATION, \"Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ==\");\n            con.setRequestProperty(Http11Header.WWW_AUTHENTICATE, \"Basic realm=\\\"karatasi\\\"\");\n            con.setRequestProperty(Http11Header.CONTENT_LENGTH, Long.toString(fileChooser.getSelectedFile().length()));\n            con.setRequestProperty(Http11Header.CONTENT_TYPE, \"application/octet-stream\");\n            final OutputStream out = con.getOutputStream();\n            try {\n                Util.copy(in, out);\n                con.connect();\n                final InputStream in2 = con.getInputStream();\n                try {\n                    textArea.setText(\"\");\n                    final byte[] buf = new byte[4096];\n                    for (int bytesRead; (bytesRead = in2.read(buf)) != -1; ) {\n                        textArea.append(new String(buf, 0, bytesRead));\n                    }\n                } finally {\n                    in2.close();\n                }\n            } finally {\n                out.close();\n            }\n        } finally {\n            in.close();\n        }\n    }\n", "label": 0, "substitutes": {"extractImage": ["Extprocessimage", "extprocessimage", "ExtprocessFrame", "extprocessImages", "extprocessFrame", "extprocessImage", "extlateFrame", "extractFrame", "extractimage", "extlateimage", "extlateImage", "extractorImages", "ExtractImage", "extractorFrame", "extractorimage", "extlateImages", "extractImages", "ExtprocessImage", "ExtractFrame", "extractorImage", "ExtprocessImages", "ExtractImages", "Extractimage"], "input": ["origin", "empty", "rc", "txt", "image", "address", "text", "img", "select", "sample", "internal", "ins", "hello", "request", "raw", "tmp", "context", "init", "accept", "before", "base", "q", "buffer", "current", "Input", "xml", "i", "background", "format", "url", "uri", "hidden", "error", "partial", "str", "initial", "out", "upload", "it", "query", "this", "audio", "path", "seed", "null", "ip", "pattern", "local", "string", "config", "start", "file", "source", "check", "index", "p", "from", "data", "prefix", "qa"], "output": ["type", "response", "image", "put", "oe", "prefix", "port", "Output", "PUT", "generated", "write", "to", "STDOUT", "current", "result", "filename", "format", "name", "hidden", "target", "success", "out", "pretty", "OU", "path", "o", "temp", "icon", "file", "source", "OUT", "print", "display"], "params": ["terms", "parents", "tags", "photos", "json", "prop", "settings", "ctx", "options", "par", "Par", "pas", "parts", "abilities", "users", "tools", "details", "m", "keys", "types", "modules", "docs", "packages", "names", "changes", "marks", "spec", "phys", "pins", "stats", "pkg", "devices", "ps", "pro", "conf", "units", "styles", "ams", "param", "properties", "fps", "pi", "pps", "rs", "caps", "images", "points", "eps", "proc", "las", " parameters", "actions", "members", "Parameters", "gs", "ims", "chains", "s", "AMS", "ports", "ars", "mm", "jp", "requires", "config", "eters", "arms", "p", "pretty", "results", "phi"], "w": ["f", "wr", "window", "Writer", "W", "d", "h", "word", "rw", "wal", "m", "ws", "wl", "wa", "wb", "wx", "hw", "we", "write", "q", "wd", "v", "e", "writer", "out", "Ws", "wt", "sw", "ew", "o", "kw", "n", "nw", "wo", "wp", "wh", "p"], "in": ["f", "all", "mi", "rin", "en", "include", "win", "inn", "ini", "gin", "con", "IN", "vin", "ins", "ar", "ln", "al", "raw", "In", "init", "inner", "po", "base", "one", "phys", "old", "Input", "edIn", "conf", "i", "e", "read", "bin", "name", "copy", "out", "sin", "it", " IN", "sql", " din", "path", "null", "nin", "ma", "mc", "mm", "local", "info", "din", "inf", "is", "isin", "source", "file", "cin", "id", "p", "from"], "dest": ["origin", "decl", "buf", "csv", "txt", "usr", "comb", "prop", "cat", "img", "orig", "oe", "pas", "cont", "way", "trans", "ws", "tmp", "wb", "pipe", "port", "mem", "rest", "write", "resp", "to", "shape", "lit", "result", "src", "opt", " dst", "alt", "target", "out", "des", " destination", "data", "st", "path", "dir", "nom", "dat", "desc", "Dest", "dist", "temp", "save", "source", "loc", "deg", "tif", "p", "end", "display"], "bi": ["ali", "mi", "bone", "fi", "pb", "buff", "bf", "ini", "bg", "bank", "bra", "di", "jiang", "qi", "bo", "abi", "yi", "bh", "ki", "BI", "bs", "bc", "bas", "be", "bits", "b", "bb", "ai", "hog", "gi", "bp", "i", "bm", "bin", "nb", "obi", "ba", "pi", "ibi", "iri", "ji", "ibe", "ni", "beck", "mu", "bie", "li", "Bi", "bis", "vi", "ble", "phy", " nib", "bil", "isi", "rob", "oi", "zi", "ib", "umi", "obo", "phi"], "os": ["ows", "oes", "Os", "us", "cos", "oss", "mos", "et", "osi", "ow", "oses", "ros", "fs", "sys", "bs", "ls", "ns", "los", "oo", "ose", "ts", "mot", "ox", "oid", "ols", "pos", "or", "bos", "ds", "ys", "acs", "ops", "ons", "obs", "css", "s", "aos", "o", "OS", "io", "is", "ios", "oos", "ks", "es", "cs", "ot"]}}
{"id1": "8468859", "id2": "3536332", "code1": "    public boolean connect() {\n        boolean isConnected = false;\n        try {\n            try {\n                this.ftpClient.connect(this.server, this.port);\n            } catch (SocketException e) {\n                status = ErrorResult.CONNECTNOTPOSSIBLE.code;\n                return false;\n            } catch (IOException e) {\n                status = ErrorResult.CONNECTNOTPOSSIBLE.code;\n                return false;\n            }\n            int reply = this.ftpClient.getReplyCode();\n            if (!FTPReply.isPositiveCompletion(reply)) {\n                this.disconnect();\n                status = ErrorResult.CONNECTNOTCORRECT.code;\n                return false;\n            }\n            try {\n                if (this.account == null) {\n                    if (!this.ftpClient.login(this.username, this.passwd)) {\n                        status = ErrorResult.LOGINNOTCORRECT.code;\n                        this.ftpClient.logout();\n                        return false;\n                    }\n                } else if (!this.ftpClient.login(this.username, this.passwd, this.account)) {\n                    status = ErrorResult.LOGINACCTNOTCORRECT.code;\n                    this.ftpClient.logout();\n                    return false;\n                }\n            } catch (IOException e) {\n                status = ErrorResult.ERRORWHILECONNECT.code;\n                try {\n                    this.ftpClient.logout();\n                } catch (IOException e1) {\n                }\n                return false;\n            }\n            isConnected = true;\n            return true;\n        } finally {\n            if ((!isConnected) && this.ftpClient.isConnected()) {\n                this.disconnect();\n            }\n        }\n    }\n", "code2": "    private String digest(String input) throws NoSuchAlgorithmException, UnsupportedEncodingException {\n        MessageDigest md = MessageDigest.getInstance(\"MD5\");\n        byte[] md5hash = new byte[64];\n        md.update(input.getBytes(\"iso-8859-1\"), 0, input.length());\n        md5hash = md.digest();\n        return this.convertToHex(md5hash);\n    }\n", "label": 0, "substitutes": {"connect": [" disconnect", "Connect", "process", "dial", "connected", "match", "sync", "con", "select", "request", "client", "create", "set", "establish", "init", "connection", "link", "log", "open", "ping", "join", "close", "error", "bind", "login", "pen", "exit", "construct", "conn", "network", "register", "ready", "config", "start", "timeout", "check", "attach", "setup"], "status": ["style", "access", "json", "settings", "flags", "sync", "output", "policy", "console", "params", "severe", "comment", "service", "score", "description", "uses", "details", "summary", "sequence", "comments", "code", "spec", "print", "stats", "ping", "result", "join", "list", "xml", "content", "format", "gc", "url", "str", "sign", "login", "impact", "stat", "sc", "search", "use", "ssl", "usage", "scale", "source", "version", "check", "sort", "update", "prefix", "display", "title"], "reply": ["back", "response", "address", "notice", "match", "next", "py", "time", "part", "comment", "frame", "feature", "code", "ply", "command", "consider", "write", "link", "message", "result", "close", " Reply", "number", "nb", "state", "error", "success", "vote", "query", "answer", "continue", "flag", "record", "ret", "Reply", "job", "repl", "user", "prefix"], "isConnected": ["isConnectable", "isConns", " isConnecting", "IsNECTing", "isCorrects", "isAdapts", " isLoadeds", "isConnectionedIn", "isConnectioned", "isNECTedIn", "IsNECTedIn", "IsConnectioned", "isLinks", " isLoaded", "isAdapting", "isLinkED", "issConnectioneded", " isConnects", "isStarteded", "isStarting", "isConnectioneded", "isLoading", "isConnecteds", "isConned", "isConnED", "isConnectedIn", "IsConnectED", "isProcessed", "issConnecteded", "IsConnectionED", " isLoads", "isLoadeds", "isConnured", "isConnects", "isPresenteded", "isStarted", "isProcessing", "IsNECTable", "IsNECTed", "isLoads", "issConnected", "isNECTing", " isConnecteds", " isLoading", "isCorrected", "issConnectioned", "isLoaded", "isPresentedIn", "issConnectedIn", "isProcessedIn", "isAdapteds", "IsConnectable", "IsConnectionured", "isConnectED", "isConnections", "issConnectioning", "isConnecting", "IsConnectedIn", "IsConnecting", "isLinked", "isAdapted", "issConnecting", "isPresenting", "IsConnections", "isConnectionED", "isStartable", "isConnecteded", "isNECTable", "IsConnected", "isPresented", "issConnectionedIn", "isConnectioning", "isConnectured", "isCorrecteds", "isProcessable", "IsConnectured", "isNECTed", "isStartedIn", "isConnectionured", "IsConnects", "isLinkured", "isCorrecting"]}}
{"id1": "12869602", "id2": "11154758", "code1": "    @Test\n    public void test_validate_tag_getTopAlbums() {\n        try {\n            SchemaFactory factory = SchemaFactory.newInstance(\"http://www.w3.org/2001/XMLSchema\");\n            File schemaLocation = new File(\"tes.xsd\");\n            Schema schema = factory.newSchema(schemaLocation);\n            Validator validator = schema.newValidator();\n            URL url = new URL(\"http://ws.audioscrobbler.com/2.0/?method=tag.gettopalbums&tag=disco&api_key=b25b959554ed76058ac220b7b2e0a026\");\n            InputStream inputStream = url.openStream();\n            Source source = new StreamSource(inputStream);\n            validator.validate(source);\n        } catch (IOException ex) {\n            Logger.getLogger(GetTopAlbums_Test.class.getName()).log(Level.SEVERE, null, ex);\n            assertFalse(\"File not found\", true);\n        } catch (SAXException ex) {\n            Logger.getLogger(GetTopAlbums_Test.class.getName()).log(Level.SEVERE, null, ex);\n            assertFalse(\"Schema did not validate\", true);\n        }\n        assertTrue(true);\n    }\n", "code2": "    public static void main(String[] args) {\n        FTPClient client = new FTPClient();\n        FileOutputStream fos = null;\n        try {\n            client.connect(\"192.168.1.10\");\n            client.login(\"a\", \"123456\");\n            String filename = \"i.exe\";\n            fos = new FileOutputStream(filename);\n            client.retrieveFile(\"/\" + filename, fos);\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            try {\n                if (fos != null) {\n                    fos.close();\n                }\n                client.disconnect();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n", "label": 0, "substitutes": {"test_validate_tag_getTopAlbums": ["test_validate_tag_getTopAlbumes", "test_validate_tag_getTopAllalbums", "test_validate_tag_getTopAlalbums", "test_validate_tag_getTopAllbumes", "test_validate_tag_getTopAloggments", "test_validate_tag_getTopAlbumments", "test_validate_tag_getTopAlalbumes", "test_validate_tag_getTopAloggs", "test_validate_tag_getTopAllbumls", "test_validate_tag_getTopAlbumls", "test_validate_tag_getTopAllalbumments", "test_validate_tag_getTopAllalbumes", "test_validate_tag_getTopAllbums", "test_validate_tag_getTopAllalbumls", "test_validate_tag_getTopAlalbumls", "test_validate_tag_getTopAllbumments", "test_validate_tag_getTopAlalbumments", "test_validate_tag_getTopAlogges", "test_validate_tag_getTopAloggls"], "factory": ["Facter", "FFactory", "Factory", "lacter", " filler", "filler", "lancy", "liller", "vacter", "facter", "fade", "fancy", "cacter", "cactory", "vactory", "cancy", "facFactory", "vade", "lactory", "facactory", "fFactory", "facacter", "facade", "vFactory", " fancy", "Fade", " facter", "ciller"], "schemaLocation": ["schembolLocation", "symaPath", "schemaLoc", "semalocation", "schemaPath", "schemaslocation", "schembollocation", "scheaturelocation", "symaLocation", "semaLoc", "seatureLocation", "syallocation", "schemalocation", "scheallocation", "schemePath", "schemasLocation", "symalocation", "schembolLoc", "scheatureLocation", "semaLocation", "scheaturePath", "seatureLoc", "syalPath", "syalLocation", "schealPath", "schealLocation", "scheatureLoc", "schemelocation", "seaturelocation", "schemeLocation", "schemasLoc"], "schema": ["scheme", " schem", "schem", "scheEMA", "maEMA", "mama", "validature", "validme", "scheator", " scheature", "cheme", " scheme", "cheEMA", "mame", "chema", "Schema", "Scheme", "cheature", "chem", "validm", "scheature", "cheator", "ScheEMA", "Scheator", "maator", "validma"], "validator": ["verma", "navigator", "navma", "scheator", "navator", "variator", " validigator", "valator", "varier", "validener", " validma", "naver", "valider", "scheer", "valer", "scheener", "varima", " valider", "validigator", "verener", "verer", "verator", "variigator", "valener", "valma", "validma"], "url": ["browser", "f", "window", "gl", "address", "u", "dl", "res", "service", "resource", "bel", "web", "ll", "base", "char", "link", "log", "sl", "b", "rel", "xml", "ur", "mount", "uri", "URL", "name", "str", "external", "get", "l", "api", "nl", "ul", "null", "hub", "r", "ssl", "channel", "http", "location", "html", "file", "Url", "user", "abs"], "inputStream": ["sourcestream", "sourceSteam", "inputStreamer", "feedstream", "InputStream", " inputSource", "InputStreamer", " inputSteam", "inputSteam", "feedSteam", "audioStream", " inputStreamer", "sourceSource", "inputstream", "audiostream", "feedStream", "sourceStream", "Inputstream", "audioStreamer", "inputSource", " inputstream", "feedSource"], "source": ["series", "ser", "response", "sample", "console", "sp", "service", "resource", "reader", "sequence", "stream", "status", "context", "in", "inner", "store", "sl", "scope", "result", "src", "xml", "Source", "str", "sf", "SOURCE", "input", "sql", "ource", "iterator", "channel", "file", "class", "body", "wrapper", "from", "data", "session"]}}
{"id1": "3558512", "id2": "812803", "code1": "    public void serialize(OutputStream out) throws IOException, BadIMSCPException {\n        ensureParsed();\n        ZipFilePackageParser parser = utils.getIMSCPParserFactory().createParser();\n        parser.setContentPackage(cp);\n        if (on_disk != null) on_disk.delete();\n        on_disk = createTemporaryFile();\n        parser.serialize(on_disk);\n        InputStream in = new FileInputStream(on_disk);\n        IOUtils.copy(in, out);\n    }\n", "code2": "    public void convert(File src, File dest) throws IOException {\n        InputStream in = new BufferedInputStream(new FileInputStream(src));\n        DcmParser p = pfact.newDcmParser(in);\n        Dataset ds = fact.newDataset();\n        p.setDcmHandler(ds.getDcmHandler());\n        try {\n            FileFormat format = p.detectFileFormat();\n            if (format != FileFormat.ACRNEMA_STREAM) {\n                System.out.println(\"\\n\" + src + \": not an ACRNEMA stream!\");\n                return;\n            }\n            p.parseDcmFile(format, Tags.PixelData);\n            if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) {\n                System.out.println(\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n                return;\n            }\n            boolean hasPixelData = p.getReadTag() == Tags.PixelData;\n            boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12;\n            int pxlen = p.getReadLength();\n            if (hasPixelData) {\n                if (inflate) {\n                    ds.putUS(Tags.BitsAllocated, 16);\n                    pxlen = pxlen * 4 / 3;\n                }\n                if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) {\n                    System.out.println(\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                    return;\n                }\n            }\n            ds.putUI(Tags.StudyInstanceUID, uid(studyUID));\n            ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID));\n            ds.putUI(Tags.SOPInstanceUID, uid(instUID));\n            ds.putUI(Tags.SOPClassUID, classUID);\n            if (!ds.contains(Tags.NumberOfSamples)) {\n                ds.putUS(Tags.NumberOfSamples, 1);\n            }\n            if (!ds.contains(Tags.PhotometricInterpretation)) {\n                ds.putCS(Tags.PhotometricInterpretation, \"MONOCHROME2\");\n            }\n            if (fmi) {\n                ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian));\n            }\n            OutputStream out = new BufferedOutputStream(new FileOutputStream(dest));\n            try {\n            } finally {\n                ds.writeFile(out, encodeParam());\n                if (hasPixelData) {\n                    if (!skipGroupLen) {\n                        out.write(PXDATA_GROUPLEN);\n                        int grlen = pxlen + 8;\n                        out.write((byte) grlen);\n                        out.write((byte) (grlen >> 8));\n                        out.write((byte) (grlen >> 16));\n                        out.write((byte) (grlen >> 24));\n                    }\n                    out.write(PXDATA_TAG);\n                    out.write((byte) pxlen);\n                    out.write((byte) (pxlen >> 8));\n                    out.write((byte) (pxlen >> 16));\n                    out.write((byte) (pxlen >> 24));\n                }\n                if (inflate) {\n                    int b2, b3;\n                    for (; pxlen > 0; pxlen -= 3) {\n                        out.write(in.read());\n                        b2 = in.read();\n                        b3 = in.read();\n                        out.write(b2 & 0x0f);\n                        out.write(b2 >> 4 | ((b3 & 0x0f) << 4));\n                        out.write(b3 >> 4);\n                    }\n                } else {\n                    for (; pxlen > 0; --pxlen) {\n                        out.write(in.read());\n                    }\n                }\n                out.close();\n            }\n            System.out.print('.');\n        } finally {\n            in.close();\n        }\n    }\n", "label": 1, "substitutes": {"serialize": ["erialate", " serialized", "serialization", "finalized", "Serialize", "finalize", "Serialization", "finalization", "initialze", "serializer", "serialate", " serialate", " serializer", "initialization", "finalze", "Serialze", "initialize", "Serialized", "initialized", "serialze", "Serialate", "erializer", "erialize", "serialized", "erialized", "Serializer"], "out": ["f", "report", "output", "res", "d", "sum", "stream", "t", "c", "log", "err", "b", "to", "result", "up", "v", "i", "serv", "os", " OUT", "OU", "ch", "it", "sw", "ou", "outs", "aos", "o", "n", "io", "Out", "file", "pool", "OUT", "p", "a", "w"], "parser": ["style", "worker", "tp", "bank", "layer", "util", "policy", "part", "rer", "builder", "reader", "tar", "processor", "base", "inner", "command", "pkg", "asser", "ker", "xml", "format", "ler", "now", "writer", "arser", "token", "jack", "aser", "proc", "walker", "per", "parse", "tree", "handler", "lp", "language", "instance", "magic", "ger", "manager", "er", "job", "file", "password", "Parser", "plan", "p", "loader", "peer"], "on_disk": ["On2link", "on2link", " on_volume", "on_disc", "On_Disk", "On_cloud", "on2file", "on_dis", " on_file", " on_Disk", " on_download", " on_dis", "On_disk", "On2file", "on2Disk", "on_Disk", "On2disk", "On_file", " on_disc", "On2Disk", "on_download", "on_link", "on2disk", "on_cloud", "on_file", "On_link", "on_volume"], "in": ["mi", "en", "rin", "inn", "and", "gin", "min", "IN", "vin", "ins", "on", "In", "inner", "inside", "i", "bin", "inc", "input", "sin", "it", " IN", " din", "ain", "ind", "r", "ad", "io", "din", "inf", "is", "isin", "body", "cin", "id", "from"]}}
{"id1": "3309233", "id2": "23215235", "code1": "        @Override\n        protected String doInBackground(String... params) {\n            try {\n                final HttpParams param = new BasicHttpParams();\n                HttpConnectionParams.setConnectionTimeout(param, 30000);\n                HttpConnectionParams.setSoTimeout(param, 30000);\n                DefaultHttpClient client = new DefaultHttpClient(param);\n                HttpPost post = new HttpPost(\"http://www.google.com/loc/json\");\n                post.setEntity(new StringEntity(params[0]));\n                if (DEBUG) Log.d(\"Location\", params[0]);\n                HttpResponse resp = client.execute(post);\n                if (resp.getStatusLine().getStatusCode() == 200) {\n                    HttpEntity entity = resp.getEntity();\n                    String result = EntityUtils.toString(entity);\n                    return result;\n                } else {\n                    if (isFirstLocation) {\n                        requestGearsLocation(1);\n                        isFirstLocation = false;\n                        return RESULT_FIRST_FAILE;\n                    }\n                }\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n            return null;\n        }\n", "code2": "    public void readFile(URL url) throws PedroException, IOException, ParserConfigurationException, SAXException {\n        this.zipFileName = url.toString();\n        URLConnection urlConnection = url.openConnection();\n        InputStream inputStream = urlConnection.getInputStream();\n        unzipNativeFormatFile(inputStream);\n        parseAlertFiles();\n        deleteAlertFiles();\n    }\n", "label": 0, "substitutes": {"doInBackground": [" doAsHttp", " doInMemory", "doAsBackground", " doAsMemory", " doIfBackground", "doAsAsync", "doInAsync", " doAsAsync", " doIfAsync", " doIfMemory", "doAsHttp", "doInMemory", " doIntHttp", "doInHttp", " doAsBackground", " doIntBackground", " doIntMemory", " doInAsync", " doIfHttp", " doInHttp", " doIntAsync", "doAsMemory"], "params": ["terms", "times", "amps", "xs", "tags", "services", "photos", "json", "settings", "ms", "options", "reports", "parts", "items", "js", "keys", "details", "types", "lines", "ls", "months", "names", "models", "stats", "pins", "ps", "shape", "words", "steps", "styles", "ams", "properties", "aws", "pps", "ids", "points", "images", "resources", "sql", "actions", "members", "ims", "fixes", "vs", "values", "posts", "p", "units", "data", "results"], "param": ["meter", "dem", "admin", "sm", "ctx", "par", "min", "pai", "sp", "resource", "m", "option", "set", "mem", "rank", "perm", "rem", "conf", "property", "amp", "cp", "ams", "minute", "dm", "cm", "pri", "initial", "input", "prom", "proc", "am", "Param", "aram", "parse", "cal", "project", "form", "conn", "space", "ram", "ad", "num", "member", "mm", "jp", "iam", "pm", "config", "arg", "pool", "vm", "Parameter", "sem", "sam", "p", "power"], "client": ["co", "response", "google", "con", "console", "cn", "city", "service", "resource", "Client", "grid", "context", "app", "connection", "c", "net", "secure", "cli", "call", "system", "cell", "close", "cp", "cache", "phone", "cm", "api", "ch", "cmd", "conn", "tc", "ip", "channel", "local", "http", "remote", "io", "wrapper", "server", "cl"], "post": ["process", "ost", "and", "tx", "put", "next", "request", "op", "pp", "pod", "create", "set", " POST", "col", "mod", "feed", "link", "rest", "build", "write", "req", "read", "def", "head", "get", "after", "upload", " Post", "dd", "parse", "form", "pre", "Post", "POST", "add", "zip", "follow", "row", "http", "wp", "save", "submit", "send", "install", "patch", "body", "ld", "p", "end", "pass"], "resp": ["exp", "respons", "response", "cmp", "dl", "res", "rep", "responsive", "sp", "comm", "cb", "obj", "wait", "https", "bs", "Response", "status", "col", "conv", "ess", "rest", "err", "soc", "bb", "rem", "re", "rel", "req", "serv", "pos", "esp", "out", "respond", "comp", "proc", "cmd", "conn", "Resp", "inv", "rex", "desc", "jp", "http", "html", "repl", "body", "rec", "cl"], "entity": ["event", "active", "response", "json", "output", "entry", "email", "ee", "resource", "obj", "details", "se", "enc", "cy", "ce", "me", "document", "xml", "content", "e", "detail", "eme", "owner", "le", "person", "ent", "note", "my", "object", "encrypted", "security", "group", "line", "el", "activity", "member", "info", "Entity", "ity", "orm", "body", "existent", "unit", "data", "pe"], "result": ["csv", "report", "response", "product", "output", "res", "match", "test", "feature", "comment", "request", "description", "summary", "sequence", "currency", "status", "table", "profile", "date", "message", "current", "join", "detail", "success", "total", "successful", "complete", "valid", "true", "answer", "continue", "group", "relation", "ret", "root", "results", "Result"]}}
{"id1": "17158020", "id2": "4921631", "code1": "    public synchronized String encryptPassword(String passwordString) throws Exception {\n        MessageDigest digest = null;\n        digest = MessageDigest.getInstance(\"SHA\");\n        digest.update(passwordString.getBytes(\"UTF-8\"));\n        byte raw[] = digest.digest();\n        String hash = (new BASE64Encoder()).encode(raw);\n        return hash;\n    }\n", "code2": "    public int create(BusinessObject o) throws DAOException {\n        int insert = 0;\n        int id = 0;\n        Item item = (Item) o;\n        try {\n            PreparedStatement pst = connection.prepareStatement(XMLGetQuery.getQuery(\"INSERT_ITEM\"));\n            pst.setString(1, item.getDescription());\n            pst.setDouble(2, item.getUnit_price());\n            pst.setInt(3, item.getQuantity());\n            pst.setDouble(4, item.getVat());\n            pst.setInt(5, item.getIdProject());\n            pst.setInt(6, item.getIdCurrency());\n            insert = pst.executeUpdate();\n            if (insert <= 0) {\n                connection.rollback();\n                throw new DAOException(\"Number of rows <= 0\");\n            } else if (insert > 1) {\n                connection.rollback();\n                throw new DAOException(\"Number of rows > 1\");\n            }\n            Statement st = connection.createStatement();\n            ResultSet rs = st.executeQuery(\"select max(id_item) from item\");\n            rs.next();\n            id = rs.getInt(1);\n            connection.commit();\n        } catch (SQLException e) {\n            Log.write(e.getMessage());\n            throw new DAOException(\"A SQLException has occured\");\n        } catch (NullPointerException npe) {\n            Log.write(npe.getMessage());\n            throw new DAOException(\"Connection null\");\n        }\n        return id;\n    }\n", "label": 0, "substitutes": {"encryptPassword": [" encryptedPass", "enccryptPass", "encryptedRequest", "encryptpassword", "encryptedpassword", "enccryptPassword", "encipherPassword", "encryptRequest", "encryptedPassword", " encryptpassword", "encipherRequest", "encryptedPass", "enccryptRequest", " encryptRequest", "encipherpassword", " encryptedPassword", " encryptedpassword", " encryptedRequest", " encryptPass", "encryptPass", "enccryptpassword", "encipherPass"], "passwordString": ["PasswordStr", "passPassword", "passwordstring", "databaseStr", "passwordUTF", "passString", "passText", "PasswordPassword", "databasePassword", "phraseText", "passwordText", " passwordstring", "passUTF", "databasestring", " passwordText", "databaseString", "phrasePassword", "phraseUTF", " passwordUTF", "passwordPassword", " passwordStr", " passwordPassword", "phraseString", "PasswordString", "passwordStr", "Passwordstring"], "digest": ["dested", "dester", "redist", "mingest", "dgest", "redester", " digse", "digist", "decest", "diggest", "dest", "hashester", "Digate", "digate", "minse", "decate", "digse", "diffested", "Digester", "minested", "diffest", "diffgest", "Digse", "digEST", "Diggest", "decEST", " digist", "hashse", "Digist", "diffester", "redest", "hashested", " digester", "Digested", "hashest", "decested", "minest", " digate", "dse", " digEST", "digested", "redEST", "digester", "DigEST", " digested", "Digest"], "raw": ["all", "buf", "json", "random", "known", "serial", "custom", "clean", "box", "mem", "buffer", "message", "result", "available", "unsigned", "sh", "input", "out", "valid", "des", "was", "hex", " Raw", "aw", "hook", "RAW", " RAW", "bar", "full", "local", "row", "core", "n", "Raw", "password", "bytes", "bare", "w"], "hash": ["ashes", "ashed", "handle", "mask", "json", "tr", "ash", "Hash", "serial", "h", "bh", "sum", "tag", "sha", "shadow", "ASH", "cert", "message", "sh", "name", "hed", "hidden", "token", "has", "total", "sign", "hex", "search", "height", "proof", "href", "key", "html", "mac", "ssh", "password", "check", "id", "user", "print"]}}
{"id1": "8468859", "id2": "9718328", "code1": "    public boolean connect() {\n        boolean isConnected = false;\n        try {\n            try {\n                this.ftpClient.connect(this.server, this.port);\n            } catch (SocketException e) {\n                status = ErrorResult.CONNECTNOTPOSSIBLE.code;\n                return false;\n            } catch (IOException e) {\n                status = ErrorResult.CONNECTNOTPOSSIBLE.code;\n                return false;\n            }\n            int reply = this.ftpClient.getReplyCode();\n            if (!FTPReply.isPositiveCompletion(reply)) {\n                this.disconnect();\n                status = ErrorResult.CONNECTNOTCORRECT.code;\n                return false;\n            }\n            try {\n                if (this.account == null) {\n                    if (!this.ftpClient.login(this.username, this.passwd)) {\n                        status = ErrorResult.LOGINNOTCORRECT.code;\n                        this.ftpClient.logout();\n                        return false;\n                    }\n                } else if (!this.ftpClient.login(this.username, this.passwd, this.account)) {\n                    status = ErrorResult.LOGINACCTNOTCORRECT.code;\n                    this.ftpClient.logout();\n                    return false;\n                }\n            } catch (IOException e) {\n                status = ErrorResult.ERRORWHILECONNECT.code;\n                try {\n                    this.ftpClient.logout();\n                } catch (IOException e1) {\n                }\n                return false;\n            }\n            isConnected = true;\n            return true;\n        } finally {\n            if ((!isConnected) && this.ftpClient.isConnected()) {\n                this.disconnect();\n            }\n        }\n    }\n", "code2": "    public void actionPerformed(ActionEvent e) {\n        if (\"register\".equals(e.getActionCommand())) {\n            buttonClicked = \"register\";\n            try {\n                String data = URLEncoder.encode(\"ver\", \"UTF-8\") + \"=\" + URLEncoder.encode(Double.toString(questVer), \"UTF-8\");\n                data += \"&\" + URLEncoder.encode(\"name\", \"UTF-8\") + \"=\" + URLEncoder.encode(name.getText(), \"UTF-8\");\n                data += \"&\" + URLEncoder.encode(\"os\", \"UTF-8\") + \"=\" + URLEncoder.encode(os.getText(), \"UTF-8\");\n                data += \"&\" + URLEncoder.encode(\"jre\", \"UTF-8\") + \"=\" + URLEncoder.encode(jre.getText(), \"UTF-8\");\n                data += \"&\" + URLEncoder.encode(\"email\", \"UTF-8\") + \"=\" + URLEncoder.encode(email.getText(), \"UTF-8\");\n                data += \"&\" + URLEncoder.encode(\"key\", \"UTF-8\") + \"=\" + URLEncoder.encode(\"Qr7SchF\", \"UTF-8\");\n                data += \"&\" + URLEncoder.encode(\"answers\", \"UTF-8\") + \"=\" + URLEncoder.encode(Integer.toString(getAnswers()), \"UTF-8\");\n                URL url = new URL(\"http://ubcdcreator.sourceforge.net/register.php\");\n                URLConnection conn = url.openConnection();\n                conn.setDoInput(true);\n                conn.setDoOutput(true);\n                OutputStreamWriter wr = new OutputStreamWriter(conn.getOutputStream());\n                wr.write(data);\n                wr.flush();\n                BufferedReader rd = new BufferedReader(new InputStreamReader(conn.getInputStream()));\n                String line;\n                while ((line = rd.readLine()) != null) {\n                }\n                rd.close();\n                wr.close();\n            } catch (Exception ex) {\n            }\n            setVisible(false);\n        } else if (\"cancel\".equals(e.getActionCommand())) {\n            buttonClicked = \"cancel\";\n            setVisible(false);\n        } else if (\"never\".equals(e.getActionCommand())) {\n            buttonClicked = \"never\";\n            setVisible(false);\n        }\n    }\n", "label": 0, "substitutes": {"connect": [" disconnect", "Connect", "process", "dial", "connected", "match", "sync", "con", "select", "request", "client", "create", "set", "establish", "init", "connection", "link", "log", "open", "ping", "join", "close", "error", "bind", "login", "pen", "exit", "construct", "conn", "network", "register", "ready", "config", "start", "timeout", "check", "attach", "setup"], "status": ["style", "access", "json", "settings", "flags", "sync", "output", "policy", "console", "params", "severe", "comment", "service", "score", "description", "uses", "details", "summary", "sequence", "comments", "code", "spec", "print", "stats", "ping", "result", "join", "list", "xml", "content", "format", "gc", "url", "str", "sign", "login", "impact", "stat", "sc", "search", "use", "ssl", "usage", "scale", "source", "version", "check", "sort", "update", "prefix", "display", "title"], "reply": ["back", "response", "address", "notice", "match", "next", "py", "time", "part", "comment", "frame", "feature", "code", "ply", "command", "consider", "write", "link", "message", "result", "close", " Reply", "number", "nb", "state", "error", "success", "vote", "query", "answer", "continue", "flag", "record", "ret", "Reply", "job", "repl", "user", "prefix"], "isConnected": ["isConnectable", "isConns", " isConnecting", "IsNECTing", "isCorrects", "isAdapts", " isLoadeds", "isConnectionedIn", "isConnectioned", "isNECTedIn", "IsNECTedIn", "IsConnectioned", "isLinks", " isLoaded", "isAdapting", "isLinkED", "issConnectioneded", " isConnects", "isStarteded", "isStarting", "isConnectioneded", "isLoading", "isConnecteds", "isConned", "isConnED", "isConnectedIn", "IsConnectED", "isProcessed", "issConnecteded", "IsConnectionED", " isLoads", "isLoadeds", "isConnured", "isConnects", "isPresenteded", "isStarted", "isProcessing", "IsNECTable", "IsNECTed", "isLoads", "issConnected", "isNECTing", " isConnecteds", " isLoading", "isCorrected", "issConnectioned", "isLoaded", "isPresentedIn", "issConnectedIn", "isProcessedIn", "isAdapteds", "IsConnectable", "IsConnectionured", "isConnectED", "isConnections", "issConnectioning", "isConnecting", "IsConnectedIn", "IsConnecting", "isLinked", "isAdapted", "issConnecting", "isPresenting", "IsConnections", "isConnectionED", "isStartable", "isConnecteded", "isNECTable", "IsConnected", "isPresented", "issConnectionedIn", "isConnectioning", "isConnectured", "isCorrecteds", "isProcessable", "IsConnectured", "isNECTed", "isStartedIn", "isConnectionured", "IsConnects", "isLinkured", "isCorrecting"]}}
{"id1": "13122204", "id2": "8788371", "code1": "    public static void unzipModel(String filename, String tempdir) throws EDITSException {\n        try {\n            BufferedOutputStream dest = null;\n            FileInputStream fis = new FileInputStream(filename);\n            int BUFFER = 2048;\n            ZipInputStream zis = new ZipInputStream(new BufferedInputStream(fis));\n            ZipEntry entry;\n            while ((entry = zis.getNextEntry()) != null) {\n                int count;\n                byte data[] = new byte[BUFFER];\n                FileOutputStream fos = new FileOutputStream(tempdir + entry.getName());\n                dest = new BufferedOutputStream(fos, BUFFER);\n                while ((count = zis.read(data, 0, BUFFER)) != -1) dest.write(data, 0, count);\n                dest.flush();\n                dest.close();\n            }\n            zis.close();\n        } catch (Exception e) {\n            throw new EDITSException(\"Can not expand model in \\\"\" + tempdir + \"\\\" because:\\n\" + e.getMessage());\n        }\n    }\n", "code2": "    private void tail(String[] cmd, int pos) throws IOException {\n        CommandFormat c = new CommandFormat(\"tail\", 1, 1, \"f\");\n        String src = null;\n        Path path = null;\n        try {\n            List<String> parameters = c.parse(cmd, pos);\n            src = parameters.get(0);\n        } catch (IllegalArgumentException iae) {\n            System.err.println(\"Usage: java FsShell \" + TAIL_USAGE);\n            throw iae;\n        }\n        boolean foption = c.getOpt(\"f\") ? true : false;\n        path = new Path(src);\n        FileSystem srcFs = path.getFileSystem(getConf());\n        if (srcFs.isDirectory(path)) {\n            throw new IOException(\"Source must be a file.\");\n        }\n        long fileSize = srcFs.getFileStatus(path).getLen();\n        long offset = (fileSize > 1024) ? fileSize - 1024 : 0;\n        while (true) {\n            FSDataInputStream in = srcFs.open(path);\n            in.seek(offset);\n            IOUtils.copyBytes(in, System.out, 1024, false);\n            offset = in.getPos();\n            in.close();\n            if (!foption) {\n                break;\n            }\n            fileSize = srcFs.getFileStatus(path).getLen();\n            offset = (fileSize > offset) ? offset : fileSize;\n            try {\n                Thread.sleep(5000);\n            } catch (InterruptedException e) {\n                break;\n            }\n        }\n    }\n", "label": 1, "substitutes": {"unzipModel": ["unzipModule", "unlateModule", "Unzipmodel", "UnarchiveModule", "uncodeModel", "unlatemodel", "unarchivemodel", "UnzipModule", "uncodeModule", "UnzipModel", "uncodemodel", "UnarchiveModel", "unarchiveModel", "uncodeImage", "unlateImage", "unlateModel", "unarchiveModule", "unarchiveImage", "UnarchiveImage", "unzipmodel", "unzipImage", "Unarchivemodel", "UnzipImage"], "filename": ["origin", "nil", "txt", "nm", "subject", "output", "original", "FILE", "ln", "fil", "fp", "river", "wl", "directory", "SourceFile", "dra", "jpg", "println", "journal", "ename", "name", "til", "FN", "kl", "sql", "nl", "stem", "Filename", "path", "ivo", "n", "download", "location", "mson", "fn", "file", "source", "FIL", "username", "fle", "title"], "tempdir": ["tempDir", "testpath", " tempDir", " tempdirectory", "tempDIR", "testfolder", "tmpfile", "tempfolder", "tempdirectory", "Tempdir", "tmpDir", "Tempfile", "temdir", " tempfile", "tmppath", "tempath", "tmpfolder", "tmpdirectory", "temDir", "tempfile", "temDIR", "testdir", "testDir", "Tempdirectory", "TempDir", "tmpDIR", "tmpdir", "temfolder", "temdirectory", "temppath", " tempDIR"], "dest": ["origin", "decl", "coord", "nt", "tr", "comb", "usr", "default", "output", "test", "deep", "cont", "slave", "obj", "trans", "sum", "tmp", "stream", "table", "est", "pipe", "port", "generated", "rest", "del", "buffer", "dc", "write", "ctr", "document", "master", "result", "src", "ptr", "bin", "writer", "target", "foreign", "tail", "out", "pos", "des", "parent", "st", "null", "dat", "nom", "inv", "desc", "Dest", "dist", "temp", "display", "send", "source", "loc", "store", "dev", "peer"], "fis": ["flis", "fi", "ljs", "flos", "fljs", "ifatis", "los", "zatis", "ifos", "ifis", "fli", "fatis", "li", "zjs", "flatis", "lis", "fjs", "ifi", "zi", "zos"], "BUFFER": ["BLBER", "BLFFER", "BBER", "MAXBuffer", " BUMT", "BufferMT", "BLBuffer", " BUBuffer", "BFFER", "FFERMT", "CUBuffer", "CUBER", "FFERBuffer", "BUMT", " BUULT", "CUFR", "MAXBER", "LOCKFFER", "FFERBER", "BAULT", "BLOUNT", "BUFR", "MAXFFER", "CUFFER", "BAOUNT", "MAXOUNT", "BUBER", " BUFR", "FFERFFER", "LOCKBER", "BAFFER", "BULT", "BOUNT", "BUBuffer", "BufferBuffer", "LOCKFR", "BufferBER", " BUBER", "BABER", "BUOUNT", "BUULT", "LOCKBuffer", "BufferFFER", " BUOUNT"], "zis": ["zoneris", "zees", "Zi", "xis", "fi", " zIS", "Zos", "zoneits", "zIS", "ziis", "Ziss", " zi", "zits", "ozis", "ozip", "zoneis", "ziIS", "zies", "zoneiss", " zris", "zeris", " zits", "xos", "zes", "xiss", "zeos", " zos", "zeits", "fiss", "zeis", " zip", "xi", "Zis", "zeIS", " ziss", " zes", "zip", "fip", "oziss", "ozi", "zris", "zi", "zos", "zeiss", "ziss", "zios"], "entry": ["ze", "nt", "image", "element", "item", "match", "ie", "piece", "part", "comment", "way", "se", "word", "inter", "table", "ce", "connection", "chain", "link", "char", "log", "zo", "je", "cell", "result", "system", "jar", "e", "def", "jo", "name", "or", "ent", "ry", "enter", "record", "zip", "member", "Entry", "key", "row", "file", "source", "existent", "index", "card", "pe", "header", "escape"], "count": ["f", "all", "cloud", "nt", "z", "match", "OUNT", "cont", "comment", "part", "force", "sum", "page", "base", "ce", "code", "c", "buffer", "ctr", "current", "call", "max", "cell", "number", "read", "cache", "counter", "nb", "child", "ct", "ount", "total", "cond", "common", "len", "length", "amount", "found", "Count", "batch", "num", "add", "n", "core", "start", "size", "check", "index", "acc", "cc"], "data": ["all", "window", "image", "step", "text", "DATA", "dec", "value", "dl", "output", "sample", "next", "d", "part", "area", "ata", "ATA", "raw", "table", "accept", "done", "buffer", "message", "result", "rel", "content", "format", "cache", "mat", "str", " DATA", "out", "valid", "dat", "batch", "n", "size", "zero", "p", "bytes", "results"], "fos": ["Foss", "foes", "foss", "voses", "vos", "foses", "Foes", "los", "loss", " foses", " foes", "Fios", "fOS", "Fos", "voss", "voes", "lOS", "Foses", " fios", "fios", " fOS", "lios", " foss", "FOS"]}}
{"id1": "2525897", "id2": "15166511", "code1": "    public static byte[] decode(String cryptPassword, byte[] encoded, byte[] salt) {\n        try {\n            MessageDigest digester = MessageDigest.getInstance(DIGEST);\n            SecureRandom random = SecureRandom.getInstance(RANDOM);\n            digester.reset();\n            for (int i = 0; i < ITERATIONS; i++) {\n                digester.update(salt);\n                digester.update(cryptPassword.getBytes(\"UTF-8\"));\n            }\n            byte[] hash = digester.digest();\n            random.setSeed(hash);\n            int maxKeySize = Cipher.getMaxAllowedKeyLength(CIPHER);\n            KeyGenerator generator = KeyGenerator.getInstance(CIPHER);\n            generator.init(maxKeySize, random);\n            SecretKey key = generator.generateKey();\n            Cipher cipher = Cipher.getInstance(CIPHER);\n            cipher.init(Cipher.DECRYPT_MODE, key);\n            byte[] decoded = cipher.doFinal(encoded);\n            return decoded;\n        } catch (Exception e) {\n            StorePlugin.getDefault().log(e);\n        }\n        return new byte[0];\n    }\n", "code2": "    private void getRandomGUID(boolean secure) {\n        MessageDigest md5 = null;\n        StringBuffer sbValueBeforeMD5 = new StringBuffer();\n        try {\n            md5 = MessageDigest.getInstance(\"MD5\");\n        } catch (NoSuchAlgorithmException e) {\n            System.out.println(\"Error: \" + e);\n        }\n        try {\n            long time = System.currentTimeMillis();\n            long rand = 0;\n            if (secure) {\n                rand = mySecureRand.nextLong();\n            } else {\n                rand = myRand.nextLong();\n            }\n            sbValueBeforeMD5.append(s_id);\n            sbValueBeforeMD5.append(\":\");\n            sbValueBeforeMD5.append(Long.toString(time));\n            sbValueBeforeMD5.append(\":\");\n            sbValueBeforeMD5.append(Long.toString(rand));\n            valueBeforeMD5 = sbValueBeforeMD5.toString();\n            md5.update(valueBeforeMD5.getBytes());\n            byte[] array = md5.digest();\n            StringBuffer sb = new StringBuffer();\n            for (int j = 0; j < array.length; ++j) {\n                int b = array[j] & 0xFF;\n                if (b < 0x10) sb.append('0');\n                sb.append(Integer.toHexString(b));\n            }\n            valueAfterMD5 = sb.toString();\n        } catch (Exception e) {\n            System.out.println(\"Error:\" + e);\n        }\n    }\n", "label": 1, "substitutes": {"decode": ["encrypt", "derypt", "deode", "Decoded", "deoded", "Deccode", "enccode", "Decode", "Decrypt", "encode", "deccode", "decrypt"], "cryptPassword": [" cryptLost", "cmdString", "Cryptpassword", "ryptLost", "cryptPass", "ryptPassword", "cryptString", "cryptLost", "CryptPass", "cmdpassword", "cmdPassword", "ryptString", "ryptPass", " cryptpassword", "CryptLost", "ryptpassword", " cryptString", "cryptpassword", " cryptPass", "CryptPassword", "cmdPass"], "encoded": ["ecoded", "sentcoded", "decashed", "encached", "enccoded", "ecoder", "decrypted", "enashed", "ecached", "ecrypted", "decoder", "sentoder", "decached", "ecashed", "encashed", "sentrypted", "sentoded", "encrypted", "enoded", "enached", "encoder", "deccoded", "enrypted", "eccoded"], "salt": ["esalt", "esalted", "slift", "Salt", "slALT", "salted", " seed", "eseed", "esALT", "sift", "Sift", "Seed", "slig", "SALT", "sig", " sig", "Salted", "seed", " sALT", "sALT", " sift", " salted", "slalt", "Sig"], "digester": ["dested", "digencer", "signifier", "diger", " digencer", " digest", " Diger", "requester", "dest", "der", "request", "pinger", "Diger", "Digifier", "digpenter", "signested", " Digest", "diffested", "Digester", "pingester", "Digpenter", "digest", "requifier", " digpenter", "diffest", "digifier", " Digester", "requer", "diffester", "signester", " digifier", "Digested", "pingpenter", "digested", " diger", " Digencer", "Digencer", "dester", "signest", "pingest", " digested", "Digest", "diffifier"], "random": ["unique", "creator", "free", "rand", "serial", "internal", "draw", "release", "runtime", "resource", "reader", "andom", "directory", "secure", "system", "testing", "re", "number", "node", "right", "state", "trust", "rot", "query", "gener", "seed", "normal", "network", "database", "auto", "manager", "remote", "volume", "relative", "smart", "password", "memory", "root", "user", "store", "server", "radius"], "i": ["u", "j", "ms", "us", "y", "ini", "I", "mill", "ie", "qi", "di", "im", "m", "client", "init", "x", "in", "ti", "me", "chain", "q", "cli", "ic", "ci", "multi", "ai", "sim", "gi", "ui", "pi", "ix", "uu", "this", "li", "si", "mult", "batch", "ind", "ip", "io", "er", "gu", "is", "start", "ii", "id", "print", "phi", "ex"], "hash": ["handle", "unique", "response", "tr", "ash", "Hash", "shift", "test", "rand", "h", "score", "sum", "sha", "shadow", "build", "number", "node", "sh", "hed", "hidden", "token", "has", "total", "hex", "query", "search", "seed", "length", "filter", "num", "inv", "full", "html", "rh", "mac", "password", "version", "id", "print", "header"], "maxKeySize": ["axKeySize", "maxKeySIZE", "maxOrderLength", "maxLockName", " maxFileLength", "maxFileLength", "maxKeyLen", "maxFileLen", " maxFileCount", "maxValueCount", "maxLockSIZE", "maxLockLength", " maxKeyLen", "maxLockSize", "axOrderLength", "maxValueLen", "maxBlockSIZE", "axKeySIZE", "maxBlockLength", "maxKeyCount", "maxOrderSize", "maxOrderSIZE", "maxKeyLength", "maxBlockCount", "axKeyName", " maxFileLen", "maxBlockSize", "maxValueLength", "axOrderName", "maxBlockName", "maxKeyName", "maxBlockLen", "axKeyLength", "maxOrderName", "maxFileSize", "axOrderSIZE", "maxValueSize", "axOrderSize", "maxFileCount", " maxFileSize", " maxKeyCount", " maxKeyLength"], "generator": ["sequicator", "genating", "genator", "genATOR", " numerulator", " numerATOR", "GenerATOR", "locor", "GENATOR", "generating", "sequator", "generate", "Generor", "loculator", "generor", "sequATOR", "Generulator", " numeror", "GENator", "genate", "provate", "provATOR", "provicator", "locATOR", "provator", "generATOR", "sequating", "GENicator", "Genericator", "locator", "Generator", "generulator", "genicator", "GENating", " numerator", "Generate", "genericator"], "key": ["address", "image", "pair", "piece", "rand", "service", "keys", "secret", "sum", "Key", "char", "code", "k", "ca", "chain", "message", "result", "mode", "sk", "owner", "name", "token", "trust", "input", "ec", "ch", "object", "seed", "length", "null", "iv", "network", "instance", "ip", "ek", "padding", "core", "size", "password", "ssh", "root", "source", "mac", "p", "data", "KEY"], "cipher": [" coder", "cip", " ciper", "ciper", "cortex", "Coder", "caster", "curip", " caster", "uncip", "cuortex", "uncoder", "cuipher", "curipher", "cuaster", "encortex", "curoder", " cip", " cortex", "Cip", "enciph", "ciph", "coder", "uncipher", "Ciper", "encipher", "curiph", "cuoder", "curiper", "Cipher", "encoder", "encaster", "unciph", "encip"], "decoded": ["ecoded", "encached", "enccoded", "divached", "decrypted", "compcoded", "compressed", "ecressed", "ecached", "encode", "ecrypted", "decached", "eccoded", "decressed", "compoded", "divode", "divoded", "encrypted", "comprypted", "deccoded", "encressed", "ecode", "divcoded"]}}
{"id1": "1966310", "id2": "13159394", "code1": "    public void init() {\n        super.init();\n        Runnable doActions = new Runnable() {\n\n            public void run() {\n                if (_plot == null) {\n                    _plot = newPlot();\n                }\n                getContentPane().add(plot(), BorderLayout.NORTH);\n                int width;\n                int height;\n                String widthspec = getParameter(\"width\");\n                if (widthspec != null) {\n                    width = Integer.parseInt(widthspec);\n                } else {\n                    width = 400;\n                }\n                String heightspec = getParameter(\"height\");\n                if (heightspec != null) {\n                    height = Integer.parseInt(heightspec);\n                } else {\n                    height = 400;\n                }\n                _setPlotSize(width, height);\n                plot().setButtons(true);\n                Color background = Color.white;\n                String colorspec = getParameter(\"background\");\n                if (colorspec != null) {\n                    background = PlotBox.getColorByName(colorspec);\n                }\n                setBackground(background);\n                plot().setBackground(background);\n                getContentPane().setBackground(background);\n                Color foreground = Color.black;\n                colorspec = getParameter(\"foreground\");\n                if (colorspec != null) {\n                    foreground = PlotBox.getColorByName(colorspec);\n                }\n                setForeground(foreground);\n                plot().setForeground(foreground);\n                plot().setVisible(true);\n                String dataurlspec = getParameter(\"dataurl\");\n                if (dataurlspec != null) {\n                    try {\n                        showStatus(\"Reading data\");\n                        URL dataurl = new URL(getDocumentBase(), dataurlspec);\n                        InputStream in = dataurl.openStream();\n                        _read(in);\n                        showStatus(\"Done\");\n                    } catch (MalformedURLException e) {\n                        System.err.println(e.toString());\n                    } catch (FileNotFoundException e) {\n                        System.err.println(\"PlotApplet: file not found: \" + e);\n                    } catch (IOException e) {\n                        System.err.println(\"PlotApplet: error reading input file: \" + e);\n                    }\n                }\n            }\n        };\n        try {\n            SwingUtilities.invokeAndWait(doActions);\n        } catch (Exception ex) {\n        }\n    }\n", "code2": "    public HttpResponse fetch(HttpServletRequest request) throws IOException {\n        GUI = SwingUI.getApplicatoin();\n        DefaultHttpClient httpclient = new DefaultHttpClient();\n        CookieSpecFactory csf = new CookieSpecFactory() {\n\n            public CookieSpec newInstance(HttpParams params) {\n                return new BrowserCompatSpec() {\n\n                    @Override\n                    public void validate(Cookie cookie, CookieOrigin origin) throws MalformedCookieException {\n                    }\n                };\n            }\n        };\n        if (Helper.useProxy()) {\n            HttpHost proxy = new HttpHost(Helper.getProxyServer(), Helper.getProxyPort());\n            httpclient.getParams().setParameter(ConnRoutePNames.DEFAULT_PROXY, proxy);\n        }\n        httpclient.getCookieSpecs().register(\"easy\", csf);\n        httpclient.getParams().setParameter(ClientPNames.COOKIE_POLICY, \"easy\");\n        String currentRemoteGAEHost = Helper.getRemoteServer();\n        try {\n            HttpUriRequest httpRequest = createRequest(request);\n            addHeader(request, httpRequest);\n            HttpResponse response = httpclient.execute(httpRequest);\n            if (response.getStatusLine().getStatusCode() == HttpStatus.SC_FORBIDDEN) {\n                challengeProxy(currentRemoteGAEHost);\n            }\n            logger.info(Helper.count.incrementAndGet() + \" Response received from \" + request.getRequestURL().toString() + \", status is \" + response.getStatusLine());\n            GUI.updateFetchCount();\n            return response;\n        } catch (ClientProtocolException e) {\n            logger.error(\"Fetch ClientProtocol Error\", e);\n            throw e;\n        } catch (IOException e) {\n            logger.error(\"Fetch IO Error\", e);\n            throw e;\n        }\n    }\n", "label": 0, "substitutes": {"init": ["Init", "ini", "reset", "plot", " Init", "rand", "js", "create", "set", "fp", "clear", "launch", "ns", "base", "build", "load", "ic", "ui", "gc", "def", "bin", "get", "initial", "it", "construct", "initialized", "norm", "destroy", "inv", "late", "n", "config", "id", "start", "fin", "fn", "ize", "update", "setup", "kit", "render"], "doActions": [" doAnctions", "doAcs", " doCallactions", " doCallctions", " doCallaction", "doDections", "doAactions", "doDeactions", " doAnactions", " doAaction", "doDeaction", " doAcs", " doAncs", " doDeactions", " doDeaction", " doCallcs", " doDecs", " doAactions", " doAnaction", "doDecs", "doAaction", " doDections"], "_plot": ["_log", " _layout", " _log", "_layout", "_Plot", "_chart", " _config", "_config", "_hide"], "width": ["axy", "window", "all", "en", "wid", "layout", "min", "output", "column", "draw", "frame", "left", "area", "depth", "view", "w", "wy", "port", "x", "write", "current", "rel", "wd", "content", "dim", "format", "widget", "right", "now", "sw", "idth", "wn", "pen", "len", "history", "Width", "path", "length", "term", "change", "wt", "focus", "true", "lon", "weight", "full", "padding", "scale", "size", "body", "px", "display", "render"], "height": ["axy", "window", "ows", "hang", "style", "div", "layout", "json", "alpha", "y", "rows", "inches", "high", "h", "draw", "gravity", "depth", "capacity", "view", "stroke", "rank", "buffer", "shape", "Height", "max", "grow", "widget", "resolution", "hash", "total", "yt", "ty", "data", "history", "length", "density", "padding", "row", "volume", "html", "crop", "ht", "size", "where", "above", "host", "power", "display", "radius", "bottom"], "widthspec": ["lengthproc", "windowspec", "windowspecies", "lengthpec", "sizeSpec", "lengthSpec", "widthpec", "lengthspecies", "weightspec", "weightproc", "widthproc", " widthpec", "lengthspec", "widthspecies", " widthSpec", "windowproc", "weightspe", " widthspe", "sizespec", "windowspe", "sizespe", "widthspe", "heightspe", "heightSpec", "widthSpec", "lengthspe", "sizepec", "heightpec", "weightspecies"], "heightspec": ["heightsimp", "heighterial", "weowsimp", "heowserial", "hericserial", "hericsspec", "heatsspec", "heuespr", "heightserial", " heightspr", " heightsSpec", "weightspec", "heatsSpec", "heuesSpec", " heatspr", "weowsspe", "heilsspec", "weightsspec", "heowspec", "heilspec", "weowsspec", "heowspr", "weowserial", "heilsspe", "weightsimp", "heilspect", "heightimp", "heowsimp", "heightsspe", "heavespect", "weowspect", "heowspect", "heavesspe", " heatsspec", "heightsspec", "heowsspec", "weightserial", " heightsspec", "heatspr", " heatspec", "heowsspe", "heightsSpec", "hericspec", " heatsSpec", "weowspec", "heavespec", "weightsspe", "heowsSpec", "heatspec", "heavesspec", "heightspr", "hericsimp", "heightpec", "heightspect", "weightspect", "heuesspec", "heuespec"], "background": ["back", "style", "cloud", "layout", "today", "radius", "ghost", "alpha", "mask", "ref", "default", "bg", "internal", "callback", "draw", "comment", "storage", "bo", "area", "gradient", "clear", "library", "base", "shadow", "buffer", "system", "close", "font", "color", "gc", "black", "hidden", "pull", "history", "material", "binary", "ground", "focus", "Background", "collection", "foundation", "database", "pattern", "padding", "blank", "sound", "password", "memory", "shell", "body", "wrapper", "support", "border", "display", "escape", "bottom"], "colorspec": ["colorsetpe", "condorsetSpec", "colodeselect", "condorsSpec", "coloresSpec", "colororsetig", "colorsec", "condorsetec", "colorsetcmp", "coloresspec", "colororspec", "colorsetpect", "colororsetspec", "colodespec", "colnersspe", "colorasSpec", "colororsetpe", "collectionspe", "collectionspec", "colorsetspe", "condorsec", "colorselect", "colororspect", "colorsetpec", "coletersspec", "colororespec", "colororesspec", "colnerspe", "colarspect", "colorespec", "collectionsspe", "colorasspec", "colornsspec", "colornsproc", "colororsetelect", "colororsSpec", "colororesSpec", "colorspect", "collectionsync", "condorsetpec", "colorsproc", "colorsetspec", "colorsspec", "colorsetproc", "colororsproc", "condorsetspec", "colororsetync", "colornspec", "coloraspec", "colorsig", "colorsetync", "colororscmp", "colororsetpec", "colorsetSpec", "colororsetpect", "coloresproc", "colodesspec", "colorspe", "colodesspe", "colodesync", "colororspe", "colodesig", "colororsspec", "colororsig", "colororsspe", "colorsspe", "colorscmp", "coloresec", "colororsetspe", "colororsetcmp", "colororselect", "coleterspect", "coletersig", "colorsetig", "colororesproc", "colarspec", "colarscmp", "condorspec", "colorasec", "colornsSpec", "colorsync", "collectionsspec", "colarsspec", "coleterselect", "coleterscmp", "colororsync", "colorsSpec", "colorsetelect", "coleterspec", "colnerspec", "colorsetec", "colnersspec", "condorsspec"], "foreground": [" foremond", "forecolor", "foremond", "ForeGROUND", "Foremain", "forground", "Foregrounds", "frontbackground", "verground", "Foregb", "Foreground", " forebackground", "foreGROUND", " foremain", " foregrounds", " forecolor", "FOREground", "forbase", "FOREbackground", "foregb", "forebackground", "frontground", "Forecolor", " Forecolor", "vermond", " Foreground", "foremain", " Foremain", "foregrounds", "frontGROUND", "FOREmond", " Forebackground", "Forebase", "FOREGROUND", "forgrounds", " forebase", "Foremond", "frontmond", "forbackground", "forebase", "vergb", "Forebackground", " foregb", "verbackground"], "dataurlspec": ["datauriSpec", "datastringSpec", "datafilenamepec", "datafilenameSPEC", "datalSPEC", " datafilenameSpec", "DATAurlSpec", "dataUrlspe", "datastrspe", "dataurispe", "datafilenameSpec", "datastrSPEC", "datastrspec", "DATAfilenameSpec", "DATAurlSPEC", "dataUrlpec", "DataurlSpec", "datauriSPEC", "dataUrlspec", "dataurlSPEC", "dataurlspe", "DATAfilenamespe", "dataurlpec", "Dataurlspec", "DATAurlspec", "DATAfilenameSPEC", "Dataurlspe", "DataUrlSpec", " datafilenamespec", "datalspec", "dataurlSpec", "datalspe", "dataurispec", "datastringspec", " datafilenamespe", " dataurlpec", "DataurlSPEC", "datalSpec", "DATAurlspe", " dataurlSpec", "datastringspe", "datastringpec", "dataUrlSPEC", "DataUrlSPEC", "dataUrlSpec", "DataUrlspe", "datastrSpec", "DATAfilenamespec", " datafilenamepec", "datafilenamespe", "datafilenamespec", " dataurlspe", "DataUrlspec"], "dataurl": ["Dataurl", "resourceurl", "imageuri", "resourceUrl", "imageURL", " datafeed", "muurl", "dataURL", "dataUrl", "muUrl", "imageUrl", "Datafeed", "DataUrl", "Datauri", "datautil", "DataURL", "Datautil", "resourceURL", "datafeed", "muutil", "resourceuri", "imageurl", " datautil", "datauri", "mufeed", " dataUrl"], "in": ["f", "rin", "inn", "ini", "gin", "sample", "IN", "vin", "ins", "d", "m", "doc", "stream", "In", "t", "inner", "c", "log", "i", "bin", "serv", "input", "out", "it", " IN", " din", "ind", "o", "r", "ma", "din", "is", "isin", "file", "source", "body", "cin", "id", "from", "data"]}}
{"id1": "10451698", "id2": "13891080", "code1": "    private void copy(File source, File destinationDirectory) throws IOException {\n        if (source.isDirectory()) {\n            File newDir = new File(destinationDirectory, source.getName());\n            newDir.mkdir();\n            File[] children = source.listFiles();\n            for (int i = 0; i < children.length; i++) {\n                if (children[i].getName().equals(\".svn\")) {\n                    continue;\n                }\n                copy(children[i], newDir);\n            }\n        } else {\n            File newFile = new File(destinationDirectory, source.getName());\n            if (newFile.exists() && source.lastModified() == newFile.lastModified()) {\n                return;\n            }\n            FileOutputStream output = new FileOutputStream(newFile);\n            FileInputStream input = new FileInputStream(source);\n            byte[] buff = new byte[2048];\n            int read = 0;\n            while ((read = input.read(buff)) > 0) {\n                output.write(buff, 0, read);\n            }\n            output.flush();\n            output.close();\n            input.close();\n        }\n    }\n", "code2": "    public static void copyFile(File srcFile, File destFile) throws IOException {\n        logger.debug(\"copyFile(srcFile={}, destFile={}) - start\", srcFile, destFile);\n        FileChannel srcChannel = new FileInputStream(srcFile).getChannel();\n        FileChannel dstChannel = new FileOutputStream(destFile).getChannel();\n        try {\n            dstChannel.transferFrom(srcChannel, 0, srcChannel.size());\n        } finally {\n            srcChannel.close();\n            dstChannel.close();\n        }\n    }\n", "label": 1, "substitutes": {"copy": ["proxy", "export", "co", "cop", "cat", "sync", "share", "remove", "create", "link", "Copy", "write", "transfer", "slice", "perm", "cp", "gc", "archive", "paste", "continue", "split", "opy", "zip", "Cop", "download", "core", "pixel", "crop", "file", "clip", "clone", "map", "delete", "move"], "source": ["origin", "empty", "style", "image", "subject", "entry", "ie", "sit", "sp", "original", "service", "resource", "se", "details", "force", "create", "raw", "status", "table", "site", "init", "in", "base", "directory", "template", "spec", "store", "ce", "inner", "scope", "secure", "current", "src", "Source", "none", "cache", "name", "get", "target", "SOURCE", "sin", "query", "note", "parent", "sql", "ource", "null", "space", "instance", "use", "local", "remote", "http", "config", "start", "file", "size", "shell", "body", "class", "unit", "from", "index"], "destinationDirectory": ["targetinationDirectory", "identinatorLocation", "destmentDir", "identinationInternal", "destinationsInternal", "destinatorLocation", "destationFolder", "destinationsdirectory", "destinationsLocation", "destarationInternal", "destinationInternal", "destineApplication", "targetinationsdirectory", "destineDirectory", "targetinationsDirectory", "identinatorDirectory", "destinationsFolder", "identinatorInternal", "destarationDirectory", "destinationFolder", "destinationApplication", " destationDirectory", "targetinationdirectory", "identinationLocation", "destinateDirectory", " destinationFolder", "targetinationsDir", "destarationLocation", "destinatorDirectory", "destmentdirectory", "destationdirectory", "destationApplication", "targetinationFolder", " destationApplication", "destinateFolder", "destmentDirectory", " destationdirectory", "destinationsDirectory", "destineFolder", "destinationsDir", "destinationLocation", "destinatorInternal", "destinatedirectory", " destinationdirectory", "identinationDirectory", "targetinationsFolder", "destinedirectory", "destinationdirectory", "targetinationDir", "destinationDir", "destmentFolder", "destationDirectory", "destinateApplication", " destinationApplication", " destationFolder"], "newDir": ["newDirectory", "newdir", "NewDir", "newFolder", " newdir", "Newdir", "nextDir", " newDirectory", "newsFile", "NewFolder", "nextFile", "newRel", "newsDirectory", "nextRel", "newsFolder", "NewDirectory", "newsdir", "nextdir", "NewRel", " newRel", "newsDir", " newFolder", "NewFile"], "children": ["parents", "times", "services", "apps", "all", "nil", "each", "these", "reports", "links", "users", "items", "keys", "his", "details", "Children", "modules", "jobs", "unknown", "lines", "ls", "bc", "packages", "classes", "names", "ml", "uploads", "its", "gc", "cache", "when", "cont", "child", "blocks", "images", "many", "ids", "resources", "members", "pres", "projects", "objects", "ports", "stories", "related", "ren", "desc", "groups", "pages", "files", "relations", "sub", "may", "kids", "follow"], "i": ["mi", "span", "json", "u", "j", "ms", "um", "y", "us", "I", "ski", "ini", "qi", "di", "ie", "im", "ri", "m", "iq", "ki", "client", "init", "x", "base", "t", "me", "in", "q", "iu", "hi", "ti", "chain", "bi", "ic", "multi", "ci", "ai", "sim", "you", "gi", "ui", "pi", "ij", "ix", "iter", "ji", "it", "uu", "li", "my", "ims", "point", "si", "xi", "g", "batch", "ip", "info", "key", "remote", "io", "gu", "is", "ii", "oi", "index", "id", "phi", "ex"], "newFile": ["ewLe", "newSourceFile", " newGlobal", "NEWDir", "NewDir", "NewLe", "createDir", "newfile", "NEWfile", "createFile", "newsGlobal", "nextDir", "newsfile", "createfile", "nextLe", " newfile", "newsFile", "NEWFile", "newLe", "NewGlobal", "nextFile", "NEWTh", "createSourceFile", "newTh", " newSourceFile", "ewDir", "newsTh", "newGlobal", "goodSourceFile", "goodFile", "Newfile", "goodDir", "ewfile", "NewTh", "goodfile", "newsDir", "nextfile", "NewFile", "ewFile"], "output": ["export", "admin", "response", "block", "text", "ilo", "put", "console", "next", "internal", "client", "stream", "web", "update", "Output", "connection", "four", "net", "write", "buffer", "open", "print", "document", "current", "message", "result", "format", "position", "writer", "enabled", "success", "outer", "out", "exit", "parent", "object", "batch", "network", "monitor", "connect", "auto", "cut", "io", "config", "blue", "file", "online", "body", "pretty", "display"], "input": ["back", "rc", "active", "image", "insert", "internal", "storage", "ink", "reader", "op", "raw", "init", "feed", "in", "inner", "before", "buffer", "open", "ic", "Input", "current", "unsigned", "child", "get", "error", "inc", "operator", "initial", "upload", "out", "iter", "it", "form", "ahead", "ip", "add", "local", "info", "io", "inf", "start", "exec", "from"], "buff": ["seq", "buf", "txt", "sb", "pb", "bf", "text", "cat", "img", "bl", "bg", "cb", " buf", "bo", "uff", "bound", "bs", "bed", "tt", "box", "mem", "buffer", "xff", "old", "b", "bb", "xx", "hold", "bin", "nb", "nd", "uf", "black", "tab", "qq", "cond", "comp", "ch", "data", "eb", "cmd", "mb", "batch", "ind", "Buff", "msg", "ff", "fb", "gb", "printf", "bytes"], "read": ["handle", "en", "each", "text", "find", "and", "select", "test", "hello", "d", " write", "ink", "wait", "raw", "stream", "set", "run", "t", "mem", "feed", "in", "before", "q", "print", "write", "old", "buffer", "readable", "load", "reads", "seek", "hold", "skip", "get", "str", " Read", "bind", "give", "need", "iter", " count", "query", "len", "length", "height", "ind", "Read", "add", "count", "ready", "config", "start", "tell", "send", "reading", "size", "check", "index", "READ", "end", "like", "push"]}}
{"id1": "19934218", "id2": "5632808", "code1": "    public static String doCrypt(String text) throws NoSuchAlgorithmException, UnsupportedEncodingException {\n        MessageDigest md;\n        md = MessageDigest.getInstance(\"SHA-1\");\n        byte[] sha1hash = new byte[40];\n        md.update(text.getBytes(\"UTF-8\"), 0, text.length());\n        sha1hash = md.digest();\n        return convertToHex(sha1hash);\n    }\n", "code2": "        @Override\n        public void respondGet(HttpServletResponse resp) throws IOException {\n            setHeaders(resp);\n            final OutputStream os;\n            if (willDeflate()) {\n                resp.setHeader(\"Content-Encoding\", \"gzip\");\n                os = new GZIPOutputStream(resp.getOutputStream(), bufferSize);\n            } else os = resp.getOutputStream();\n            transferStreams(url.openStream(), os);\n        }\n", "label": 0, "substitutes": {"doCrypt": [" doesHash", "doHash", "doDec", " doescrypt", " doesDec", "Docrypt", "docrypt", " doesCrypt", " doDec", "DoHash", "DoCrypt", " doHash", " docrypt", "DoDec"], "text": ["event", "txt", "nt", "value", "subject", "select", "output", "tx", "test", "cont", "comment", "word", "aut", "context", "t", "x", "template", "code", "command", "buffer", "print", "log", "document", "message", "content", "ext", "read", "format", "url", "act", "name", "now", "pt", "str", "ct", "input", "TEXT", "form", "path", "term", "binary", "Text", "pattern", "key", "string", "config", "msg", "password", "source", "body", "translation", "data", "title", "w"], "UnsupportedEncodingException": ["UnsupportedChoderEx", "UnsupportedEncgorithmError", "UnsupportedEncoderExit", "UnsupportedEncoderEx", "UnsupportedEncryptionError", "UnsupportedEncodingError", "UnsupportedEncodingExit", "UnsupportedChoderExit", "UnsupportedChodingError", "UnsupportedChodingException", "UnsupportedEncgorithmEx", "UnsupportedEncgorithmExit", "UnsupportedEncryptionException", "UnsupportedEncodingEx", "UnsupportedEncgorithmException", "UnsupportedEncoderException", "UnsupportedChodingExit", "UnsupportedEncoderError", "UnsupportedChoderException", "UnsupportedEncryptionEx", "UnsupportedEncryptionExit", "UnsupportedChoderError", "UnsupportedChodingEx"], "md": [" Md", " mp", "sm", "ms", "pd", "od", " mac", " ms", "d", "di", "der", " mo", "mt", " cmd", "m", "sha", "mg", "red", " exec", "mp", "rm", "det", "dm", " maj", "sd", "td", " cd", " rm", " od", "ent", "gm", "dd", "cmd", "mand", " dd", "dir", "cd", "mb", "hd", "MD", "ind", "add", "ad", "grad", " man", "mc", " df", "mm", "mn", "bd", "mk", "ld", "nd", "df"], "sha1hash": ["SHA1key", "sha512cache", "shaOnehash", "SHA2key", "ha1sum", "sha2hex", "shaonehex", "sha512hash", "shaOnesum", "SHA1Hash", "shaoneHash", "sha512Hash", " SHAOneheader", "sha1cache", "shaonehash", "SHA2hash", "sha512sum", "sha2sum", "SHA1hash", "haonesum", "sha2cache", " SHAOnesum", "sha2Hash", "sha2hash", "sha1hex", "SHA2hex", "haoneHash", "sha1Hash", "sha4cache", "sha1key", "shaonesum", "sha3hex", "sha4header", " SHA1cache", "sha1sum", " SHA1header", "sha4hash", "ha1cache", "sha2header", "haonecache", "sha3Hash", "sha2key", " SHAOnecache", "sha3hash", "sha3key", " SHAOnehash", "haonehash", "shaonekey", "ha1Hash", " SHA1sum", " SHA1hash", "ha1hash", "shaonecache", "SHA2Hash", "sha4sum", "SHA1hex", "shaOnecache", "sha1header", "shaOneheader"]}}
{"id1": "771802", "id2": "9824814", "code1": "    public BufferedWriter createOutputStream(String inFile, String outFile) throws IOException {\n        int k_blockSize = 1024;\n        int byteCount;\n        char[] buf = new char[k_blockSize];\n        File ofp = new File(outFile);\n        ZipOutputStream zos = new ZipOutputStream(new FileOutputStream(ofp));\n        zos.setMethod(ZipOutputStream.DEFLATED);\n        OutputStreamWriter osw = new OutputStreamWriter(zos, \"ISO-8859-1\");\n        BufferedWriter bw = new BufferedWriter(osw);\n        ZipEntry zot = null;\n        File ifp = new File(inFile);\n        ZipInputStream zis = new ZipInputStream(new FileInputStream(ifp));\n        InputStreamReader isr = new InputStreamReader(zis, \"ISO-8859-1\");\n        BufferedReader br = new BufferedReader(isr);\n        ZipEntry zit = null;\n        while ((zit = zis.getNextEntry()) != null) {\n            if (zit.getName().equals(\"content.xml\")) {\n                continue;\n            }\n            zot = new ZipEntry(zit.getName());\n            zos.putNextEntry(zot);\n            while ((byteCount = br.read(buf, 0, k_blockSize)) >= 0) bw.write(buf, 0, byteCount);\n            bw.flush();\n            zos.closeEntry();\n        }\n        zos.putNextEntry(new ZipEntry(\"content.xml\"));\n        bw.flush();\n        osw = new OutputStreamWriter(zos, \"UTF8\");\n        bw = new BufferedWriter(osw);\n        return bw;\n    }\n", "code2": "    public void run() {\n        if (status == COMPLETE) {\n            return;\n        }\n        waitRandom();\n        RandomAccessFile file = null;\n        InputStream inputStream = null;\n        boolean success = false;\n        URL url = null;\n        try {\n            BeatportAccessor beatportAccessor = new BeatportAccessor();\n            if (sessionCookies == null) {\n                sessionCookies = beatportAccessor.getSessionCookies(user, password);\n            }\n            url = new URL(new BeatportAccessor().getTrackDownloadUrl(downloadId, sessionCookies));\n            log.info(\"Open (DownloadWorker.run): \" + url);\n            HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n            connection.setRequestProperty(\"User-Agent\", BeatportAccessor.userAgent);\n            connection.setRequestProperty(\"Cookie\", sessionCookies);\n            connection.connect();\n            if (connection.getResponseCode() / 100 != 2) {\n                log.error(\"Unexpected response from server: \" + connection.getResponseCode());\n                error();\n                return;\n            }\n            if (connection.getContentType().indexOf(\"text\") >= 0) {\n                log.error(\"Tried to request: \" + url.toString());\n                log.error(\"Unexpected file content type from server: \" + connection.getContentType());\n                log.error(\"Server replied:\\n\" + getContentAsString(connection));\n                error();\n                return;\n            }\n            int contentLength = connection.getContentLength();\n            if (contentLength < 1) {\n                log.error(\"Invalid content length: \" + connection.getContentLength());\n                error();\n                return;\n            }\n            if (size == -1) {\n                size = contentLength;\n                stateChanged();\n            } else if (size != contentLength) {\n                changeTotal(0, contentLength - size);\n            }\n            if (new File(tmpFileName(fileName)).exists()) {\n                if (!new File(tmpFileName(fileName)).delete()) {\n                    throw new Exception(\"Could not delete file: \" + tmpFileName(fileName));\n                }\n            }\n            file = new RandomAccessFile(tmpFileName(fileName), \"rw\");\n            file.seek(downloaded);\n            inputStream = connection.getInputStream();\n            if (started == 0) {\n                started = System.currentTimeMillis();\n                time = started;\n            }\n            statusChangedObserver.statusChanged(status);\n            byte buffer[] = new byte[MAX_BUFFER_SIZE];\n            while (status == DOWNLOADING) {\n                if (size - downloaded < MAX_BUFFER_SIZE) {\n                    buffer = new byte[(int) (size - downloaded)];\n                }\n                int read = inputStream.read(buffer);\n                if (read == -1) break;\n                file.write(buffer, 0, read);\n                downloaded += read;\n                changeTotal(read, 0);\n                stateChanged();\n            }\n            if (status == DOWNLOADING) {\n                stopped = System.currentTimeMillis();\n                status = COMPLETE;\n            }\n            statusChangedObserver.statusChanged(status);\n            stateChanged();\n            success = true;\n        } catch (Exception e) {\n            e.printStackTrace();\n            error();\n        } finally {\n            try {\n                file.close();\n            } catch (Exception e) {\n            }\n            if (success) {\n                try {\n                    if (!new File(tmpFileName(fileName)).renameTo(new File(fileName))) {\n                        throw new Exception(\"Rename Failed\");\n                    }\n                } catch (Exception e) {\n                    log.error(\"Error moving temp file \" + tmpFileName(fileName) + \" file: \" + fileName, e);\n                }\n            } else {\n                try {\n                    new File(tmpFileName(fileName)).delete();\n                } catch (Exception e) {\n                    log.error(\"Error deleting erroneous temp file: \" + tmpFileName(fileName), e);\n                }\n            }\n            try {\n                inputStream.close();\n            } catch (Exception e) {\n                log.error(\"Error closing input stream of: \" + url + \" / \" + fileName, e);\n            }\n        }\n    }\n", "label": 0, "substitutes": {"createOutputStream": ["createInputFile", " createFileStream", " createOutstream", " createInputSteam", " createOutFile", " createOutStream", "createInputstream", " createOutputFile", " createInputFile", " createOutputSteam", " createFileFile", "createInputSteam", "createOutputSteam", " createInputStream", " createFileSteam", "createOutputFile", "createInputStream", "createOutputstream", " createInputstream", " createOutSteam", " createOutputstream", " createFilestream"], "inFile": [" inFilename", "inFilename", "inputFile", " infile", "ninFilename", "inPort", " inDir", "dinPort", "inputDir", "outfile", "outFilename", "inPath", "dinFile", "ninPath", "dinPath", "ninFile", "inputPort", " inPort", "dinDir", "ninfile", "inputPath", "outPath", "inDir", "infile", " inPath"], "outFile": ["inFilename", "exfile", "newFile", "outputPlace", "newfile", "newPlace", "inPort", "outputfile", "newFilename", "outputFile", "outputFilename", "outfile", "outFilename", "Outfile", "OutFile", "outPort", "toFilename", "exPlace", "exFilename", "toFile", "outPlace", "toPort", "OutPort", "tofile", "OutFilename", "infile", "exFile"], "k_blockSize": ["k_byteCount", "k_batchTime", "k_BlockTime", "k_BlockLength", "k2byteSize", "k_batchLength", "k4blockName", "k_blockCount", "k_blockLength", "k4BlockCount", "k2byteCount", "k_byteStyle", "k2blockCount", "k_byteSize", "k_blockName", "k_batchSize", "k4blockSize", "k2blockLength", "k_byteName", "k_byteLength", "k2blockTime", "k_byteTime", "k_blockTime", "k2byteTime", "k4blockCount", "k4blockStyle", "k4BlockStyle", "k_BlockName", "k_BlockStyle", "k4BlockName", "k4BlockSize", "k_batchCount", "k2byteLength", "k_BlockCount", "k2blockSize", "k_BlockSize", "k_blockStyle"], "byteCount": [" byteCheck", "linePtr", "byteLength", "bitCheck", "wordN", "byteCode", " bytePtr", "byteCounter", "byteCheck", "linecount", "lineCount", "bytecount", " bytecount", "bitN", "bbCode", "bitCount", "bitCounter", "charcount", "bytePtr", "wordCode", "blockCounter", "wordCount", "charLength", "blockCheck", " byteCounter", "bitLength", "charCount", "wordSize", "blockCount", "lineLength", "bitSize", "blockLength", "bbSize", "charPtr", "byteN", " byteLength", "byteSize", "bitCode", "bbCount", "bbN"], "buf": ["seq", "exp", "txt", "cv", "block", "buff", "pb", "img", "cat", "ctx", "bl", "bg", "tx", "cast", "cb", "doc", "raw", "bc", "conv", "mem", "buffer", "pkg", "bag", "b", "ctr", "cur", "db", "fg", "Buffer", "uf", "rb", "str", "alph", "proc", "cmd", "queue", "batch", "Buff", "cap", "msg", "arr", "bn", "vec", "bytes"], "ofp": ["owlpa", "owld", "OFp", "ofl", " ofP", "owlp", " ofd", "Ofp", " ofl", "OfP", "ofpa", "Ofpa", "OFl", "OFP", " ofpa", "ofd", "Ofl", "owlP", "OFd", "Ofd", "ofP"], "zos": ["ze", "zag", "amia", "nz", "rss", "zon", "z", "settings", "cos", "webkit", "zin", "oss", "south", "js", "zb", "jas", "osi", "ws", "bs", "zy", "sbm", "zen", "init", "tis", "zh", "hz", "los", "zona", "ps", "zo", "ossus", "rose", "enos", "zes", "os", "ez", "za", "std", "esa", "bes", "psy", "cz", "sch", "gs", "css", "zu", "zzle", "eros", "zip", "zl", "zers", "jp", "LOS", "rez", "socket", "hess", "zik", "zer", "zi", "es", "python", "sis"], "osw": ["oswx", "opace", "osws", "iswx", " oswx", "ossW", "aosws", "ossrw", "aosw", "osrw", "osW", "isW", " osW", "owa", "osswd", "ow", " osd", "isw", "oW", "osew", "aosW", "ospace", "sysW", "aoswd", "aosrw", "osd", "osswx", "sysrw", "aosew", "osiwa", "sysw", "osssw", "cosd", "ossw", "osipace", "aoswa", " osew", "cosws", "aospace", "cosw", "issw", "cosew", "oswa", "aosd", "oswd", "osiw", "syswd", " osws", " ossw", "osiW"], "bw": ["bem", "pbwy", "nbew", "bx", "sbz", "sbwt", " bem", "bwy", "nbw", "abwe", "bew", "abw", " bend", "bend", "wbw", " bwk", "nbwe", "nbwy", "bwk", "obsw", "bwt", "wbwt", "pbew", "pbz", " bwl", "bwp", " bz", "pbwb", "wbz", "bbwt", " bx", "bbws", "obz", "abew", "wbend", "bbz", "bewk", "besw", " bsw", "bwl", "wbem", "bz", "wbx", "bbem", "bwe", "bws", "obwk", "rbws", " bwt", "bewl", "rbw", "sbw", "sbwb", "rbz", "rbex", "bsw", "bbx", "pbwt", "bbwp", "obwt", "bbw", "bbend", "pbw", "bex", "obwb", " bwp", "bwb", "wbwp", " bex", "pbwe", "obwl", "abwy", " bws", "bbex", "obw"], "zot": [" zor", "Zit", " zonet", "zeror", "zipiot", " zott", "zoor", "Zot", "zeronet", " zote", "zote", "zoonet", "ziat", "zerhot", "zipiat", "zoo", "zor", "zerott", "zeriat", "Zott", "zerit", "zott", "zo", " zhot", "zerote", "zeriot", "ziot", "zoot", " ziat", " zo", "zonet", "zipot", "ziphot", "zerot", "zhot", " ziot", "zero", "Zote"], "ifp": ["iwp", " ifr", " iftp", "ihr", "ihtp", " ifd", "ifP", " ifjp", "IfP", "isth", "isp", "ihp", "ifjp", "ifd", "iwd", "iwr", "iwtp", "isjp", "Ifth", "ifr", "ihd", "iftp", " ifP", "ifth", "isP", "Ifp", "Ifjp", " ifth"], "zis": ["ziiss", " zic", " zIS", "izi", "zinit", "zIS", "ziis", " zi", "zipIS", "izinit", "zois", "ezisc", "ezi", "zeris", "zeric", "ziss", "zipis", "izisc", "zerIS", "izis", "zoinit", " ziss", "zisa", "zipic", "zoisa", "ziinit", "iziss", " zisc", "zic", "zisc", "ezis", "zoiss", "izisa", "zi", "ziisa", "eziss"], "isr": ["issrc", "siscr", "sisrs", " isrc", "itssr", "itsr", "issr", "sisrc", "isalsr", "issrs", "itsstr", "isalstr", "ispr", " isrs", "iossr", "isscr", "isalr", "iosstr", "iosr", "isalpr", " iscr", "isrs", "itspr", "sisr", "isrc", "isstr", "iospr", "iscr"], "br": ["wr", "hr", "bt", "tr", " Br", "bf", "bl", "mr", "bro", "js", "cr", "bh", "fr", "kr", "BR", "ber", "bi", "b", "ctr", "sr", "dr", "lr", "bj", "rel", "bp", "bm", "ptr", "ba", "yr", "rb", "str", "Br", "r", "Fr", "gr", "vr", "shr", "obl", "bn", "pr", "bd"], "zit": ["lexIT", "ziplit", "zeot", "zop", "iziti", "ozunit", "zipIt", "izip", "oziti", "cziti", "ziti", "lexIt", "zeip", "ezit", "ezite", " zop", "ozip", "zipist", " zlit", "izunit", "zlit", "ozit", "zite", "czip", " zite", "zist", "zeop", "zIT", "czop", "lexit", "ezlit", " zIT", "zunit", "zeit", "izit", "zipite", " zip", "lexist", "zipit", "zIt", "ziIT", "ezIT", "ziit", "zip", "ziIt", "czot", "zipIT", "ziist", "czunit", "czit"]}}
{"id1": "3309233", "id2": "4168534", "code1": "        @Override\n        protected String doInBackground(String... params) {\n            try {\n                final HttpParams param = new BasicHttpParams();\n                HttpConnectionParams.setConnectionTimeout(param, 30000);\n                HttpConnectionParams.setSoTimeout(param, 30000);\n                DefaultHttpClient client = new DefaultHttpClient(param);\n                HttpPost post = new HttpPost(\"http://www.google.com/loc/json\");\n                post.setEntity(new StringEntity(params[0]));\n                if (DEBUG) Log.d(\"Location\", params[0]);\n                HttpResponse resp = client.execute(post);\n                if (resp.getStatusLine().getStatusCode() == 200) {\n                    HttpEntity entity = resp.getEntity();\n                    String result = EntityUtils.toString(entity);\n                    return result;\n                } else {\n                    if (isFirstLocation) {\n                        requestGearsLocation(1);\n                        isFirstLocation = false;\n                        return RESULT_FIRST_FAILE;\n                    }\n                }\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n            return null;\n        }\n", "code2": "    public String insertSmsInf(Sms sms) throws Exception {\n        String smsId = null;\n        Connection conn = null;\n        PreparedStatement pstmt = null;\n        StringBuffer buffer = new StringBuffer();\n        try {\n            buffer.append(\"INSERT INTO COMTNSMS\\n\");\n            buffer.append(\"  (SMS_ID, TRNSMIS_TELNO, TRNSMIS_CN,\\n\");\n            buffer.append(\"   FRST_REGISTER_ID, FRST_REGIST_PNTTM )\\n\");\n            buffer.append(\"VALUES\\n\");\n            buffer.append(\"(?, ?, ?, ?, SYSDATE())\");\n            conn = SmsBasicDBUtil.getConnection();\n            conn.setAutoCommit(false);\n            smsId = getNextId(conn);\n            pstmt = conn.prepareStatement(buffer.toString());\n            int index = 0;\n            pstmt.setString(++index, smsId);\n            pstmt.setString(++index, sms.getTrnsmitTelno());\n            pstmt.setString(++index, sms.getTrnsmitCn());\n            pstmt.setString(++index, sms.getFrstRegisterId());\n            pstmt.executeUpdate();\n            conn.commit();\n            return smsId;\n        } catch (Exception ex) {\n            if (conn != null) {\n                conn.rollback();\n            }\n            throw ex;\n        } finally {\n            SmsBasicDBUtil.close(null, pstmt, conn);\n        }\n    }\n", "label": 0, "substitutes": {"doInBackground": [" doAsHttp", " doInMemory", "doAsBackground", " doAsMemory", " doIfBackground", "doAsAsync", "doInAsync", " doAsAsync", " doIfAsync", " doIfMemory", "doAsHttp", "doInMemory", " doIntHttp", "doInHttp", " doAsBackground", " doIntBackground", " doIntMemory", " doInAsync", " doIfHttp", " doInHttp", " doIntAsync", "doAsMemory"], "params": ["terms", "times", "amps", "xs", "tags", "services", "photos", "json", "settings", "ms", "options", "reports", "parts", "items", "js", "keys", "details", "types", "lines", "ls", "months", "names", "models", "stats", "pins", "ps", "shape", "words", "steps", "styles", "ams", "properties", "aws", "pps", "ids", "points", "images", "resources", "sql", "actions", "members", "ims", "fixes", "vs", "values", "posts", "p", "units", "data", "results"], "param": ["meter", "dem", "admin", "sm", "ctx", "par", "min", "pai", "sp", "resource", "m", "option", "set", "mem", "rank", "perm", "rem", "conf", "property", "amp", "cp", "ams", "minute", "dm", "cm", "pri", "initial", "input", "prom", "proc", "am", "Param", "aram", "parse", "cal", "project", "form", "conn", "space", "ram", "ad", "num", "member", "mm", "jp", "iam", "pm", "config", "arg", "pool", "vm", "Parameter", "sem", "sam", "p", "power"], "client": ["co", "response", "google", "con", "console", "cn", "city", "service", "resource", "Client", "grid", "context", "app", "connection", "c", "net", "secure", "cli", "call", "system", "cell", "close", "cp", "cache", "phone", "cm", "api", "ch", "cmd", "conn", "tc", "ip", "channel", "local", "http", "remote", "io", "wrapper", "server", "cl"], "post": ["process", "ost", "and", "tx", "put", "next", "request", "op", "pp", "pod", "create", "set", " POST", "col", "mod", "feed", "link", "rest", "build", "write", "req", "read", "def", "head", "get", "after", "upload", " Post", "dd", "parse", "form", "pre", "Post", "POST", "add", "zip", "follow", "row", "http", "wp", "save", "submit", "send", "install", "patch", "body", "ld", "p", "end", "pass"], "resp": ["exp", "respons", "response", "cmp", "dl", "res", "rep", "responsive", "sp", "comm", "cb", "obj", "wait", "https", "bs", "Response", "status", "col", "conv", "ess", "rest", "err", "soc", "bb", "rem", "re", "rel", "req", "serv", "pos", "esp", "out", "respond", "comp", "proc", "cmd", "conn", "Resp", "inv", "rex", "desc", "jp", "http", "html", "repl", "body", "rec", "cl"], "entity": ["event", "active", "response", "json", "output", "entry", "email", "ee", "resource", "obj", "details", "se", "enc", "cy", "ce", "me", "document", "xml", "content", "e", "detail", "eme", "owner", "le", "person", "ent", "note", "my", "object", "encrypted", "security", "group", "line", "el", "activity", "member", "info", "Entity", "ity", "orm", "body", "existent", "unit", "data", "pe"], "result": ["csv", "report", "response", "product", "output", "res", "match", "test", "feature", "comment", "request", "description", "summary", "sequence", "currency", "status", "table", "profile", "date", "message", "current", "join", "detail", "success", "total", "successful", "complete", "valid", "true", "answer", "continue", "group", "relation", "ret", "root", "results", "Result"]}}
{"id1": "3252116", "id2": "10176678", "code1": "    public static String getMD5(String source) {\n        String s = null;\n        char hexDigits[] = { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f' };\n        try {\n            java.security.MessageDigest md = java.security.MessageDigest.getInstance(\"MD5\");\n            md.update(source.getBytes());\n            byte tmp[] = md.digest();\n            char str[] = new char[16 * 2];\n            int k = 0;\n            for (int i = 0; i < 16; i++) {\n                byte byte0 = tmp[i];\n                str[k++] = hexDigits[byte0 >>> 4 & 0xf];\n                str[k++] = hexDigits[byte0 & 0xf];\n            }\n            s = new String(str);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return s;\n    }\n", "code2": "    @Test\n    public void testLoadHttpGzipped() throws Exception {\n        String url = HTTP_GZIPPED;\n        LoadingInfo loadingInfo = Utils.openFileObject(fsManager.resolveFile(url));\n        InputStream contentInputStream = loadingInfo.getContentInputStream();\n        byte[] actual = IOUtils.toByteArray(contentInputStream);\n        byte[] expected = IOUtils.toByteArray(new GZIPInputStream(new URL(url).openStream()));\n        assertEquals(expected.length, actual.length);\n    }\n", "label": 0, "substitutes": {"getMD5": ["getHash5", "Getmd1", "GetMD10", "getMD4", "getHash4", "getHash1", "GetMD1", "getMD10", "getmd1", "Getmd5", "GetMD5", "getMC10", "GetMD4", "getmd10", "getMD1", "getMC4", "Getmd4", "getmd5", "getHash10", "getMC1", "getmd4", "Getmd10", "getMC5"], "source": ["origin", "f", "ser", "style", "image", "text", "subject", "output", "sample", "dest", "sequence", "secret", "site", "base", "template", "code", "c", "buffer", "b", "message", "src", "content", "Source", "e", "name", "copy", "target", "SOURCE", "input", "this", "object", "seed", "ource", "null", "string", "start", "file", "from", "data"], "s": ["xs", "ss", "ads", "sb", "ses", "p", " gets", "ends", "ins", "parts", "js", "a", "ws", "fs", "bs", "ls", "t", "hs", "ns", " ls", "ings", "cs", "b", "ps", "ts", "S", "its", " es", " streams", "ats", "rs", "os", "ds", "eps", "bes", " returns", "gs", " ts", " sets", " samples", " outputs", "uns", "sts", "gets", " fs", " ans", " rs", " ss", "es", "ies", "abs"], "hexDigits": ["hexdigists", "exdigits", "exDigitions", " hexDigals", "hexDigists", "hexdigit", " hexDigities", "hexDigitions", "hexdigals", "exDigities", "hexdigits", "hexDigbits", "hexFunals", "hexDigities", "hexDigit", "exdigals", "exdigities", "hexdigbits", "exdigitions", "hexdigitions", "hexDities", "hexFunbits", "hexPosals", "hexDits", " hexDigbits", "hexPosits", "exDigits", "hexFunit", "hexPosities", " hexDigit", " hexDigists", "exDigals", "hexDists", "hexdigities", "hexDitions", "hexDigals", " hexDigitions", "hexPositions", "hexFunits"], "md": [" Md", "nt", "sm", "pd", "ms", "od", "di", "d", "der", "mt", "amd", "m", "mod", "red", "dr", "rm", "det", "dm", "sd", "td", "nd", "cond", "dd", "cmd", "mb", "cd", "hd", "MD", "dig", "ind", "add", "grad", "mn", "desc", "mm", "mc", "ad", "mk", "de", "ld", "pdf", "bd", "df", "dh"], "tmp": ["xs", "txt", "buff", "dirty", "img", "cmp", "ctx", "test", "params", "sp", "cb", "js", "obj", "Temp", "table", "tt", "xy", "pkg", "mp", "bag", "fake", "perm", "cur", "sym", "db", "yy", "up", "nb", "sup", "qq", "proc", "comp", "np", "mb", "bis", "etc", "zip", "emp", "local", "html", "temp", "bytes"], "str": ["buf", "txt", "tr", "div", "br", "text", "cat", "vol", "cast", "sp", "ar", "cr", "obj", "m", "fr", "set", "t", "char", "c", "sl", "cs", "b", "ctr", "Str", "dr", "list", "v", "e", "name", "out", "iter", "it", "ch", "hex", "sc", "sw", "st", "stri", "r", "arc", "n", "gr", "string", "STR", "arr", "p", "print", "data", "w"], "k": ["ikk", "f", "kid", "ko", "j", "z", "p", "unk", "ke", "d", "tk", "h", "kh", "m", "kt", "set", "K", "kar", "t", "x", "q", "c", "b", "v", "sk", "ak", "l", "kj", "kl", "ck", "g", "kk", "ka", "km", "n", "key", "kw", "ok", "mk", "kan", "ku", "ks", "id", "kn", "ik", "w"], "i": ["mi", "u", "j", "ini", "I", "qi", "di", "im", "ri", "m", "status", "inter", "conv", "iu", " j", "x", "ti", "me", "hi", "chain", "bi", "in", "cli", "ic", "ci", "multi", "ai", "sim", "gi", "ui", "e", "v", "pi", "ij", "ix", "it", "ji", "li", "xi", "\u0438", "si", "o", "ip", "info", "n", "io", "ii", "is", "index", "zi", "p", "print", "phi"], "byte0": [" byte8", "Byte3", " byte6", "byte1", "node2", "byte2", "byte140", "Byte8", "channel0", "node8", "hexElement", "channel140", "node0", "channel3", "byte8", " byte3", "Byte140", "byte3", "Byte2", "pixel6", "pixel0", "channel1", "pixelElement", " byte1", "hex1", " byte2", "pixel1", "byte6", "Byte0", " byteElement", " byte140", "Byte1", "hex6", "hex0", "byteElement", "node1"]}}
{"id1": "15580610", "id2": "12380475", "code1": "    @Override\n    public void trainClassifier(File dir, String... args) throws Exception {\n        String[] command = new String[args.length + 3];\n        command[0] = this.getCommand();\n        System.arraycopy(args, 0, command, 1, args.length);\n        command[command.length - 2] = new File(dir, \"training-data.libsvm\").getPath();\n        command[command.length - 1] = new File(dir, this.getModelName()).getPath();\n        Process process = Runtime.getRuntime().exec(command);\n        IOUtils.copy(process.getInputStream(), System.out);\n        IOUtils.copy(process.getErrorStream(), System.err);\n        process.waitFor();\n    }\n", "code2": "    public void transport(File file) throws TransportException {\n        if (file.exists()) {\n            if (file.isDirectory()) {\n                File[] files = file.listFiles();\n                for (int i = 0; i < files.length; i++) {\n                    transport(file);\n                }\n            } else if (file.isFile()) {\n                try {\n                    FileChannel inChannel = new FileInputStream(file).getChannel();\n                    FileChannel outChannel = new FileOutputStream(destinationDir).getChannel();\n                    inChannel.transferTo(0, inChannel.size(), outChannel);\n                } catch (IOException e) {\n                    log.error(\"File transfer failed\", e);\n                }\n            }\n        }\n    }\n", "label": 1, "substitutes": {"trainClassifier": [" trainclassizer", " trainClassizer", " trainModification", " trainObjectification", " trainclassifier", " trainObjectifer", " trainObjectifier", " runClassifier", " runClassizer", " trainclassifer", " trainClassification", " runClassifer", " trainClassifer", " runclassizer", " trainModifier", " runclassification", " runclassifer", " trainModifer", " runClassification", " trainObjectizer", " trainModizer", " runclassifier", " trainclassification"], "dir": ["report", "div", " directory", "dl", "output", "d", "disk", "doc", "tmp", "module", "base", "directory", "done", "md", "log", "addr", "pkg", "dr", "db", "wd", "src", "dm", "url", "lib", "pos", "dd", "this", "Dir", "ir", "path", "rad", "null", "DIR", "grad", "local", "config", "files", "dist", "io", "folder", "loc", "root", "direct", "data", "prefix"], "command": ["event", "response", "text", "and", "operation", "shift", "column", "mpeg", "comment", "argument", "execute", "application", "request", "option", "description", "sequence", "force", "sudo", "set", "clear", "script", "base", "directory", "menu", "chain", "template", "attribute", "connection", "Command", "function", "document", "message", "link", "call", "buffer", "content", "program", "condition", "position", "archive", "statement", "method", "initial", "three", "cmd", "query", "history", "search", "component", "paste", "form", "binary", "group", "pattern", "requisite", "key", "volume", "string", "config", "display", "multiple", "control", "relative", "button", "password", "mac", "shell", "send", "pretty", "delete", "power", "expression"], "length": ["needs", "transform", "value", "creator", "ENGTH", "shift", "deep", "Length", "capacity", "depth", "distance", "sequence", "append", "pad", "level", "bus", "limit", "build", "pieces", "load", "shape", "max", "strip", "available", "number", "now", "position", "factor", "total", "SIZE", "last", "dump", "len", "upper", "form", "height", "space", "ength", "ctors", "fleet", "prototype", "collection", "full", "count", "volume", "size", "loc", "diff", "end", "power", "duration", "character", "given"], "process": ["event", "handle", "worker", "output", "Process", "pid", "console", "task", "mpeg", "service", "request", "pp", "view", "processor", "processing", "status", "thread", "run", "script", "in", "link", "function", "load", "message", "call", "result", "system", "flow", "post", "program", "node", "cp", "position", "method", "proc", "cmd", "parse", "object", "component", "search", "term", "complex", "record", "network", "connect", "use", "channel", "display", "start", "exec", "class", "check", "p", "session"]}}
{"id1": "12055086", "id2": "15445861", "code1": "    protected static void copyDeleting(File source, File dest) throws IOException {\n        byte[] buf = new byte[8 * 1024];\n        FileInputStream in = new FileInputStream(source);\n        try {\n            FileOutputStream out = new FileOutputStream(dest);\n            try {\n                int count;\n                while ((count = in.read(buf)) >= 0) out.write(buf, 0, count);\n            } finally {\n                out.close();\n            }\n        } finally {\n            in.close();\n        }\n    }\n", "code2": "    public static void copyFile(File srcFile, File destFile) throws IOException {\n        if (!(srcFile.exists() && srcFile.isFile())) throw new IllegalArgumentException(\"Source file doesn't exist: \" + srcFile.getAbsolutePath());\n        if (destFile.exists() && destFile.isDirectory()) throw new IllegalArgumentException(\"Destination file is directory: \" + destFile.getAbsolutePath());\n        FileInputStream in = new FileInputStream(srcFile);\n        FileOutputStream out = new FileOutputStream(destFile);\n        byte[] buffer = new byte[4096];\n        int no = 0;\n        try {\n            while ((no = in.read(buffer)) != -1) out.write(buffer, 0, no);\n        } finally {\n            in.close();\n            out.close();\n        }\n    }\n", "label": 1, "substitutes": {"copyDeleting": [" copydeletging", " copyDeletting", " copyDeletving", " copyDeletging", " copyDeleing", " copyDelinging", " copyDelingving", " copyDeleging", " copyDelingging", " copydeletving", " copyDelingting", " copydeleing", " copyDeeleting", " copyDeleving", " copyDeeleving", " copyDeeleging", " copydeleving", " copydeleting", " copydeleging", " copyDeeleing", " copydeletting"], "source": ["origin", "back", "style", "image", "sample", "oss", "sp", "original", "service", "se", "resource", "site", "init", "base", "ce", "template", "spec", "store", "scope", "src", "Source", "ace", "target", "SOURCE", "input", "query", "sql", "parent", "search", "seed", "ource", "form", "local", "start", "body", "from"], "dest": ["origin", "exp", "decl", "comb", "img", "pub", "cat", "orig", "pas", "them", "sp", "d", "way", "tom", "trans", "https", "est", "port", "rest", "del", "th", "cas", "master", "lit", "src", "bin", "target", "it", "st", "null", "dir", "nom", "mm", "Dest", "dist", "temp", "loc", "end", "w"], "buf": ["seq", "cv", "pause", "block", "br", "buff", "ref", "cat", "img", "comb", "prop", "bl", "tx", "cast", "cb", "bh", "bs", "bc", "conv", "box", "bus", "buffer", "pkg", "bag", "b", "cur", "capt", "db", "aka", "fg", "cp", "Buffer", "uf", "str", "rb", "tab", "meg", "alph", "data", "cmd", "eb", "batch", "Buff", "cap", "cf", "arr", "fb", "vec", "bytes"], "in": ["ze", "rin", "en", "inn", "ini", "by", "con", "gin", "IN", "ins", "ri", "on", "al", "In", "init", "inside", "inner", "ic", "ai", "un", "i", "read", "bin", "inc", "input", "or", "iter", "it", "per", "ind", "el", "mm", "info", "din", "inf", "is", "isin", "cin", "user", "from"], "out": ["ion", "co", "en", "nt", "flush", "by", "con", "output", "res", "oss", "cn", "obj", "on", "client", "sys", "sum", "page", "conv", "t", "inner", "dis", "net", "write", "log", "to", "end", "up", "v", "i", "writer", "os", "outer", "conn", "ou", "at", "aos", "outs", "o", "auto", "n", "io", "Out", "OUT", "can", "ne"], "count": ["nt", "cloud", "span", "z", "deep", "cont", "comment", "sum", "t", "char", "code", "q", "c", "ctr", "current", "max", "conf", "number", "ct", "counter", "nb", "read", "now", "ount", "coll", "total", "cond", "ch", "common", "len", "length", "amount", "found", "Count", "ind", "batch", "num", "add", "n", "core", "cap", "start", "size", "check", "index", "acc", "cc"]}}
{"id1": "9805906", "id2": "22366505", "code1": "    public static boolean dump(File source, File target) {\n        boolean done = false;\n        try {\n            InputStream is = new BufferedInputStream(new FileInputStream(source));\n            OutputStream os = new BufferedOutputStream(new FileOutputStream(target));\n            while (is.available() > 0) {\n                os.write(is.read());\n            }\n            os.flush();\n            os.close();\n            is.close();\n            return true;\n        } catch (IOException e) {\n        }\n        return done;\n    }\n", "code2": "    @Override\n    public void incluir(Igreja igreja) throws Exception {\n        Connection connection = criaConexao(false);\n        String sql = \"insert into igreja ? as idlocal, ? as possui_salao;\";\n        String sql2 = \"SELECT MAX(idlocal) FROM Local\";\n        PreparedStatement stmt = null;\n        PreparedStatement stmt2 = null;\n        ResultSet rs = null;\n        try {\n            stmt = connection.prepareStatement(sql);\n            stmt2 = connection.prepareStatement(sql2);\n            rs = stmt2.executeQuery();\n            stmt.setInt(1, rs.getInt(\"max\"));\n            stmt.setBoolean(2, igreja.getPossuiSalao());\n            int retorno = stmt.executeUpdate();\n            if (retorno == 0) {\n                connection.rollback();\n                throw new SQLException(\"Ocorreu um erro inesperado no momento de inserir dados de cliente no banco!\");\n            }\n            connection.commit();\n        } catch (SQLException e) {\n            connection.rollback();\n            throw e;\n        } finally {\n            try {\n                stmt.close();\n                stmt2.close();\n                rs.close();\n                this.fechaConexao();\n            } catch (SQLException e) {\n                throw e;\n            }\n        }\n    }\n", "label": 0, "substitutes": {"dump": ["export", " debug", "flush", " describe", "update", "init", "debug", "link", " dumped", "write", "store", "load", "println", " println", "read", "copy", "stat", " show", "show", "zip", "info", "download", "save", "send", "diff", " dumps", "print", "display"], "source": ["origin", "style", "image", "text", "select", "sample", "ie", "service", "resource", "se", "ink", "view", "sequence", "sys", "site", "init", "script", "template", "spec", "store", "scope", "src", "Source", "copy", "SOURCE", "input", "iter", "sql", "parent", "search", "java", "ource", "form", "local", "info", "remote", "config", "start", "file", "shell", "check", "from"], "target": ["proxy", "style", "that", "match", "output", "test", "next", "dest", "goal", "table", "t", "base", "template", "link", "replace", "to", "current", "host", "Target", "copy", "top", "it", "gt", "project", "compatible", "null", "term", "pattern", "local", "bolt", "mac", "file", "arget", "tif", "delete", "arg"], "is": ["xs", "ics", "ois", "ist", "ms", "iris", "mos", "ins", "oss", "im", "Is", "ar", "nis", "ri", "sys", "ls", "isa", "ais", "init", "in", "tis", "abs", "bits", "ic", "ai", "i", "its", "act", "ris", "IS", "are", "ys", "has", "it", "isc", "ims", "isl", "si", "lis", "ir", "s", "bis", "isf", "ip", "ists", "ii", "isi", "ios", "isin", "iso", "iss", "ib", "es", "sis"], "os": ["ows", "oes", "dos", "ss", "Os", "ost", "cos", "oss", "mos", "es", "osi", "js", "oses", "ros", "fs", "sys", "bs", "ants", "ls", "ns", "uts", "los", "ose", "ps", "ts", "ox", "ols", "pos", "or", "bos", "ds", "obs", "css", "s", "aos", "outs", "o", "oS", "OS", "io", "ios", "oos", "nos", "cs", "ot"], "done": ["led", "Done", "expected", "dirty", "pleted", "di", "d", " continued", "set", "finished", "die", "only", "shown", "made", "ded", "started", "seen", "progress", "complete", "enabled", "valid", "des", " Done", "loaded", "continue", "flag", "checked", "gone", "created", "found", "did", "desc", "de", "failed", "later", "needed", "du", "disabled", "filled", "ished", "given"]}}
{"id1": "15241397", "id2": "14758866", "code1": "    @Override\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String rewrittenQueryString = URLDecoder.decode(request.getRequestURI(), \"UTF-8\").replaceFirst(\"^.*?\\\\/(id:.*)\\\\/.*?$\", \"$1\");\n        logger.debug(\"rewrittenQueryString: \" + rewrittenQueryString);\n        URL rewrittenUrl = new URL(fedoraUrl + rewrittenQueryString);\n        logger.debug(\"rewrittenUrl: \" + rewrittenUrl.getProtocol() + \"://\" + rewrittenUrl.getHost() + \":\" + rewrittenUrl.getPort() + rewrittenUrl.getFile());\n        HttpURLConnection httpURLConnection = (HttpURLConnection) rewrittenUrl.openConnection();\n        HttpURLConnection.setFollowRedirects(false);\n        httpURLConnection.connect();\n        response.setStatus(httpURLConnection.getResponseCode());\n        logger.debug(\"[status=\" + httpURLConnection.getResponseCode() + \"]\");\n        logger.debug(\"[headers]\");\n        for (Entry<String, List<String>> header : httpURLConnection.getHeaderFields().entrySet()) {\n            if (header.getKey() != null) {\n                for (String value : header.getValue()) {\n                    if (value != null) {\n                        logger.debug(header.getKey() + \": \" + value);\n                        if (!header.getKey().equals(\"Server\") && !header.getKey().equals(\"Transfer-Encoding\")) {\n                            response.addHeader(header.getKey(), value);\n                        }\n                    }\n                }\n            }\n        }\n        logger.debug(\"[/headers]\");\n        InputStream inputStream = httpURLConnection.getInputStream();\n        OutputStream outputStream = response.getOutputStream();\n        IOUtils.copy(inputStream, outputStream);\n    }\n", "code2": "    public synchronized InputStream getResourceAsStream(String name) {\n        InputStream inputStream = null;\n        BufferedInputStream in = null;\n        BufferedOutputStream out = null;\n        try {\n            URL url = getResource(name);\n            String remoteName = url.toExternalForm();\n            String localName = (String) cacheHashtable.get(remoteName);\n            if (localName != null) {\n                System.out.println(\"Retrieving \\\"\" + localName + \"\\\"...\");\n                return new FileInputStream(localName);\n            }\n            String host = url.getHost();\n            String prot = url.getProtocol();\n            int port = url.getPort();\n            File cacheFile = new File(cacheDir, prot + File.separator + host + File.separator + \"port\" + (port == -1 ? \"\" : Integer.toString(port)) + File.separator + name);\n            cacheFile = new File(cacheFile.getCanonicalPath());\n            localName = cacheFile.getCanonicalPath();\n            System.out.println(\"Comparing \\\"\" + localName + \"\\\"...\");\n            URLConnection urlConnection = url.openConnection();\n            if (cacheFile.exists()) {\n                urlConnection.setIfModifiedSince(cacheFile.lastModified());\n            }\n            if (urlConnection instanceof HttpURLConnection) {\n                HttpURLConnection httpURLConnection = (HttpURLConnection) urlConnection;\n                httpURLConnection.setFollowRedirects(true);\n                httpURLConnection.setRequestMethod(\"GET\");\n                int responseCode = httpURLConnection.getResponseCode();\n                System.out.println(httpURLConnection.getResponseMessage() + \", \" + httpURLConnection.getContentLength() + \" bytes\" + \", \" + new Date(httpURLConnection.getDate()) + \", \" + new Date(httpURLConnection.getLastModified()));\n                if (responseCode != HttpURLConnection.HTTP_OK) {\n                    return null;\n                }\n            }\n            inputStream = urlConnection.getInputStream();\n            if (inputStream == null) return null;\n            if (cacheFile.exists()) {\n                long lastModified = urlConnection.getLastModified();\n                if ((lastModified > 0) && (lastModified < cacheFile.lastModified())) {\n                    inputStream.close();\n                    cacheHashtable.put(remoteName, localName);\n                    System.out.println(\"Retrieving \\\"\" + localName + \"\\\"...\");\n                    return new FileInputStream(cacheFile);\n                }\n            }\n            File parentFile = new File(cacheFile.getParent());\n            parentFile.mkdirs();\n            localName = cacheFile.getCanonicalPath();\n            System.out.println(\"CACHING \\\"\" + localName + \"\\\"...\");\n            in = new BufferedInputStream(inputStream);\n            out = new BufferedOutputStream(new FileOutputStream(cacheFile));\n            int i;\n            while ((i = in.read()) > -1) out.write(i);\n            out.close();\n            in.close();\n            cacheHashtable.put(remoteName, localName);\n            System.out.println(\"Retrieving \\\"\" + localName + \"\\\"...\");\n            return new FileInputStream(localName);\n        } catch (Exception ex) {\n            try {\n                inputStream.close();\n            } catch (Exception ex1) {\n            }\n            try {\n                in.close();\n            } catch (Exception ex1) {\n            }\n            try {\n                out.close();\n            } catch (Exception ex1) {\n            }\n            ex.printStackTrace();\n            return null;\n        }\n    }\n", "label": 1, "substitutes": {"doGet": ["DoPut", "doGET", " doPut", " doGET", "handlePut", "Doget", "handleGET", "doget", " doget", "doPut", "handleget", "handleGet", "DoGET", "DoGet"], "request": ["first", "report", "transform", "address", "reference", "each", "reset", "the", "hello", "forward", "frame", "application", "client", "create", "quest", "context", "in", "connection", "command", "attribute", "document", "message", "current", "Request", "re", "req", "position", "get", "complete", "input", "initial", "query", "question", "http", "start", "QUEST", "user", "server", "setup"], "response": ["report", "reply", "image", "json", "block", "output", "reset", "res", "next", "console", "service", "frame", "description", "application", "resource", "view", "sequence", "Response", "status", "page", "site", "context", "fire", "connection", "ce", "ve", "write", "resp", "document", "message", "result", "onse", "xml", "content", "position", "success", "respond", "exit", "object", "form", "answer", "network", "session", "http", "send", "body", "version", "print", "server"], "rewrittenQueryString": ["rewrittenCurrentStr", "rewrittenRequestStr", "rewartedQuerystring", "rewliedqueryStr", "rewrittenURLString", "rewrittenQuStream", "rewrittenHeaderStr", "rewrittenHeaderStream", "rewrittenRequestQuery", "rewwrittenQueryString", "rewrittenqueryStr", "rewrittenQuestionString", "rewrittenCurrentQuery", "rewrittenURLStr", "rewwrittenqueryQuery", "rewrittenCurrentstring", "rewrittenQuString", "rewrittenURLStream", "rewrittenqueryQuery", "rewartedQueryStream", "rewartedQueryString", "rewwrittenQueryStr", "rewrittenRequeststring", "rewrittenURLstring", "rewliedQueryString", "rewliedqueryString", "rewwrittenquerystring", "rewartedHeaderstring", "rewrittenQuestionStr", "rewrittenQueryStream", "rewrittenHeaderString", "rewartedHeaderStr", "rewrittenQustring", "rewrittenHeaderstring", "rewartedQueryStr", "rewliedqueryStream", "rewrittenquerystring", "rewartedHeaderStream", "rewrittenQueryStr", "rewwrittenQuerystring", "rewrittenQuStr", "rewliedQueryStr", "rewartedHeaderString", "rewwrittenqueryString", "rewliedQueryStream", "rewrittenQuerystring", "rewrittenqueryString", "rewwrittenQueryQuery", "rewrittenqueryStream", "rewwrittenqueryStr", "rewrittenQueryQuery", "rewrittenCurrentString", "rewrittenQuestionStream", "rewrittenRequestString"], "rewrittenUrl": ["RewrittenPosition", "rewrittenPosition", "RewwrittenString", "rewrapedURL", "rewadjustedUrl", "RewrittenString", "rewriddenUr", "RewrittenLink", "rewrownUrl", "RewwrittenUr", "rewittenLink", "RewrittenUrl", "rewriterUrl", "rewwrittenPort", "rewriteurl", "rewrittenUr", "rewwrittenUrl", "rewadjustedUr", "RewwrittenURL", "rewriteUr", "rewroteLink", "rewriteURL", "rewrapedUr", "rewwrittenPosition", "RewwrittenPosition", "rewroteurl", "rewittenURL", "rewartedurl", "rewadjustedURL", "rewwrittenLink", "rewriddenURL", "rewrapedPort", "rewrownURL", "rewrownPosition", "rewartedUr", "rewriteUrl", "rewroteUr", "rewrittenLink", "rewedString", "rewittenUrl", "RewrittenURL", "rewwrittenString", "rewrittenurl", "rewartedUrl", "RewwrittenLink", "rewrapedUrl", "rewedUrl", "RewrittenUr", "rewedUr", "rewwrittenURL", "rewroteURL", "rewrownUr", "rewadjustedPort", "rewrotePosition", "RewwrittenUrl", "rewittenurl", "rewrittenString", "rewedURL", "rewriterURL", "rewroteUrl", "Rewwrittenurl", "rewwrittenUr", "rewartedURL", "RewrittenPort", "RewwrittenPort", "rewriddenUrl", "rewrittenURL", "rewriterUr", "rewriddenPosition", "rewwrittenurl", "Rewrittenurl", "rewriterString", "rewrittenPort", "rewartedPosition"], "httpURLConnection": ["httpSRConnect", "httpUrlConn", " httpURLConnect", "HttpHTTPApplication", "ttpUrlConnection", "httpFileConn", "ttpUrlApplication", "httpURLConfiguration", "HttpURLApplication", "httpMLconnection", "httpURLconnection", "httpSRConnection", "ttpURLConnection", "httpURLConn", "httpFileConnection", "ttpURLApplication", "httpUrlControl", "ttpURLConnect", "httpMLApplication", "ttpURLconnection", " httpUrlConnection", "httpUrlConnect", "httpHTTPApplication", "httpRLconnection", "httpSRconnection", " httpUrlApplication", "HttpURLConnection", "ttpUrlConnect", "httpHTTPControl", "httpRLConnect", "httpURLConnect", "HttpHTTPconnection", "httpFileConnect", "httpUrlconnection", "httpHTTPConfiguration", " httpUrlConnect", "HttpUrlconnection", "httpRLApplication", "httpURLControl", "HttpUrlConnect", " httpURLconnection", "ttpUrlConn", "ttpURLConn", "HttpHTTPConnect", "httpHTTPconnection", "httpRLConnection", "httpUrlApplication", "httpFileApplication", "httpSRControl", "HttpHTTPConfiguration", "ttpUrlconnection", "httpSRConfiguration", "httpHTTPConnection", "httpUrlConfiguration", "ttpURLControl", "httpSRApplication", "ttpUrlControl", "httpHTTPConn", "HttpURLconnection", "httpUrlConnection", "HttpURLConnect", "httpURLApplication", "HttpURLConfiguration", " httpUrlconnection", "httpMLConnection", "HttpUrlConnection", " httpURLApplication", "httpHTTPConnect", "httpMLConnect", "HttpHTTPConnection"], "header": ["event", "rule", "handle", "zone", "block", "address", "shift", "policy", "layer", "column", "part", "comment", "feature", "argument", "h", "option", "client", "status", "page", "tag", "prefix", "init", "port", "attribute", "buffer", "device", "dr", "detail", "format", "variable", "state", "head", "token", "hidden", "hash", "operator", "section", "meta", "query", "Header", "metadata", "handler", "component", "term", "peer", "headers", "line", "filter", "relation", "padding", "info", "core", "er", "heading", "field", "version", "user", "wrapper", "check", "holder", "ter", "title"], "value": ["json", "text", "zone", "vector", "element", "default", "pair", "sample", "entry", "test", "hello", "email", "comment", "description", "sequence", "create", "VALUE", "label", "attribute", "ue", "message", "current", "v", "property", "content", "format", "sv", "see", "example", "Value", "address", "name", "hash", "des", "val", "language", "record", "instance", "key", "python", "string", "save", "values", "server", "field", "job", "password", "version", "unit", "data", "expression"], "inputStream": ["InputStream", "outputWindow", "outputView", "inputLoop", " inputSteam", "inputSteam", "errorStream", "errorWindow", "InputView", "outputThread", " inputWindow", "InputThread", "errorstream", "outputSteam", "outputstream", "inputstream", " inputLoop", "inputView", " inputThread", "errorSteam", "InputLoop", "outputLoop", " inputView", "inputThread", " inputstream", "inputWindow"], "outputStream": [" outputLength", "outputView", "responseForm", "outputForm", "inputSteam", "displayView", "OutputStream", " outputView", "displayStream", "displaySteam", "OutputLength", "responseLength", "displaystream", "responseSteam", "OutputSteam", " outputSteam", "outputSteam", "outputstream", "inputstream", "OutputForm", "outputLength", "inputView", " outputstream", " outputForm", "responseStream"]}}
{"id1": "3252116", "id2": "22022715", "code1": "    public static String getMD5(String source) {\n        String s = null;\n        char hexDigits[] = { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f' };\n        try {\n            java.security.MessageDigest md = java.security.MessageDigest.getInstance(\"MD5\");\n            md.update(source.getBytes());\n            byte tmp[] = md.digest();\n            char str[] = new char[16 * 2];\n            int k = 0;\n            for (int i = 0; i < 16; i++) {\n                byte byte0 = tmp[i];\n                str[k++] = hexDigits[byte0 >>> 4 & 0xf];\n                str[k++] = hexDigits[byte0 & 0xf];\n            }\n            s = new String(str);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return s;\n    }\n", "code2": "    protected static final byte[] digest(String s) {\n        byte[] ret = null;\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"MD5\");\n            md.update(s.getBytes());\n            ret = md.digest();\n        } catch (NoSuchAlgorithmException e) {\n            System.err.println(\"no message digest algorithm available!\");\n            System.exit(1);\n        }\n        return ret;\n    }\n", "label": 1, "substitutes": {"getMD5": ["getHash5", "Getmd1", "GetMD10", "getMD4", "getHash4", "getHash1", "GetMD1", "getMD10", "getmd1", "Getmd5", "GetMD5", "getMC10", "GetMD4", "getmd10", "getMD1", "getMC4", "Getmd4", "getmd5", "getHash10", "getMC1", "getmd4", "Getmd10", "getMC5"], "source": ["origin", "f", "ser", "style", "image", "text", "subject", "output", "sample", "dest", "sequence", "secret", "site", "base", "template", "code", "c", "buffer", "b", "message", "src", "content", "Source", "e", "name", "copy", "target", "SOURCE", "input", "this", "object", "seed", "ource", "null", "string", "start", "file", "from", "data"], "s": ["xs", "ss", "ads", "sb", "ses", "p", " gets", "ends", "ins", "parts", "js", "a", "ws", "fs", "bs", "ls", "t", "hs", "ns", " ls", "ings", "cs", "b", "ps", "ts", "S", "its", " es", " streams", "ats", "rs", "os", "ds", "eps", "bes", " returns", "gs", " ts", " sets", " samples", " outputs", "uns", "sts", "gets", " fs", " ans", " rs", " ss", "es", "ies", "abs"], "hexDigits": ["hexdigists", "exdigits", "exDigitions", " hexDigals", "hexDigists", "hexdigit", " hexDigities", "hexDigitions", "hexdigals", "exDigities", "hexdigits", "hexDigbits", "hexFunals", "hexDigities", "hexDigit", "exdigals", "exdigities", "hexdigbits", "exdigitions", "hexdigitions", "hexDities", "hexFunbits", "hexPosals", "hexDits", " hexDigbits", "hexPosits", "exDigits", "hexFunit", "hexPosities", " hexDigit", " hexDigists", "exDigals", "hexDists", "hexdigities", "hexDitions", "hexDigals", " hexDigitions", "hexPositions", "hexFunits"], "md": [" Md", "nt", "sm", "pd", "ms", "od", "di", "d", "der", "mt", "amd", "m", "mod", "red", "dr", "rm", "det", "dm", "sd", "td", "nd", "cond", "dd", "cmd", "mb", "cd", "hd", "MD", "dig", "ind", "add", "grad", "mn", "desc", "mm", "mc", "ad", "mk", "de", "ld", "pdf", "bd", "df", "dh"], "tmp": ["xs", "txt", "buff", "dirty", "img", "cmp", "ctx", "test", "params", "sp", "cb", "js", "obj", "Temp", "table", "tt", "xy", "pkg", "mp", "bag", "fake", "perm", "cur", "sym", "db", "yy", "up", "nb", "sup", "qq", "proc", "comp", "np", "mb", "bis", "etc", "zip", "emp", "local", "html", "temp", "bytes"], "str": ["buf", "txt", "tr", "div", "br", "text", "cat", "vol", "cast", "sp", "ar", "cr", "obj", "m", "fr", "set", "t", "char", "c", "sl", "cs", "b", "ctr", "Str", "dr", "list", "v", "e", "name", "out", "iter", "it", "ch", "hex", "sc", "sw", "st", "stri", "r", "arc", "n", "gr", "string", "STR", "arr", "p", "print", "data", "w"], "k": ["ikk", "f", "kid", "ko", "j", "z", "p", "unk", "ke", "d", "tk", "h", "kh", "m", "kt", "set", "K", "kar", "t", "x", "q", "c", "b", "v", "sk", "ak", "l", "kj", "kl", "ck", "g", "kk", "ka", "km", "n", "key", "kw", "ok", "mk", "kan", "ku", "ks", "id", "kn", "ik", "w"], "i": ["mi", "u", "j", "ini", "I", "qi", "di", "im", "ri", "m", "status", "inter", "conv", "iu", " j", "x", "ti", "me", "hi", "chain", "bi", "in", "cli", "ic", "ci", "multi", "ai", "sim", "gi", "ui", "e", "v", "pi", "ij", "ix", "it", "ji", "li", "xi", "\u0438", "si", "o", "ip", "info", "n", "io", "ii", "is", "index", "zi", "p", "print", "phi"], "byte0": [" byte8", "Byte3", " byte6", "byte1", "node2", "byte2", "byte140", "Byte8", "channel0", "node8", "hexElement", "channel140", "node0", "channel3", "byte8", " byte3", "Byte140", "byte3", "Byte2", "pixel6", "pixel0", "channel1", "pixelElement", " byte1", "hex1", " byte2", "pixel1", "byte6", "Byte0", " byteElement", " byte140", "Byte1", "hex6", "hex0", "byteElement", "node1"]}}
{"id1": "7872659", "id2": "18793482", "code1": "    private static boolean genCustRatingFileAndMovieIndexFile(String completePath, String masterFile, String CustRatingFileName, String MovieIndexFileName) {\n        try {\n            File inFile = new File(completePath + fSep + \"SmartGRAPE\" + fSep + masterFile);\n            FileChannel inC = new FileInputStream(inFile).getChannel();\n            File outFile1 = new File(completePath + fSep + \"SmartGRAPE\" + fSep + MovieIndexFileName);\n            FileChannel outC1 = new FileOutputStream(outFile1, true).getChannel();\n            File outFile2 = new File(completePath + fSep + \"SmartGRAPE\" + fSep + CustRatingFileName);\n            FileChannel outC2 = new FileOutputStream(outFile2, true).getChannel();\n            int fileSize = (int) inC.size();\n            int totalNoDataRows = fileSize / 7;\n            ByteBuffer mappedBuffer = inC.map(FileChannel.MapMode.READ_ONLY, 0, fileSize);\n            int startIndex = 1, count = 0;\n            short currentMovie = 1;\n            while (mappedBuffer.hasRemaining()) {\n                count++;\n                short movieName = mappedBuffer.getShort();\n                int customer = mappedBuffer.getInt();\n                byte rating = mappedBuffer.get();\n                if (movieName != currentMovie) {\n                    ByteBuffer outBuf1 = ByteBuffer.allocate(10);\n                    outBuf1.putShort(currentMovie);\n                    outBuf1.putInt(startIndex);\n                    outBuf1.putInt(count - 1);\n                    outBuf1.flip();\n                    outC1.write(outBuf1);\n                    currentMovie = movieName;\n                    startIndex = count;\n                }\n                ByteBuffer outBuf2 = ByteBuffer.allocate(5);\n                outBuf2.putInt(customer);\n                outBuf2.put(rating);\n                outBuf2.flip();\n                outC2.write(outBuf2);\n            }\n            ByteBuffer endOfIndexFile = ByteBuffer.allocate(10);\n            endOfIndexFile.putShort(currentMovie);\n            endOfIndexFile.putInt(startIndex);\n            endOfIndexFile.putInt(100480506);\n            endOfIndexFile.flip();\n            outC1.write(endOfIndexFile);\n            outC1.close();\n            outC2.close();\n            return true;\n        } catch (IOException e) {\n            System.err.println(e);\n            return false;\n        }\n    }\n", "code2": "    public void modifyApplicationMessage(String locale, String messageName, String messageValue) {\n        Properties properties = new Properties();\n        try {\n            String i18nPath = ServerUtil.removelastResourceURL(ConfigurationServiceImpl.class.getResource(\"/es/ua/tranube/prototype/main/client/TranubeConstants_en.properties\").getPath()).toString();\n            File englishFile = new File(i18nPath + \"TranubeConstants_en.properties\");\n            if (!englishFile.exists()) throw new Exception(\"English file not found\");\n            String propertiesFilePath = i18nPath + \"TranubeConstants_\" + locale + \".properties\";\n            File file = new File(propertiesFilePath);\n            if (!file.exists()) {\n                FileReader in = new FileReader(englishFile);\n                FileWriter out = new FileWriter(file);\n                int c;\n                while ((c = in.read()) != -1) out.write(c);\n                in.close();\n                out.close();\n            }\n            InputStream is = ConfigurationServiceImpl.class.getResourceAsStream(\"/es/ua/tranube/prototype/main/client/TranubeConstants_\" + locale + \".properties\");\n            BufferedReader breader = new BufferedReader(new InputStreamReader(is));\n            String line = null;\n            StringBuilder strBuilder = new StringBuilder();\n            boolean found = false;\n            while ((line = breader.readLine()) != null) {\n                if (line.startsWith(\"#\")) strBuilder.append(line).append(\"\\n\"); else {\n                    String[] pieces = line.split(\"=\");\n                    if (pieces.length == 2) {\n                        if (pieces[0].trim().equals(messageName)) {\n                            strBuilder.append(pieces[0].trim() + \" = \" + messageValue + \"\\n\");\n                            found = true;\n                        } else strBuilder.append(line).append(\"\\n\");\n                    } else strBuilder.append(line).append(\"\\n\");\n                }\n            }\n            if (!found) strBuilder.append(messageName).append(\" = \").append(messageValue).append(\"\\n\");\n            breader.close();\n            is.close();\n            FileWriter writer = new FileWriter(file);\n            writer.write(strBuilder.toString());\n            writer.close();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n", "label": 1, "substitutes": {"genCustRatingFileAndMovieIndexFile": [" genCustRatingFileAndMovieVersionfile", " genCustRatingFileAndMovieindexTable", " genCustRatingFileAndVideoindexFiles", " genCustRatingFileAndMovieIndexFiles", " genCustRatingFileAndVideoIndexfile", " genCustRatingFileAndMovieVersionFile", " genCustRatingFileAndVideoindexfile", " genCustRatingFileAndMovieIndexfile", " genCustRatingFileAndVideoIndexTable", " genCustRatingFileAndVideoindexFile", " genCustRatingFileAndVideoIndexFile", " genCustRatingFileAndMovieVersionTable", " genCustRatingFileAndMovieindexfile", " genCustRatingFileAndMovieindexFiles", " genCustRatingFileAndMovieindexFile", " genCustRatingFileAndMovieIndexTable", " genCustRatingFileAndMovieVersionFiles", " genCustRatingFileAndVideoIndexFiles", " genCustRatingFileAndVideoindexTable"], "completePath": [" completeDirectory", "completeScript", "fullLocation", "COMPLELog", "completeDir", " completesLocation", "completePod", "pleteLocation", "pleteDir", "completeDirectory", "pletionProject", "CompleteDirectory", "pletionPath", "totalRoot", "totalLocation", "CompleteLog", " completeLocation", "CompleteDir", "COMPLEScript", "fullPath", "completeRoot", "pletePath", " completesDirectory", "CompleteScript", "CompletePath", "CompleteLocation", "pleteRoot", "fullPod", " completesPath", "completeNow", "completeProject", "totalPod", "pletionNow", "pleteScript", "totalPath", "COMPLEPath", "pleteProject", "completeLocation", "fullRoot", "pletePod", "pleteNow", "COMPLEDir", " completesDir", "pletionDir", "CompleteProject", "completeLog", "CompleteNow", " completeDir", "pleteLog"], "masterFile": ["currentName", "masterfile", "masterFilename", "managerPath", "MasterFile", " masterFilename", " masterPath", "completeName", "managerfile", "MasterName", "completefile", "managerFile", "currentfile", "managerFilename", "currentPath", "MasterPath", "Masterfile", " masterfile", "masterName", "MasterFilename", "completeFile", "masterPath", "currentFile"], "CustRatingFileName": ["CustRatingFilesName", "CustRankFilename", "CustRatingTableNames", "CustRatedFileSet", "CustRatingFilesInfo", "CustRatingFilesType", "CustRatedfileNames", "CustRatingFilenameNames", "CustRatedFileNames", "CustRatedfileType", "CustRankFileName", "CustRatedfileName", "CustRatingfileName", "CustRatingFileInfo", "CustRatingTablename", "CustRatingTableName", "CustRatingFilenameName", "CustRatingFileSet", "CustRankFileInfo", "CustRatingTableType", "CustRatingFilenameType", "CustRatingfileSet", "CustRatingFieldType", "CustRatingFieldInfo", "CustRatingFileNames", "CustRatingFileType", "CustRankFilesType", "CustRankFilesInfo", "CustRatedFileType", "CustRatedfileSet", "CustRankFilesName", "CustRatingFilesname", "CustRatingTableSet", "CustRatingFieldName", "CustRatedFileName", "CustRankFileType", "CustRatingfileType", "CustRatingfileNames", "CustRatingFieldname", "CustRatingTableInfo", "CustRatingFilename", "CustRatingFilenameSet", "CustRankFilesname"], "MovieIndexFileName": ["MovieIndexFileNumber", "MovieIndexFILEName", "MovieIndexfileType", "MovieindexFileNumber", "MovieindexFileNames", "MovieindexfileName", "MovieIndexFieldNames", "MovieindexFileKey", "MovieIndexFILEType", "MovieIndexFileKey", "MovieindexfileNumber", "MovieIndexfileName", "MovieIndexFileType", "MovieIndexTableKey", "MovieindexfileNames", "MovieindexfileKey", "MovieIndexFieldName", "MovieIndexFILENames", "MovieindexFileType", "MovieindexFileName", "MovieIndexFILENumber", "MovieIndexFileNames", "MovieIndexFieldType", "MovieIndexTableType", "MovieIndexFieldKey", "MovieIndexTableNames", "MovieIndexTableName", "MovieIndexfileKey", "MovieindexfileType", "MovieIndexfileNames", "MovieIndexfileNumber"], "inFile": ["inF", " infile", "INF", "outFile", "INFILE", "localFILE", "outfile", "localFile", "INfile", "localC", "localfile", "inFILE", "outC", "INFile", "outF", "INC", " inFILE", " inF", "infile"], "inC": [" outL", " inCI", "inF", "intC", " outC", "inputFile", " inG", " outF", "intCI", "outFile", "inCL", " inCS", "outG", "iCI", "outL", "iCS", "iR", " outCL", "inG", "inputF", "outC", "inputC", "inR", "outCL", "iC", "outF", "intR", "intCS", "inL", "inCS", " inL", " inF", "inCI", " inR", " inCL", "inputG"], "outFile1": ["outFile0", "outFile9", "outPage2", "outfile2", "outputFileOne", "outFileOnce", "outPage1", "outFILE1", "outputFile9", "outFileOne", "outputFile1", "outChannel9", "outFILE6", " outFile6", "outChannel1", "outPage9", "outfile0", "outfile1", "outFILE2", "outPage6", " outfile1", "outPageOne", "outputPage9", "outputPageOnce", " outfile6", "outFILE0", "outputPageOne", " outfile0", "outfile6", "outFile6", "outChannelOnce", "outPageOnce", " outFile0", "outputFileOnce", "outChannelOne", "outPage0", "outputPage1", " outfile2"], "outC1": ["inFile3", "inFileOne", "outROne", "outc3", "outC3", "outCB3", "outR3", "outc2", "outFileOne", "outPOne", "outc1", "outP1", "outCB1", "outP3", "outR1", "outR2", "inC0", "inC1", "outCB2", "outCOne", "inC2", "outFile3", "inCOne", "outCB0", "outP2", "inFile2", "outC0", "inC3", "inFile1", "outc0"], "outFile2": ["outFile0", "outF2", "outfile2", "outF1", " outFile02", " outFileTwo", "outF3", "outTable2", "exFile3", "exChannel2", "outChannel1", "exChannel3", "outfile0", "outfile1", "outTable3", "outFile02", "exFile1", "outChannel3", "outChannel0", "outChannel2", "exFile2", "outfile02", "outfileTwo", "outFileTwo", "exChannel1", "outFile3", " outFile3", "outF0", "exFile0", "outTable02", "exChannel0", "outTableTwo", "outfile3"], "outC2": ["allCTwo", "OutR1", "outE3", "outM22", "OutR2", "outE2", "outB22", "allB3", "outC3", "allC3", "outE4", "outC22", "outR3", "allC2", "OutR4", "outS2", "outS22", "OutC4", "allBTwo", "outR1", "outR2", "OutC1", "outM2", "outE1", "outBTwo", "outR4", "OutC2", "outMTwo", "allB22", "outB2", "allB2", "outS3", "outC4", "allC22", "outCTwo", "OutC3", "outSTwo", "outB3", "OutR3", "outM3"], "fileSize": ["byteLength", "baseSize", "fileSIZE", "FileName", "issueSize", " fileCount", "FileSIZE", "baseName", "baseSIZE", " fileSIZE", "issueName", "fileCount", "FileCount", " fileName", "issueSIZE", "FileSize", "byteName", "FileLength", "issueLength", "fileName", "fileLength", " fileLength", "byteSize", "byteSIZE", "baseCount"], "totalNoDataRows": ["totalNoDataRecoles", "totalNoDataRocks", "totalNoDataRecues", "totalNoDataSlues", "totalNodataRecocks", "totalNoDataRues", "totalNodataRecues", "totalNoDataRecocks", "totalNodataRues", "totalNodataRoles", "totalNodataRecows", "totalNoDataSloles", "totalNoDataSlows", "totalNoDataBocks", "totalNoDataSlocks", "totalNoDataBows", "totalNoDataBues", "totalNoDataRecows", "totalNoDataRoles", "totalNodataRocks", "totalNodataRecoles", "totalNodataRows", "totalNoDataBoles"], "mappedBuffer": ["mappingBuff", "mapperBuff", " mapedBuffer", "mmappedBuff", "MapedBB", " mapperCounter", "mapedCallback", " mapedBuff", "mapedQueue", "mattedData", "mappingData", "mmappingBuffer", "mappedQueue", "mressedBuff", "mappedBuff", "mappingBuffer", "mressedFB", "mmappedQueue", "maphBuff", "mapedBuffer", "mapedbuffer", " mappedFB", "maphCallback", "mapBuff", "mapperQueue", "matchedCounter", "maphBuffer", "matchedBuffer", "mappingCounter", " mapedFB", "mappedbuffer", " mapedCallback", "mattedBuff", "mappedData", "mattedBuffer", "mappingBB", "mappedCallback", "MapedData", "MapedBuff", "MappedData", "MappedBuffer", "mappingbuffer", " mapperBuff", "mressedBuffer", "mmappedBuffer", "mmappingbuffer", "mappedFB", "mapperBB", "mapedFB", "mmappingQueue", " mappedCallback", " mappedBuff", "mappingQueue", "mapedData", "mapBuffer", "matchedQueue", "mappedBB", "MapperBB", "MappedBB", "mapperbuffer", "MapperBuff", "MapedBuffer", "mressedCallback", "MappedBuff", "maphFB", "mmappingBuff", " mappedQueue", "mapedBB", "mapBB", "MapperBuffer", "matchedBuff", "mattedBB", "mapperCounter", "mapperBuffer", "mappedCounter", " mapperBuffer", " mappedCounter", "mmappedbuffer", " mapperQueue", "mapedBuff"], "startIndex": ["initindex", "StartIndex", "startIter", "StartInd", "StartPoint", "StartPosition", "firstIndex", "startPage", "startPos", "endPage", " startPage", "StartIter", " startPoint", "firstindex", " startPosition", "startPosition", " startPos", "initIndex", "firstPosition", "startInd", "Startindex", "endIter", "currentPoint", " startindex", "currentIndex", "currentPosition", "StartPos", "endIndex", " startInd", "initPosition", "startPoint", "currentPos", "StartPage", "startindex", "firstInd", " startIter", "endPosition"], "count": ["type", "first", "cloud", "process", "find", "con", "cast", "next", "depth", "force", "sum", "category", "status", "page", "limit", "code", "c", "ctr", "current", "call", "result", "max", "list", "conf", "mount", "number", "i", "counter", "act", "state", "name", "ount", "coll", "now", "total", "last", "order", "length", "continue", "amount", "batch", "Count", "ind", "found", "num", "add", "created", "n", "core", "info", "id", "start", "size", "more", "index", "check", "user"], "currentMovie": ["activeMovie", "reportedMusic", "activeSpider", "firstMouse", "currentDate", "currentMusic", "currentlyMovie", "firstMovie", "currentPlayer", "currentlySpider", "reportedMouse", "firstMonster", " currentMedia", "presentMusic", " currentPlayer", "currentlyHero", "reportedHero", " currentMonster", "presentHero", "currentlyDate", " currentVideo", "primaryMovie", "currentlyMonster", "currentMouse", "currentVideo", "primaryHero", "firstDate", "currentImage", "currentSpider", "reportedMovie", "currentlyPlayer", "reportedMedia", "presentImage", " currentSpider", " currentHero", " currentMouse", "currentMonster", "firstMedia", "primaryVideo", "activeVideo", "currentHero", "reportedImage", " currentImage", " currentMusic", "presentMovie", "currentlyVideo", "currentMedia", "activePlayer", "primaryDate", "firstVideo", "firstHero"], "movieName": ["ovieGroup", "filmName", "ovieNAME", " moviename", "movieNAME", "mpegNAME", "oviename", "filmNAME", "filmname", "mpegGroup", "moviename", "movieGroup", "httpname", "MovieType", " movieNAME", "monsterNAME", " movieTitle", "Moviename", "httpNAME", "MovieName", "MovieTitle", "movieTitle", " movieType", "ovieName", "filmType", "httpName", "mpegname", "filmGroup", "monsterName", "monstername", "movieType", "filmTitle", "mpegName"], "customer": ["CustomER", "customER", "sticker", " customator", "customity", "stickity", "developity", " customER", "Customity", "customator", "ustomator", "developorder", "customorder", "developizer", "stickizer", "stickER", "ustomer", "Customizer", "developer", "developER", "ustomorder", " customorder", "developator", "ustomER", "Customer", "customizer"], "rating": ["type", "playing", "boarding", "setting", "score", "option", " Rating", "credit", "tag", "ating", "rank", "average", "rat", "strength", "attribute", "ping", "rated", "testing", "review", "format", "rage", "having", "saving", "error", "Rating", "rate", "ranking", "scoring", "term", "weight", "core", "scale", "heading", "reading", "user", "reporting", "card", "translation"], "outBuf1": ["outBool3", "outBbufOne", "outBfx0", "outBuc5", "outBuff0", "outBdf1", "outBBuff0", "outBBuff11", "outBurg0", "outBuf64", "outBuff1", "outBuf5", "outBuffy1", "outBurg3", "outBdf64", "outRbuf0", "outBurg1", "outBulp64", "outBlf3", "outBulp3", "outRbuf18", "outBbuf18", "outBuf11", "outBuffy0", "outBbuf11", "outBufOnce", "outBooll", "outDuf11", "outBuffyl", "outBbufone", "outBulp1", "outDbuf0", "outBulpOnce", "outRufOne", "outBuff3", "outDuf0", "outBuffy3", "outRbufOne", "outBbufOnce", "outDuf1", "outBBuff1", "outBbuf0", "outBuf3", "outBbuf5", "outBufone", "outBbuf64", "outDbuf3", "outBbuf3", "outBuff2", "outBurg18", "outRuf3", "outBfx11", "outRuf18", "outBuffy18", "outDbuf1", "outBuffyone", "outBucOne", "outRuf5", "outBlf2", "outBbufl", "outBfx1", "outBool1", "outRuf1", "outBdfOnce", "outRbuf3", "outDuf3", "outBuf0", "outBlf1", "outBBuff3", "outBfx3", "outBlf0", "outRbuf1", "outRuf0", "outBufOne", "outBoolone", "outDbuf11", "outBuc1", "outBuc0", "outBdf3", "outBufl", "outBbuf1", "outBuf18", "outRbuf5"], "outBuf2": ["outBufTwo", "outBbuff15", "outBuf02", "outBuffj", "outMuf2", "outBuffy02", "outMuf3", "outBuffTwo", "outBbuf02", "outBfx15", "outBuffy4", "outBfgTwo", "outMbuf15", "outFbuf2", "outBfx1", "outBuf3", "outBbuf15", "outFufTwo", "outBuff4", "outBfg02", "outFbuf4", "outBuf15", "outBfg2", "outBbuff3", "outBfx3", "outBbufTwo", "outBbuf3", "outMuf15", "outMbuf2", "outBfx2", "outMbuf1", "outBuff2", "outFbufTwo", "outBuf42", "outBuff42", "outFuf4", "outFbuf02", "outBbuff2", "outFuf02", "outBuff3", "outMbuf3", "outBuff1", "outBuf4", "outBbuf2", "outBbufj", "outBbuff1", "outBbuff4", "outBbuf42", "outBuffy2", "outBuffyTwo", "outBbuff42", "outBbuf4", "outBufj", "outBbuffj", "outBuffy3", "outBbuf1", "outMuf1", "outFuf2", "outBfg4"], "endOfIndexFile": ["endOfIndLine", "endOfErrorF", "endofindexFile", "endOfIndexfile", "endFile", "endOfErrorFile", "endOfIndfile", "endofIndexfile", "endOfPositionFiles", "endOFIndexFile", "endOFIndexLine", "EndFile", "endOfindexTable", "endOfErrorFiles", "endOFindexFile", "endOfindexLine", "endOFindexfile", "endofIndexTable", "endofIndexF", "endOFindexLine", "endOfErrorfile", " endFile", "endofindexTable", "endofindexfile", "endofindexF", "endOfindexF", "endOfIndexFiles", "endOfindexfile", "endofIndexFile", "endOfIndFile", "endOfIndexLine", "endofindexFiles", "endofIndexFiles", "endOFIndexfile", "endOfPositionFile", "endOfindexFiles", "endOfIndexF", "endOfPositionfile", "endOfPositionTable", "endOfIndexTable", "endOfindexFile", "endedFile"]}}
{"id1": "3430784", "id2": "22536033", "code1": "    public static Body decodeBody(InputStream in, String contentTransferEncoding) throws IOException {\n        if (contentTransferEncoding != null) {\n            contentTransferEncoding = MimeUtility.getHeaderParameter(contentTransferEncoding, null);\n            if (\"quoted-printable\".equalsIgnoreCase(contentTransferEncoding)) {\n                in = new QuotedPrintableInputStream(in);\n            } else if (\"base64\".equalsIgnoreCase(contentTransferEncoding)) {\n                in = new Base64InputStream(in);\n            }\n        }\n        BinaryTempFileBody tempBody = new BinaryTempFileBody();\n        OutputStream out = tempBody.getOutputStream();\n        IOUtils.copy(in, out);\n        out.close();\n        return tempBody;\n    }\n", "code2": "    private boolean setPayload() throws IOException {\n        if (Index < Headers.length) {\n            FileOutputStream fos = new FileOutputStream(Headers[Index], true);\n            FileInputStream fis = new FileInputStream(HeadlessData);\n            FileChannel fic = fis.getChannel();\n            FileChannel foc = fos.getChannel();\n            fic.transferTo(0, fic.size(), foc);\n            fic.close();\n            foc.close();\n            setDestination(Destinations[Index]);\n            setPayload(Headers[Index]);\n            Index++;\n            return true;\n        }\n        return false;\n    }\n", "label": 1, "substitutes": {"decodeBody": ["decodedForm", " DecodeBody", "decodeContent", "decodedHeader", "decodedContent", " DecodeContent", " DecodeHeader", "decodesContent", "decprocessContent", "decprocessBody", " DecodesContent", "decodedBody", " DecodeForm", "decodesHeader", "decodesForm", "decprocessForm", "decodesBody", "decodeForm", " DecodesForm", "decprocessHeader", " DecodesBody", "decodeHeader", " DecodesHeader"], "in": ["IN", "ins", "h", "oin", "In", "inner", "q", "c", "to", "up", "v", "mat", "get", "inc", "pi", "or", "iter", "it", "sql", "form", "nin", "info", "n", "inf", "isin", "from", "all", "en", "rin", "cont", "reader", "on", "doc", "al", "inside", "asin", "i", "req", "act", "pc", "conn", "ind", "mm", "din", "is", "file", "cin", "check", "inn", "con", "k", "b", "xml", "serv", "input", "ain", "ma", "body", "data", "gin", "vin", "m", "init", "load", "ai", "content", "bin", "ac", "l", "add", "r", "source", "ex"], "contentTransferEncoding": ["contentTransferEncoded", "contentTransferencacing", "contentTransferencoding", "contentTransferEnling", "contentTransferEnType", "contentRequestEncication", "contentTransferAuthoding", "contentTransferColloding", "contentTransferEnation", "contentRequestEncasting", "contentTransferEncode", "contentRequestEnoding", "contentTransferFormType", "contentRequestEnasting", "contentInfoencoding", "contentTransferEncapping", "contentTransferSeode", "contentTransferEvoded", "contentTransferEncication", "contentTransferEncation", "contentRequestEnation", "contentTransferSeoded", "contentRequestencoder", "contentTransferEnode", "contentTransferEnapping", "contentTransferEnoding", "contentTransferEncoder", "contentTransferEvication", "contentTransferencoder", "contentTransferChoding", "contentRequestencoding", "contentInfoEncling", "contentTypeEncapping", "contentRequestencoded", "contentRequestEncation", "contentRequestEnoder", "contentTypeEncode", "contentTransferFormoding", "contentTransferencling", "contentInfoEncacing", "contentRequestEncoding", "contentTransferChode", "contentTransferAuthoded", "contentTypeEnoded", "contentTypeEnapping", "contentTransferCollation", "contentTypeEnoding", "contentTransferFormoder", "contentRequestEncType", "contentTypeEncoding", "contentInfoencacing", "contentTransferencType", "contentTypeEnode", "contentTransferEncasting", "contentTransferEncacing", "contentInfoencling", "contentTransferencoded", "contentTransferAuthoder", "contentTransferEnoder", "contentTransferEnacing", "contentTransferChapping", "contentTransferColloder", "contentTransferFormling", "contentTransferEncling", "contentTypeEncoded", "contentRequestEncoder", "contentTransferencication", "contentTransferCollasting", "contentInfoEncoding", "contentRequestEncoded", "contentInfoencoder", "contentInfoEncoder", "contentTransferEnoded", "contentTransferEvoding", "contentTransferEnasting", "contentTransferAuthType", "contentRequestEnType", "contentTransferSeapping", "contentTransferEnication", "contentRequestEnoded", "contentRequestencication", "contentTransferChoded", "contentTransferSeoding", "contentTransferEvoder", "contentTransferEncType"], "tempBody": [" temporaryReturn", " temporaryBox", " tempFile", "temFile", " temporaryBody", "tempFoot", "tabReturn", "tempHead", "tabBody", "temReturn", "Tempbody", "temBody", "temFoot", "temHead", "tabFoot", "temBox", "tempbody", "tmpbody", " temporaryFoot", " tempHead", "TempFile", "tmpBody", "TempHead", "tmpBox", "tembody", "tempFile", "tempBox", "tempReturn", " tempBox", " tempbody", "tabBox", "TempBody", "tmpHead"], "out": ["all", "co", "con", "output", "cos", "res", "oss", "cn", "obj", "m", "client", "sys", "sum", "conv", "t", "inner", "one", "net", "log", "to", "up", "v", "gc", "writer", "os", "l", "outer", "ent", "it", "OU", "null", "ou", "outs", "o", "aos", "inv", "auto", "n", "io", "is", "Out", "OUT", "user", "cin", "ex"]}}
{"id1": "23291583", "id2": "4750967", "code1": "    private ByteArrayInputStream fetchUrl(String urlString, Exception[] outException) {\n        URL url;\n        try {\n            url = new URL(urlString);\n            InputStream is = null;\n            int inc = 65536;\n            int curr = 0;\n            byte[] result = new byte[inc];\n            try {\n                is = url.openStream();\n                int n;\n                while ((n = is.read(result, curr, result.length - curr)) != -1) {\n                    curr += n;\n                    if (curr == result.length) {\n                        byte[] temp = new byte[curr + inc];\n                        System.arraycopy(result, 0, temp, 0, curr);\n                        result = temp;\n                    }\n                }\n                return new ByteArrayInputStream(result, 0, curr);\n            } finally {\n                if (is != null) {\n                    try {\n                        is.close();\n                    } catch (IOException e) {\n                    }\n                }\n            }\n        } catch (Exception e) {\n            if (outException != null) {\n                outException[0] = e;\n            }\n        }\n        return null;\n    }\n", "code2": "    public void patch() throws IOException {\n        if (mods.isEmpty()) {\n            return;\n        }\n        IOUtils.copy(new FileInputStream(Paths.getMinecraftJarPath()), new FileOutputStream(new File(Paths.getMinecraftBackupPath())));\n        JarFile mcjar = new JarFile(Paths.getMinecraftJarPath());\n    }\n", "label": 0, "substitutes": {"fetchUrl": ["FetchUrl", "faultUrl", "Fetchurl", "fectUrl", "fectString", "fecturl", "FetchURL", "faultURL", "faulturl", "FetchString", "fetchString", "fetchurl", "fectURL", "faultString", "fetchURL"], "urlString": ["urlName", "UrlString", "urlStr", "urlstring", "UrlRest", " urlstring", "lSeries", "uristring", "lStr", "uriString", "sslSeries", "uriRest", " urlName", "sslString", " urlSeries", "Urlstring", "sslName", "sslStr", "urlSeries", "urlRest", "lName", "lString", " urlRest", " urlStr"], "outException": ["cnExample", "outTransaction", " outCondition", "outExample", "OUTExample", " OUTTransaction", "outCondition", "inExample", " outTransaction", " OUTExample", "cnEvent", " OUTEvent", "inError", " OUTException", "inException", " outEvent", "cnException", "inAddress", "OUTError", "OutCondition", "inCondition", "OUTTransaction", "OutEvent", "OutAddress", "OUTException", "cnError", "outError", " outAddress", " outExample", "outAddress", "inEvent", "OutException", "outEvent", "OUTEvent"], "url": ["hl", "gl", "address", "u", "dll", "dl", "bl", "email", "www", "https", "lt", "bel", "web", "ls", "ll", "base", "char", "link", "pl", "build", "sl", "pkg", "log", "cert", "b", "impl", "rel", "xml", "ur", "org", "mount", "uri", "URL", "str", "rl", "get", "l", "nl", "ul", "mail", "github", "hub", "r", "ssl", "el", "channel", "http", "download", "job", "il", "Url", "ml", "host"], "is": ["xs", "ois", "ms", "res", "mos", "oss", "im", "Is", "js", "ri", "fs", "sys", "bs", "ls", "isa", "ais", "init", "in", "dis", "abs", "ism", "tis", "bits", "vis", "sim", "ires", "i", "its", "serv", "ris", "os", "IS", "has", "ys", "eps", "was", "isc", "ir", "ims", "isl", "lis", "s", "bis", "ip", "isf", "ists", "isi", "iso", "ios", "isin", "still", "iss", "ils", "inst", "ib", "es", "sis"], "inc": ["exp", "rc", "include", "Inc", "dec", "step", "inn", "min", "ins", "integ", "occ", "enc", "pp", "ln", "pad", "init", "in", "acc", "err", "c", "ctr", "asc", "ac", "const", "ec", "iter", "ch", "sc", "isc", "exc", "ind", "INC", "num", "add", "count", "inf", "width", "zero", "ipl", "index", "rec", "incre", "dc", "frac", "cc"], "curr": ["Currid", "chp", "currc", " curR", "corl", "curmr", "Currs", "corrd", "currd", "constrs", "catr", "contr", "Curl", " currs", "curn", "chr", "corn", " currb", " currid", " curn", "contp", "curR", " curp", "chR", "urrc", "currb", "grp", "rcmr", "currs", "contrd", "grrs", "catrs", "rcl", "constrid", " curmr", "Curr", "currid", "curl", "grr", "chn", "corp", "contn", "urr", "Currc", "rcrs", "corr", "Curmr", " currc", "rcr", " currd", "corrb", "grrc", " curl", "Curp", "CurR", "contl", "curp", "Currb", "catrid", "contrc", "Curn", "constr"], "result": ["phrase", "all", "report", "buf", "csv", "response", "block", "value", "text", "res", "output", "RESULTS", "next", "test", "match", "description", "summary", "sequence", "currency", "status", "table", "page", "prefix", "tmp", "command", "buffer", "master", "message", "cur", "current", "list", "cache", "false", "success", "total", "complete", "successful", "valid", "proc", "rue", "this", "true", "search", "answer", "term", "null", "length", "record", "pre", "batch", "rendered", "collection", "r", "ret", "row", "repl", "memory", "data", "results", "Result"], "n": ["f", "na", "en", "nt", "nm", "j", "z", "N", "nan", "gn", "y", "ng", "d", "cn", "nn", "yn", "m", "ln", "ll", "t", "ns", "c", "nor", "un", "v", "i", "e", "number", "name", "le", "nu", "l", "len", "np", "nl", "s", "sn", "g", "o", "num", "r", "el", "nr", "nc", "ren", "no", "fn", "an", "p", "ne"], "temp": ["txt", "tr", "buff", "orig", "test", "unt", "create", "tmp", "Temp", "tv", "t", " tmp", "tt", "met", "template", "mod", "mem", "em", "buffer", " Temp", "mp", "fake", "perm", "current", "tty", "v", "ph", "ptr", "variable", "alt", "copy", "pt", "partial", "tab", " temporary", "term", "dat", "pre", "tc", "created", "porary", "tem", "emp", "mm", "make", "local", "EMP", "tm"]}}
{"id1": "14758866", "id2": "20886320", "code1": "    public synchronized InputStream getResourceAsStream(String name) {\n        InputStream inputStream = null;\n        BufferedInputStream in = null;\n        BufferedOutputStream out = null;\n        try {\n            URL url = getResource(name);\n            String remoteName = url.toExternalForm();\n            String localName = (String) cacheHashtable.get(remoteName);\n            if (localName != null) {\n                System.out.println(\"Retrieving \\\"\" + localName + \"\\\"...\");\n                return new FileInputStream(localName);\n            }\n            String host = url.getHost();\n            String prot = url.getProtocol();\n            int port = url.getPort();\n            File cacheFile = new File(cacheDir, prot + File.separator + host + File.separator + \"port\" + (port == -1 ? \"\" : Integer.toString(port)) + File.separator + name);\n            cacheFile = new File(cacheFile.getCanonicalPath());\n            localName = cacheFile.getCanonicalPath();\n            System.out.println(\"Comparing \\\"\" + localName + \"\\\"...\");\n            URLConnection urlConnection = url.openConnection();\n            if (cacheFile.exists()) {\n                urlConnection.setIfModifiedSince(cacheFile.lastModified());\n            }\n            if (urlConnection instanceof HttpURLConnection) {\n                HttpURLConnection httpURLConnection = (HttpURLConnection) urlConnection;\n                httpURLConnection.setFollowRedirects(true);\n                httpURLConnection.setRequestMethod(\"GET\");\n                int responseCode = httpURLConnection.getResponseCode();\n                System.out.println(httpURLConnection.getResponseMessage() + \", \" + httpURLConnection.getContentLength() + \" bytes\" + \", \" + new Date(httpURLConnection.getDate()) + \", \" + new Date(httpURLConnection.getLastModified()));\n                if (responseCode != HttpURLConnection.HTTP_OK) {\n                    return null;\n                }\n            }\n            inputStream = urlConnection.getInputStream();\n            if (inputStream == null) return null;\n            if (cacheFile.exists()) {\n                long lastModified = urlConnection.getLastModified();\n                if ((lastModified > 0) && (lastModified < cacheFile.lastModified())) {\n                    inputStream.close();\n                    cacheHashtable.put(remoteName, localName);\n                    System.out.println(\"Retrieving \\\"\" + localName + \"\\\"...\");\n                    return new FileInputStream(cacheFile);\n                }\n            }\n            File parentFile = new File(cacheFile.getParent());\n            parentFile.mkdirs();\n            localName = cacheFile.getCanonicalPath();\n            System.out.println(\"CACHING \\\"\" + localName + \"\\\"...\");\n            in = new BufferedInputStream(inputStream);\n            out = new BufferedOutputStream(new FileOutputStream(cacheFile));\n            int i;\n            while ((i = in.read()) > -1) out.write(i);\n            out.close();\n            in.close();\n            cacheHashtable.put(remoteName, localName);\n            System.out.println(\"Retrieving \\\"\" + localName + \"\\\"...\");\n            return new FileInputStream(localName);\n        } catch (Exception ex) {\n            try {\n                inputStream.close();\n            } catch (Exception ex1) {\n            }\n            try {\n                in.close();\n            } catch (Exception ex1) {\n            }\n            try {\n                out.close();\n            } catch (Exception ex1) {\n            }\n            ex.printStackTrace();\n            return null;\n        }\n    }\n", "code2": "    @Override\n    public List<SearchResult> search(String query, SortOrder order, int maxResults) throws Exception {\n        if (query == null) {\n            return null;\n        }\n        String encodedQuery = \"\";\n        try {\n            encodedQuery = URLEncoder.encode(query, \"UTF-8\");\n        } catch (UnsupportedEncodingException e) {\n            throw e;\n        }\n        final int startAt = 0;\n        final int pageNr = (startAt - 1) / 30;\n        final String url = String.format(QUERYURL, encodedQuery, String.valueOf(pageNr), (order == SortOrder.BySeeders ? SORT_SEEDS : SORT_COMPOSITE));\n        HttpParams httpparams = new BasicHttpParams();\n        HttpConnectionParams.setConnectionTimeout(httpparams, CONNECTION_TIMEOUT);\n        HttpConnectionParams.setSoTimeout(httpparams, CONNECTION_TIMEOUT);\n        DefaultHttpClient httpclient = new DefaultHttpClient(httpparams);\n        httpclient.getParams().setParameter(\"http.useragent\", \"Mozilla/5.0 (Windows; U; Windows NT 6.1; en-US; rv:1.9.2.2) Gecko/20100316 Firefox/3.6.2\");\n        HttpGet httpget = new HttpGet(url);\n        HttpResponse response = httpclient.execute(httpget);\n        InputStream instream = response.getEntity().getContent();\n        String html = HttpHelper.ConvertStreamToString(instream);\n        instream.close();\n        return parseHtml(html);\n    }\n", "label": 0, "substitutes": {"getResourceAsStream": ["getResourceasForm", "getResourceInSteam", "getResourceInInput", "getStreamasStream", "getResourceAsSteam", "getResourceasStream", "getResourceAsInput", "getStreamasInput", "getResourceInForm", "getResourceASSteam", "getResourceASForm", "getResourceAsForm", "getStreamAsForm", "getStreamAsSteam", "getResourceASInput", "getStreamasSteam", "getResourceInStream", "getResourceASStream", "getStreamAsInput", "getStreamasForm", "getStreamAsStream", "getResourceasInput", "getResourceasSteam"], "name": ["type", "image", "address", "part", "word", "resource", "description", "a", "client", "run", "names", "base", "pkg", "missing", "filename", "format", "cache", "uri", "error", "initial", "NAME", "search", "path", "ame", "local", "domain", "key", "n", "string", "location", "remote", "file", "password", "source", "size", "version", "id", "Name", "prefix", "title"], "inputStream": ["inputForm", "InputChannel", "rawstream", "InputStream", "inputFile", "rawStream", " inputForm", "uploadSteam", " inputSteam", "inputSteam", "quickForm", " inputChannel", "quickChannel", " inputFile", "inputChannel", "currentSteam", "rawSteam", "InputFile", "quickStream", "uploadView", "InputPort", "currentStream", " inputPort", "uploadstream", "rawView", "inputstream", "inputPort", "inputView", "currentPort", "quickSteam", "InputSteam", "InputForm", "uploadStream", " inputView", " inputstream", "currentFile"], "in": ["con", "IN", "ins", "m", "stream", "In", "context", "inner", "buffer", "edIn", "ai", "xml", "bin", "input", "o", "r", "mc", "info", "n", "io", "din", "inf", "file", "p", "data"], "out": ["all", "report", "nt", "output", "res", "ins", "cn", "obj", "m", "client", "ln", "sys", "tmp", "inter", "conv", "t", "inner", "dis", "c", "net", "log", "b", "to", "buffer", "err", "list", "up", "cache", "writer", "os", "l", "outer", "pretty", "last", "conn", "gov", "ou", "dir", "outs", "o", "cfg", "group", "inv", "screen", "info", "n", "io", "msg", "Out", "OUT", "user", "p", "print", "ex", "w"], "url": ["f", "browser", "handle", "hl", "gl", "address", "ref", "git", "dl", "resource", "https", "bel", "raw", "ls", "web", "ll", "base", "char", "link", "addr", "log", "build", "b", "impl", "call", "rel", "re", "ur", "mount", "xml", "uri", "URL", "cl", "get", "rl", "str", "l", "this", "nl", "sql", "mail", "path", "github", "r", "ssl", "el", "domain", "http", "location", "remote", "html", "server", "file", "loc", "il", "Url", "abs"], "remoteName": ["externalPath", "commonname", " remoteKey", "localPath", "remoteKey", "remotePath", "externalname", "quickName", "externalName", "commonPath", "quickPath", " remotename", "quickKey", "localname", "remotename", "localKey", "commonName", " remotePath", "quickname", "externalKey", "commonKey"], "localName": ["localImage", " localValue", "fullNames", "localNames", "locValue", " localNode", "remoteFile", "shortname", " localFile", "shortFilename", "remoteKey", " localKey", "fullValue", "locNode", "remoteValue", "shortName", " localNames", "localType", "remoteType", "remoteFilename", "localFile", "singlename", "fixedName", "locFilename", "fullName", "locName", "localNode", "locFile", " localImage", " localname", "Localname", "localname", "localFilename", "locImage", "remoteImage", "fullname", "localKey", "localNAME", " localFilename", "fullKey", "fixedFilename", "locType", "remoteNode", "shortNAME", "LocalKey", "remoteNames", "fixedNAME", "singleFilename", "LocalValue", " localType", "singleName", "singleNAME", "fixedname", "LocalName", "LocalNames", "localValue"], "host": ["handle", "address", "home", "subject", "ost", "Host", "h", "www", "client", "base", "chain", "addr", "ca", "cert", "system", "uri", "target", "localhost", "top", "bind", "hop", "path", "height", "dir", "hook", "hd", "ip", "domain", "local", "http", "remote", "campus", "source", "loc", "root", "server"], "prot": ["type", "iot", "ref", "prop", "tp", "platform", "client", "https", "eth", "col", "sche", "net", "pkg", "ping", "system", "pro", "format", "uri", "top", "tel", "rot", "path", "at", "ocol", "prototype", "Prot", "ssl", "pattern", "typ", "ret", "http", "ht", "pat", "pool", "password", "version", "ios", "server", "prefix", "header", "crypt"], "port": ["proxy", "report", "Port", "pid", "test", "pport", "column", "client", "page", "trace", "limit", "priority", "message", "ping", "post", "pro", "number", "position", "pt", "pi", "localhost", "trust", "note", "point", "project", "length", "PORT", "language", "ports", "padding", "key", "ort", "socket", "width", "eport", "file", "timeout", "password", "version", "size", "pool", "p", "print", "server", "pe", "duration"], "cacheFile": ["cacheEntry", " cacheFILE", "CacheEntry", "apachefile", "cacheStore", "localField", "localDir", "mapFile", "proxyInfo", "Cachefile", " cacheFiles", " cachefile", "cacheFilename", "cacheDir", "localStore", "CacheFILE", "mapfile", "CacheFile", "CacheFolder", "CacheFilename", "acheField", "tempFilename", " cacheStore", "cacheUser", "cacheFolder", "mapStore", "acheDir", "apacheInfo", " cacheField", "apacheFolder", "localFiles", "localFile", "localEntry", "cachefile", "cacheInfo", "acheUser", " cacheUser", "localfile", "CacheDir", "apacheFile", "cacheFILE", " cacheFilename", "tempfile", " cacheDir", "tempFILE", " cacheEntry", "acheFile", " cacheInfo", "mapDir", "cacheFiles", "CacheStore", "tempFile", "cacheField", "proxyfile", "proxyFile", "acheFolder", " cacheFolder", "CacheFiles", "achefile", "localUser", "proxyFolder"], "urlConnection": ["urlconnection", " urlconnection", "channelConnect", "methodConnection", "llconnection", "browserConnection", "dlconnection", "methodLink", "browserconnection", "llConnection", "URLConnection", "urlFile", "sslconnection", " urlConnect", "browserFile", "Urlconnection", "httpconnection", "sslTransaction", "urlConn", "urlComment", "methodconnection", "dlConn", "URLConn", "URLFile", "httpFile", "browserConnect", "browserResponse", "httpConnect", "urlTransaction", "httpLink", "channelComment", "methodConnect", "UrlConnect", "sslConnect", " urlTransaction", "httpConn", "UrlLink", "llConnector", "URLConnector", "llConn", "urlLink", "httpConnection", "browserConn", "dlConnect", "dlConnection", "UrlResponse", "UrlConnection", "channelConnector", "channelConnection", "browserConnector", "httpTransaction", "urlResponse", "URLConnect", "urlConnector", "urlConnect", "dlConnector", "dlComment", " urlResponse", "URLComment", "sslConnection"], "httpURLConnection": ["HttpURLInstance", " httpMLConnection", "httpHTTPInstance", "githubUrlConnect", "httpDBTransaction", "httpSRConnect", "httpSSLEntry", "httpULConnection", " httpURLConnect", "httpTLConnection", "httpILConnection", "httpsURLConnect", "httpREConnect", "HttpURLConn", "httpULInstance", "httpDBconnection", "httpSSLConnect", "httpDOMEntry", "historyURLConnect", "webUrlEntry", "HttpHTTPConn", "httpPORTConnect", "httpALLConnection", "httpMLconnection", "httpURLconnection", "HttpHTTPEntry", "httpSRConnection", "httpsHTTPConn", "HttpURLConnector", "githubURLConnect", "httpREConn", " httpURLConn", "httpDOMconnection", "httpUrlConnector", "httpURLConn", "githubURLTransaction", "HttpHTTPConnector", "historyURLconnection", "httpURLInstance", "httpILconnection", "httpULConnect", "webURLEntry", "historyURLNetwork", "httpULEntry", "historyILNetwork", "httpUrlConnect", "httpDBConnection", "httpTLConn", "httpSRConn", "httpUrlNetwork", " httpMLConnect", "httpsHTTPConnector", "httpPORTConnector", "httpSRconnection", "httpUrlTransaction", "HttpURLConnection", "httpMLConn", "httpsURLConn", "httpREConnection", "webURLConnect", "historyILConnect", "httpsHTTPConnection", "httpsURLConnection", "httpILNetwork", "HttpURLEntry", "httpALLConn", "httpURLConnect", "httpUrlEntry", "HttpHTTPconnection", "httpPORTConnection", "webUrlconnection", "httpHTTPNetwork", "httpDOMConnection", "historyURLConnection", "historyILConnection", "webURLconnection", "githubUrlTransaction", "httpURLEntry", "httpUrlconnection", " httpMLConn", "githubUrlConnection", "httpHTTPEntry", "githubURLConnection", " httpURLconnection", "HttpHTTPConnect", "httpsURLConnector", "httpHTTPconnection", " httpMLconnection", "httpALLConnect", "httpSSLInstance", "httpURLConnector", "historyILconnection", "githubUrlconnection", "webUrlConnection", "webUrlConnect", "httpDBConnect", "httpALLconnection", "httpILConnect", "httpHTTPConnection", "httpHTTPTransaction", "httpURLTransaction", "httpSSLConnection", "httpTLConnect", "httpHTTPConn", "webURLConnection", "HttpURLconnection", "httpUrlConnection", "HttpURLConnect", "HttpHTTPInstance", "httpURLNetwork", "httpsHTTPConnect", "httpMLConnection", "httpHTTPConnector", "httpREConnector", "httpDOMConnect", "httpHTTPConnect", "httpMLConnect", "httpTLConnector", "githubURLconnection", "HttpHTTPConnection"], "responseCode": ["replyClass", "resultCode", " responseCategory", "responseCategory", "requestClass", "requestSize", "resultSize", "replyCategory", "requestCount", " responseClass", "responseCount", "ResponseSize", "responseActionCode", "resultCount", "complianceClass", "ResponseCode", "complianceActionCode", " responseActionCode", "ResponseClass", "complianceCategory", "responseSize", "responseClass", "resultClass", "ResponseCount", "complianceCode", "replyActionCode", "replyCode", "requestCode"], "lastModified": ["lastModmodified", "LastModifier", "lastContentmodified", "lastModifier", " lastTrification", "lastModed", "_", "LastContentified", "lastTrification", "lastContented", "lastContentifier", "lastmodmodified", " lastModmodified", " lastTrmodified", "LastContentifier", "lastmodify", " lastTrified", " lastModification", "lastModify", "lastMODifier", "LastModify", "lastTrified", " lastTred", "lastMODification", " lastModed", "lastTrmodified", "LastModified", "lastmodified", "LastModification", "lastContentified", "LastContentify", "lastTrifier", "New", "lastMODify", "lastMODified", "lastModification", "lastmodification", " lastTrify", "lastmoded", "LastContentification", "lastContentify", "lastTred", " lastModify", "lastContentification", "lastTrify"]}}
{"id1": "1798720", "id2": "15645004", "code1": "    public static void save(String packageName, ArrayList<byte[]> fileContents, ArrayList<String> fileNames) throws Exception {\n        String dirBase = Util.JAVA_DIR + File.separator + packageName;\n        File packageDir = new File(dirBase);\n        if (!packageDir.exists()) {\n            boolean created = packageDir.mkdir();\n            if (!created) {\n                File currentPath = new File(\".\");\n                throw new Exception(\"Directory \" + packageName + \" could not be created. Current directory: \" + currentPath.getAbsolutePath());\n            }\n        }\n        for (int i = 0; i < fileContents.size(); i++) {\n            File file = new File(Util.JAVA_DIR + File.separator + fileNames.get(i));\n            FileOutputStream fos = new FileOutputStream(file);\n            fos.write(fileContents.get(i));\n            fos.flush();\n            fos.close();\n        }\n        for (int i = 0; i < fileNames.size(); i++) {\n            File fileSrc = new File(Util.JAVA_DIR + File.separator + fileNames.get(i));\n            File fileDst = new File(dirBase + File.separator + fileNames.get(i));\n            BufferedReader reader = new BufferedReader(new FileReader(fileSrc));\n            BufferedWriter writer = new BufferedWriter(new FileWriter(fileDst));\n            writer.append(\"package \" + packageName + \";\\n\");\n            String line = \"\";\n            while ((line = reader.readLine()) != null) writer.append(line + \"\\n\");\n            writer.flush();\n            writer.close();\n            reader.close();\n        }\n    }\n", "code2": "    private void unzip(File filename) throws ZipException, IOException {\n        ZipInputStream in = new ZipInputStream(new BufferedInputStream(new FileInputStream(filename)));\n        ZipEntry entry = null;\n        boolean first_entry = true;\n        while ((entry = in.getNextEntry()) != null) {\n            if (first_entry) {\n                if (!entry.isDirectory()) {\n                    File subdir = new File(dir + File.separator + filename.getName().substring(0, filename.getName().length() - SUFFIX_ZIP.length()));\n                    if (!subdir.exists()) {\n                        subdir.mkdir();\n                        dir = subdir;\n                    }\n                }\n                first_entry = false;\n            }\n            if (entry.isDirectory()) {\n                FileUtils.forceMkdir(new File(dir + File.separator + entry.getName()));\n            } else {\n                File outfile = new File(dir + File.separator + entry.getName());\n                File outdir = new File(outfile.getAbsolutePath().substring(0, outfile.getAbsolutePath().length() - outfile.getName().length()));\n                if (!outdir.exists()) FileUtils.forceMkdir(outdir);\n                FileOutputStream fo = new FileOutputStream(outfile);\n                BufferedOutputStream bos = new BufferedOutputStream(fo, BUFFER);\n                int read;\n                byte data[] = new byte[BUFFER];\n                while ((read = in.read(data, 0, BUFFER)) != -1) {\n                    read_position++;\n                    bos.write(data, 0, read);\n                }\n                bos.flush();\n                bos.close();\n            }\n        }\n        in.close();\n    }\n", "label": 1, "substitutes": {"save": ["export", " seal", "Save", " Save", "release", "init", "accept", "pkg", "filename", "saving", "archive", "upload", "dump", "data", "pack", "aw", "register", "zip", "download", "install", "send", "folder", "version", "store", "update", "delete"], "packageName": ["packagename", "modulename", "pkgKey", "packageNames", " packageNames", "moduleId", " packageId", " packageType", "packageCode", "moduleCode", " packageKey", "pkgNames", "pkgCode", "PackageId", "packageKey", "pkgId", "pkgname", "moduleNames", "pkgName", " packageCode", " packagename", "PackageType", "PackageName", "PackageNames", "moduleKey", "packageType", "pkgType", "moduleName", "packageId"], "fileContents": ["pageBytes", "packageNames", "packageContents", "FileContents", " fileIngredients", "packageContent", "FileNames", " fileBytes", "byteContent", "FileItems", "fileBytes", "pageContents", " fileValues", "byteContents", "FileIngredients", "fileItems", "byteNames", " fileItems", "pageNames", "fileIngredients", "byteValues", "packageIngredients", " fileContent", "fileValues", "fileContent", "FileBytes", "FileValues", "pageItems", "FileContent"], "fileNames": ["fieldContents", "issueContents", "messageValues", " fileKeys", "fileNumbers", "FileLeaks", "messageKeys", "dirLeaks", "FileName", " fileNumbers", "issueVaults", "fieldNames", "FileContents", "resourceNames", "FileNames", "dirNames", "resourceContents", "moduleVaults", "resourceTypes", "issueName", "FileKeys", " fileName", " fileValues", "fileLeaks", "messageName", "fileKeys", "messageNames", "fileTypes", "moduleNames", "fieldTypes", "resourceNumbers", "issueNames", "resourceValues", "fileValues", " fileTypes", "fileName", "FileTypes", "fileVaults", "FileValues", "moduleName", " fileLeaks", " fileVaults", "fieldNumbers", "dirTypes", "dirKeys", "moduleContents"], "dirBase": ["DIRBase", "DIRBuilder", "DirBuilder", "folderbase", "DirBase", "dirBasic", "folderBas", "pathBase", "dirBottom", " directoryBuilder", "folderBasic", "irBase", "DirBottom", "pkgBas", "irbase", "DirBas", " directoryBottom", "pkgSet", "directorySet", "dirbase", "pkgbase", "DIRBas", " directoryBas", "dirBuilder", "pkgBase", "dirBas", "irSet", "directoryBase", " directoryBase", "directoryBasic", "irBas", "directorybase", "pathBasic", "DIRBottom", "pathbase", "pathBas", "folderBase", "directoryBas", "dirSet"], "packageDir": ["installDist", "packageFolder", "packageD", " packageRel", " packagePath", "moduleDir", "podDef", "pkgDir", "pkgPath", "packageRel", "installD", "pkgDef", "podDist", "modulePath", " packageDef", " packageD", "installDir", "podDir", "moduleRel", "installDef", "moduleDef", "pkgFolder", "packagePath", " packageFolder", " packageDist", "podD", "moduleFolder", "packageDist", "pkgRel", "packageDef"], "created": ["defined", "installed", "Created", "creator", "developed", "provided", "locked", "create", "joined", " started", "registered", "generated", "associated", "creat", "raised", "forced", "founded", "called", "made", "mounted", "released", "started", "arted", "printed", "successful", "creation", "recorded", "loaded", "present", "allowed", "confirmed", "checked", " generated", "added", "TED", "ready", "ced", "produced", "existent", "activated", "reported", "filled", "given"], "currentPath": ["currentName", " currentFile", " currentParent", "CurrentFile", "currentCh", "recentName", "recentPoint", "currentlyFile", " currentCh", "recentParent", "currentlyPath", "recentPath", "CurrentName", "CurrentPath", " currentPoint", "CurrentCh", "currentlyName", "CurrentParent", "currentlyCh", "currentPoint", "currentParent", "CurrentPoint", " currentName", "currentFile"], "i": ["exp", "y", "I", "di", "ri", "ei", "yi", "ti", "me", "q", "cgi", "ic", "sim", "gi", "v", "pi", "it", "ip", "info", "oi", "index", "f", "iy", "ini", "them", "iq", "hi", "cli", "slice", "ci", "uri", "os", "xi", "si", "g", "ind", "batch", "key", "ity", "id", "ix", "major", "u", "j", "im", "iu", "in", "chain", "jj", "bi", "multi", "ui", "my", "o", "phi", "mi", "ski", "ie", "qi", "m", "ki", "status", "ami", "init", "go", "ai", "ij", "ji", "this", "li", "mu", "ii", "iii", "zi", "p", "ex"], "file": ["type", "f", "rule", "handle", "play", "File", "et", "FILE", "h", "resource", "comment", "disk", "set", "page", "table", "port", "base", "template", "link", "buffer", "log", "db", "ile", "format", "child", "le", "name", "sf", "l", "fo", "parent", "handler", "path", "dir", "local", "info", "row", "io", "pool", "source", "body", "p", "header"], "fos": ["Foss", "ffos", "foes", "fbos", "woes", "fow", "foss", "flos", " faos", "fbow", "ffo", "floses", "foses", "floss", "Foes", "sfoss", " fo", "faos", "flaos", "oo", "fbaos", " foses", " foes", "Fo", "wos", "fOS", "fbo", "Fos", "fo", "sfos", "floes", "flo", "woss", "oaos", " fOS", "Faos", " fow", " foss", "ffaos", "sfOS", "oos", "FOS", "ffoes", "woses", "sfaos", "oow"], "fileSrc": ["fileEri", "fileDci", "fileErc", "fileSci", "fileNrl", " fileSource", "fileNri", "fileInrc", " fileInsRC", "fileDsrc", "jobSrl", "fileInsrc", "fileDRC", "fileDource", "fileErl", "fileDrc", "jobSrc", "jobSri", " fileInsource", "fileSRC", " fileSsrc", "fileInssrc", "jobSci", "fileDrl", "jobNrl", "fileInRC", " fileSRC", " fileInssrc", "fileInsource", "fileSri", "fileDri", "jobNri", "fileInsRC", "fileSsrc", "fileSrl", "fileNrc", " fileInsrc", "fileNci", "jobNci", "fileSource", "fileInource", "jobNrc", "fileEci"], "fileDst": ["FileSld", "FileSnd", "fileDld", "fileNot", "fileDpl", "fileWst", "fileSld", "fileSst", "FileSst", "fileNcr", "fileSnd", "FileSpl", "FileDcr", "fileWpl", "fileNld", "FileDpl", "fileWot", "FileDlt", "fileNpl", "fileNnd", "fileDcr", "FileSot", "FileDst", "fileDlt", "fileWlt", "FileDld", "FileDot", "fileSlt", "FileScr", "FileDnd", "fileSpl", "FileSlt", "filedld", "filednd", "filedcr", "fileDnd", "fileNst", "fileNlt", "fileScr", "fileDot", "fileSot", "filedst"], "reader": ["runner", "author", "rar", "rc", "actor", "entry", "rer", "driver", "parser", "resource", "ri", "ro", "stream", "context", "inner", "Reader", "oder", "buffer", "readable", "dr", "roller", "review", "read", "ler", "rr", "rl", "iter", "ocker", "rot", "query", "upper", "rx", "ader", "handler", "controller", "iterator", "r", "Larry", "book", "row", "ner", "er", "reading", "loader"], "writer": ["runner", "browser", "report", "window", "worker", "creator", "flush", "writers", "Writer", "caster", "entry", "test", "console", "draw", "driver", "storage", "service", "word", "parser", "client", "wright", "builder", "writing", "stream", "table", "maker", "Reader", "editor", "write", "buffer", "print", "function", "document", "println", "format", "read", "variable", "liner", "operator", "outer", "wrapper", "iter", "order", "walker", "query", "handler", "wire", "iterator", "manager", "riter", "later", "player", "user", "adder", "store", "loader", "server", "ter", "w"], "line": ["rule", "LINE", "style", "block", "lin", "text", "eline", "entry", "ine", "sample", "column", "comment", "frame", "word", "ln", "sequence", "page", "stroke", "port", "chain", "range", "link", "code", "date", "label", "message", "cell", "kin", "detail", "number", "node", "le", "liner", "entity", "l", "valid", "nl", "lined", "point", "continue", "record", "edge", "Line", "row", "string", "inline", "source", "ole", "user", "print", "pe", "header"]}}
{"id1": "22235113", "id2": "21368981", "code1": "    protected Object unmarshallXml(final Unmarshaller unmarshaller, final String accessUrl, final String nameSpace, final String replace, final String with) throws Exception {\n        final URL url = new URL(accessUrl);\n        final BufferedReader inputStream = new BufferedReader(new InputStreamReader(url.openStream()));\n        String xmlContent = readWithStringBuffer(inputStream);\n        if (replace != null) {\n            xmlContent = xmlContent.replace(replace, with);\n        }\n        LOGGER.info(\"Calls \" + accessUrl);\n        if (LOGGER.isDebugEnabled()) {\n            LOGGER.debug(\"\\nXml:\" + accessUrl + \"\\n\" + xmlContent);\n        }\n        if (LOGGER.isDebugEnabled()) {\n            final BufferedWriter out = new BufferedWriter(new FileWriter(\"target/XmlAgentLog\" + xmlRequestNumber++ + \".txt\"));\n            out.write(xmlContent);\n            out.close();\n        }\n        final ByteArrayInputStream byteArrayInputStream = new ByteArrayInputStream(xmlContent.getBytes());\n        Source source;\n        if (nameSpace != null) {\n            source = setNameSpaceOnXmlStream(byteArrayInputStream, nameSpace);\n        } else {\n            source = new StreamSource(byteArrayInputStream);\n        }\n        return unmarshaller.unmarshal(source);\n    }\n", "code2": "    public APIResponse create(Application application) throws Exception {\n        APIResponse response = new APIResponse();\n        connection = (HttpURLConnection) new URL(url + \"/api/application/create\").openConnection();\n        connection.setDoOutput(true);\n        connection.setRequestMethod(\"POST\");\n        connection.setRequestProperty(\"Content-Type\", \"application/json; charset=utf-8\");\n        connection.setUseCaches(false);\n        connection.setConnectTimeout(TIMEOUT);\n        connection.connect();\n        marshaller.marshal(application, new MappedXMLStreamWriter(new MappedNamespaceConvention(new Configuration()), new OutputStreamWriter(connection.getOutputStream(), \"utf-8\")));\n        connection.getOutputStream().flush();\n        connection.getOutputStream().close();\n        if (connection.getResponseCode() == HttpURLConnection.HTTP_OK) {\n            JSONObject obj = new JSONObject(new String(new BufferedReader(new InputStreamReader(connection.getInputStream(), \"utf-8\")).readLine()));\n            response.setDone(true);\n            response.setMessage(unmarshaller.unmarshal(new MappedXMLStreamReader(obj, new MappedNamespaceConvention(new Configuration()))));\n            connection.getInputStream().close();\n        } else {\n            response.setDone(false);\n            response.setMessage(\"Create Application Error Code: Http (\" + connection.getResponseCode() + \")\");\n        }\n        connection.disconnect();\n        return response;\n    }\n", "label": 0, "substitutes": {"unmarshallXml": ["unmarshallXxml", "unmarshallEplex", "unmarshalXplex", "unmarshallEml", "unmarshallYplex", "unmarshalYplex", "unmarshallYml", "unmarshallAsplex", "unmarshallYsl", "unmarshalXml", "unmarshallAsxml", "unmarshallXsl", "unmarshalYxml", "unmarshalXxml", "unmarshalXsl", "unmarshallAssl", "unmarshallAsml", "unmarshallExml", "unmarshallEsl", "unmarshalYsl", "unmarshalYml", "unmarshallXplex", "unmarshallYxml"], "unmarshaller": ["unmarshiller", "unmarshcallers", "unmarshcallier", "unmarshailer", "unmarshailers", "unmarshallable", "unmarshCaller", "unmarshallier", "unmarshelloser", "unmMarshcallers", "unmachailers", "unmarshailing", "unmachalling", "unmarshcaller", "unmarshalloser", "unmMarshcaller", "unmarshilloser", "unmarshailable", "unmMarshcallier", "unmarshcalloser", "unmarshellers", "unmarshcalling", "unmarshCallable", "unmachaller", "unmMarshallers", "unmMarshallier", "unmMarshaller", "unmachallers", "unmarshCallers", "unmachailer", "unmarsheller", "unmarshillers", "unmachailing", "unmarshellier", "unmachallable", "unmarshalling", "unmarshCalling", "unmMarshalloser", "unmMarshcalloser", "unmarshallers", "unmarshcallable", "unmachailable", "unmarshillier"], "accessUrl": ["aceUrl", "uploadUr", "execURL", "accessibleURL", "aceurl", "axUrl", "ccessurl", "AccessPage", "accessibleDb", "acePage", "ccessUr", "AccessURL", "execPath", "axURL", "uploadUrl", "ccessUrl", "uploadURL", "accessibleUrl", "accessURL", "uploadurl", "aceURL", "Accessurl", "AccessDb", "accessurl", "execUrl", "AccessUrl", "axDb", " accessurl", "execUr", "accessibleUr", " accessPath", "axUr", "ccessPage", "AccessPath", "accessPage", "AccessUr", "accessDb", " accessUr", "ccessURL", "accessUr", " accessURL", "accessPath"], "nameSpace": ["resourcespace", "whiteAccount", "linkspace", "linkSpace", "wordspace", "NameAccount", "whiteSp", "wordSpace", "whitespace", " namespace", "nameType", "linkSp", "NameSpace", "nameBox", "NameType", "NameSp", " nameType", "wordBox", "Namespace", " nameBox", "resourceBox", " nameSp", " nameAccount", "nameSp", "whiteSpace", "linkType", "nameAccount", "namespace", "resourceSpace"], "replace": ["transform", "same", "include", "pair", "each", "insert", "find", "match", "fill", "remove", "cover", "share", "force", "fix", "gre", "tool", "template", "store", "write", "old", "places", "join", "close", "re", "strip", "over", "format", "align", "after", "hash", "change", "search", "look", "group", "record", "filter", "add", "use", "register", "alter", "place", "string", "repeat", "save", "sub", "repl", "apply", "wrapper", "map", "update", "delete", "prefix", "escape"], "with": ["php", "handle", "via", "value", "by", "default", "tx", "With", "which", "then", "using", "set", "here", "context", " WITH", "work", "x", "ith", "spec", "require", "join", "xml", "color", "format", "now", "after", "without", "sql", "form", "path", " without", "add", "self", "cap", "repeat", "spr", "where", "apply", "id", "title"], "url": ["browser", "address", "u", "sb", "ref", "dl", "service", "resource", "https", "bel", "web", "ls", "ll", "base", "char", "link", "sl", "open", "cert", "impl", "xml", "ur", "mount", "uri", "URL", "str", "rl", "external", "l", "this", "nl", "ul", "mail", "r", "ssl", "channel", "http", "Url", "user"], "inputStream": [" InputThread", "instream", " InputStream", "activestream", "inSteam", " inputSteam", "inputSteam", "activeSteam", " InputSteam", "outputStream", "imageStream", "outputSteam", "outputstream", "inputstream", "imageSteam", "imagestream", " inputThread", "imageThread", " Inputstream", " inputstream", "inputThread", "activeStream", "inStream"], "xmlContent": ["xmlText", " xmlValue", "xfcontent", "phpcontent", "formText", "mlRaw", "textText", "phpContent", "mlContent", " xmlAccept", "mlContents", " xmlcontent", "formContent", " xmlRaw", "xfContents", "jsonContents", "xaValue", "mlValue", "xaAccept", "xmlAccept", "mlAccept", "jsoncontent", "mlcontent", "formContents", "mlText", "xmlValue", "xfName", "phpText", "xaText", "xaContent", " xmlContents", "jsonText", "xmlContents", "textName", "phpContents", " xmlText", "textContents", "formRaw", "textContent", "xfContent", "xmlName", "xmlRaw", "textcontent", " xmlName", "xmlcontent", "jsonContent"], "out": ["extra", "co", "nt", "flush", "con", "output", "cos", "cn", "comment", "client", "sys", "conv", "init", "in", "inner", "t", "net", "write", "log", "to", "list", "up", "conf", "copy", "writer", "external", "os", "outer", "ent", "cmd", "conn", "null", "ou", "at", "outs", "aos", "o", "auto", "n", "io", "Out", "file", "OUT", "user", "check", "ex"], "xmlRequestNumber": ["xmlResponseCounter", "xmlRequestCounter", " xmlResponseCounter", "xmlResponseNumber", " xmlRequestNo", "xmlEventNumber", " xmlRequestCounter", "xmlResponseNo", " xmlResponseCount", "xmlRequestNo", " xmlRequestCount", "xmlEventNo", "xmlCounterNo", " xmlResponseNo", "xmlResponseCount", "xmlCounterCounter", " xmlResponseNumber", "xmlRequestCount", "xmlEventCounter", "xmlCounterNumber", "xmlEventCount", "xmlCounterCount"], "byteArrayInputStream": ["byteArrayIntSteam", "byteArrayOutputForm", "byteArrayReadForm", "byteOrderInputSteam", "byteArrayInputSocket", "byteStringOutputSteam", "byteArrayOutputSource", "byteArrayRawForm", "byteOrderReadForm", "byteArrayStorageSteam", "byteStreamInputSet", "byteArrayStorageStream", "byteArrayinputForm", "byteArrayOutputSocket", "byteArrayStorageSet", "byteArrayinputSteam", "byteOrderReadSteam", "byteStreamInputStream", "byteArrayOutputStream", "byteStringInputStream", "byteStringOutputSocket", "byteArrayInputSource", "byteArrayHttpSource", "byteArrayRawSocket", "byteArrayRawStream", "byteOrderInputForm", "byteStreamInputSteam", "byteArrayinputSocket", "byteArrayReadStream", "byteArrayIntSet", "byteStringOutputForm", "byteStreamOutputForm", "byteStreamOutputStream", "byteArrayOutputSet", "byteStreamOutputSteam", "byteArrayIntStream", "byteStreamOutputSet", "byteArrayinputStream", "byteStringInputSocket", "byteArrayHttpStream", "byteOrderReadSource", "byteStringOutputStream", "byteArrayReadSource", "byteStringInputForm", "byteArrayRawSteam", "byteOrderReadStream", "byteArrayOutputSteam", "byteOrderInputSource", "byteArrayInputSteam", "byteArrayStorageForm", "byteArrayReadSteam", "byteArrayIntForm", "byteArrayInputForm", "byteStreamInputForm", "byteArrayHttpSteam", "byteStringInputSteam", "byteOrderInputStream", "byteArrayInputSet", "byteArrayHttpForm"], "source": ["proxy", "report", "ser", "style", "handle", "layout", "json", "subject", "select", "console", "params", "service", "comment", "resource", "se", "details", "sequence", "stream", "status", "reason", "table", "context", "site", "in", "inner", "trace", "template", "store", "scope", "join", "src", "xml", "content", "Source", "state", "copy", "position", "target", "SOURCE", "input", "parent", "parse", "object", "component", "ource", "instance", "ident", "relation", "config", "file", "where", "body", "unit", "cause", "from", "expression"]}}
{"id1": "8490710", "id2": "14191679", "code1": "    public void actualizar() throws SQLException, ClassNotFoundException, Exception {\n        Connection conn = null;\n        PreparedStatement ms = null;\n        registroActualizado = false;\n        try {\n            conn = ToolsBD.getConn();\n            conn.setAutoCommit(false);\n            Date fechaSystem = new Date();\n            DateFormat aaaammdd = new SimpleDateFormat(\"yyyyMMdd\");\n            int fzafsis = Integer.parseInt(aaaammdd.format(fechaSystem));\n            DateFormat hhmmss = new SimpleDateFormat(\"HHmmss\");\n            DateFormat sss = new SimpleDateFormat(\"S\");\n            String ss = sss.format(fechaSystem);\n            if (ss.length() > 2) {\n                ss = ss.substring(0, 2);\n            }\n            int fzahsis = Integer.parseInt(hhmmss.format(fechaSystem) + ss);\n            ms = conn.prepareStatement(SENTENCIA_UPDATE);\n            ms.setString(1, descartadoEntrada);\n            ms.setString(2, usuarioEntrada);\n            ms.setString(3, motivosDescarteEntrada);\n            ms.setInt(4, Integer.parseInt(anoOficio));\n            ms.setInt(5, Integer.parseInt(oficinaOficio));\n            ms.setInt(6, Integer.parseInt(numeroOficio));\n            ms.setInt(7, anoEntrada != null ? Integer.parseInt(anoEntrada) : 0);\n            ms.setInt(8, oficinaEntrada != null ? Integer.parseInt(oficinaEntrada) : 0);\n            ms.setInt(9, numeroEntrada != null ? Integer.parseInt(numeroEntrada) : 0);\n            int afectados = ms.executeUpdate();\n            if (afectados > 0) {\n                registroActualizado = true;\n            } else {\n                registroActualizado = false;\n            }\n            conn.commit();\n        } catch (Exception ex) {\n            System.out.println(\"Error inesperat, no s'ha desat el registre: \" + ex.getMessage());\n            ex.printStackTrace();\n            registroActualizado = false;\n            errores.put(\"\", \"Error inesperat, no s'ha desat el registre\" + \": \" + ex.getClass() + \"->\" + ex.getMessage());\n            try {\n                if (conn != null) conn.rollback();\n            } catch (SQLException sqle) {\n                throw new RemoteException(\"S'ha produ\u00eft un error i no s'han pogut tornar enrere els canvis efectuats\", sqle);\n            }\n            throw new RemoteException(\"Error inesperat, no s'ha modifcat el registre\", ex);\n        } finally {\n            ToolsBD.closeConn(conn, ms, null);\n        }\n    }\n", "code2": "    protected File EncodeReturn() throws EncodeFailedException, IOException {\n        CryptoClient c = getNode().getCryptoClientByID(PiggybackCrypto);\n        File tmpf = getNode().getTempFM().createNewFile(\"encodereturn\", \"download\");\n        ChannelWriter cw = new ChannelWriter(tmpf);\n        cw.putLongFile(DownloadData);\n        cw.close();\n        File encdata = c.RawEncode(tmpf, RawKey);\n        File pigdata = PigData.EncodeData(encdata);\n        File pigroute = ReturnPigRoute.EncodeData(ReturnRouteFile);\n        FileOutputStream fos = new FileOutputStream(pigroute, true);\n        FileChannel foc = fos.getChannel();\n        FileInputStream fis = new FileInputStream(pigdata);\n        FileChannel fic = fis.getChannel();\n        fic.transferTo(0, fic.size(), foc);\n        foc.close();\n        fic.close();\n        pigdata.delete();\n        ReturnRouteFile.delete();\n        encdata.delete();\n        return pigroute;\n    }\n", "label": 0, "substitutes": {"actualizar": ["ualizaar", "ualizAR", " actualizeAR", " actualizer", " actualizaAR", " actualizear", " actualisAR", " actualiser", " actualizaiar", "ualizaAR", " actualisar", " actualizAR", " actualizeer", " actualizeiar", " actualisiar", "ualizer", "ualizaer", "ualiziar", "ualizaiar", " actualizaar", "ualizar", " actualiziar", " actualizaer"], "ClassNotFoundException": ["ClassNotFoundError", "ClassNotfoundError", "ClassNotPresentError", "ClassNotfoundException", "ClassNotPresentException"], "Exception": ["E", "Context", "Message", "I", "Handler", "File", "Time", "Operation", "Response", "Class", "Exit", "Throw", "ception", "Interface", "Index", "Un", "Application", "Null", "Status", "Exc", "Connection", "EX", "Warning", "Event", "Ex", "Option", "Instance", "End", "ION", "Example", "None", " exception", "Type", "Configuration", "T", "Error", "Result", "Transaction"], "conn": [" con", "en", "nt", "rc", "Connect", "ctx", "con", "pas", "oss", "comm", "cn", "cb", "js", "yn", "enc", "obj", "ln", "ws", "mt", "ont", "yes", "client", "sys", "gate", "init", "ann", "ns", "connection", "die", "c", "open", "pg", "cert", "db", "close", "org", "conf", "cp", "ct", "act", "Conn", "rs", "Connection", "ec", "pen", "ch", "ens", "cmd", "sc", "sql", "ctrl", "connect", "mc", "nc", "jp", "n", "config", "socket", "exec", "pool", "ks", "Con", "session", "cc"], "ms": ["terms", "mi", "xs", "sm", "res", "mill", "mos", "ins", "mys", "mic", "js", "mt", "MS", "windows", "m", "ws", "fs", "cms", "qs", "ants", "bs", "cus", "sys", "mx", "mod", "ns", "uts", "md", "ocks", "mes", "mp", "ps", "ts", "ents", "ats", "rs", "os", "ys", "eps", "ces", "ims", "pers", "ems", "s", "inv", "ma", "mn", "mc", "mm", "vs", "eds", "Ms", "pm", "uns", "posts", "is", "ks", "arms", "ml", "ies", "cs"], "fechaSystem": ["fetasystem", "fechaesystem", "fechtaSTEM", "fochtaSTEM", "fetiSys", "fochaServer", "fochaSystem", "fechaeSys", "fetaeSys", "fetisystem", "fechoaSystem", "fochaSTEM", "fechosystem", "fechisystem", "feshoServer", "fechasystem", "fechtaServer", "fechoSys", "fechoaServer", "fetaesystem", "feshasystem", "fechlaSystem", "feshaSystem", "fetaeSystem", "fechtaSystem", "fechlaSys", "fechoServer", "fechaeSTEM", "fechiSys", "fetaSystem", "fechaeSystem", "feshaServer", "fechaeServer", "fetaSys", "fochtaServer", "fetiSystem", "fechoSTEM", "fechlasystem", "feshoSystem", "fechaServer", "fechoSystem", "fechiSystem", "fechoaSys", "feshosystem", "fochtaSystem", "fechaSys", "fechoasystem", "fechaSTEM"], "aaaammdd": ["aaaaamd", "aaaammm", "aaammds", "aaaammd", "aaaaummd", "aaaammmm", "aaaammds", "aaaaumd", "aaaaammm", "aaaamdd", "aaammmd", "aammds", "aaaaammd", "aaaaumds", "aammmd", "aaaamldd", "aaammd", "aaaamds", "aaaaumdd", "aaaamd", "aaaaammmm", "aaammmm", "aaaaammdd", "aammd", "aaammdd", "aaaamlmm", "aammdd", "aaaamld", "aaaaamdd", "aaaammmd"], "fzafsis": ["fzeajesi", "fzajsis", "fzamses", "fzamesi", "fzajesi", "fzahses", "fzeafses", "fzamsi", "fzeajses", "fzajses", "fzafses", "fzamsis", "fzeafsi", "fzafesi", "fzeajsi", "fzeafesi", "fzeajsis", "fzahesi", "fzahsi", "fzafsi", "fzeafsis", "fzajsi"], "hhmmss": ["hhmbess", "hmmmss", "hhmmms", "hhmps", "hhmmmse", "hmmbess", "hmmbs", "hmmms", "hhmss", "HHMMs", "hhmbss", "hmmmess", "hhms", "hhmmmess", "HHMMss", "hhMMs", "hhmbse", "hhMMss", "hmmbse", "HHmmms", "hhMMess", "hhmbs", "HHmmps", "hhMMps", "hhMMms", "hhmmess", "hhmmmss", "hmmbss", "hhmmse", "hmmmse", "hhmms", "hhMMse", "HHmms", "hhmmmms", "HHMMms", "hhmmmps", "hhmmps", "HHMMps", "HHmmss"], "sss": ["ossss", "isses", "ssn", "ssss", "issss", "ssjs", "essl", "essjs", "essn", "essss", "osss", "rsses", "esss", "ossjs", "rssss", " ssjs", "sses", "rssl", "isss", " ssn", "rsss", "issl", "esses", "ssl", " ssss", "ossn"], "ss": ["SS", "txt", "good", "rss", "sb", "su", "ses", "tz", "ress", "tx", "oss", "pse", "js", "se", "ws", "sys", "bs", "https", "tt", "hs", "ns", "ess", "sq", "sl", "stats", "ps", "ts", "xx", "less", "sd", "styles", "sv", "sh", "ius", "str", "sf", "pps", "rs", "lower", "ys", "ds", "sql", "pres", "css", "si", "s", "ssl", "string", "hess", "ass", "iss", "\u00df", "cs", "pass"], "fzahsis": ["fzaqsi", "fzaqsis", "fzabses", "fzahses", "fizafsis", "fzafses", "fzabsi", "fizafsi", "fizahses", "fizahorus", "fzaqses", "fzaforus", "fzahsi", "fizahsis", "fizahsi", "fzahorus", "fzabsis", "fzafsi", "fzaqorus", "fizaforus", "fzaborus", "fizafses"], "afectados": ["affectadas", "affecturated", "afelectators", "affectados", "affectulas", "afECTado", "affECTurated", "afectators", "afecturated", "afitectado", "affectarians", "afitectados", "afittulas", "afectionarians", "afECTados", "affectado", "afectadas", "afectado", "afettados", "afectarians", "afectionados", "afittadas", "affectators", "affettulas", "afitectarians", "afectionado", "affECTado", "affettators", "afECTarians", "afittators", "afectulas", "afelectulas", "afitecturated", "afectionurated", "afelectados", "affECTarians", "affECTados", "afECTurated", "afelectadas", "afettulas", "afettators", "affettados", "afettadas", "affettadas", "afittados"]}}
{"id1": "10674824", "id2": "5682569", "code1": "    @Before\n    public void setUp() throws Exception {\n        final URL url = getClass().getClassLoader().getResource(\"insecureSSL.keystore\");\n        final KeyStore keystore = KeyStore.getInstance(\"jks\");\n        final char[] pwd = \"nopassword\".toCharArray();\n        keystore.load(url.openStream(), pwd);\n        final TrustManagerFactory trustManagerFactory = createTrustManagerFactory();\n        trustManagerFactory.init(keystore);\n        final TrustManager[] trustManagers = trustManagerFactory.getTrustManagers();\n        final KeyManagerFactory keyManagerFactory = createKeyManagerFactory();\n        keyManagerFactory.init(keystore, pwd);\n        final KeyManager[] keyManagers = keyManagerFactory.getKeyManagers();\n        final SSLContext serverSSLContext = SSLContext.getInstance(\"TLS\");\n        serverSSLContext.init(keyManagers, trustManagers, null);\n        localServer_ = new LocalTestServer(serverSSLContext);\n        localServer_.registerDefaultHandlers();\n        localServer_.start();\n    }\n", "code2": "    public void metodo1() {\n        int temp;\n        boolean flagDesordenado = true;\n        while (flagDesordenado) {\n            flagDesordenado = false;\n            for (int i = 0; i < this.tamanoTabla - 1; i++) {\n                if (tabla[i] > tabla[i + 1]) {\n                    flagDesordenado = true;\n                    temp = tabla[i];\n                    tabla[i] = tabla[i + 1];\n                    tabla[i + 1] = temp;\n                }\n            }\n        }\n    }\n", "label": 0, "substitutes": {"setUp": [" setup", "setSetup", "setUP", "cleanup", "settingup", "cleanSetup", "cleanUP", " setUP", "settingSetup", "settingUP", "cleanUp", "settingUp", "setup", " setSetup"], "url": ["f", "browser", "address", "sb", "ref", "res", "util", "service", "resource", "obj", "ls", "web", "ll", "context", "char", "k", "log", "cert", "result", "xml", "ur", "uri", "URL", "str", "rl", "l", "mail", "path", "r", "ssl", "channel", "http", "location", "file", "password", "Url", "user", "host"], "keystore": ["truststore", "chaintool", "Keystore", "ntool", "Keytool", "Keyspace", "trusthandle", "hashStore", "ktool", "KeyStore", "chainstorage", "chainhandle", "keytool", "hashstorage", " keyhandle", "hashstore", "keyhandle", "nStore", " keytool", "trustStore", "keystorage", "keyStore", "kstorage", "kStore", "hashspace", "truststorage", "nstorage", " keystorage", "keyspace", "Keystorage", " keyspace", "chainstore", "kstore", "nstore", " keyStore", "chainStore"], "pwd": ["vwd", "hword", "pw", "ppws", " pws", " ppassword", "Pwd", "ppassword", "kwd", "Pws", "Pw", " pword", "hwk", "kword", "pasword", "ppwd", "pws", "hw", "vword", " pw", "hwd", "paspassword", "vw", "vwk", "paswd", "pppassword", "pwk", "pasw", "Ppassword", "ppw", "kw", " pwk", "pword", "kpassword"], "trustManagerFactory": ["rustManagerFactory", "trustHandlerInterface", "trustmanagerFact", "ttManagerFactory", "trustmanageractory", "rustProviderFact", "rustProvideractory", "ttManagerTemplate", "trustManagerTemplate", "pairmanagerFunction", "trustProvideractory", "trustManagerFunction", "trustmanagerBuilder", "trustManagerFrame", "trustmanagerFactory", "trustManTemplate", "rustManagerService", "trustHandleractory", "trustStoreFactory", "pairmanagerInterface", "rustManageractory", "rustProviderService", "rustProviderFactory", "ttManTemplate", "trustmanagerFunction", "trustManagerInterface", "ttManBuilder", "trustProviderService", "pairManagerFunction", "trustProviderFact", "trustManagerBuilder", "trustmanagerTemplate", "pairmanagerFact", "trustManFrame", "trustManBuilder", "trustProviderFactory", "pairmanagerFactory", "ttManagerBuilder", "trustHandlerFact", "trustmanagerInterface", "trustManagerService", "ttManFactory", "rustManagerFact", "trustHandlerFactory", "ttManagerFrame", "trustStoreFrame", "trustManageractory", "trustStoreBuilder", "trustHandlerService", "trustManagerFact", "trustHandlerFunction", "pairManagerFactory", "trustManFactory", "pairManagerFact", "ttManFrame", "trustStoreTemplate", "trustmanagerFrame", "pairManagerInterface", "trustmanagerService"], "trustManagers": ["trustManageragers", "trustManagerages", "rustManageruers", "trustMurers", "trustMagers", "ertManagerurers", "rustManuers", "ertManages", "ertManagements", "rustManagements", "ertManagerages", "trustmanurers", "trustMatuers", "rustManages", "ertManageragers", "trustManuers", "rustManageragers", "trustMatagers", "rustManageragements", "trustmanagers", "trustModages", "rustManagers", "trustModuers", "ertManageragements", "trustManagerurers", "trustModagements", "trustManages", "trustMatages", "rustManagerages", "ertManurers", "trustManurers", "trustMagements", "trustmanagements", "trustManagements", "trustManageruers", "ertManagers", "trustmanages", "trustMatagements", "trustMages", "trustManageragements", "trustModagers"], "keyManagerFactory": ["lockManagementFact", "lockManagementFactory", "lockManagerFact", "KeyManagerFact", " keyManagerFact", "keyManagerForeign", " keyManageractory", "keyManagementFactory", "keymanagerFact", "keyMessageactory", "keyMessageFact", "keyManactory", "keymanagerFactory", "KeyManagerFactory", "keyProvideractory", "keyManagementactory", "keyMessageFactory", "keyManagementFact", "keyManFact", "keyManageractory", "keyManForeign", "KeyManageractory", "keyManFactory", " keyManagerForeign", "keyProviderFactory", "keyManagerFact", "keyMessageForeign", "lockManagerFactory", "keyProviderFact"], "keyManagers": [" keyManappers", "keyMurers", "keyManifiers", "keymanifiers", "trustMiders", "trustMagers", "keyMinifiers", " keymanagers", "keyManages", "keyMiniders", "trustMifiers", "trustMages", "keyMackers", "keyMinages", "keyMiders", "keyMifiers", "trustManifiers", "keymanages", "keymanurers", " keyManurers", "keymanappers", "keyManurers", " keymanappers", "keyManackers", "keyManiders", "keyMappers", "keyMinagers", "trustManiders", "trustManages", "keyMages", "keyMagers", " keymanackers", "keymaniders", "keymanagers", " keymanurers", "keyManappers", " keyManackers", "keymanackers"], "serverSSLContext": ["serverSRContext", "serverSAModule", "serSLInstance", "serverSecurityContext", "serverSecurityConfig", "ServerSSLcontext", "serverSLInstance", "serverSSLInstance", "serverSRcontext", "serverHTTPConfig", "serverServerModule", "erverSAModule", "serverServerConfig", "erverSSLModule", "serverSLContext", "serverSRConfig", "serSLConfig", "ServerSSLConfig", "serverSLcontext", "serSSLcontext", "ServerSRcontext", "serverServerContext", "serverLLContext", "erverSAConfig", "serSLcontext", "serverSSLModule", "ServerSRContext", "ServerSSLContext", "serSLContext", "serSSLInstance", "serverSSLConfig", "serverLLConfig", "serverLLInstance", "erverSSLContext", "serverLLcontext", "ServerSRConfig", "serverSecurityInstance", "serverHTTPcontext", "serverSLConfig", "serverHTTPModule", "serverSSLcontext", "erverSSLConfig", "serverSAConfig", "serSSLContext", "serverSecuritycontext", "erverSAContext", "serverSAContext", "serSSLConfig", "serverHTTPContext"], "localServer_": ["localserver_", "localServiceM", "localClientJ", " localClientM", " localClient_", "localserverJ", "localClient_", " localServerM", "localServerJ", "localManagerJ", "localQueueM", "localService_", " localManager_", " localServerJ", "localserverM", "localServerM", " localManagerJ", "localQueue_", "localManager_", "localClientM"]}}
{"id1": "16466743", "id2": "14590676", "code1": "    public String getmd5(String password) {\n        String pwHash = \"\";\n        MessageDigest md = null;\n        try {\n            md = MessageDigest.getInstance(\"MD5\");\n            md.reset();\n            md.update(password.getBytes());\n            byte[] b = md.digest();\n            for (int i = 0; i < b.length; i++) {\n                pwHash += Integer.toString((b[i] & 0xFF) + 0x100, 16).substring(1);\n            }\n        } catch (NoSuchAlgorithmException ex) {\n            Logger.fatal(\"MD5 Hash Algorithm not found\", ex);\n        }\n        Logger.info(\"PWHash erzeugt und wird \u00fcbergeben\");\n        return pwHash;\n    }\n", "code2": "    public static void download(String address, String localFileName) {\n        OutputStream out = null;\n        URLConnection conn = null;\n        InputStream in = null;\n        try {\n            URL url = new URL(address);\n            out = new BufferedOutputStream(new FileOutputStream(localFileName));\n            conn = url.openConnection();\n            in = conn.getInputStream();\n            byte[] buffer = new byte[1024];\n            int numRead;\n            long numWritten = 0;\n            while ((numRead = in.read(buffer)) != -1) {\n                out.write(buffer, 0, numRead);\n                numWritten += numRead;\n            }\n            System.out.println(localFileName + \"\\t\" + numWritten);\n        } catch (Exception exception) {\n            exception.printStackTrace();\n        } finally {\n            try {\n                if (in != null) in.close();\n                if (out != null) out.close();\n            } catch (IOException ioe) {\n                ioe.printStackTrace();\n            }\n        }\n    }\n", "label": 0, "substitutes": {"getmd5": ["getsha4", "getsha2", "getsha6", "getMD4", "getmd2", "getMD5", " getMD5", "getMD2", "getmd6", " getMD6", " getMD2", " getMD4", " getmd4", "getmd4", "getMD6", " getmd2", " getmd6", "getsha5"], "password": ["phrase", "address", "value", "text", "p", "entry", "email", "hello", "word", "description", "secret", " Password", "shadow", "code", "attribute", "Password", "message", "wd", "wordpress", "name", "token", "hash", "pass", "login", "auth", "ew", "path", "security", "sword", "database", "pattern", "padding", "key", "string", "user", "username", "data", "prefix", "w"], "pwHash": [" pwSum", "pswSum", " pwdHash", "pwHas", "spwdSum", "pwtHas", "pswhash", " pwdSum", "pwsHas", "pwshash", "pwhash", "pswHash", "pswHas", "pwdHas", "pwtSum", "pWHas", "pwsHash", "pwthash", "pwtHash", " pwhash", "spwhash", "spwHash", "pwdhash", "pwSum", "spwdHas", " pwHas", "spwdHash", "spwHas", "pWHash", "pWSum", "pwsSum", "spwdhash", "pWhash", "spwSum", " pwdhash", " pwdHas", "pwdHash", "pwdSum"], "md": [" Md", " mc", "sm", "pd", "ms", "cmp", "od", "ng", "di", "d", "der", " mo", "mt", "m", " mm", "doc", "mo", "mod", "mem", "mg", "red", "del", "mp", "man", "rm", "det", "dm", "sd", "def", "td", "nd", "cond", "ds", "dd", "cmd", "metadata", "mail", " dd", "material", "dir", "cd", "mb", "hd", "MD", "dig", "add", "ind", "grad", "mn", "mc", "mm", "desc", "ad", "pm", "mk", "msg", "exec", "ld", "bd", "df"], "b": ["f", "sb", "B", "buff", "bf", "br", "y", "ib", "cb", "d", "ob", "obj", "m", "bh", "bs", "bc", "bas", "abs", "be", "bi", "bb", "db", "bp", "v", "nb", "ba", "rb", "reb", "l", "bu", "eb", "binary", "mb", "batch", "g", "bis", "bar", "fb", "gb", "p", "a", "bytes", "ab", "w"], "i": ["mi", "span", "json", "u", "ini", "j", "us", "y", "ms", "I", "ski", "qi", "di", "ie", "im", "next", "ri", "ei", "m", "ki", "yi", "init", "x", "in", "iu", "ti", "hi", "q", "bi", "ic", "cli", "ci", "multi", "ai", "sim", "gi", "ui", "v", "pi", "ij", "l", "ix", "iter", "it", "ji", "li", "my", "\u0438", "xi", "si", "ind", "o", "ip", "n", "io", "gu", "is", "ii", "oi", "index", "id", "p", "a", "phi"]}}
